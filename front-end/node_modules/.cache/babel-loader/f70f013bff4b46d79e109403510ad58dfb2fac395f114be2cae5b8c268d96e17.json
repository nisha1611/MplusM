{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\n// 65536 is the size of a wasm memory page\n// 64 is the maximum chunk size for every possible wasm hash implementation\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\nconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\nclass WasmHash {\n  /**\r\n   * @param {WebAssembly.Instance} instance wasm instance\r\n   * @param {WebAssembly.Instance[]} instancesPool pool of instances\r\n   * @param {number} chunkSize size of data chunks passed to wasm\r\n   * @param {number} digestSize size of digest returned by wasm\r\n   */\n  constructor(instance, instancesPool, chunkSize, digestSize) {\n    const exports = /** @type {any} */instance.exports;\n    exports.init();\n    this.exports = exports;\n    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n    this.buffered = 0;\n    this.instancesPool = instancesPool;\n    this.chunkSize = chunkSize;\n    this.digestSize = digestSize;\n  }\n  reset() {\n    this.buffered = 0;\n    this.exports.init();\n  }\n\n  /**\r\n   * @param {Buffer | string} data data\r\n   * @param {BufferEncoding=} encoding encoding\r\n   * @returns {this} itself\r\n   */\n  update(data, encoding) {\n    if (typeof data === \"string\") {\n      while (data.length > MAX_SHORT_STRING) {\n        this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n        data = data.slice(MAX_SHORT_STRING);\n      }\n      this._updateWithShortString(data, encoding);\n      return this;\n    }\n    this._updateWithBuffer(data);\n    return this;\n  }\n\n  /**\r\n   * @param {string} data data\r\n   * @param {BufferEncoding=} encoding encoding\r\n   * @returns {void}\r\n   */\n  _updateWithShortString(data, encoding) {\n    const {\n      exports,\n      buffered,\n      mem,\n      chunkSize\n    } = this;\n    let endPos;\n    if (data.length < 70) {\n      if (!encoding || encoding === \"utf-8\" || encoding === \"utf8\") {\n        endPos = buffered;\n        for (let i = 0; i < data.length; i++) {\n          const cc = data.charCodeAt(i);\n          if (cc < 0x80) mem[endPos++] = cc;else if (cc < 0x800) {\n            mem[endPos] = cc >> 6 | 0xc0;\n            mem[endPos + 1] = cc & 0x3f | 0x80;\n            endPos += 2;\n          } else {\n            // bail-out for weird chars\n            endPos += mem.write(data.slice(i), endPos, encoding);\n            break;\n          }\n        }\n      } else if (encoding === \"latin1\") {\n        endPos = buffered;\n        for (let i = 0; i < data.length; i++) {\n          const cc = data.charCodeAt(i);\n          mem[endPos++] = cc;\n        }\n      } else {\n        endPos = buffered + mem.write(data, buffered, encoding);\n      }\n    } else {\n      endPos = buffered + mem.write(data, buffered, encoding);\n    }\n    if (endPos < chunkSize) {\n      this.buffered = endPos;\n    } else {\n      const l = endPos & ~(this.chunkSize - 1);\n      exports.update(l);\n      const newBuffered = endPos - l;\n      this.buffered = newBuffered;\n      if (newBuffered > 0) mem.copyWithin(0, l, endPos);\n    }\n  }\n\n  /**\r\n   * @param {Buffer} data data\r\n   * @returns {void}\r\n   */\n  _updateWithBuffer(data) {\n    const {\n      exports,\n      buffered,\n      mem\n    } = this;\n    const length = data.length;\n    if (buffered + length < this.chunkSize) {\n      data.copy(mem, buffered, 0, length);\n      this.buffered += length;\n    } else {\n      const l = buffered + length & ~(this.chunkSize - 1);\n      if (l > 65536) {\n        let i = 65536 - buffered;\n        data.copy(mem, buffered, 0, i);\n        exports.update(65536);\n        const stop = l - buffered - 65536;\n        while (i < stop) {\n          data.copy(mem, 0, i, i + 65536);\n          exports.update(65536);\n          i += 65536;\n        }\n        data.copy(mem, 0, i, l - buffered);\n        exports.update(l - buffered - i);\n      } else {\n        data.copy(mem, buffered, 0, l - buffered);\n        exports.update(l);\n      }\n      const newBuffered = length + buffered - l;\n      this.buffered = newBuffered;\n      if (newBuffered > 0) data.copy(mem, 0, length - newBuffered, length);\n    }\n  }\n  digest(type) {\n    const {\n      exports,\n      buffered,\n      mem,\n      digestSize\n    } = this;\n    exports.final(buffered);\n    this.instancesPool.push(this);\n    const hex = mem.toString(\"latin1\", 0, digestSize);\n    if (type === \"hex\") return hex;\n    if (type === \"binary\" || !type) return Buffer.from(hex, \"hex\");\n    return Buffer.from(hex, \"hex\").toString(type);\n  }\n}\nconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\n  if (instancesPool.length > 0) {\n    const old = instancesPool.pop();\n    old.reset();\n    return old;\n  } else {\n    return new WasmHash(new WebAssembly.Instance(wasmModule), instancesPool, chunkSize, digestSize);\n  }\n};\nmodule.exports = create;\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;","map":{"version":3,"names":["MAX_SHORT_STRING","Math","floor","WasmHash","constructor","instance","instancesPool","chunkSize","digestSize","exports","init","mem","Buffer","from","memory","buffer","buffered","reset","update","data","encoding","length","_updateWithShortString","slice","_updateWithBuffer","endPos","i","cc","charCodeAt","write","l","newBuffered","copyWithin","copy","stop","digest","type","final","push","hex","toString","create","wasmModule","old","pop","WebAssembly","Instance","module"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/util/hash/wasm-hash.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\n// 65536 is the size of a wasm memory page\r\n// 64 is the maximum chunk size for every possible wasm hash implementation\r\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\r\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\r\nconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\r\n\r\nclass WasmHash {\r\n\t/**\r\n\t * @param {WebAssembly.Instance} instance wasm instance\r\n\t * @param {WebAssembly.Instance[]} instancesPool pool of instances\r\n\t * @param {number} chunkSize size of data chunks passed to wasm\r\n\t * @param {number} digestSize size of digest returned by wasm\r\n\t */\r\n\tconstructor(instance, instancesPool, chunkSize, digestSize) {\r\n\t\tconst exports = /** @type {any} */ (instance.exports);\r\n\t\texports.init();\r\n\t\tthis.exports = exports;\r\n\t\tthis.mem = Buffer.from(exports.memory.buffer, 0, 65536);\r\n\t\tthis.buffered = 0;\r\n\t\tthis.instancesPool = instancesPool;\r\n\t\tthis.chunkSize = chunkSize;\r\n\t\tthis.digestSize = digestSize;\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.buffered = 0;\r\n\t\tthis.exports.init();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Buffer | string} data data\r\n\t * @param {BufferEncoding=} encoding encoding\r\n\t * @returns {this} itself\r\n\t */\r\n\tupdate(data, encoding) {\r\n\t\tif (typeof data === \"string\") {\r\n\t\t\twhile (data.length > MAX_SHORT_STRING) {\r\n\t\t\t\tthis._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\r\n\t\t\t\tdata = data.slice(MAX_SHORT_STRING);\r\n\t\t\t}\r\n\t\t\tthis._updateWithShortString(data, encoding);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tthis._updateWithBuffer(data);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} data data\r\n\t * @param {BufferEncoding=} encoding encoding\r\n\t * @returns {void}\r\n\t */\r\n\t_updateWithShortString(data, encoding) {\r\n\t\tconst { exports, buffered, mem, chunkSize } = this;\r\n\t\tlet endPos;\r\n\t\tif (data.length < 70) {\r\n\t\t\tif (!encoding || encoding === \"utf-8\" || encoding === \"utf8\") {\r\n\t\t\t\tendPos = buffered;\r\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\t\tconst cc = data.charCodeAt(i);\r\n\t\t\t\t\tif (cc < 0x80) mem[endPos++] = cc;\r\n\t\t\t\t\telse if (cc < 0x800) {\r\n\t\t\t\t\t\tmem[endPos] = (cc >> 6) | 0xc0;\r\n\t\t\t\t\t\tmem[endPos + 1] = (cc & 0x3f) | 0x80;\r\n\t\t\t\t\t\tendPos += 2;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// bail-out for weird chars\r\n\t\t\t\t\t\tendPos += mem.write(data.slice(i), endPos, encoding);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (encoding === \"latin1\") {\r\n\t\t\t\tendPos = buffered;\r\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\t\tconst cc = data.charCodeAt(i);\r\n\t\t\t\t\tmem[endPos++] = cc;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tendPos = buffered + mem.write(data, buffered, encoding);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tendPos = buffered + mem.write(data, buffered, encoding);\r\n\t\t}\r\n\t\tif (endPos < chunkSize) {\r\n\t\t\tthis.buffered = endPos;\r\n\t\t} else {\r\n\t\t\tconst l = endPos & ~(this.chunkSize - 1);\r\n\t\t\texports.update(l);\r\n\t\t\tconst newBuffered = endPos - l;\r\n\t\t\tthis.buffered = newBuffered;\r\n\t\t\tif (newBuffered > 0) mem.copyWithin(0, l, endPos);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Buffer} data data\r\n\t * @returns {void}\r\n\t */\r\n\t_updateWithBuffer(data) {\r\n\t\tconst { exports, buffered, mem } = this;\r\n\t\tconst length = data.length;\r\n\t\tif (buffered + length < this.chunkSize) {\r\n\t\t\tdata.copy(mem, buffered, 0, length);\r\n\t\t\tthis.buffered += length;\r\n\t\t} else {\r\n\t\t\tconst l = (buffered + length) & ~(this.chunkSize - 1);\r\n\t\t\tif (l > 65536) {\r\n\t\t\t\tlet i = 65536 - buffered;\r\n\t\t\t\tdata.copy(mem, buffered, 0, i);\r\n\t\t\t\texports.update(65536);\r\n\t\t\t\tconst stop = l - buffered - 65536;\r\n\t\t\t\twhile (i < stop) {\r\n\t\t\t\t\tdata.copy(mem, 0, i, i + 65536);\r\n\t\t\t\t\texports.update(65536);\r\n\t\t\t\t\ti += 65536;\r\n\t\t\t\t}\r\n\t\t\t\tdata.copy(mem, 0, i, l - buffered);\r\n\t\t\t\texports.update(l - buffered - i);\r\n\t\t\t} else {\r\n\t\t\t\tdata.copy(mem, buffered, 0, l - buffered);\r\n\t\t\t\texports.update(l);\r\n\t\t\t}\r\n\t\t\tconst newBuffered = length + buffered - l;\r\n\t\t\tthis.buffered = newBuffered;\r\n\t\t\tif (newBuffered > 0) data.copy(mem, 0, length - newBuffered, length);\r\n\t\t}\r\n\t}\r\n\r\n\tdigest(type) {\r\n\t\tconst { exports, buffered, mem, digestSize } = this;\r\n\t\texports.final(buffered);\r\n\t\tthis.instancesPool.push(this);\r\n\t\tconst hex = mem.toString(\"latin1\", 0, digestSize);\r\n\t\tif (type === \"hex\") return hex;\r\n\t\tif (type === \"binary\" || !type) return Buffer.from(hex, \"hex\");\r\n\t\treturn Buffer.from(hex, \"hex\").toString(type);\r\n\t}\r\n}\r\n\r\nconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\r\n\tif (instancesPool.length > 0) {\r\n\t\tconst old = instancesPool.pop();\r\n\t\told.reset();\r\n\t\treturn old;\r\n\t} else {\r\n\t\treturn new WasmHash(\r\n\t\t\tnew WebAssembly.Instance(wasmModule),\r\n\t\t\tinstancesPool,\r\n\t\t\tchunkSize,\r\n\t\t\tdigestSize\r\n\t\t);\r\n\t}\r\n};\r\n\r\nmodule.exports = create;\r\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}