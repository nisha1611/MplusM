{"ast":null,"code":"'use strict';\n\n///@ts-check\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\nconst regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser {\n  constructor(options) {\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\": {\n        regex: /&(apos|#39|#x27);/g,\n        val: \"'\"\n      },\n      \"gt\": {\n        regex: /&(gt|#62|#x3E);/g,\n        val: \">\"\n      },\n      \"lt\": {\n        regex: /&(lt|#60|#x3C);/g,\n        val: \"<\"\n      },\n      \"quot\": {\n        regex: /&(quot|#34|#x22);/g,\n        val: \"\\\"\"\n      }\n    };\n    this.ampEntity = {\n      regex: /&(amp|#38|#x26);/g,\n      val: \"&\"\n    };\n    this.htmlEntities = {\n      \"space\": {\n        regex: /&(nbsp|#160);/g,\n        val: \" \"\n      },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\": {\n        regex: /&(cent|#162);/g,\n        val: \"¢\"\n      },\n      \"pound\": {\n        regex: /&(pound|#163);/g,\n        val: \"£\"\n      },\n      \"yen\": {\n        regex: /&(yen|#165);/g,\n        val: \"¥\"\n      },\n      \"euro\": {\n        regex: /&(euro|#8364);/g,\n        val: \"€\"\n      },\n      \"copyright\": {\n        regex: /&(copy|#169);/g,\n        val: \"©\"\n      },\n      \"reg\": {\n        regex: /&(reg|#174);/g,\n        val: \"®\"\n      },\n      \"inr\": {\n        regex: /&(inr|#8377);/g,\n        val: \"₹\"\n      }\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n  }\n}\nfunction addExternalEntities(externalEntities) {\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n      regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n      val: externalEntities[ent]\n    };\n  }\n}\n\n/**\r\n * @param {string} val\r\n * @param {string} tagName\r\n * @param {string} jPath\r\n * @param {boolean} dontTrim\r\n * @param {boolean} hasAttributes\r\n * @param {boolean} isLeafNode\r\n * @param {boolean} escapeEntities\r\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if (val.length > 0) {\n      if (!escapeEntities) val = this.replaceEntitiesValue(val);\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if (newval === null || newval === undefined) {\n        //don't parse\n        return val;\n      } else if (typeof newval !== typeof val || newval !== val) {\n        //overwrite\n        return newval;\n      } else if (this.options.trimValues) {\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      } else {\n        const trimmedVal = val.trim();\n        if (trimmedVal === val) {\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        } else {\n          return val;\n        }\n      }\n    }\n  }\n}\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\nfunction buildAttributesMap(attrStr, jPath) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      const aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if (newVal === null || newVal === undefined) {\n            //don't parse\n            attrs[aName] = oldVal;\n          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n            //overwrite\n            attrs[aName] = newVal;\n          } else {\n            //parse\n            attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\nconst parseXml = function (xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for (let i = 0; i < xmlData.length; i++) {\n    //for each char in XML data\n    const ch = xmlData[i];\n    if (ch === '<') {\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (this.options.removeNSPrefix) {\n          const colonIndex = tagName.indexOf(\":\");\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        if (currentNode) {\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n        currentNode = this.tagsNodeStack.pop(); //avoid recurssion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        let tagData = readTagExp(xmlData, i, false, \"?>\");\n        if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath);\n          }\n          currentNode.addChild(childNode);\n        }\n        i = tagData.closeIndex + 1;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n        if (this.options.commentPropName) {\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n          currentNode.add(this.options.commentPropName, [{\n            [this.options.textNodeName]: comment\n          }]);\n        }\n        i = endIndex;\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9, closeIndex);\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if (this.options.cdataPropName) {\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [{\n            [this.options.textNodeName]: tagExp\n          }]);\n        } else {\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if (val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        i = closeIndex + 2;\n      } else {\n        //Opening tag\n        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n        let tagName = result.tagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        //save text as child node\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n        if (tagName !== xmlObj.tagname) {\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n          currentNode = this.tagsNodeStack.pop();\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          //TODO: namespace\n          let tagContent = \"\";\n          //self-closing tag\n          if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n            i = result.closeIndex;\n          }\n          //boolean tag\n          else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n            i = result.closeIndex;\n          }\n          //normal tag\n          else {\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\n            if (!result) throw new Error(`Unexpected end of ${tagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n          const childNode = new xmlNode(tagName);\n          if (tagName !== tagExp && attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n          }\n          if (tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          currentNode.addChild(childNode);\n        } else {\n          //selfClosing tag\n          if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n            if (tagName[tagName.length - 1] === \"/\") {\n              //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              tagExp = tagName;\n            } else {\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            const childNode = new xmlNode(tagName);\n            if (tagName !== tagExp && attrExpPresent) {\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n            }\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n            currentNode.addChild(childNode);\n          }\n          //opening tag\n          else {\n            const childNode = new xmlNode(tagName);\n            this.tagsNodeStack.push(currentNode);\n            if (tagName !== tagExp && attrExpPresent) {\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n            }\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n};\nconst replaceEntitiesValue = function (val) {\n  if (this.options.processEntities) {\n    for (let entityName in this.docTypeEntities) {\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace(entity.regx, entity.val);\n    }\n    for (let entityName in this.lastEntities) {\n      const entity = this.lastEntities[entityName];\n      val = val.replace(entity.regex, entity.val);\n    }\n    if (this.options.htmlEntities) {\n      for (let entityName in this.htmlEntities) {\n        const entity = this.htmlEntities[entityName];\n        val = val.replace(entity.regex, entity.val);\n      }\n    }\n    val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n};\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) {\n    //store previously collected data as textNode\n    if (isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;\n    textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n    if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\r\n * \r\n * @param {string[]} stopNodes \r\n * @param {string} jPath\r\n * @param {string} currentTagName \r\n */\nfunction isItStopNode(stopNodes, jPath, currentTagName) {\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n  }\n  return false;\n}\n\n/**\r\n * Returns the tag Expression and where it is ending handling single-dobule quotes situation\r\n * @param {string} xmlData \r\n * @param {number} i starting index\r\n * @returns \r\n */\nfunction tagExpWithClosingIndex(xmlData, i) {\n  let closingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \">\";\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if (closingChar[1]) {\n        if (xmlData[index + 1] === closingChar[1]) {\n          return {\n            data: tagExp,\n            index: index\n          };\n        }\n      } else {\n        return {\n          data: tagExp,\n          index: index\n        };\n      }\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n    tagExp += ch;\n  }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix) {\n  let closingChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \">\";\n  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n  if (!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if (separatorIndex !== -1) {\n    //separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n  if (removeNSPrefix) {\n    const colonIndex = tagName.indexOf(\":\");\n    if (colonIndex !== -1) {\n      tagName = tagName.substr(colonIndex + 1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent\n  };\n}\n/**\r\n * find paired tag for a stop node\r\n * @param {string} xmlData \r\n * @param {string} tagName \r\n * @param {number} i \r\n */\nfunction readStopNodeData(xmlData, tagName, i) {\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === \"<\") {\n      if (xmlData[i + 1] === \"/\") {\n        //close tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (closeTagName === tagName) {\n          openTagCount--;\n          if (openTagCount === 0) {\n            return {\n              tagContent: xmlData.substring(startIndex, i),\n              i: closeIndex\n            };\n          }\n        }\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n        i = closeIndex;\n      } else {\n        const tagData = readTagExp(xmlData, i, '>');\n        if (tagData) {\n          const openTagName = tagData && tagData.tagName;\n          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n            openTagCount++;\n          }\n          i = tagData.closeIndex;\n        }\n      }\n    }\n  } //end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\nmodule.exports = OrderedObjParser;","map":{"version":3,"names":["util","require","xmlNode","readDocType","toNumber","regx","replace","nameRegexp","OrderedObjParser","constructor","options","currentNode","tagsNodeStack","docTypeEntities","lastEntities","regex","val","ampEntity","htmlEntities","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","externalEntities","entKeys","Object","keys","i","length","ent","RegExp","tagName","jPath","dontTrim","hasAttributes","isLeafNode","escapeEntities","undefined","trimValues","trim","newval","tagValueProcessor","parseValue","parseTagValue","numberParseOptions","trimmedVal","tagname","removeNSPrefix","tags","split","prefix","charAt","attrsRegx","attrStr","ignoreAttributes","matches","getAllMatches","len","attrs","attrName","oldVal","aName","attributeNamePrefix","newVal","attributeValueProcessor","parseAttributeValue","allowBooleanAttributes","attributesGroupName","attrCollection","xmlData","xmlObj","textData","ch","closeIndex","findClosingIndex","substring","colonIndex","indexOf","substr","transformTagName","lastIndexOf","pop","tagData","readTagExp","Error","ignoreDeclaration","ignorePiTags","childNode","add","textNodeName","tagExp","attrExpPresent","addChild","endIndex","commentPropName","comment","result","entities","cdataPropName","lastTag","unpairedTags","stopNodes","tagContent","push","child","processEntities","entityName","entity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","tagExpWithClosingIndex","closingChar","attrBoundary","index","data","str","errMsg","closingIndex","separatorIndex","search","startIndex","openTagCount","closeTagName","openTagName","shouldParse","isExist","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"],"sourcesContent":["'use strict';\r\n///@ts-check\r\n\r\nconst util = require('../util');\r\nconst xmlNode = require('./xmlNode');\r\nconst readDocType = require(\"./DocTypeReader\");\r\nconst toNumber = require(\"strnum\");\r\n\r\nconst regx =\r\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\r\n  .replace(/NAME/g, util.nameRegexp);\r\n\r\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\r\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\r\n\r\nclass OrderedObjParser{\r\n  constructor(options){\r\n    this.options = options;\r\n    this.currentNode = null;\r\n    this.tagsNodeStack = [];\r\n    this.docTypeEntities = {};\r\n    this.lastEntities = {\r\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\r\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\r\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\r\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\r\n    };\r\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\r\n    this.htmlEntities = {\r\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\r\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\r\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\r\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\r\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\r\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\r\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\r\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\r\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\r\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\r\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\r\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\r\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\r\n    };\r\n    this.addExternalEntities = addExternalEntities;\r\n    this.parseXml = parseXml;\r\n    this.parseTextData = parseTextData;\r\n    this.resolveNameSpace = resolveNameSpace;\r\n    this.buildAttributesMap = buildAttributesMap;\r\n    this.isItStopNode = isItStopNode;\r\n    this.replaceEntitiesValue = replaceEntitiesValue;\r\n    this.readStopNodeData = readStopNodeData;\r\n    this.saveTextToParentTag = saveTextToParentTag;\r\n  }\r\n\r\n}\r\n\r\nfunction addExternalEntities(externalEntities){\r\n  const entKeys = Object.keys(externalEntities);\r\n  for (let i = 0; i < entKeys.length; i++) {\r\n    const ent = entKeys[i];\r\n    this.lastEntities[ent] = {\r\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\r\n       val : externalEntities[ent]\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} val\r\n * @param {string} tagName\r\n * @param {string} jPath\r\n * @param {boolean} dontTrim\r\n * @param {boolean} hasAttributes\r\n * @param {boolean} isLeafNode\r\n * @param {boolean} escapeEntities\r\n */\r\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\r\n  if (val !== undefined) {\r\n    if (this.options.trimValues && !dontTrim) {\r\n      val = val.trim();\r\n    }\r\n    if(val.length > 0){\r\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\r\n      \r\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\r\n      if(newval === null || newval === undefined){\r\n        //don't parse\r\n        return val;\r\n      }else if(typeof newval !== typeof val || newval !== val){\r\n        //overwrite\r\n        return newval;\r\n      }else if(this.options.trimValues){\r\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\r\n      }else{\r\n        const trimmedVal = val.trim();\r\n        if(trimmedVal === val){\r\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\r\n        }else{\r\n          return val;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction resolveNameSpace(tagname) {\r\n  if (this.options.removeNSPrefix) {\r\n    const tags = tagname.split(':');\r\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\r\n    if (tags[0] === 'xmlns') {\r\n      return '';\r\n    }\r\n    if (tags.length === 2) {\r\n      tagname = prefix + tags[1];\r\n    }\r\n  }\r\n  return tagname;\r\n}\r\n\r\n//TODO: change regex to capture NS\r\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\r\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\r\n\r\nfunction buildAttributesMap(attrStr, jPath) {\r\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\r\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\r\n    //attrStr = attrStr || attrStr.trim();\r\n\r\n    const matches = util.getAllMatches(attrStr, attrsRegx);\r\n    const len = matches.length; //don't make it inline\r\n    const attrs = {};\r\n    for (let i = 0; i < len; i++) {\r\n      const attrName = this.resolveNameSpace(matches[i][1]);\r\n      let oldVal = matches[i][4];\r\n      const aName = this.options.attributeNamePrefix + attrName;\r\n      if (attrName.length) {\r\n        if (oldVal !== undefined) {\r\n          if (this.options.trimValues) {\r\n            oldVal = oldVal.trim();\r\n          }\r\n          oldVal = this.replaceEntitiesValue(oldVal);\r\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\r\n          if(newVal === null || newVal === undefined){\r\n            //don't parse\r\n            attrs[aName] = oldVal;\r\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\r\n            //overwrite\r\n            attrs[aName] = newVal;\r\n          }else{\r\n            //parse\r\n            attrs[aName] = parseValue(\r\n              oldVal,\r\n              this.options.parseAttributeValue,\r\n              this.options.numberParseOptions\r\n            );\r\n          }\r\n        } else if (this.options.allowBooleanAttributes) {\r\n          attrs[aName] = true;\r\n        }\r\n      }\r\n    }\r\n    if (!Object.keys(attrs).length) {\r\n      return;\r\n    }\r\n    if (this.options.attributesGroupName) {\r\n      const attrCollection = {};\r\n      attrCollection[this.options.attributesGroupName] = attrs;\r\n      return attrCollection;\r\n    }\r\n    return attrs;\r\n  }\r\n}\r\n\r\nconst parseXml = function(xmlData) {\r\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\r\n  const xmlObj = new xmlNode('!xml');\r\n  let currentNode = xmlObj;\r\n  let textData = \"\";\r\n  let jPath = \"\";\r\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\r\n    const ch = xmlData[i];\r\n    if(ch === '<'){\r\n      // const nextIndex = i+1;\r\n      // const _2ndChar = xmlData[nextIndex];\r\n      if( xmlData[i+1] === '/') {//Closing Tag\r\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\r\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\r\n\r\n        if(this.options.removeNSPrefix){\r\n          const colonIndex = tagName.indexOf(\":\");\r\n          if(colonIndex !== -1){\r\n            tagName = tagName.substr(colonIndex+1);\r\n          }\r\n        }\r\n\r\n        if(this.options.transformTagName) {\r\n          tagName = this.options.transformTagName(tagName);\r\n        }\r\n\r\n        if(currentNode){\r\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\r\n        }\r\n\r\n        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\r\n        \r\n        currentNode = this.tagsNodeStack.pop();//avoid recurssion, set the parent tag scope\r\n        textData = \"\";\r\n        i = closeIndex;\r\n      } else if( xmlData[i+1] === '?') {\r\n\r\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\r\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\r\n\r\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\r\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\r\n\r\n        }else{\r\n  \r\n          const childNode = new xmlNode(tagData.tagName);\r\n          childNode.add(this.options.textNodeName, \"\");\r\n          \r\n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\r\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath);\r\n          }\r\n          currentNode.addChild(childNode);\r\n\r\n        }\r\n\r\n\r\n        i = tagData.closeIndex + 1;\r\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\r\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\r\n        if(this.options.commentPropName){\r\n          const comment = xmlData.substring(i + 4, endIndex - 2);\r\n\r\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\r\n\r\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\r\n        }\r\n        i = endIndex;\r\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\r\n        const result = readDocType(xmlData, i);\r\n        this.docTypeEntities = result.entities;\r\n        i = result.i;\r\n      }else if(xmlData.substr(i + 1, 2) === '![') {\r\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\r\n        const tagExp = xmlData.substring(i + 9,closeIndex);\r\n\r\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\r\n\r\n        //cdata should be set even if it is 0 length string\r\n        if(this.options.cdataPropName){\r\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\r\n          // if(!val) val = \"\";\r\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\r\n        }else{\r\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\r\n          if(val == undefined) val = \"\";\r\n          currentNode.add(this.options.textNodeName, val);\r\n        }\r\n        \r\n        i = closeIndex + 2;\r\n      }else {//Opening tag\r\n        let result = readTagExp(xmlData,i, this. options.removeNSPrefix);\r\n        let tagName= result.tagName;\r\n        let tagExp = result.tagExp;\r\n        let attrExpPresent = result.attrExpPresent;\r\n        let closeIndex = result.closeIndex;\r\n\r\n        if (this.options.transformTagName) {\r\n          tagName = this.options.transformTagName(tagName);\r\n        }\r\n        \r\n        //save text as child node\r\n        if (currentNode && textData) {\r\n          if(currentNode.tagname !== '!xml'){\r\n            //when nested tag is found\r\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\r\n          }\r\n        }\r\n\r\n        if(tagName !== xmlObj.tagname){\r\n          jPath += jPath ? \".\" + tagName : tagName;\r\n        }\r\n\r\n        //check if last tag was unpaired tag\r\n        const lastTag = currentNode;\r\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\r\n          currentNode = this.tagsNodeStack.pop();\r\n        }\r\n\r\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace\r\n          let tagContent = \"\";\r\n          //self-closing tag\r\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\r\n            i = result.closeIndex;\r\n          }\r\n          //boolean tag\r\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\r\n            i = result.closeIndex;\r\n          }\r\n          //normal tag\r\n          else{\r\n            //read until closing tag is found\r\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\r\n            if(!result) throw new Error(`Unexpected end of ${tagName}`);\r\n            i = result.i;\r\n            tagContent = result.tagContent;\r\n          }\r\n\r\n          const childNode = new xmlNode(tagName);\r\n          if(tagName !== tagExp && attrExpPresent){\r\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\r\n          }\r\n          if(tagContent) {\r\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\r\n          }\r\n          \r\n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\r\n          childNode.add(this.options.textNodeName, tagContent);\r\n          \r\n          currentNode.addChild(childNode);\r\n        }else{\r\n  //selfClosing tag\r\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\r\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\r\n              tagName = tagName.substr(0, tagName.length - 1);\r\n              tagExp = tagName;\r\n            }else{\r\n              tagExp = tagExp.substr(0, tagExp.length - 1);\r\n            }\r\n            \r\n            if(this.options.transformTagName) {\r\n              tagName = this.options.transformTagName(tagName);\r\n            }\r\n\r\n            const childNode = new xmlNode(tagName);\r\n            if(tagName !== tagExp && attrExpPresent){\r\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\r\n            }\r\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\r\n            currentNode.addChild(childNode);\r\n          }\r\n    //opening tag\r\n          else{\r\n            const childNode = new xmlNode( tagName);\r\n            this.tagsNodeStack.push(currentNode);\r\n            \r\n            if(tagName !== tagExp && attrExpPresent){\r\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\r\n            }\r\n            currentNode.addChild(childNode);\r\n            currentNode = childNode;\r\n          }\r\n          textData = \"\";\r\n          i = closeIndex;\r\n        }\r\n      }\r\n    }else{\r\n      textData += xmlData[i];\r\n    }\r\n  }\r\n  return xmlObj.child;\r\n}\r\n\r\nconst replaceEntitiesValue = function(val){\r\n\r\n  if(this.options.processEntities){\r\n    for(let entityName in this.docTypeEntities){\r\n      const entity = this.docTypeEntities[entityName];\r\n      val = val.replace( entity.regx, entity.val);\r\n    }\r\n    for(let entityName in this.lastEntities){\r\n      const entity = this.lastEntities[entityName];\r\n      val = val.replace( entity.regex, entity.val);\r\n    }\r\n    if(this.options.htmlEntities){\r\n      for(let entityName in this.htmlEntities){\r\n        const entity = this.htmlEntities[entityName];\r\n        val = val.replace( entity.regex, entity.val);\r\n      }\r\n    }\r\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\r\n  }\r\n  return val;\r\n}\r\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\r\n  if (textData) { //store previously collected data as textNode\r\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\r\n    \r\n    textData = this.parseTextData(textData,\r\n      currentNode.tagname,\r\n      jPath,\r\n      false,\r\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\r\n      isLeafNode);\r\n\r\n    if (textData !== undefined && textData !== \"\")\r\n      currentNode.add(this.options.textNodeName, textData);\r\n    textData = \"\";\r\n  }\r\n  return textData;\r\n}\r\n\r\n//TODO: use jPath to simplify the logic\r\n/**\r\n * \r\n * @param {string[]} stopNodes \r\n * @param {string} jPath\r\n * @param {string} currentTagName \r\n */\r\nfunction isItStopNode(stopNodes, jPath, currentTagName){\r\n  const allNodesExp = \"*.\" + currentTagName;\r\n  for (const stopNodePath in stopNodes) {\r\n    const stopNodeExp = stopNodes[stopNodePath];\r\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns the tag Expression and where it is ending handling single-dobule quotes situation\r\n * @param {string} xmlData \r\n * @param {number} i starting index\r\n * @returns \r\n */\r\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\r\n  let attrBoundary;\r\n  let tagExp = \"\";\r\n  for (let index = i; index < xmlData.length; index++) {\r\n    let ch = xmlData[index];\r\n    if (attrBoundary) {\r\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\r\n    } else if (ch === '\"' || ch === \"'\") {\r\n        attrBoundary = ch;\r\n    } else if (ch === closingChar[0]) {\r\n      if(closingChar[1]){\r\n        if(xmlData[index + 1] === closingChar[1]){\r\n          return {\r\n            data: tagExp,\r\n            index: index\r\n          }\r\n        }\r\n      }else{\r\n        return {\r\n          data: tagExp,\r\n          index: index\r\n        }\r\n      }\r\n    } else if (ch === '\\t') {\r\n      ch = \" \"\r\n    }\r\n    tagExp += ch;\r\n  }\r\n}\r\n\r\nfunction findClosingIndex(xmlData, str, i, errMsg){\r\n  const closingIndex = xmlData.indexOf(str, i);\r\n  if(closingIndex === -1){\r\n    throw new Error(errMsg)\r\n  }else{\r\n    return closingIndex + str.length - 1;\r\n  }\r\n}\r\n\r\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\r\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\r\n  if(!result) return;\r\n  let tagExp = result.data;\r\n  const closeIndex = result.index;\r\n  const separatorIndex = tagExp.search(/\\s/);\r\n  let tagName = tagExp;\r\n  let attrExpPresent = true;\r\n  if(separatorIndex !== -1){//separate tag name and attributes expression\r\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\r\n    tagExp = tagExp.substr(separatorIndex + 1);\r\n  }\r\n\r\n  if(removeNSPrefix){\r\n    const colonIndex = tagName.indexOf(\":\");\r\n    if(colonIndex !== -1){\r\n      tagName = tagName.substr(colonIndex+1);\r\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\r\n    }\r\n  }\r\n\r\n  return {\r\n    tagName: tagName,\r\n    tagExp: tagExp,\r\n    closeIndex: closeIndex,\r\n    attrExpPresent: attrExpPresent,\r\n  }\r\n}\r\n/**\r\n * find paired tag for a stop node\r\n * @param {string} xmlData \r\n * @param {string} tagName \r\n * @param {number} i \r\n */\r\nfunction readStopNodeData(xmlData, tagName, i){\r\n  const startIndex = i;\r\n  // Starting at 1 since we already have an open tag\r\n  let openTagCount = 1;\r\n\r\n  for (; i < xmlData.length; i++) {\r\n    if( xmlData[i] === \"<\"){ \r\n      if (xmlData[i+1] === \"/\") {//close tag\r\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\r\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\r\n          if(closeTagName === tagName){\r\n            openTagCount--;\r\n            if (openTagCount === 0) {\r\n              return {\r\n                tagContent: xmlData.substring(startIndex, i),\r\n                i : closeIndex\r\n              }\r\n            }\r\n          }\r\n          i=closeIndex;\r\n        } else if(xmlData[i+1] === '?') { \r\n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\r\n          i=closeIndex;\r\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \r\n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\r\n          i=closeIndex;\r\n        } else if(xmlData.substr(i + 1, 2) === '![') { \r\n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\r\n          i=closeIndex;\r\n        } else {\r\n          const tagData = readTagExp(xmlData, i, '>')\r\n\r\n          if (tagData) {\r\n            const openTagName = tagData && tagData.tagName;\r\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\r\n              openTagCount++;\r\n            }\r\n            i=tagData.closeIndex;\r\n          }\r\n        }\r\n      }\r\n  }//end for loop\r\n}\r\n\r\nfunction parseValue(val, shouldParse, options) {\r\n  if (shouldParse && typeof val === 'string') {\r\n    //console.log(options)\r\n    const newval = val.trim();\r\n    if(newval === 'true' ) return true;\r\n    else if(newval === 'false' ) return false;\r\n    else return toNumber(val, options);\r\n  } else {\r\n    if (util.isExist(val)) {\r\n      return val;\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = OrderedObjParser;\r\n"],"mappings":"AAAA,YAAY;;AACZ;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC/B,MAAMC,OAAO,GAAGD,OAAO,CAAC,WAAW,CAAC;AACpC,MAAME,WAAW,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAC9C,MAAMG,QAAQ,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAElC,MAAMI,IAAI,GACR,uFAAuF,CACtFC,OAAO,CAAC,OAAO,EAAEN,IAAI,CAACO,UAAU,CAAC;;AAEpC;AACA;;AAEA,MAAMC,gBAAgB;EACpBC,WAAW,CAACC,OAAO,EAAC;IAClB,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,eAAe,GAAG,CAAC,CAAC;IACzB,IAAI,CAACC,YAAY,GAAG;MAClB,MAAM,EAAG;QAAEC,KAAK,EAAE,oBAAoB;QAAEC,GAAG,EAAG;MAAG,CAAC;MAClD,IAAI,EAAG;QAAED,KAAK,EAAE,kBAAkB;QAAEC,GAAG,EAAG;MAAG,CAAC;MAC9C,IAAI,EAAG;QAAED,KAAK,EAAE,kBAAkB;QAAEC,GAAG,EAAG;MAAG,CAAC;MAC9C,MAAM,EAAG;QAAED,KAAK,EAAE,oBAAoB;QAAEC,GAAG,EAAG;MAAI;IACpD,CAAC;IACD,IAAI,CAACC,SAAS,GAAG;MAAEF,KAAK,EAAE,mBAAmB;MAAEC,GAAG,EAAG;IAAG,CAAC;IACzD,IAAI,CAACE,YAAY,GAAG;MAClB,OAAO,EAAE;QAAEH,KAAK,EAAE,gBAAgB;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC9C;MACA;MACA;MACA;MACA;MACA,MAAM,EAAG;QAAED,KAAK,EAAE,gBAAgB;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC9C,OAAO,EAAG;QAAED,KAAK,EAAE,iBAAiB;QAAEC,GAAG,EAAE;MAAI,CAAC;MAChD,KAAK,EAAG;QAAED,KAAK,EAAE,eAAe;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC5C,MAAM,EAAG;QAAED,KAAK,EAAE,iBAAiB;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC/C,WAAW,EAAG;QAAED,KAAK,EAAE,gBAAgB;QAAEC,GAAG,EAAE;MAAI,CAAC;MACnD,KAAK,EAAG;QAAED,KAAK,EAAE,eAAe;QAAEC,GAAG,EAAE;MAAI,CAAC;MAC5C,KAAK,EAAG;QAAED,KAAK,EAAE,gBAAgB;QAAEC,GAAG,EAAE;MAAI;IAC9C,CAAC;IACD,IAAI,CAACG,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;EAChD;AAEF;AAEA,SAASR,mBAAmB,CAACS,gBAAgB,EAAC;EAC5C,MAAMC,OAAO,GAAGC,MAAM,CAACC,IAAI,CAACH,gBAAgB,CAAC;EAC7C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,OAAO,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC,MAAME,GAAG,GAAGL,OAAO,CAACG,CAAC,CAAC;IACtB,IAAI,CAAClB,YAAY,CAACoB,GAAG,CAAC,GAAG;MACtBnB,KAAK,EAAE,IAAIoB,MAAM,CAAC,GAAG,GAACD,GAAG,GAAC,GAAG,EAAC,GAAG,CAAC;MAClClB,GAAG,EAAGY,gBAAgB,CAACM,GAAG;IAC7B,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,aAAa,CAACL,GAAG,EAAEoB,OAAO,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,UAAU,EAAEC,cAAc,EAAE;EAC/F,IAAIzB,GAAG,KAAK0B,SAAS,EAAE;IACrB,IAAI,IAAI,CAAChC,OAAO,CAACiC,UAAU,IAAI,CAACL,QAAQ,EAAE;MACxCtB,GAAG,GAAGA,GAAG,CAAC4B,IAAI,EAAE;IAClB;IACA,IAAG5B,GAAG,CAACiB,MAAM,GAAG,CAAC,EAAC;MAChB,IAAG,CAACQ,cAAc,EAAEzB,GAAG,GAAG,IAAI,CAACS,oBAAoB,CAACT,GAAG,CAAC;MAExD,MAAM6B,MAAM,GAAG,IAAI,CAACnC,OAAO,CAACoC,iBAAiB,CAACV,OAAO,EAAEpB,GAAG,EAAEqB,KAAK,EAAEE,aAAa,EAAEC,UAAU,CAAC;MAC7F,IAAGK,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAKH,SAAS,EAAC;QACzC;QACA,OAAO1B,GAAG;MACZ,CAAC,MAAK,IAAG,OAAO6B,MAAM,KAAK,OAAO7B,GAAG,IAAI6B,MAAM,KAAK7B,GAAG,EAAC;QACtD;QACA,OAAO6B,MAAM;MACf,CAAC,MAAK,IAAG,IAAI,CAACnC,OAAO,CAACiC,UAAU,EAAC;QAC/B,OAAOI,UAAU,CAAC/B,GAAG,EAAE,IAAI,CAACN,OAAO,CAACsC,aAAa,EAAE,IAAI,CAACtC,OAAO,CAACuC,kBAAkB,CAAC;MACrF,CAAC,MAAI;QACH,MAAMC,UAAU,GAAGlC,GAAG,CAAC4B,IAAI,EAAE;QAC7B,IAAGM,UAAU,KAAKlC,GAAG,EAAC;UACpB,OAAO+B,UAAU,CAAC/B,GAAG,EAAE,IAAI,CAACN,OAAO,CAACsC,aAAa,EAAE,IAAI,CAACtC,OAAO,CAACuC,kBAAkB,CAAC;QACrF,CAAC,MAAI;UACH,OAAOjC,GAAG;QACZ;MACF;IACF;EACF;AACF;AAEA,SAASM,gBAAgB,CAAC6B,OAAO,EAAE;EACjC,IAAI,IAAI,CAACzC,OAAO,CAAC0C,cAAc,EAAE;IAC/B,MAAMC,IAAI,GAAGF,OAAO,CAACG,KAAK,CAAC,GAAG,CAAC;IAC/B,MAAMC,MAAM,GAAGJ,OAAO,CAACK,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,EAAE;IACnD,IAAIH,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;MACvB,OAAO,EAAE;IACX;IACA,IAAIA,IAAI,CAACpB,MAAM,KAAK,CAAC,EAAE;MACrBkB,OAAO,GAAGI,MAAM,GAAGF,IAAI,CAAC,CAAC,CAAC;IAC5B;EACF;EACA,OAAOF,OAAO;AAChB;;AAEA;AACA;AACA,MAAMM,SAAS,GAAG,IAAItB,MAAM,CAAC,8CAA8C,EAAE,IAAI,CAAC;AAElF,SAASZ,kBAAkB,CAACmC,OAAO,EAAErB,KAAK,EAAE;EAC1C,IAAI,CAAC,IAAI,CAAC3B,OAAO,CAACiD,gBAAgB,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE;IACjE;IACA;;IAEA,MAAME,OAAO,GAAG5D,IAAI,CAAC6D,aAAa,CAACH,OAAO,EAAED,SAAS,CAAC;IACtD,MAAMK,GAAG,GAAGF,OAAO,CAAC3B,MAAM,CAAC,CAAC;IAC5B,MAAM8B,KAAK,GAAG,CAAC,CAAC;IAChB,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,GAAG,EAAE9B,CAAC,EAAE,EAAE;MAC5B,MAAMgC,QAAQ,GAAG,IAAI,CAAC1C,gBAAgB,CAACsC,OAAO,CAAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACrD,IAAIiC,MAAM,GAAGL,OAAO,CAAC5B,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1B,MAAMkC,KAAK,GAAG,IAAI,CAACxD,OAAO,CAACyD,mBAAmB,GAAGH,QAAQ;MACzD,IAAIA,QAAQ,CAAC/B,MAAM,EAAE;QACnB,IAAIgC,MAAM,KAAKvB,SAAS,EAAE;UACxB,IAAI,IAAI,CAAChC,OAAO,CAACiC,UAAU,EAAE;YAC3BsB,MAAM,GAAGA,MAAM,CAACrB,IAAI,EAAE;UACxB;UACAqB,MAAM,GAAG,IAAI,CAACxC,oBAAoB,CAACwC,MAAM,CAAC;UAC1C,MAAMG,MAAM,GAAG,IAAI,CAAC1D,OAAO,CAAC2D,uBAAuB,CAACL,QAAQ,EAAEC,MAAM,EAAE5B,KAAK,CAAC;UAC5E,IAAG+B,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK1B,SAAS,EAAC;YACzC;YACAqB,KAAK,CAACG,KAAK,CAAC,GAAGD,MAAM;UACvB,CAAC,MAAK,IAAG,OAAOG,MAAM,KAAK,OAAOH,MAAM,IAAIG,MAAM,KAAKH,MAAM,EAAC;YAC5D;YACAF,KAAK,CAACG,KAAK,CAAC,GAAGE,MAAM;UACvB,CAAC,MAAI;YACH;YACAL,KAAK,CAACG,KAAK,CAAC,GAAGnB,UAAU,CACvBkB,MAAM,EACN,IAAI,CAACvD,OAAO,CAAC4D,mBAAmB,EAChC,IAAI,CAAC5D,OAAO,CAACuC,kBAAkB,CAChC;UACH;QACF,CAAC,MAAM,IAAI,IAAI,CAACvC,OAAO,CAAC6D,sBAAsB,EAAE;UAC9CR,KAAK,CAACG,KAAK,CAAC,GAAG,IAAI;QACrB;MACF;IACF;IACA,IAAI,CAACpC,MAAM,CAACC,IAAI,CAACgC,KAAK,CAAC,CAAC9B,MAAM,EAAE;MAC9B;IACF;IACA,IAAI,IAAI,CAACvB,OAAO,CAAC8D,mBAAmB,EAAE;MACpC,MAAMC,cAAc,GAAG,CAAC,CAAC;MACzBA,cAAc,CAAC,IAAI,CAAC/D,OAAO,CAAC8D,mBAAmB,CAAC,GAAGT,KAAK;MACxD,OAAOU,cAAc;IACvB;IACA,OAAOV,KAAK;EACd;AACF;AAEA,MAAM3C,QAAQ,GAAG,UAASsD,OAAO,EAAE;EACjCA,OAAO,GAAGA,OAAO,CAACpE,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;EAC3C,MAAMqE,MAAM,GAAG,IAAIzE,OAAO,CAAC,MAAM,CAAC;EAClC,IAAIS,WAAW,GAAGgE,MAAM;EACxB,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIvC,KAAK,GAAG,EAAE;EACd,KAAI,IAAIL,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE0C,OAAO,CAACzC,MAAM,EAAED,CAAC,EAAE,EAAC;IAAC;IACnC,MAAM6C,EAAE,GAAGH,OAAO,CAAC1C,CAAC,CAAC;IACrB,IAAG6C,EAAE,KAAK,GAAG,EAAC;MACZ;MACA;MACA,IAAIH,OAAO,CAAC1C,CAAC,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAAC;QACzB,MAAM8C,UAAU,GAAGC,gBAAgB,CAACL,OAAO,EAAE,GAAG,EAAE1C,CAAC,EAAE,4BAA4B,CAAC;QAClF,IAAII,OAAO,GAAGsC,OAAO,CAACM,SAAS,CAAChD,CAAC,GAAC,CAAC,EAAC8C,UAAU,CAAC,CAAClC,IAAI,EAAE;QAEtD,IAAG,IAAI,CAAClC,OAAO,CAAC0C,cAAc,EAAC;UAC7B,MAAM6B,UAAU,GAAG7C,OAAO,CAAC8C,OAAO,CAAC,GAAG,CAAC;UACvC,IAAGD,UAAU,KAAK,CAAC,CAAC,EAAC;YACnB7C,OAAO,GAAGA,OAAO,CAAC+C,MAAM,CAACF,UAAU,GAAC,CAAC,CAAC;UACxC;QACF;QAEA,IAAG,IAAI,CAACvE,OAAO,CAAC0E,gBAAgB,EAAE;UAChChD,OAAO,GAAG,IAAI,CAAC1B,OAAO,CAAC0E,gBAAgB,CAAChD,OAAO,CAAC;QAClD;QAEA,IAAGzB,WAAW,EAAC;UACbiE,QAAQ,GAAG,IAAI,CAACjD,mBAAmB,CAACiD,QAAQ,EAAEjE,WAAW,EAAE0B,KAAK,CAAC;QACnE;QAEAA,KAAK,GAAGA,KAAK,CAAC8C,MAAM,CAAC,CAAC,EAAE9C,KAAK,CAACgD,WAAW,CAAC,GAAG,CAAC,CAAC;QAE/C1E,WAAW,GAAG,IAAI,CAACC,aAAa,CAAC0E,GAAG,EAAE,CAAC;QACvCV,QAAQ,GAAG,EAAE;QACb5C,CAAC,GAAG8C,UAAU;MAChB,CAAC,MAAM,IAAIJ,OAAO,CAAC1C,CAAC,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAE/B,IAAIuD,OAAO,GAAGC,UAAU,CAACd,OAAO,EAAC1C,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC;QAChD,IAAG,CAACuD,OAAO,EAAE,MAAM,IAAIE,KAAK,CAAC,uBAAuB,CAAC;QAErDb,QAAQ,GAAG,IAAI,CAACjD,mBAAmB,CAACiD,QAAQ,EAAEjE,WAAW,EAAE0B,KAAK,CAAC;QACjE,IAAK,IAAI,CAAC3B,OAAO,CAACgF,iBAAiB,IAAIH,OAAO,CAACnD,OAAO,KAAK,MAAM,IAAK,IAAI,CAAC1B,OAAO,CAACiF,YAAY,EAAC,CAEhG,CAAC,MAAI;UAEH,MAAMC,SAAS,GAAG,IAAI1F,OAAO,CAACqF,OAAO,CAACnD,OAAO,CAAC;UAC9CwD,SAAS,CAACC,GAAG,CAAC,IAAI,CAACnF,OAAO,CAACoF,YAAY,EAAE,EAAE,CAAC;UAE5C,IAAGP,OAAO,CAACnD,OAAO,KAAKmD,OAAO,CAACQ,MAAM,IAAIR,OAAO,CAACS,cAAc,EAAC;YAC9DJ,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAACrE,kBAAkB,CAACgE,OAAO,CAACQ,MAAM,EAAE1D,KAAK,CAAC;UAClE;UACA1B,WAAW,CAACsF,QAAQ,CAACL,SAAS,CAAC;QAEjC;QAGA5D,CAAC,GAAGuD,OAAO,CAACT,UAAU,GAAG,CAAC;MAC5B,CAAC,MAAM,IAAGJ,OAAO,CAACS,MAAM,CAACnD,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;QAC5C,MAAMkE,QAAQ,GAAGnB,gBAAgB,CAACL,OAAO,EAAE,KAAK,EAAE1C,CAAC,GAAC,CAAC,EAAE,wBAAwB,CAAC;QAChF,IAAG,IAAI,CAACtB,OAAO,CAACyF,eAAe,EAAC;UAC9B,MAAMC,OAAO,GAAG1B,OAAO,CAACM,SAAS,CAAChD,CAAC,GAAG,CAAC,EAAEkE,QAAQ,GAAG,CAAC,CAAC;UAEtDtB,QAAQ,GAAG,IAAI,CAACjD,mBAAmB,CAACiD,QAAQ,EAAEjE,WAAW,EAAE0B,KAAK,CAAC;UAEjE1B,WAAW,CAACkF,GAAG,CAAC,IAAI,CAACnF,OAAO,CAACyF,eAAe,EAAE,CAAE;YAAE,CAAC,IAAI,CAACzF,OAAO,CAACoF,YAAY,GAAIM;UAAQ,CAAC,CAAE,CAAC;QAC9F;QACApE,CAAC,GAAGkE,QAAQ;MACd,CAAC,MAAM,IAAIxB,OAAO,CAACS,MAAM,CAACnD,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;QAC5C,MAAMqE,MAAM,GAAGlG,WAAW,CAACuE,OAAO,EAAE1C,CAAC,CAAC;QACtC,IAAI,CAACnB,eAAe,GAAGwF,MAAM,CAACC,QAAQ;QACtCtE,CAAC,GAAGqE,MAAM,CAACrE,CAAC;MACd,CAAC,MAAK,IAAG0C,OAAO,CAACS,MAAM,CAACnD,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;QAC1C,MAAM8C,UAAU,GAAGC,gBAAgB,CAACL,OAAO,EAAE,KAAK,EAAE1C,CAAC,EAAE,sBAAsB,CAAC,GAAG,CAAC;QAClF,MAAM+D,MAAM,GAAGrB,OAAO,CAACM,SAAS,CAAChD,CAAC,GAAG,CAAC,EAAC8C,UAAU,CAAC;QAElDF,QAAQ,GAAG,IAAI,CAACjD,mBAAmB,CAACiD,QAAQ,EAAEjE,WAAW,EAAE0B,KAAK,CAAC;;QAEjE;QACA,IAAG,IAAI,CAAC3B,OAAO,CAAC6F,aAAa,EAAC;UAC5B;UACA;UACA5F,WAAW,CAACkF,GAAG,CAAC,IAAI,CAACnF,OAAO,CAAC6F,aAAa,EAAE,CAAE;YAAE,CAAC,IAAI,CAAC7F,OAAO,CAACoF,YAAY,GAAIC;UAAO,CAAC,CAAE,CAAC;QAC3F,CAAC,MAAI;UACH,IAAI/E,GAAG,GAAG,IAAI,CAACK,aAAa,CAAC0E,MAAM,EAAEpF,WAAW,CAACwC,OAAO,EAAEd,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;UACnF,IAAGrB,GAAG,IAAI0B,SAAS,EAAE1B,GAAG,GAAG,EAAE;UAC7BL,WAAW,CAACkF,GAAG,CAAC,IAAI,CAACnF,OAAO,CAACoF,YAAY,EAAE9E,GAAG,CAAC;QACjD;QAEAgB,CAAC,GAAG8C,UAAU,GAAG,CAAC;MACpB,CAAC,MAAK;QAAC;QACL,IAAIuB,MAAM,GAAGb,UAAU,CAACd,OAAO,EAAC1C,CAAC,EAAE,IAAI,CAAEtB,OAAO,CAAC0C,cAAc,CAAC;QAChE,IAAIhB,OAAO,GAAEiE,MAAM,CAACjE,OAAO;QAC3B,IAAI2D,MAAM,GAAGM,MAAM,CAACN,MAAM;QAC1B,IAAIC,cAAc,GAAGK,MAAM,CAACL,cAAc;QAC1C,IAAIlB,UAAU,GAAGuB,MAAM,CAACvB,UAAU;QAElC,IAAI,IAAI,CAACpE,OAAO,CAAC0E,gBAAgB,EAAE;UACjChD,OAAO,GAAG,IAAI,CAAC1B,OAAO,CAAC0E,gBAAgB,CAAChD,OAAO,CAAC;QAClD;;QAEA;QACA,IAAIzB,WAAW,IAAIiE,QAAQ,EAAE;UAC3B,IAAGjE,WAAW,CAACwC,OAAO,KAAK,MAAM,EAAC;YAChC;YACAyB,QAAQ,GAAG,IAAI,CAACjD,mBAAmB,CAACiD,QAAQ,EAAEjE,WAAW,EAAE0B,KAAK,EAAE,KAAK,CAAC;UAC1E;QACF;QAEA,IAAGD,OAAO,KAAKuC,MAAM,CAACxB,OAAO,EAAC;UAC5Bd,KAAK,IAAIA,KAAK,GAAG,GAAG,GAAGD,OAAO,GAAGA,OAAO;QAC1C;;QAEA;QACA,MAAMoE,OAAO,GAAG7F,WAAW;QAC3B,IAAG6F,OAAO,IAAI,IAAI,CAAC9F,OAAO,CAAC+F,YAAY,CAACvB,OAAO,CAACsB,OAAO,CAACrD,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;UACvExC,WAAW,GAAG,IAAI,CAACC,aAAa,CAAC0E,GAAG,EAAE;QACxC;QAEA,IAAI,IAAI,CAAC9D,YAAY,CAAC,IAAI,CAACd,OAAO,CAACgG,SAAS,EAAErE,KAAK,EAAED,OAAO,CAAC,EAAE;UAAE;UAC/D,IAAIuE,UAAU,GAAG,EAAE;UACnB;UACA,IAAGZ,MAAM,CAAC9D,MAAM,GAAG,CAAC,IAAI8D,MAAM,CAACV,WAAW,CAAC,GAAG,CAAC,KAAKU,MAAM,CAAC9D,MAAM,GAAG,CAAC,EAAC;YACpED,CAAC,GAAGqE,MAAM,CAACvB,UAAU;UACvB;UACA;UAAA,KACK,IAAG,IAAI,CAACpE,OAAO,CAAC+F,YAAY,CAACvB,OAAO,CAAC9C,OAAO,CAAC,KAAK,CAAC,CAAC,EAAC;YACxDJ,CAAC,GAAGqE,MAAM,CAACvB,UAAU;UACvB;UACA;UAAA,KACI;YACF;YACA,MAAMuB,MAAM,GAAG,IAAI,CAAC3E,gBAAgB,CAACgD,OAAO,EAAEtC,OAAO,EAAE0C,UAAU,GAAG,CAAC,CAAC;YACtE,IAAG,CAACuB,MAAM,EAAE,MAAM,IAAIZ,KAAK,CAAE,qBAAoBrD,OAAQ,EAAC,CAAC;YAC3DJ,CAAC,GAAGqE,MAAM,CAACrE,CAAC;YACZ2E,UAAU,GAAGN,MAAM,CAACM,UAAU;UAChC;UAEA,MAAMf,SAAS,GAAG,IAAI1F,OAAO,CAACkC,OAAO,CAAC;UACtC,IAAGA,OAAO,KAAK2D,MAAM,IAAIC,cAAc,EAAC;YACtCJ,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAACrE,kBAAkB,CAACwE,MAAM,EAAE1D,KAAK,CAAC;UAC1D;UACA,IAAGsE,UAAU,EAAE;YACbA,UAAU,GAAG,IAAI,CAACtF,aAAa,CAACsF,UAAU,EAAEvE,OAAO,EAAEC,KAAK,EAAE,IAAI,EAAE2D,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC;UAC/F;UAEA3D,KAAK,GAAGA,KAAK,CAAC8C,MAAM,CAAC,CAAC,EAAE9C,KAAK,CAACgD,WAAW,CAAC,GAAG,CAAC,CAAC;UAC/CO,SAAS,CAACC,GAAG,CAAC,IAAI,CAACnF,OAAO,CAACoF,YAAY,EAAEa,UAAU,CAAC;UAEpDhG,WAAW,CAACsF,QAAQ,CAACL,SAAS,CAAC;QACjC,CAAC,MAAI;UACX;UACQ,IAAGG,MAAM,CAAC9D,MAAM,GAAG,CAAC,IAAI8D,MAAM,CAACV,WAAW,CAAC,GAAG,CAAC,KAAKU,MAAM,CAAC9D,MAAM,GAAG,CAAC,EAAC;YACpE,IAAGG,OAAO,CAACA,OAAO,CAACH,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAC;cAAE;cACvCG,OAAO,GAAGA,OAAO,CAAC+C,MAAM,CAAC,CAAC,EAAE/C,OAAO,CAACH,MAAM,GAAG,CAAC,CAAC;cAC/C8D,MAAM,GAAG3D,OAAO;YAClB,CAAC,MAAI;cACH2D,MAAM,GAAGA,MAAM,CAACZ,MAAM,CAAC,CAAC,EAAEY,MAAM,CAAC9D,MAAM,GAAG,CAAC,CAAC;YAC9C;YAEA,IAAG,IAAI,CAACvB,OAAO,CAAC0E,gBAAgB,EAAE;cAChChD,OAAO,GAAG,IAAI,CAAC1B,OAAO,CAAC0E,gBAAgB,CAAChD,OAAO,CAAC;YAClD;YAEA,MAAMwD,SAAS,GAAG,IAAI1F,OAAO,CAACkC,OAAO,CAAC;YACtC,IAAGA,OAAO,KAAK2D,MAAM,IAAIC,cAAc,EAAC;cACtCJ,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAACrE,kBAAkB,CAACwE,MAAM,EAAE1D,KAAK,CAAC;YAC1D;YACAA,KAAK,GAAGA,KAAK,CAAC8C,MAAM,CAAC,CAAC,EAAE9C,KAAK,CAACgD,WAAW,CAAC,GAAG,CAAC,CAAC;YAC/C1E,WAAW,CAACsF,QAAQ,CAACL,SAAS,CAAC;UACjC;UACN;UAAA,KACU;YACF,MAAMA,SAAS,GAAG,IAAI1F,OAAO,CAAEkC,OAAO,CAAC;YACvC,IAAI,CAACxB,aAAa,CAACgG,IAAI,CAACjG,WAAW,CAAC;YAEpC,IAAGyB,OAAO,KAAK2D,MAAM,IAAIC,cAAc,EAAC;cACtCJ,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAACrE,kBAAkB,CAACwE,MAAM,EAAE1D,KAAK,CAAC;YAC1D;YACA1B,WAAW,CAACsF,QAAQ,CAACL,SAAS,CAAC;YAC/BjF,WAAW,GAAGiF,SAAS;UACzB;UACAhB,QAAQ,GAAG,EAAE;UACb5C,CAAC,GAAG8C,UAAU;QAChB;MACF;IACF,CAAC,MAAI;MACHF,QAAQ,IAAIF,OAAO,CAAC1C,CAAC,CAAC;IACxB;EACF;EACA,OAAO2C,MAAM,CAACkC,KAAK;AACrB,CAAC;AAED,MAAMpF,oBAAoB,GAAG,UAAST,GAAG,EAAC;EAExC,IAAG,IAAI,CAACN,OAAO,CAACoG,eAAe,EAAC;IAC9B,KAAI,IAAIC,UAAU,IAAI,IAAI,CAAClG,eAAe,EAAC;MACzC,MAAMmG,MAAM,GAAG,IAAI,CAACnG,eAAe,CAACkG,UAAU,CAAC;MAC/C/F,GAAG,GAAGA,GAAG,CAACV,OAAO,CAAE0G,MAAM,CAAC3G,IAAI,EAAE2G,MAAM,CAAChG,GAAG,CAAC;IAC7C;IACA,KAAI,IAAI+F,UAAU,IAAI,IAAI,CAACjG,YAAY,EAAC;MACtC,MAAMkG,MAAM,GAAG,IAAI,CAAClG,YAAY,CAACiG,UAAU,CAAC;MAC5C/F,GAAG,GAAGA,GAAG,CAACV,OAAO,CAAE0G,MAAM,CAACjG,KAAK,EAAEiG,MAAM,CAAChG,GAAG,CAAC;IAC9C;IACA,IAAG,IAAI,CAACN,OAAO,CAACQ,YAAY,EAAC;MAC3B,KAAI,IAAI6F,UAAU,IAAI,IAAI,CAAC7F,YAAY,EAAC;QACtC,MAAM8F,MAAM,GAAG,IAAI,CAAC9F,YAAY,CAAC6F,UAAU,CAAC;QAC5C/F,GAAG,GAAGA,GAAG,CAACV,OAAO,CAAE0G,MAAM,CAACjG,KAAK,EAAEiG,MAAM,CAAChG,GAAG,CAAC;MAC9C;IACF;IACAA,GAAG,GAAGA,GAAG,CAACV,OAAO,CAAE,IAAI,CAACW,SAAS,CAACF,KAAK,EAAE,IAAI,CAACE,SAAS,CAACD,GAAG,CAAC;EAC9D;EACA,OAAOA,GAAG;AACZ,CAAC;AACD,SAASW,mBAAmB,CAACiD,QAAQ,EAAEjE,WAAW,EAAE0B,KAAK,EAAEG,UAAU,EAAE;EACrE,IAAIoC,QAAQ,EAAE;IAAE;IACd,IAAGpC,UAAU,KAAKE,SAAS,EAAEF,UAAU,GAAGV,MAAM,CAACC,IAAI,CAACpB,WAAW,CAACkG,KAAK,CAAC,CAAC5E,MAAM,KAAK,CAAC;IAErF2C,QAAQ,GAAG,IAAI,CAACvD,aAAa,CAACuD,QAAQ,EACpCjE,WAAW,CAACwC,OAAO,EACnBd,KAAK,EACL,KAAK,EACL1B,WAAW,CAAC,IAAI,CAAC,GAAGmB,MAAM,CAACC,IAAI,CAACpB,WAAW,CAAC,IAAI,CAAC,CAAC,CAACsB,MAAM,KAAK,CAAC,GAAG,KAAK,EACvEO,UAAU,CAAC;IAEb,IAAIoC,QAAQ,KAAKlC,SAAS,IAAIkC,QAAQ,KAAK,EAAE,EAC3CjE,WAAW,CAACkF,GAAG,CAAC,IAAI,CAACnF,OAAO,CAACoF,YAAY,EAAElB,QAAQ,CAAC;IACtDA,QAAQ,GAAG,EAAE;EACf;EACA,OAAOA,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASpD,YAAY,CAACkF,SAAS,EAAErE,KAAK,EAAE4E,cAAc,EAAC;EACrD,MAAMC,WAAW,GAAG,IAAI,GAAGD,cAAc;EACzC,KAAK,MAAME,YAAY,IAAIT,SAAS,EAAE;IACpC,MAAMU,WAAW,GAAGV,SAAS,CAACS,YAAY,CAAC;IAC3C,IAAID,WAAW,KAAKE,WAAW,IAAI/E,KAAK,KAAK+E,WAAW,EAAI,OAAO,IAAI;EACzE;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,sBAAsB,CAAC3C,OAAO,EAAE1C,CAAC,EAAoB;EAAA,IAAlBsF,WAAW,uEAAG,GAAG;EAC3D,IAAIC,YAAY;EAChB,IAAIxB,MAAM,GAAG,EAAE;EACf,KAAK,IAAIyB,KAAK,GAAGxF,CAAC,EAAEwF,KAAK,GAAG9C,OAAO,CAACzC,MAAM,EAAEuF,KAAK,EAAE,EAAE;IACnD,IAAI3C,EAAE,GAAGH,OAAO,CAAC8C,KAAK,CAAC;IACvB,IAAID,YAAY,EAAE;MACd,IAAI1C,EAAE,KAAK0C,YAAY,EAAEA,YAAY,GAAG,EAAE,CAAC;IAC/C,CAAC,MAAM,IAAI1C,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,GAAG,EAAE;MACjC0C,YAAY,GAAG1C,EAAE;IACrB,CAAC,MAAM,IAAIA,EAAE,KAAKyC,WAAW,CAAC,CAAC,CAAC,EAAE;MAChC,IAAGA,WAAW,CAAC,CAAC,CAAC,EAAC;QAChB,IAAG5C,OAAO,CAAC8C,KAAK,GAAG,CAAC,CAAC,KAAKF,WAAW,CAAC,CAAC,CAAC,EAAC;UACvC,OAAO;YACLG,IAAI,EAAE1B,MAAM;YACZyB,KAAK,EAAEA;UACT,CAAC;QACH;MACF,CAAC,MAAI;QACH,OAAO;UACLC,IAAI,EAAE1B,MAAM;UACZyB,KAAK,EAAEA;QACT,CAAC;MACH;IACF,CAAC,MAAM,IAAI3C,EAAE,KAAK,IAAI,EAAE;MACtBA,EAAE,GAAG,GAAG;IACV;IACAkB,MAAM,IAAIlB,EAAE;EACd;AACF;AAEA,SAASE,gBAAgB,CAACL,OAAO,EAAEgD,GAAG,EAAE1F,CAAC,EAAE2F,MAAM,EAAC;EAChD,MAAMC,YAAY,GAAGlD,OAAO,CAACQ,OAAO,CAACwC,GAAG,EAAE1F,CAAC,CAAC;EAC5C,IAAG4F,YAAY,KAAK,CAAC,CAAC,EAAC;IACrB,MAAM,IAAInC,KAAK,CAACkC,MAAM,CAAC;EACzB,CAAC,MAAI;IACH,OAAOC,YAAY,GAAGF,GAAG,CAACzF,MAAM,GAAG,CAAC;EACtC;AACF;AAEA,SAASuD,UAAU,CAACd,OAAO,EAAC1C,CAAC,EAAEoB,cAAc,EAAoB;EAAA,IAAlBkE,WAAW,uEAAG,GAAG;EAC9D,MAAMjB,MAAM,GAAGgB,sBAAsB,CAAC3C,OAAO,EAAE1C,CAAC,GAAC,CAAC,EAAEsF,WAAW,CAAC;EAChE,IAAG,CAACjB,MAAM,EAAE;EACZ,IAAIN,MAAM,GAAGM,MAAM,CAACoB,IAAI;EACxB,MAAM3C,UAAU,GAAGuB,MAAM,CAACmB,KAAK;EAC/B,MAAMK,cAAc,GAAG9B,MAAM,CAAC+B,MAAM,CAAC,IAAI,CAAC;EAC1C,IAAI1F,OAAO,GAAG2D,MAAM;EACpB,IAAIC,cAAc,GAAG,IAAI;EACzB,IAAG6B,cAAc,KAAK,CAAC,CAAC,EAAC;IAAC;IACxBzF,OAAO,GAAG2D,MAAM,CAACZ,MAAM,CAAC,CAAC,EAAE0C,cAAc,CAAC,CAACvH,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAChEyF,MAAM,GAAGA,MAAM,CAACZ,MAAM,CAAC0C,cAAc,GAAG,CAAC,CAAC;EAC5C;EAEA,IAAGzE,cAAc,EAAC;IAChB,MAAM6B,UAAU,GAAG7C,OAAO,CAAC8C,OAAO,CAAC,GAAG,CAAC;IACvC,IAAGD,UAAU,KAAK,CAAC,CAAC,EAAC;MACnB7C,OAAO,GAAGA,OAAO,CAAC+C,MAAM,CAACF,UAAU,GAAC,CAAC,CAAC;MACtCe,cAAc,GAAG5D,OAAO,KAAKiE,MAAM,CAACoB,IAAI,CAACtC,MAAM,CAACF,UAAU,GAAG,CAAC,CAAC;IACjE;EACF;EAEA,OAAO;IACL7C,OAAO,EAAEA,OAAO;IAChB2D,MAAM,EAAEA,MAAM;IACdjB,UAAU,EAAEA,UAAU;IACtBkB,cAAc,EAAEA;EAClB,CAAC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStE,gBAAgB,CAACgD,OAAO,EAAEtC,OAAO,EAAEJ,CAAC,EAAC;EAC5C,MAAM+F,UAAU,GAAG/F,CAAC;EACpB;EACA,IAAIgG,YAAY,GAAG,CAAC;EAEpB,OAAOhG,CAAC,GAAG0C,OAAO,CAACzC,MAAM,EAAED,CAAC,EAAE,EAAE;IAC9B,IAAI0C,OAAO,CAAC1C,CAAC,CAAC,KAAK,GAAG,EAAC;MACrB,IAAI0C,OAAO,CAAC1C,CAAC,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAAC;QACvB,MAAM8C,UAAU,GAAGC,gBAAgB,CAACL,OAAO,EAAE,GAAG,EAAE1C,CAAC,EAAG,GAAEI,OAAQ,gBAAe,CAAC;QAChF,IAAI6F,YAAY,GAAGvD,OAAO,CAACM,SAAS,CAAChD,CAAC,GAAC,CAAC,EAAC8C,UAAU,CAAC,CAAClC,IAAI,EAAE;QAC3D,IAAGqF,YAAY,KAAK7F,OAAO,EAAC;UAC1B4F,YAAY,EAAE;UACd,IAAIA,YAAY,KAAK,CAAC,EAAE;YACtB,OAAO;cACLrB,UAAU,EAAEjC,OAAO,CAACM,SAAS,CAAC+C,UAAU,EAAE/F,CAAC,CAAC;cAC5CA,CAAC,EAAG8C;YACN,CAAC;UACH;QACF;QACA9C,CAAC,GAAC8C,UAAU;MACd,CAAC,MAAM,IAAGJ,OAAO,CAAC1C,CAAC,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC9B,MAAM8C,UAAU,GAAGC,gBAAgB,CAACL,OAAO,EAAE,IAAI,EAAE1C,CAAC,GAAC,CAAC,EAAE,yBAAyB,CAAC;QAClFA,CAAC,GAAC8C,UAAU;MACd,CAAC,MAAM,IAAGJ,OAAO,CAACS,MAAM,CAACnD,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;QAC5C,MAAM8C,UAAU,GAAGC,gBAAgB,CAACL,OAAO,EAAE,KAAK,EAAE1C,CAAC,GAAC,CAAC,EAAE,yBAAyB,CAAC;QACnFA,CAAC,GAAC8C,UAAU;MACd,CAAC,MAAM,IAAGJ,OAAO,CAACS,MAAM,CAACnD,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;QAC3C,MAAM8C,UAAU,GAAGC,gBAAgB,CAACL,OAAO,EAAE,KAAK,EAAE1C,CAAC,EAAE,yBAAyB,CAAC,GAAG,CAAC;QACrFA,CAAC,GAAC8C,UAAU;MACd,CAAC,MAAM;QACL,MAAMS,OAAO,GAAGC,UAAU,CAACd,OAAO,EAAE1C,CAAC,EAAE,GAAG,CAAC;QAE3C,IAAIuD,OAAO,EAAE;UACX,MAAM2C,WAAW,GAAG3C,OAAO,IAAIA,OAAO,CAACnD,OAAO;UAC9C,IAAI8F,WAAW,KAAK9F,OAAO,IAAImD,OAAO,CAACQ,MAAM,CAACR,OAAO,CAACQ,MAAM,CAAC9D,MAAM,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAC9E+F,YAAY,EAAE;UAChB;UACAhG,CAAC,GAACuD,OAAO,CAACT,UAAU;QACtB;MACF;IACF;EACJ,CAAC;AACH;;AAEA,SAAS/B,UAAU,CAAC/B,GAAG,EAAEmH,WAAW,EAAEzH,OAAO,EAAE;EAC7C,IAAIyH,WAAW,IAAI,OAAOnH,GAAG,KAAK,QAAQ,EAAE;IAC1C;IACA,MAAM6B,MAAM,GAAG7B,GAAG,CAAC4B,IAAI,EAAE;IACzB,IAAGC,MAAM,KAAK,MAAM,EAAG,OAAO,IAAI,CAAC,KAC9B,IAAGA,MAAM,KAAK,OAAO,EAAG,OAAO,KAAK,CAAC,KACrC,OAAOzC,QAAQ,CAACY,GAAG,EAAEN,OAAO,CAAC;EACpC,CAAC,MAAM;IACL,IAAIV,IAAI,CAACoI,OAAO,CAACpH,GAAG,CAAC,EAAE;MACrB,OAAOA,GAAG;IACZ,CAAC,MAAM;MACL,OAAO,EAAE;IACX;EACF;AACF;AAGAqH,MAAM,CAACC,OAAO,GAAG9H,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}