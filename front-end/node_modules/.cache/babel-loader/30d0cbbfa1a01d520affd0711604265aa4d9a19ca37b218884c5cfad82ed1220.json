{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst {\n  formatSize\n} = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n  createFileSerializer,\n  NOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nclass PackContainer {\n  /**\r\n   * @param {Object} data stored data\r\n   * @param {string} version version identifier\r\n   * @param {Snapshot} buildSnapshot snapshot of all build dependencies\r\n   * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\r\n   * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\r\n   * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\r\n   */\n  constructor(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {\n    this.data = data;\n    this.version = version;\n    this.buildSnapshot = buildSnapshot;\n    this.buildDependencies = buildDependencies;\n    this.resolveResults = resolveResults;\n    this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n  }\n  serialize(_ref) {\n    let {\n      write,\n      writeLazy\n    } = _ref;\n    write(this.version);\n    write(this.buildSnapshot);\n    write(this.buildDependencies);\n    write(this.resolveResults);\n    write(this.resolveBuildDependenciesSnapshot);\n    writeLazy(this.data);\n  }\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.version = read();\n    this.buildSnapshot = read();\n    this.buildDependencies = read();\n    this.resolveResults = read();\n    this.resolveBuildDependenciesSnapshot = read();\n    this.data = read();\n  }\n}\nmakeSerializable(PackContainer, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContainer\");\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n  /**\r\n   * @param {string} identifier identifier of item\r\n   * @param {string | null} etag etag of item\r\n   * @param {any} value fresh value of item\r\n   */\n  constructor(identifier, etag, value) {\n    this.identifier = identifier;\n    this.etag = etag;\n    this.location = -1;\n    this.lastAccess = Date.now();\n    this.freshValue = value;\n  }\n}\nclass Pack {\n  constructor(logger, maxAge) {\n    /** @type {Map<string, PackItemInfo>} */\n    this.itemInfo = new Map();\n    /** @type {string[]} */\n    this.requests = [];\n    this.requestsTimeout = undefined;\n    /** @type {Map<string, PackItemInfo>} */\n    this.freshContent = new Map();\n    /** @type {(undefined | PackContent)[]} */\n    this.content = [];\n    this.invalid = false;\n    this.logger = logger;\n    this.maxAge = maxAge;\n  }\n  _addRequest(identifier) {\n    this.requests.push(identifier);\n    if (this.requestsTimeout === undefined) {\n      this.requestsTimeout = setTimeout(() => {\n        this.requests.push(undefined);\n        this.requestsTimeout = undefined;\n      }, MAX_TIME_IN_FRESH_PACK);\n      if (this.requestsTimeout.unref) this.requestsTimeout.unref();\n    }\n  }\n  stopCapturingRequests() {\n    if (this.requestsTimeout !== undefined) {\n      clearTimeout(this.requestsTimeout);\n      this.requestsTimeout = undefined;\n    }\n  }\n\n  /**\r\n   * @param {string} identifier unique name for the resource\r\n   * @param {string | null} etag etag of the resource\r\n   * @returns {any} cached content\r\n   */\n  get(identifier, etag) {\n    const info = this.itemInfo.get(identifier);\n    this._addRequest(identifier);\n    if (info === undefined) {\n      return undefined;\n    }\n    if (info.etag !== etag) return null;\n    info.lastAccess = Date.now();\n    const loc = info.location;\n    if (loc === -1) {\n      return info.freshValue;\n    } else {\n      if (!this.content[loc]) {\n        return undefined;\n      }\n      return this.content[loc].get(identifier);\n    }\n  }\n\n  /**\r\n   * @param {string} identifier unique name for the resource\r\n   * @param {string | null} etag etag of the resource\r\n   * @param {any} data cached content\r\n   * @returns {void}\r\n   */\n  set(identifier, etag, data) {\n    if (!this.invalid) {\n      this.invalid = true;\n      this.logger.log(`Pack got invalid because of write to: ${identifier}`);\n    }\n    const info = this.itemInfo.get(identifier);\n    if (info === undefined) {\n      const newInfo = new PackItemInfo(identifier, etag, data);\n      this.itemInfo.set(identifier, newInfo);\n      this._addRequest(identifier);\n      this.freshContent.set(identifier, newInfo);\n    } else {\n      const loc = info.location;\n      if (loc >= 0) {\n        this._addRequest(identifier);\n        this.freshContent.set(identifier, info);\n        const content = this.content[loc];\n        content.delete(identifier);\n        if (content.items.size === 0) {\n          this.content[loc] = undefined;\n          this.logger.debug(\"Pack %d got empty and is removed\", loc);\n        }\n      }\n      info.freshValue = data;\n      info.lastAccess = Date.now();\n      info.etag = etag;\n      info.location = -1;\n    }\n  }\n  getContentStats() {\n    let count = 0;\n    let size = 0;\n    for (const content of this.content) {\n      if (content !== undefined) {\n        count++;\n        const s = content.getSize();\n        if (s > 0) {\n          size += s;\n        }\n      }\n    }\n    return {\n      count,\n      size\n    };\n  }\n\n  /**\r\n   * @returns {number} new location of data entries\r\n   */\n  _findLocation() {\n    let i;\n    for (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n    return i;\n  }\n  _gcAndUpdateLocation(items, usedItems, newLoc) {\n    let count = 0;\n    let lastGC;\n    const now = Date.now();\n    for (const identifier of items) {\n      const info = this.itemInfo.get(identifier);\n      if (now - info.lastAccess > this.maxAge) {\n        this.itemInfo.delete(identifier);\n        items.delete(identifier);\n        usedItems.delete(identifier);\n        count++;\n        lastGC = identifier;\n      } else {\n        info.location = newLoc;\n      }\n    }\n    if (count > 0) {\n      this.logger.log(\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\", count, newLoc, items.size, lastGC);\n    }\n  }\n  _persistFreshContent() {\n    const itemsCount = this.freshContent.size;\n    if (itemsCount > 0) {\n      const packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n      const itemsPerPack = Math.ceil(itemsCount / packCount);\n      const packs = [];\n      let i = 0;\n      let ignoreNextTimeTick = false;\n      const createNextPack = () => {\n        const loc = this._findLocation();\n        this.content[loc] = null; // reserve\n        const pack = {\n          /** @type {Set<string>} */\n          items: new Set(),\n          /** @type {Map<string, any>} */\n          map: new Map(),\n          loc\n        };\n        packs.push(pack);\n        return pack;\n      };\n      let pack = createNextPack();\n      if (this.requestsTimeout !== undefined) clearTimeout(this.requestsTimeout);\n      for (const identifier of this.requests) {\n        if (identifier === undefined) {\n          if (ignoreNextTimeTick) {\n            ignoreNextTimeTick = false;\n          } else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n            i = 0;\n            pack = createNextPack();\n          }\n          continue;\n        }\n        const info = this.freshContent.get(identifier);\n        if (info === undefined) continue;\n        pack.items.add(identifier);\n        pack.map.set(identifier, info.freshValue);\n        info.location = pack.loc;\n        info.freshValue = undefined;\n        this.freshContent.delete(identifier);\n        if (++i > itemsPerPack) {\n          i = 0;\n          pack = createNextPack();\n          ignoreNextTimeTick = true;\n        }\n      }\n      this.requests.length = 0;\n      for (const pack of packs) {\n        this.content[pack.loc] = new PackContent(pack.items, new Set(pack.items), new PackContentItems(pack.map));\n      }\n      this.logger.log(`${itemsCount} fresh items in cache put into pack ${packs.length > 1 ? packs.map(pack => `${pack.loc} (${pack.items.size} items)`).join(\", \") : packs[0].loc}`);\n    }\n  }\n\n  /**\r\n   * Merges small content files to a single content file\r\n   */\n  _optimizeSmallContent() {\n    // 1. Find all small content files\n    // Treat unused content files separately to avoid\n    // a merge-split cycle\n    /** @type {number[]} */\n    const smallUsedContents = [];\n    /** @type {number} */\n    let smallUsedContentSize = 0;\n    /** @type {number[]} */\n    const smallUnusedContents = [];\n    /** @type {number} */\n    let smallUnusedContentSize = 0;\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      if (content.outdated) continue;\n      const size = content.getSize();\n      if (size < 0 || size > MIN_CONTENT_SIZE) continue;\n      if (content.used.size > 0) {\n        smallUsedContents.push(i);\n        smallUsedContentSize += size;\n      } else {\n        smallUnusedContents.push(i);\n        smallUnusedContentSize += size;\n      }\n    }\n\n    // 2. Check if minimum number is reached\n    let mergedIndices;\n    if (smallUsedContents.length >= CONTENT_COUNT_TO_MERGE || smallUsedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUsedContents;\n    } else if (smallUnusedContents.length >= CONTENT_COUNT_TO_MERGE || smallUnusedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUnusedContents;\n    } else return;\n    const mergedContent = [];\n\n    // 3. Remove old content entries\n    for (const i of mergedIndices) {\n      mergedContent.push(this.content[i]);\n      this.content[i] = undefined;\n    }\n\n    // 4. Determine merged items\n    /** @type {Set<string>} */\n    const mergedItems = new Set();\n    /** @type {Set<string>} */\n    const mergedUsedItems = new Set();\n    /** @type {(function(Map<string, any>): Promise)[]} */\n    const addToMergedMap = [];\n    for (const content of mergedContent) {\n      for (const identifier of content.items) {\n        mergedItems.add(identifier);\n      }\n      for (const identifier of content.used) {\n        mergedUsedItems.add(identifier);\n      }\n      addToMergedMap.push(async map => {\n        // unpack existing content\n        // after that values are accessible in .content\n        await content.unpack(\"it should be merged with other small pack contents\");\n        for (const [identifier, value] of content.content) {\n          map.set(identifier, value);\n        }\n      });\n    }\n\n    // 5. GC and update location of merged items\n    const newLoc = this._findLocation();\n    this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n    // 6. If not empty, store content somewhere\n    if (mergedItems.size > 0) {\n      this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize(async () => {\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        await Promise.all(addToMergedMap.map(fn => fn(map)));\n        return new PackContentItems(map);\n      }));\n      this.logger.log(\"Merged %d small files with %d cache items into pack %d\", mergedContent.length, mergedItems.size, newLoc);\n    }\n  }\n\n  /**\r\n   * Split large content files with used and unused items\r\n   * into two parts to separate used from unused items\r\n   */\n  _optimizeUnusedContent() {\n    // 1. Find a large content file with used and unused items\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      const size = content.getSize();\n      if (size < MIN_CONTENT_SIZE) continue;\n      const used = content.used.size;\n      const total = content.items.size;\n      if (used > 0 && used < total) {\n        // 2. Remove this content\n        this.content[i] = undefined;\n\n        // 3. Determine items for the used content file\n        const usedItems = new Set(content.used);\n        const newLoc = this._findLocation();\n        this._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n        // 4. Create content file for used items\n        if (usedItems.size > 0) {\n          this.content[newLoc] = new PackContent(usedItems, new Set(usedItems), async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n            for (const identifier of usedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n            return new PackContentItems(map);\n          });\n        }\n\n        // 5. Determine items for the unused content file\n        const unusedItems = new Set(content.items);\n        const usedOfUnusedItems = new Set();\n        for (const identifier of usedItems) {\n          unusedItems.delete(identifier);\n        }\n        const newUnusedLoc = this._findLocation();\n        this._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n        // 6. Create content file for unused items\n        if (unusedItems.size > 0) {\n          this.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n            for (const identifier of unusedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n            return new PackContentItems(map);\n          });\n        }\n        this.logger.log(\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size);\n\n        // optimizing only one of them is good enough and\n        // reduces the amount of serialization needed\n        return;\n      }\n    }\n  }\n\n  /**\r\n   * Find the content with the oldest item and run GC on that.\r\n   * Only runs for one content to avoid large invalidation.\r\n   */\n  _gcOldestContent() {\n    /** @type {PackItemInfo} */\n    let oldest = undefined;\n    for (const info of this.itemInfo.values()) {\n      if (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n        oldest = info;\n      }\n    }\n    if (Date.now() - oldest.lastAccess > this.maxAge) {\n      const loc = oldest.location;\n      if (loc < 0) return;\n      const content = this.content[loc];\n      const items = new Set(content.items);\n      const usedItems = new Set(content.used);\n      this._gcAndUpdateLocation(items, usedItems, loc);\n      this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, async () => {\n        await content.unpack(\"it contains old items that should be garbage collected\");\n        const map = new Map();\n        for (const identifier of items) {\n          map.set(identifier, content.content.get(identifier));\n        }\n        return new PackContentItems(map);\n      }) : undefined;\n    }\n  }\n  serialize(_ref3) {\n    let {\n      write,\n      writeSeparate\n    } = _ref3;\n    this._persistFreshContent();\n    this._optimizeSmallContent();\n    this._optimizeUnusedContent();\n    this._gcOldestContent();\n    for (const identifier of this.itemInfo.keys()) {\n      write(identifier);\n    }\n    write(null); // null as marker of the end of keys\n    for (const info of this.itemInfo.values()) {\n      write(info.etag);\n    }\n    for (const info of this.itemInfo.values()) {\n      write(info.lastAccess);\n    }\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content !== undefined) {\n        write(content.items);\n        content.writeLazy(lazy => writeSeparate(lazy, {\n          name: `${i}`\n        }));\n      } else {\n        write(undefined); // undefined marks an empty content slot\n      }\n    }\n\n    write(null); // null as marker of the end of items\n  }\n\n  deserialize(_ref4) {\n    let {\n      read,\n      logger\n    } = _ref4;\n    this.logger = logger;\n    {\n      const items = [];\n      let item = read();\n      while (item !== null) {\n        items.push(item);\n        item = read();\n      }\n      this.itemInfo.clear();\n      const infoItems = items.map(identifier => {\n        const info = new PackItemInfo(identifier, undefined, undefined);\n        this.itemInfo.set(identifier, info);\n        return info;\n      });\n      for (const info of infoItems) {\n        info.etag = read();\n      }\n      for (const info of infoItems) {\n        info.lastAccess = read();\n      }\n    }\n    this.content.length = 0;\n    let items = read();\n    while (items !== null) {\n      if (items === undefined) {\n        this.content.push(items);\n      } else {\n        const idx = this.content.length;\n        const lazy = read();\n        this.content.push(new PackContent(items, new Set(), lazy, logger, `${this.content.length}`));\n        for (const identifier of items) {\n          this.itemInfo.get(identifier).location = idx;\n        }\n      }\n      items = read();\n    }\n  }\n}\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\nclass PackContentItems {\n  /**\r\n   * @param {Map<string, any>} map items\r\n   */\n  constructor(map) {\n    this.map = map;\n  }\n  serialize(_ref5) {\n    let {\n      write,\n      snapshot,\n      rollback,\n      logger,\n      profile\n    } = _ref5;\n    if (profile) {\n      write(false);\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n        try {\n          write(key);\n          const start = process.hrtime();\n          write(value);\n          const durationHr = process.hrtime(start);\n          const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n          if (duration > 1) {\n            if (duration > 500) logger.error(`Serialization of '${key}': ${duration} ms`);else if (duration > 50) logger.warn(`Serialization of '${key}': ${duration} ms`);else if (duration > 10) logger.info(`Serialization of '${key}': ${duration} ms`);else if (duration > 5) logger.log(`Serialization of '${key}': ${duration} ms`);else logger.debug(`Serialization of '${key}': ${duration} ms`);\n          }\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          const msg = \"Skipped not serializable cache item\";\n          if (e.message.includes(\"ModuleBuildError\")) {\n            logger.log(`${msg} (in build error): ${e.message}`);\n            logger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n          } else {\n            logger.warn(`${msg}: ${e.message}`);\n            logger.debug(`${msg} '${key}': ${e.stack}`);\n          }\n        }\n      }\n      write(null);\n      return;\n    }\n    // Try to serialize all at once\n    const s = snapshot();\n    try {\n      write(true);\n      write(this.map);\n    } catch (e) {\n      rollback(s);\n\n      // Try to serialize each item on it's own\n      write(false);\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n        try {\n          write(key);\n          write(value);\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`);\n          logger.debug(e.stack);\n        }\n      }\n      write(null);\n    }\n  }\n  deserialize(_ref6) {\n    let {\n      read,\n      logger,\n      profile\n    } = _ref6;\n    if (read()) {\n      this.map = read();\n    } else if (profile) {\n      const map = new Map();\n      let key = read();\n      while (key !== null) {\n        const start = process.hrtime();\n        const value = read();\n        const durationHr = process.hrtime(start);\n        const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n        if (duration > 1) {\n          if (duration > 100) logger.error(`Deserialization of '${key}': ${duration} ms`);else if (duration > 20) logger.warn(`Deserialization of '${key}': ${duration} ms`);else if (duration > 5) logger.info(`Deserialization of '${key}': ${duration} ms`);else if (duration > 2) logger.log(`Deserialization of '${key}': ${duration} ms`);else logger.debug(`Deserialization of '${key}': ${duration} ms`);\n        }\n        map.set(key, value);\n        key = read();\n      }\n      this.map = map;\n    } else {\n      const map = new Map();\n      let key = read();\n      while (key !== null) {\n        map.set(key, read());\n        key = read();\n      }\n      this.map = map;\n    }\n  }\n}\nmakeSerializable(PackContentItems, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContentItems\");\nclass PackContent {\n  /*\r\n  \tThis class can be in these states:\r\n  \t   |   this.lazy    | this.content | this.outdated | state\r\n  \tA1 |   undefined    |     Map      |     false     | fresh content\r\n  \tA2 |   undefined    |     Map      |     true      | (will not happen)\r\n  \tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\r\n  \tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\r\n  \tC1 | lazy* () => {} |     Map      |     false     | deserialized\r\n  \tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\r\n  \n  \tthis.used is a subset of this.items.\r\n  \tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\r\n  \tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\r\n  \tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\r\n  \tWhen this.lazy and this.content is set, they contain the same data.\r\n  \tthis.get must only be called with a valid item from this.items.\r\n  \tIn state C this.lazy is unMemoized\r\n  */\n\n  /**\r\n   * @param {Set<string>} items keys\r\n   * @param {Set<string>} usedItems used keys\r\n   * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\r\n   * @param {Logger=} logger logger for logging\r\n   * @param {string=} lazyName name of dataOrFn for logging\r\n   */\n  constructor(items, usedItems, dataOrFn, logger, lazyName) {\n    this.items = items;\n    /** @type {function(): Promise<PackContentItems> | PackContentItems} */\n    this.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n    /** @type {Map<string, any>} */\n    this.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n    this.outdated = false;\n    this.used = usedItems;\n    this.logger = logger;\n    this.lazyName = lazyName;\n  }\n  get(identifier) {\n    this.used.add(identifier);\n    if (this.content) {\n      return this.content.get(identifier);\n    }\n\n    // We are in state B\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `restore cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to restore cache content ${lazyName} (${formatSize(this.getSize())}) because of request to: ${identifier}`);\n      this.logger.time(timeMessage);\n    }\n    const value = this.lazy();\n    if (\"then\" in value) {\n      return value.then(data => {\n        const map = data.map;\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        // Move to state C\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return map.get(identifier);\n      });\n    } else {\n      const map = value.map;\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n      // Move to state C\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n      return map.get(identifier);\n    }\n  }\n\n  /**\r\n   * @param {string} reason explanation why unpack is necessary\r\n   * @returns {void | Promise} maybe a promise if lazy\r\n   */\n  unpack(reason) {\n    if (this.content) return;\n\n    // Move from state B to C\n    if (this.lazy) {\n      const {\n        lazyName\n      } = this;\n      let timeMessage;\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n        this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because ${reason}`);\n        this.logger.time(timeMessage);\n      }\n      const value = this.lazy();\n      if (\"then\" in value) {\n        return value.then(data => {\n          if (timeMessage) {\n            this.logger.timeEnd(timeMessage);\n          }\n          this.content = data.map;\n        });\n      } else {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        this.content = value.map;\n      }\n    }\n  }\n\n  /**\r\n   * @returns {number} size of the content or -1 if not known\r\n   */\n  getSize() {\n    if (!this.lazy) return -1;\n    const options = /** @type {any} */this.lazy.options;\n    if (!options) return -1;\n    const size = options.size;\n    if (typeof size !== \"number\") return -1;\n    return size;\n  }\n  delete(identifier) {\n    this.items.delete(identifier);\n    this.used.delete(identifier);\n    this.outdated = true;\n  }\n\n  /**\r\n   * @template T\r\n   * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\r\n   * @returns {void}\r\n   */\n  writeLazy(write) {\n    if (!this.outdated && this.lazy) {\n      // State B1 or C1\n      // this.lazy is still the valid deserialized version\n      write(this.lazy);\n      return;\n    }\n    if (!this.outdated && this.content) {\n      // State A1\n      const map = new Map(this.content);\n      // Move to state C1\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n    if (this.content) {\n      // State A2 or C2\n      /** @type {Map<string, any>} */\n      const map = new Map();\n      for (const item of this.items) {\n        map.set(item, this.content.get(item));\n      }\n      // Move to state C1\n      this.outdated = false;\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n    // State B2\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because it's outdated and need to be serialized`);\n      this.logger.time(timeMessage);\n    }\n    const value = this.lazy();\n    this.outdated = false;\n    if (\"then\" in value) {\n      // Move to state B1\n      this.lazy = write(() => value.then(data => {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        const oldMap = data.map;\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        for (const item of this.items) {\n          map.set(item, oldMap.get(item));\n        }\n        // Move to state C1 (or maybe C2)\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return new PackContentItems(map);\n      }));\n    } else {\n      // Move to state C1\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n      const oldMap = value.map;\n      /** @type {Map<string, any>} */\n      const map = new Map();\n      for (const item of this.items) {\n        map.set(item, oldMap.get(item));\n      }\n      this.content = map;\n      this.lazy = write(() => new PackContentItems(map));\n    }\n  }\n}\nconst allowCollectingMemory = buf => {\n  const wasted = buf.buffer.byteLength - buf.byteLength;\n  if (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n    return Buffer.from(buf);\n  }\n  return buf;\n};\nclass PackFileCacheStrategy {\n  /**\r\n   * @param {Object} options options\r\n   * @param {Compiler} options.compiler the compiler\r\n   * @param {IntermediateFileSystem} options.fs the filesystem\r\n   * @param {string} options.context the context directory\r\n   * @param {string} options.cacheLocation the location of the cache data\r\n   * @param {string} options.version version identifier\r\n   * @param {Logger} options.logger a logger\r\n   * @param {SnapshotOptions} options.snapshot options regarding snapshotting\r\n   * @param {number} options.maxAge max age of cache items\r\n   * @param {boolean} options.profile track and log detailed timing information for individual cache items\r\n   * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\r\n   * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\r\n   */\n  constructor(_ref7) {\n    let {\n      compiler,\n      fs,\n      context,\n      cacheLocation,\n      version,\n      logger,\n      snapshot,\n      maxAge,\n      profile,\n      allowCollectingMemory,\n      compression\n    } = _ref7;\n    this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction);\n    this.fileSystemInfo = new FileSystemInfo(fs, {\n      managedPaths: snapshot.managedPaths,\n      immutablePaths: snapshot.immutablePaths,\n      logger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n      hashFunction: compiler.options.output.hashFunction\n    });\n    this.compiler = compiler;\n    this.context = context;\n    this.cacheLocation = cacheLocation;\n    this.version = version;\n    this.logger = logger;\n    this.maxAge = maxAge;\n    this.profile = profile;\n    this.allowCollectingMemory = allowCollectingMemory;\n    this.compression = compression;\n    this._extension = compression === \"brotli\" ? \".pack.br\" : compression === \"gzip\" ? \".pack.gz\" : \".pack\";\n    this.snapshot = snapshot;\n    /** @type {Set<string>} */\n    this.buildDependencies = new Set();\n    /** @type {LazySet<string>} */\n    this.newBuildDependencies = new LazySet();\n    /** @type {Snapshot} */\n    this.resolveBuildDependenciesSnapshot = undefined;\n    /** @type {Map<string, string | false>} */\n    this.resolveResults = undefined;\n    /** @type {Snapshot} */\n    this.buildSnapshot = undefined;\n    /** @type {Promise<Pack>} */\n    this.packPromise = this._openPack();\n    this.storePromise = Promise.resolve();\n  }\n  _getPack() {\n    if (this.packPromise === undefined) {\n      this.packPromise = this.storePromise.then(() => this._openPack());\n    }\n    return this.packPromise;\n  }\n\n  /**\r\n   * @returns {Promise<Pack>} the pack\r\n   */\n  _openPack() {\n    const {\n      logger,\n      profile,\n      cacheLocation,\n      version\n    } = this;\n    /** @type {Snapshot} */\n    let buildSnapshot;\n    /** @type {Set<string>} */\n    let buildDependencies;\n    /** @type {Set<string>} */\n    let newBuildDependencies;\n    /** @type {Snapshot} */\n    let resolveBuildDependenciesSnapshot;\n    /** @type {Map<string, string | false>} */\n    let resolveResults;\n    logger.time(\"restore cache container\");\n    return this.fileSerializer.deserialize(null, {\n      filename: `${cacheLocation}/index${this._extension}`,\n      extension: `${this._extension}`,\n      logger,\n      profile,\n      retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : undefined\n    }).catch(err => {\n      if (err.code !== \"ENOENT\") {\n        logger.warn(`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`);\n        logger.debug(err.stack);\n      } else {\n        logger.debug(`No pack exists at ${cacheLocation}${this._extension}: ${err}`);\n      }\n      return undefined;\n    }).then(packContainer => {\n      logger.timeEnd(\"restore cache container\");\n      if (!packContainer) return undefined;\n      if (!(packContainer instanceof PackContainer)) {\n        logger.warn(`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`, packContainer);\n        return undefined;\n      }\n      if (packContainer.version !== version) {\n        logger.log(`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`);\n        return undefined;\n      }\n      logger.time(\"check build dependencies\");\n      return Promise.all([new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n          if (!valid) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`);\n            return resolve(false);\n          }\n          buildSnapshot = packContainer.buildSnapshot;\n          return resolve(true);\n        });\n      }), new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n          if (valid) {\n            resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot;\n            buildDependencies = packContainer.buildDependencies;\n            resolveResults = packContainer.resolveResults;\n            return resolve(true);\n          }\n          logger.log(\"resolving of build dependencies is invalid, will re-resolve build dependencies\");\n          this.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, (err, valid) => {\n            if (err) {\n              logger.log(`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`);\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n            if (valid) {\n              newBuildDependencies = packContainer.buildDependencies;\n              resolveResults = packContainer.resolveResults;\n              return resolve(true);\n            }\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`);\n            return resolve(false);\n          });\n        });\n      })]).catch(err => {\n        logger.timeEnd(\"check build dependencies\");\n        throw err;\n      }).then(_ref8 => {\n        let [buildSnapshotValid, resolveValid] = _ref8;\n        logger.timeEnd(\"check build dependencies\");\n        if (buildSnapshotValid && resolveValid) {\n          logger.time(\"restore cache content metadata\");\n          const d = packContainer.data();\n          logger.timeEnd(\"restore cache content metadata\");\n          return d;\n        }\n        return undefined;\n      });\n    }).then(pack => {\n      if (pack) {\n        pack.maxAge = this.maxAge;\n        this.buildSnapshot = buildSnapshot;\n        if (buildDependencies) this.buildDependencies = buildDependencies;\n        if (newBuildDependencies) this.newBuildDependencies.addAll(newBuildDependencies);\n        this.resolveResults = resolveResults;\n        this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n        return pack;\n      }\n      return new Pack(logger, this.maxAge);\n    }).catch(err => {\n      this.logger.warn(`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`);\n      this.logger.debug(err.stack);\n      return new Pack(logger, this.maxAge);\n    });\n  }\n\n  /**\r\n   * @param {string} identifier unique name for the resource\r\n   * @param {Etag | null} etag etag of the resource\r\n   * @param {any} data cached content\r\n   * @returns {Promise<void>} promise\r\n   */\n  store(identifier, etag, data) {\n    return this._getPack().then(pack => {\n      pack.set(identifier, etag === null ? null : etag.toString(), data);\n    });\n  }\n\n  /**\r\n   * @param {string} identifier unique name for the resource\r\n   * @param {Etag | null} etag etag of the resource\r\n   * @returns {Promise<any>} promise to the cached content\r\n   */\n  restore(identifier, etag) {\n    return this._getPack().then(pack => pack.get(identifier, etag === null ? null : etag.toString())).catch(err => {\n      if (err && err.code !== \"ENOENT\") {\n        this.logger.warn(`Restoring failed for ${identifier} from pack: ${err}`);\n        this.logger.debug(err.stack);\n      }\n    });\n  }\n  storeBuildDependencies(dependencies) {\n    this.newBuildDependencies.addAll(dependencies);\n  }\n  afterAllStored() {\n    const packPromise = this.packPromise;\n    if (packPromise === undefined) return Promise.resolve();\n    const reportProgress = ProgressPlugin.getReporter(this.compiler);\n    return this.storePromise = packPromise.then(pack => {\n      pack.stopCapturingRequests();\n      if (!pack.invalid) return;\n      this.packPromise = undefined;\n      this.logger.log(`Storing pack...`);\n      let promise;\n      const newBuildDependencies = new Set();\n      for (const dep of this.newBuildDependencies) {\n        if (!this.buildDependencies.has(dep)) {\n          newBuildDependencies.add(dep);\n        }\n      }\n      if (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n        if (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n        this.logger.debug(`Capturing build dependencies... (${Array.from(newBuildDependencies).join(\", \")})`);\n        promise = new Promise((resolve, reject) => {\n          this.logger.time(\"resolve build dependencies\");\n          this.fileSystemInfo.resolveBuildDependencies(this.context, newBuildDependencies, (err, result) => {\n            this.logger.timeEnd(\"resolve build dependencies\");\n            if (err) return reject(err);\n            this.logger.time(\"snapshot build dependencies\");\n            const {\n              files,\n              directories,\n              missing,\n              resolveResults,\n              resolveDependencies\n            } = result;\n            if (this.resolveResults) {\n              for (const [key, value] of resolveResults) {\n                this.resolveResults.set(key, value);\n              }\n            } else {\n              this.resolveResults = resolveResults;\n            }\n            if (reportProgress) {\n              reportProgress(0.6, \"snapshot build dependencies\", \"resolving\");\n            }\n            this.fileSystemInfo.createSnapshot(undefined, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, this.snapshot.resolveBuildDependencies, (err, snapshot) => {\n              if (err) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(err);\n              }\n              if (!snapshot) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(new Error(\"Unable to snapshot resolve dependencies\"));\n              }\n              if (this.resolveBuildDependenciesSnapshot) {\n                this.resolveBuildDependenciesSnapshot = this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot, snapshot);\n              } else {\n                this.resolveBuildDependenciesSnapshot = snapshot;\n              }\n              if (reportProgress) {\n                reportProgress(0.7, \"snapshot build dependencies\", \"modules\");\n              }\n              this.fileSystemInfo.createSnapshot(undefined, files, directories, missing, this.snapshot.buildDependencies, (err, snapshot) => {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                if (err) return reject(err);\n                if (!snapshot) {\n                  return reject(new Error(\"Unable to snapshot build dependencies\"));\n                }\n                this.logger.debug(\"Captured build dependencies\");\n                if (this.buildSnapshot) {\n                  this.buildSnapshot = this.fileSystemInfo.mergeSnapshots(this.buildSnapshot, snapshot);\n                } else {\n                  this.buildSnapshot = snapshot;\n                }\n                resolve();\n              });\n            });\n          });\n        });\n      } else {\n        promise = Promise.resolve();\n      }\n      return promise.then(() => {\n        if (reportProgress) reportProgress(0.8, \"serialize pack\");\n        this.logger.time(`store pack`);\n        const updatedBuildDependencies = new Set(this.buildDependencies);\n        for (const dep of newBuildDependencies) {\n          updatedBuildDependencies.add(dep);\n        }\n        const content = new PackContainer(pack, this.version, this.buildSnapshot, updatedBuildDependencies, this.resolveResults, this.resolveBuildDependenciesSnapshot);\n        return this.fileSerializer.serialize(content, {\n          filename: `${this.cacheLocation}/index${this._extension}`,\n          extension: `${this._extension}`,\n          logger: this.logger,\n          profile: this.profile\n        }).then(() => {\n          for (const dep of newBuildDependencies) {\n            this.buildDependencies.add(dep);\n          }\n          this.newBuildDependencies.clear();\n          this.logger.timeEnd(`store pack`);\n          const stats = pack.getContentStats();\n          this.logger.log(\"Stored pack (%d items, %d files, %d MiB)\", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));\n        }).catch(err => {\n          this.logger.timeEnd(`store pack`);\n          this.logger.warn(`Caching failed for pack: ${err}`);\n          this.logger.debug(err.stack);\n        });\n      });\n    }).catch(err => {\n      this.logger.warn(`Caching failed for pack: ${err}`);\n      this.logger.debug(err.stack);\n    });\n  }\n  clear() {\n    this.fileSystemInfo.clear();\n    this.buildDependencies.clear();\n    this.newBuildDependencies.clear();\n    this.resolveBuildDependenciesSnapshot = undefined;\n    this.resolveResults = undefined;\n    this.buildSnapshot = undefined;\n    this.packPromise = undefined;\n  }\n}\nmodule.exports = PackFileCacheStrategy;","map":{"version":3,"names":["FileSystemInfo","require","ProgressPlugin","formatSize","SerializerMiddleware","LazySet","makeSerializable","memoize","createFileSerializer","NOT_SERIALIZABLE","PackContainer","constructor","data","version","buildSnapshot","buildDependencies","resolveResults","resolveBuildDependenciesSnapshot","serialize","write","writeLazy","deserialize","read","MIN_CONTENT_SIZE","CONTENT_COUNT_TO_MERGE","MIN_ITEMS_IN_FRESH_PACK","MAX_ITEMS_IN_FRESH_PACK","MAX_TIME_IN_FRESH_PACK","PackItemInfo","identifier","etag","value","location","lastAccess","Date","now","freshValue","Pack","logger","maxAge","itemInfo","Map","requests","requestsTimeout","undefined","freshContent","content","invalid","_addRequest","push","setTimeout","unref","stopCapturingRequests","clearTimeout","get","info","loc","set","log","newInfo","delete","items","size","debug","getContentStats","count","s","getSize","_findLocation","i","length","_gcAndUpdateLocation","usedItems","newLoc","lastGC","_persistFreshContent","itemsCount","packCount","Math","ceil","itemsPerPack","packs","ignoreNextTimeTick","createNextPack","pack","Set","map","add","PackContent","PackContentItems","join","_optimizeSmallContent","smallUsedContents","smallUsedContentSize","smallUnusedContents","smallUnusedContentSize","outdated","used","mergedIndices","mergedContent","mergedItems","mergedUsedItems","addToMergedMap","unpack","Promise","all","fn","_optimizeUnusedContent","total","unusedItems","usedOfUnusedItems","newUnusedLoc","_gcOldestContent","oldest","values","writeSeparate","keys","lazy","name","item","clear","infoItems","idx","snapshot","rollback","profile","key","start","process","hrtime","durationHr","duration","error","warn","e","msg","message","includes","stack","dataOrFn","lazyName","timeMessage","time","then","timeEnd","unMemoizeLazy","reason","options","oldMap","allowCollectingMemory","buf","wasted","buffer","byteLength","Buffer","from","PackFileCacheStrategy","compiler","fs","context","cacheLocation","compression","fileSerializer","output","hashFunction","fileSystemInfo","managedPaths","immutablePaths","getChildLogger","_extension","newBuildDependencies","packPromise","_openPack","storePromise","resolve","_getPack","filename","extension","retainedBuffer","catch","err","code","packContainer","reject","checkSnapshotValid","valid","checkResolveResultsValid","buildSnapshotValid","resolveValid","d","addAll","store","toString","restore","storeBuildDependencies","dependencies","afterAllStored","reportProgress","getReporter","promise","dep","has","Array","resolveBuildDependencies","result","files","directories","missing","resolveDependencies","createSnapshot","Error","mergeSnapshots","updatedBuildDependencies","stats","round","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/cache/PackFileCacheStrategy.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst FileSystemInfo = require(\"../FileSystemInfo\");\r\nconst ProgressPlugin = require(\"../ProgressPlugin\");\r\nconst { formatSize } = require(\"../SizeFormatHelpers\");\r\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\r\nconst LazySet = require(\"../util/LazySet\");\r\nconst makeSerializable = require(\"../util/makeSerializable\");\r\nconst memoize = require(\"../util/memoize\");\r\nconst {\r\n\tcreateFileSerializer,\r\n\tNOT_SERIALIZABLE\r\n} = require(\"../util/serialization\");\r\n\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\r\n/** @typedef {import(\"../Cache\").Etag} Etag */\r\n/** @typedef {import(\"../Compiler\")} Compiler */\r\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\r\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\r\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\r\n\r\nclass PackContainer {\r\n\t/**\r\n\t * @param {Object} data stored data\r\n\t * @param {string} version version identifier\r\n\t * @param {Snapshot} buildSnapshot snapshot of all build dependencies\r\n\t * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\r\n\t * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\r\n\t * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\r\n\t */\r\n\tconstructor(\r\n\t\tdata,\r\n\t\tversion,\r\n\t\tbuildSnapshot,\r\n\t\tbuildDependencies,\r\n\t\tresolveResults,\r\n\t\tresolveBuildDependenciesSnapshot\r\n\t) {\r\n\t\tthis.data = data;\r\n\t\tthis.version = version;\r\n\t\tthis.buildSnapshot = buildSnapshot;\r\n\t\tthis.buildDependencies = buildDependencies;\r\n\t\tthis.resolveResults = resolveResults;\r\n\t\tthis.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\r\n\t}\r\n\r\n\tserialize({ write, writeLazy }) {\r\n\t\twrite(this.version);\r\n\t\twrite(this.buildSnapshot);\r\n\t\twrite(this.buildDependencies);\r\n\t\twrite(this.resolveResults);\r\n\t\twrite(this.resolveBuildDependenciesSnapshot);\r\n\t\twriteLazy(this.data);\r\n\t}\r\n\r\n\tdeserialize({ read }) {\r\n\t\tthis.version = read();\r\n\t\tthis.buildSnapshot = read();\r\n\t\tthis.buildDependencies = read();\r\n\t\tthis.resolveResults = read();\r\n\t\tthis.resolveBuildDependenciesSnapshot = read();\r\n\t\tthis.data = read();\r\n\t}\r\n}\r\n\r\nmakeSerializable(\r\n\tPackContainer,\r\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\r\n\t\"PackContainer\"\r\n);\r\n\r\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\r\nconst CONTENT_COUNT_TO_MERGE = 10;\r\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\r\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\r\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\r\n\r\nclass PackItemInfo {\r\n\t/**\r\n\t * @param {string} identifier identifier of item\r\n\t * @param {string | null} etag etag of item\r\n\t * @param {any} value fresh value of item\r\n\t */\r\n\tconstructor(identifier, etag, value) {\r\n\t\tthis.identifier = identifier;\r\n\t\tthis.etag = etag;\r\n\t\tthis.location = -1;\r\n\t\tthis.lastAccess = Date.now();\r\n\t\tthis.freshValue = value;\r\n\t}\r\n}\r\n\r\nclass Pack {\r\n\tconstructor(logger, maxAge) {\r\n\t\t/** @type {Map<string, PackItemInfo>} */\r\n\t\tthis.itemInfo = new Map();\r\n\t\t/** @type {string[]} */\r\n\t\tthis.requests = [];\r\n\t\tthis.requestsTimeout = undefined;\r\n\t\t/** @type {Map<string, PackItemInfo>} */\r\n\t\tthis.freshContent = new Map();\r\n\t\t/** @type {(undefined | PackContent)[]} */\r\n\t\tthis.content = [];\r\n\t\tthis.invalid = false;\r\n\t\tthis.logger = logger;\r\n\t\tthis.maxAge = maxAge;\r\n\t}\r\n\r\n\t_addRequest(identifier) {\r\n\t\tthis.requests.push(identifier);\r\n\t\tif (this.requestsTimeout === undefined) {\r\n\t\t\tthis.requestsTimeout = setTimeout(() => {\r\n\t\t\t\tthis.requests.push(undefined);\r\n\t\t\t\tthis.requestsTimeout = undefined;\r\n\t\t\t}, MAX_TIME_IN_FRESH_PACK);\r\n\t\t\tif (this.requestsTimeout.unref) this.requestsTimeout.unref();\r\n\t\t}\r\n\t}\r\n\r\n\tstopCapturingRequests() {\r\n\t\tif (this.requestsTimeout !== undefined) {\r\n\t\t\tclearTimeout(this.requestsTimeout);\r\n\t\t\tthis.requestsTimeout = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} identifier unique name for the resource\r\n\t * @param {string | null} etag etag of the resource\r\n\t * @returns {any} cached content\r\n\t */\r\n\tget(identifier, etag) {\r\n\t\tconst info = this.itemInfo.get(identifier);\r\n\t\tthis._addRequest(identifier);\r\n\t\tif (info === undefined) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tif (info.etag !== etag) return null;\r\n\t\tinfo.lastAccess = Date.now();\r\n\t\tconst loc = info.location;\r\n\t\tif (loc === -1) {\r\n\t\t\treturn info.freshValue;\r\n\t\t} else {\r\n\t\t\tif (!this.content[loc]) {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t\treturn this.content[loc].get(identifier);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} identifier unique name for the resource\r\n\t * @param {string | null} etag etag of the resource\r\n\t * @param {any} data cached content\r\n\t * @returns {void}\r\n\t */\r\n\tset(identifier, etag, data) {\r\n\t\tif (!this.invalid) {\r\n\t\t\tthis.invalid = true;\r\n\t\t\tthis.logger.log(`Pack got invalid because of write to: ${identifier}`);\r\n\t\t}\r\n\t\tconst info = this.itemInfo.get(identifier);\r\n\t\tif (info === undefined) {\r\n\t\t\tconst newInfo = new PackItemInfo(identifier, etag, data);\r\n\t\t\tthis.itemInfo.set(identifier, newInfo);\r\n\t\t\tthis._addRequest(identifier);\r\n\t\t\tthis.freshContent.set(identifier, newInfo);\r\n\t\t} else {\r\n\t\t\tconst loc = info.location;\r\n\t\t\tif (loc >= 0) {\r\n\t\t\t\tthis._addRequest(identifier);\r\n\t\t\t\tthis.freshContent.set(identifier, info);\r\n\t\t\t\tconst content = this.content[loc];\r\n\t\t\t\tcontent.delete(identifier);\r\n\t\t\t\tif (content.items.size === 0) {\r\n\t\t\t\t\tthis.content[loc] = undefined;\r\n\t\t\t\t\tthis.logger.debug(\"Pack %d got empty and is removed\", loc);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.freshValue = data;\r\n\t\t\tinfo.lastAccess = Date.now();\r\n\t\t\tinfo.etag = etag;\r\n\t\t\tinfo.location = -1;\r\n\t\t}\r\n\t}\r\n\r\n\tgetContentStats() {\r\n\t\tlet count = 0;\r\n\t\tlet size = 0;\r\n\t\tfor (const content of this.content) {\r\n\t\t\tif (content !== undefined) {\r\n\t\t\t\tcount++;\r\n\t\t\t\tconst s = content.getSize();\r\n\t\t\t\tif (s > 0) {\r\n\t\t\t\t\tsize += s;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { count, size };\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} new location of data entries\r\n\t */\r\n\t_findLocation() {\r\n\t\tlet i;\r\n\t\tfor (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\r\n\t\treturn i;\r\n\t}\r\n\r\n\t_gcAndUpdateLocation(items, usedItems, newLoc) {\r\n\t\tlet count = 0;\r\n\t\tlet lastGC;\r\n\t\tconst now = Date.now();\r\n\t\tfor (const identifier of items) {\r\n\t\t\tconst info = this.itemInfo.get(identifier);\r\n\t\t\tif (now - info.lastAccess > this.maxAge) {\r\n\t\t\t\tthis.itemInfo.delete(identifier);\r\n\t\t\t\titems.delete(identifier);\r\n\t\t\t\tusedItems.delete(identifier);\r\n\t\t\t\tcount++;\r\n\t\t\t\tlastGC = identifier;\r\n\t\t\t} else {\r\n\t\t\t\tinfo.location = newLoc;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (count > 0) {\r\n\t\t\tthis.logger.log(\r\n\t\t\t\t\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\",\r\n\t\t\t\tcount,\r\n\t\t\t\tnewLoc,\r\n\t\t\t\titems.size,\r\n\t\t\t\tlastGC\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t_persistFreshContent() {\r\n\t\tconst itemsCount = this.freshContent.size;\r\n\t\tif (itemsCount > 0) {\r\n\t\t\tconst packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\r\n\t\t\tconst itemsPerPack = Math.ceil(itemsCount / packCount);\r\n\t\t\tconst packs = [];\r\n\t\t\tlet i = 0;\r\n\t\t\tlet ignoreNextTimeTick = false;\r\n\t\t\tconst createNextPack = () => {\r\n\t\t\t\tconst loc = this._findLocation();\r\n\t\t\t\tthis.content[loc] = null; // reserve\r\n\t\t\t\tconst pack = {\r\n\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\titems: new Set(),\r\n\t\t\t\t\t/** @type {Map<string, any>} */\r\n\t\t\t\t\tmap: new Map(),\r\n\t\t\t\t\tloc\r\n\t\t\t\t};\r\n\t\t\t\tpacks.push(pack);\r\n\t\t\t\treturn pack;\r\n\t\t\t};\r\n\t\t\tlet pack = createNextPack();\r\n\t\t\tif (this.requestsTimeout !== undefined)\r\n\t\t\t\tclearTimeout(this.requestsTimeout);\r\n\t\t\tfor (const identifier of this.requests) {\r\n\t\t\t\tif (identifier === undefined) {\r\n\t\t\t\t\tif (ignoreNextTimeTick) {\r\n\t\t\t\t\t\tignoreNextTimeTick = false;\r\n\t\t\t\t\t} else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\r\n\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\tpack = createNextPack();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst info = this.freshContent.get(identifier);\r\n\t\t\t\tif (info === undefined) continue;\r\n\t\t\t\tpack.items.add(identifier);\r\n\t\t\t\tpack.map.set(identifier, info.freshValue);\r\n\t\t\t\tinfo.location = pack.loc;\r\n\t\t\t\tinfo.freshValue = undefined;\r\n\t\t\t\tthis.freshContent.delete(identifier);\r\n\t\t\t\tif (++i > itemsPerPack) {\r\n\t\t\t\t\ti = 0;\r\n\t\t\t\t\tpack = createNextPack();\r\n\t\t\t\t\tignoreNextTimeTick = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.requests.length = 0;\r\n\t\t\tfor (const pack of packs) {\r\n\t\t\t\tthis.content[pack.loc] = new PackContent(\r\n\t\t\t\t\tpack.items,\r\n\t\t\t\t\tnew Set(pack.items),\r\n\t\t\t\t\tnew PackContentItems(pack.map)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tthis.logger.log(\r\n\t\t\t\t`${itemsCount} fresh items in cache put into pack ${\r\n\t\t\t\t\tpacks.length > 1\r\n\t\t\t\t\t\t? packs\r\n\t\t\t\t\t\t\t\t.map(pack => `${pack.loc} (${pack.items.size} items)`)\r\n\t\t\t\t\t\t\t\t.join(\", \")\r\n\t\t\t\t\t\t: packs[0].loc\r\n\t\t\t\t}`\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Merges small content files to a single content file\r\n\t */\r\n\t_optimizeSmallContent() {\r\n\t\t// 1. Find all small content files\r\n\t\t// Treat unused content files separately to avoid\r\n\t\t// a merge-split cycle\r\n\t\t/** @type {number[]} */\r\n\t\tconst smallUsedContents = [];\r\n\t\t/** @type {number} */\r\n\t\tlet smallUsedContentSize = 0;\r\n\t\t/** @type {number[]} */\r\n\t\tconst smallUnusedContents = [];\r\n\t\t/** @type {number} */\r\n\t\tlet smallUnusedContentSize = 0;\r\n\t\tfor (let i = 0; i < this.content.length; i++) {\r\n\t\t\tconst content = this.content[i];\r\n\t\t\tif (content === undefined) continue;\r\n\t\t\tif (content.outdated) continue;\r\n\t\t\tconst size = content.getSize();\r\n\t\t\tif (size < 0 || size > MIN_CONTENT_SIZE) continue;\r\n\t\t\tif (content.used.size > 0) {\r\n\t\t\t\tsmallUsedContents.push(i);\r\n\t\t\t\tsmallUsedContentSize += size;\r\n\t\t\t} else {\r\n\t\t\t\tsmallUnusedContents.push(i);\r\n\t\t\t\tsmallUnusedContentSize += size;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 2. Check if minimum number is reached\r\n\t\tlet mergedIndices;\r\n\t\tif (\r\n\t\t\tsmallUsedContents.length >= CONTENT_COUNT_TO_MERGE ||\r\n\t\t\tsmallUsedContentSize > MIN_CONTENT_SIZE\r\n\t\t) {\r\n\t\t\tmergedIndices = smallUsedContents;\r\n\t\t} else if (\r\n\t\t\tsmallUnusedContents.length >= CONTENT_COUNT_TO_MERGE ||\r\n\t\t\tsmallUnusedContentSize > MIN_CONTENT_SIZE\r\n\t\t) {\r\n\t\t\tmergedIndices = smallUnusedContents;\r\n\t\t} else return;\r\n\r\n\t\tconst mergedContent = [];\r\n\r\n\t\t// 3. Remove old content entries\r\n\t\tfor (const i of mergedIndices) {\r\n\t\t\tmergedContent.push(this.content[i]);\r\n\t\t\tthis.content[i] = undefined;\r\n\t\t}\r\n\r\n\t\t// 4. Determine merged items\r\n\t\t/** @type {Set<string>} */\r\n\t\tconst mergedItems = new Set();\r\n\t\t/** @type {Set<string>} */\r\n\t\tconst mergedUsedItems = new Set();\r\n\t\t/** @type {(function(Map<string, any>): Promise)[]} */\r\n\t\tconst addToMergedMap = [];\r\n\t\tfor (const content of mergedContent) {\r\n\t\t\tfor (const identifier of content.items) {\r\n\t\t\t\tmergedItems.add(identifier);\r\n\t\t\t}\r\n\t\t\tfor (const identifier of content.used) {\r\n\t\t\t\tmergedUsedItems.add(identifier);\r\n\t\t\t}\r\n\t\t\taddToMergedMap.push(async map => {\r\n\t\t\t\t// unpack existing content\r\n\t\t\t\t// after that values are accessible in .content\r\n\t\t\t\tawait content.unpack(\r\n\t\t\t\t\t\"it should be merged with other small pack contents\"\r\n\t\t\t\t);\r\n\t\t\t\tfor (const [identifier, value] of content.content) {\r\n\t\t\t\t\tmap.set(identifier, value);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// 5. GC and update location of merged items\r\n\t\tconst newLoc = this._findLocation();\r\n\t\tthis._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\r\n\r\n\t\t// 6. If not empty, store content somewhere\r\n\t\tif (mergedItems.size > 0) {\r\n\t\t\tthis.content[newLoc] = new PackContent(\r\n\t\t\t\tmergedItems,\r\n\t\t\t\tmergedUsedItems,\r\n\t\t\t\tmemoize(async () => {\r\n\t\t\t\t\t/** @type {Map<string, any>} */\r\n\t\t\t\t\tconst map = new Map();\r\n\t\t\t\t\tawait Promise.all(addToMergedMap.map(fn => fn(map)));\r\n\t\t\t\t\treturn new PackContentItems(map);\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t\tthis.logger.log(\r\n\t\t\t\t\"Merged %d small files with %d cache items into pack %d\",\r\n\t\t\t\tmergedContent.length,\r\n\t\t\t\tmergedItems.size,\r\n\t\t\t\tnewLoc\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Split large content files with used and unused items\r\n\t * into two parts to separate used from unused items\r\n\t */\r\n\t_optimizeUnusedContent() {\r\n\t\t// 1. Find a large content file with used and unused items\r\n\t\tfor (let i = 0; i < this.content.length; i++) {\r\n\t\t\tconst content = this.content[i];\r\n\t\t\tif (content === undefined) continue;\r\n\t\t\tconst size = content.getSize();\r\n\t\t\tif (size < MIN_CONTENT_SIZE) continue;\r\n\t\t\tconst used = content.used.size;\r\n\t\t\tconst total = content.items.size;\r\n\t\t\tif (used > 0 && used < total) {\r\n\t\t\t\t// 2. Remove this content\r\n\t\t\t\tthis.content[i] = undefined;\r\n\r\n\t\t\t\t// 3. Determine items for the used content file\r\n\t\t\t\tconst usedItems = new Set(content.used);\r\n\t\t\t\tconst newLoc = this._findLocation();\r\n\t\t\t\tthis._gcAndUpdateLocation(usedItems, usedItems, newLoc);\r\n\r\n\t\t\t\t// 4. Create content file for used items\r\n\t\t\t\tif (usedItems.size > 0) {\r\n\t\t\t\t\tthis.content[newLoc] = new PackContent(\r\n\t\t\t\t\t\tusedItems,\r\n\t\t\t\t\t\tnew Set(usedItems),\r\n\t\t\t\t\t\tasync () => {\r\n\t\t\t\t\t\t\tawait content.unpack(\r\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tconst map = new Map();\r\n\t\t\t\t\t\t\tfor (const identifier of usedItems) {\r\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn new PackContentItems(map);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 5. Determine items for the unused content file\r\n\t\t\t\tconst unusedItems = new Set(content.items);\r\n\t\t\t\tconst usedOfUnusedItems = new Set();\r\n\t\t\t\tfor (const identifier of usedItems) {\r\n\t\t\t\t\tunusedItems.delete(identifier);\r\n\t\t\t\t}\r\n\t\t\t\tconst newUnusedLoc = this._findLocation();\r\n\t\t\t\tthis._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\r\n\r\n\t\t\t\t// 6. Create content file for unused items\r\n\t\t\t\tif (unusedItems.size > 0) {\r\n\t\t\t\t\tthis.content[newUnusedLoc] = new PackContent(\r\n\t\t\t\t\t\tunusedItems,\r\n\t\t\t\t\t\tusedOfUnusedItems,\r\n\t\t\t\t\t\tasync () => {\r\n\t\t\t\t\t\t\tawait content.unpack(\r\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tconst map = new Map();\r\n\t\t\t\t\t\t\tfor (const identifier of unusedItems) {\r\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn new PackContentItems(map);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.logger.log(\r\n\t\t\t\t\t\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\",\r\n\t\t\t\t\ti,\r\n\t\t\t\t\tnewLoc,\r\n\t\t\t\t\tusedItems.size,\r\n\t\t\t\t\tnewUnusedLoc,\r\n\t\t\t\t\tunusedItems.size\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// optimizing only one of them is good enough and\r\n\t\t\t\t// reduces the amount of serialization needed\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Find the content with the oldest item and run GC on that.\r\n\t * Only runs for one content to avoid large invalidation.\r\n\t */\r\n\t_gcOldestContent() {\r\n\t\t/** @type {PackItemInfo} */\r\n\t\tlet oldest = undefined;\r\n\t\tfor (const info of this.itemInfo.values()) {\r\n\t\t\tif (oldest === undefined || info.lastAccess < oldest.lastAccess) {\r\n\t\t\t\toldest = info;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (Date.now() - oldest.lastAccess > this.maxAge) {\r\n\t\t\tconst loc = oldest.location;\r\n\t\t\tif (loc < 0) return;\r\n\t\t\tconst content = this.content[loc];\r\n\t\t\tconst items = new Set(content.items);\r\n\t\t\tconst usedItems = new Set(content.used);\r\n\t\t\tthis._gcAndUpdateLocation(items, usedItems, loc);\r\n\r\n\t\t\tthis.content[loc] =\r\n\t\t\t\titems.size > 0\r\n\t\t\t\t\t? new PackContent(items, usedItems, async () => {\r\n\t\t\t\t\t\t\tawait content.unpack(\r\n\t\t\t\t\t\t\t\t\"it contains old items that should be garbage collected\"\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tconst map = new Map();\r\n\t\t\t\t\t\t\tfor (const identifier of items) {\r\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn new PackContentItems(map);\r\n\t\t\t\t\t  })\r\n\t\t\t\t\t: undefined;\r\n\t\t}\r\n\t}\r\n\r\n\tserialize({ write, writeSeparate }) {\r\n\t\tthis._persistFreshContent();\r\n\t\tthis._optimizeSmallContent();\r\n\t\tthis._optimizeUnusedContent();\r\n\t\tthis._gcOldestContent();\r\n\t\tfor (const identifier of this.itemInfo.keys()) {\r\n\t\t\twrite(identifier);\r\n\t\t}\r\n\t\twrite(null); // null as marker of the end of keys\r\n\t\tfor (const info of this.itemInfo.values()) {\r\n\t\t\twrite(info.etag);\r\n\t\t}\r\n\t\tfor (const info of this.itemInfo.values()) {\r\n\t\t\twrite(info.lastAccess);\r\n\t\t}\r\n\t\tfor (let i = 0; i < this.content.length; i++) {\r\n\t\t\tconst content = this.content[i];\r\n\t\t\tif (content !== undefined) {\r\n\t\t\t\twrite(content.items);\r\n\t\t\t\tcontent.writeLazy(lazy => writeSeparate(lazy, { name: `${i}` }));\r\n\t\t\t} else {\r\n\t\t\t\twrite(undefined); // undefined marks an empty content slot\r\n\t\t\t}\r\n\t\t}\r\n\t\twrite(null); // null as marker of the end of items\r\n\t}\r\n\r\n\tdeserialize({ read, logger }) {\r\n\t\tthis.logger = logger;\r\n\t\t{\r\n\t\t\tconst items = [];\r\n\t\t\tlet item = read();\r\n\t\t\twhile (item !== null) {\r\n\t\t\t\titems.push(item);\r\n\t\t\t\titem = read();\r\n\t\t\t}\r\n\t\t\tthis.itemInfo.clear();\r\n\t\t\tconst infoItems = items.map(identifier => {\r\n\t\t\t\tconst info = new PackItemInfo(identifier, undefined, undefined);\r\n\t\t\t\tthis.itemInfo.set(identifier, info);\r\n\t\t\t\treturn info;\r\n\t\t\t});\r\n\t\t\tfor (const info of infoItems) {\r\n\t\t\t\tinfo.etag = read();\r\n\t\t\t}\r\n\t\t\tfor (const info of infoItems) {\r\n\t\t\t\tinfo.lastAccess = read();\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.content.length = 0;\r\n\t\tlet items = read();\r\n\t\twhile (items !== null) {\r\n\t\t\tif (items === undefined) {\r\n\t\t\t\tthis.content.push(items);\r\n\t\t\t} else {\r\n\t\t\t\tconst idx = this.content.length;\r\n\t\t\t\tconst lazy = read();\r\n\t\t\t\tthis.content.push(\r\n\t\t\t\t\tnew PackContent(\r\n\t\t\t\t\t\titems,\r\n\t\t\t\t\t\tnew Set(),\r\n\t\t\t\t\t\tlazy,\r\n\t\t\t\t\t\tlogger,\r\n\t\t\t\t\t\t`${this.content.length}`\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t\tfor (const identifier of items) {\r\n\t\t\t\t\tthis.itemInfo.get(identifier).location = idx;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\titems = read();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\r\n\r\nclass PackContentItems {\r\n\t/**\r\n\t * @param {Map<string, any>} map items\r\n\t */\r\n\tconstructor(map) {\r\n\t\tthis.map = map;\r\n\t}\r\n\r\n\tserialize({ write, snapshot, rollback, logger, profile }) {\r\n\t\tif (profile) {\r\n\t\t\twrite(false);\r\n\t\t\tfor (const [key, value] of this.map) {\r\n\t\t\t\tconst s = snapshot();\r\n\t\t\t\ttry {\r\n\t\t\t\t\twrite(key);\r\n\t\t\t\t\tconst start = process.hrtime();\r\n\t\t\t\t\twrite(value);\r\n\t\t\t\t\tconst durationHr = process.hrtime(start);\r\n\t\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\r\n\t\t\t\t\tif (duration > 1) {\r\n\t\t\t\t\t\tif (duration > 500)\r\n\t\t\t\t\t\t\tlogger.error(`Serialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\t\telse if (duration > 50)\r\n\t\t\t\t\t\t\tlogger.warn(`Serialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\t\telse if (duration > 10)\r\n\t\t\t\t\t\t\tlogger.info(`Serialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\t\telse if (duration > 5)\r\n\t\t\t\t\t\t\tlogger.log(`Serialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\t\telse logger.debug(`Serialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\trollback(s);\r\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\r\n\t\t\t\t\tconst msg = \"Skipped not serializable cache item\";\r\n\t\t\t\t\tif (e.message.includes(\"ModuleBuildError\")) {\r\n\t\t\t\t\t\tlogger.log(`${msg} (in build error): ${e.message}`);\r\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlogger.warn(`${msg}: ${e.message}`);\r\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}': ${e.stack}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twrite(null);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Try to serialize all at once\r\n\t\tconst s = snapshot();\r\n\t\ttry {\r\n\t\t\twrite(true);\r\n\t\t\twrite(this.map);\r\n\t\t} catch (e) {\r\n\t\t\trollback(s);\r\n\r\n\t\t\t// Try to serialize each item on it's own\r\n\t\t\twrite(false);\r\n\t\t\tfor (const [key, value] of this.map) {\r\n\t\t\t\tconst s = snapshot();\r\n\t\t\t\ttry {\r\n\t\t\t\t\twrite(key);\r\n\t\t\t\t\twrite(value);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\trollback(s);\r\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\r\n\t\t\t\t\t);\r\n\t\t\t\t\tlogger.debug(e.stack);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twrite(null);\r\n\t\t}\r\n\t}\r\n\r\n\tdeserialize({ read, logger, profile }) {\r\n\t\tif (read()) {\r\n\t\t\tthis.map = read();\r\n\t\t} else if (profile) {\r\n\t\t\tconst map = new Map();\r\n\t\t\tlet key = read();\r\n\t\t\twhile (key !== null) {\r\n\t\t\t\tconst start = process.hrtime();\r\n\t\t\t\tconst value = read();\r\n\t\t\t\tconst durationHr = process.hrtime(start);\r\n\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\r\n\t\t\t\tif (duration > 1) {\r\n\t\t\t\t\tif (duration > 100)\r\n\t\t\t\t\t\tlogger.error(`Deserialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\telse if (duration > 20)\r\n\t\t\t\t\t\tlogger.warn(`Deserialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\telse if (duration > 5)\r\n\t\t\t\t\t\tlogger.info(`Deserialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\telse if (duration > 2)\r\n\t\t\t\t\t\tlogger.log(`Deserialization of '${key}': ${duration} ms`);\r\n\t\t\t\t\telse logger.debug(`Deserialization of '${key}': ${duration} ms`);\r\n\t\t\t\t}\r\n\t\t\t\tmap.set(key, value);\r\n\t\t\t\tkey = read();\r\n\t\t\t}\r\n\t\t\tthis.map = map;\r\n\t\t} else {\r\n\t\t\tconst map = new Map();\r\n\t\t\tlet key = read();\r\n\t\t\twhile (key !== null) {\r\n\t\t\t\tmap.set(key, read());\r\n\t\t\t\tkey = read();\r\n\t\t\t}\r\n\t\t\tthis.map = map;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmakeSerializable(\r\n\tPackContentItems,\r\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\r\n\t\"PackContentItems\"\r\n);\r\n\r\nclass PackContent {\r\n\t/*\r\n\t\tThis class can be in these states:\r\n\t\t   |   this.lazy    | this.content | this.outdated | state\r\n\t\tA1 |   undefined    |     Map      |     false     | fresh content\r\n\t\tA2 |   undefined    |     Map      |     true      | (will not happen)\r\n\t\tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\r\n\t\tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\r\n\t\tC1 | lazy* () => {} |     Map      |     false     | deserialized\r\n\t\tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\r\n\r\n\t\tthis.used is a subset of this.items.\r\n\t\tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\r\n\t\tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\r\n\t\tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\r\n\t\tWhen this.lazy and this.content is set, they contain the same data.\r\n\t\tthis.get must only be called with a valid item from this.items.\r\n\t\tIn state C this.lazy is unMemoized\r\n\t*/\r\n\r\n\t/**\r\n\t * @param {Set<string>} items keys\r\n\t * @param {Set<string>} usedItems used keys\r\n\t * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\r\n\t * @param {Logger=} logger logger for logging\r\n\t * @param {string=} lazyName name of dataOrFn for logging\r\n\t */\r\n\tconstructor(items, usedItems, dataOrFn, logger, lazyName) {\r\n\t\tthis.items = items;\r\n\t\t/** @type {function(): Promise<PackContentItems> | PackContentItems} */\r\n\t\tthis.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\r\n\t\t/** @type {Map<string, any>} */\r\n\t\tthis.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\r\n\t\tthis.outdated = false;\r\n\t\tthis.used = usedItems;\r\n\t\tthis.logger = logger;\r\n\t\tthis.lazyName = lazyName;\r\n\t}\r\n\r\n\tget(identifier) {\r\n\t\tthis.used.add(identifier);\r\n\t\tif (this.content) {\r\n\t\t\treturn this.content.get(identifier);\r\n\t\t}\r\n\r\n\t\t// We are in state B\r\n\t\tconst { lazyName } = this;\r\n\t\tlet timeMessage;\r\n\t\tif (lazyName) {\r\n\t\t\t// only log once\r\n\t\t\tthis.lazyName = undefined;\r\n\t\t\ttimeMessage = `restore cache content ${lazyName} (${formatSize(\r\n\t\t\t\tthis.getSize()\r\n\t\t\t)})`;\r\n\t\t\tthis.logger.log(\r\n\t\t\t\t`starting to restore cache content ${lazyName} (${formatSize(\r\n\t\t\t\t\tthis.getSize()\r\n\t\t\t\t)}) because of request to: ${identifier}`\r\n\t\t\t);\r\n\t\t\tthis.logger.time(timeMessage);\r\n\t\t}\r\n\t\tconst value = this.lazy();\r\n\t\tif (\"then\" in value) {\r\n\t\t\treturn value.then(data => {\r\n\t\t\t\tconst map = data.map;\r\n\t\t\t\tif (timeMessage) {\r\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\r\n\t\t\t\t}\r\n\t\t\t\t// Move to state C\r\n\t\t\t\tthis.content = map;\r\n\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\r\n\t\t\t\treturn map.get(identifier);\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tconst map = value.map;\r\n\t\t\tif (timeMessage) {\r\n\t\t\t\tthis.logger.timeEnd(timeMessage);\r\n\t\t\t}\r\n\t\t\t// Move to state C\r\n\t\t\tthis.content = map;\r\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\r\n\t\t\treturn map.get(identifier);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} reason explanation why unpack is necessary\r\n\t * @returns {void | Promise} maybe a promise if lazy\r\n\t */\r\n\tunpack(reason) {\r\n\t\tif (this.content) return;\r\n\r\n\t\t// Move from state B to C\r\n\t\tif (this.lazy) {\r\n\t\t\tconst { lazyName } = this;\r\n\t\t\tlet timeMessage;\r\n\t\t\tif (lazyName) {\r\n\t\t\t\t// only log once\r\n\t\t\t\tthis.lazyName = undefined;\r\n\t\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\r\n\t\t\t\t\tthis.getSize()\r\n\t\t\t\t)})`;\r\n\t\t\t\tthis.logger.log(\r\n\t\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\r\n\t\t\t\t\t\tthis.getSize()\r\n\t\t\t\t\t)}) because ${reason}`\r\n\t\t\t\t);\r\n\t\t\t\tthis.logger.time(timeMessage);\r\n\t\t\t}\r\n\t\t\tconst value = this.lazy();\r\n\t\t\tif (\"then\" in value) {\r\n\t\t\t\treturn value.then(data => {\r\n\t\t\t\t\tif (timeMessage) {\r\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.content = data.map;\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (timeMessage) {\r\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\r\n\t\t\t\t}\r\n\t\t\t\tthis.content = value.map;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} size of the content or -1 if not known\r\n\t */\r\n\tgetSize() {\r\n\t\tif (!this.lazy) return -1;\r\n\t\tconst options = /** @type {any} */ (this.lazy).options;\r\n\t\tif (!options) return -1;\r\n\t\tconst size = options.size;\r\n\t\tif (typeof size !== \"number\") return -1;\r\n\t\treturn size;\r\n\t}\r\n\r\n\tdelete(identifier) {\r\n\t\tthis.items.delete(identifier);\r\n\t\tthis.used.delete(identifier);\r\n\t\tthis.outdated = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @template T\r\n\t * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\r\n\t * @returns {void}\r\n\t */\r\n\twriteLazy(write) {\r\n\t\tif (!this.outdated && this.lazy) {\r\n\t\t\t// State B1 or C1\r\n\t\t\t// this.lazy is still the valid deserialized version\r\n\t\t\twrite(this.lazy);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!this.outdated && this.content) {\r\n\t\t\t// State A1\r\n\t\t\tconst map = new Map(this.content);\r\n\t\t\t// Move to state C1\r\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\r\n\t\t\t\twrite(() => new PackContentItems(map))\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.content) {\r\n\t\t\t// State A2 or C2\r\n\t\t\t/** @type {Map<string, any>} */\r\n\t\t\tconst map = new Map();\r\n\t\t\tfor (const item of this.items) {\r\n\t\t\t\tmap.set(item, this.content.get(item));\r\n\t\t\t}\r\n\t\t\t// Move to state C1\r\n\t\t\tthis.outdated = false;\r\n\t\t\tthis.content = map;\r\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\r\n\t\t\t\twrite(() => new PackContentItems(map))\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// State B2\r\n\t\tconst { lazyName } = this;\r\n\t\tlet timeMessage;\r\n\t\tif (lazyName) {\r\n\t\t\t// only log once\r\n\t\t\tthis.lazyName = undefined;\r\n\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\r\n\t\t\t\tthis.getSize()\r\n\t\t\t)})`;\r\n\t\t\tthis.logger.log(\r\n\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\r\n\t\t\t\t\tthis.getSize()\r\n\t\t\t\t)}) because it's outdated and need to be serialized`\r\n\t\t\t);\r\n\t\t\tthis.logger.time(timeMessage);\r\n\t\t}\r\n\t\tconst value = this.lazy();\r\n\t\tthis.outdated = false;\r\n\t\tif (\"then\" in value) {\r\n\t\t\t// Move to state B1\r\n\t\t\tthis.lazy = write(() =>\r\n\t\t\t\tvalue.then(data => {\r\n\t\t\t\t\tif (timeMessage) {\r\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst oldMap = data.map;\r\n\t\t\t\t\t/** @type {Map<string, any>} */\r\n\t\t\t\t\tconst map = new Map();\r\n\t\t\t\t\tfor (const item of this.items) {\r\n\t\t\t\t\t\tmap.set(item, oldMap.get(item));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Move to state C1 (or maybe C2)\r\n\t\t\t\t\tthis.content = map;\r\n\t\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\r\n\r\n\t\t\t\t\treturn new PackContentItems(map);\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\t// Move to state C1\r\n\t\t\tif (timeMessage) {\r\n\t\t\t\tthis.logger.timeEnd(timeMessage);\r\n\t\t\t}\r\n\t\t\tconst oldMap = value.map;\r\n\t\t\t/** @type {Map<string, any>} */\r\n\t\t\tconst map = new Map();\r\n\t\t\tfor (const item of this.items) {\r\n\t\t\t\tmap.set(item, oldMap.get(item));\r\n\t\t\t}\r\n\t\t\tthis.content = map;\r\n\t\t\tthis.lazy = write(() => new PackContentItems(map));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst allowCollectingMemory = buf => {\r\n\tconst wasted = buf.buffer.byteLength - buf.byteLength;\r\n\tif (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\r\n\t\treturn Buffer.from(buf);\r\n\t}\r\n\treturn buf;\r\n};\r\n\r\nclass PackFileCacheStrategy {\r\n\t/**\r\n\t * @param {Object} options options\r\n\t * @param {Compiler} options.compiler the compiler\r\n\t * @param {IntermediateFileSystem} options.fs the filesystem\r\n\t * @param {string} options.context the context directory\r\n\t * @param {string} options.cacheLocation the location of the cache data\r\n\t * @param {string} options.version version identifier\r\n\t * @param {Logger} options.logger a logger\r\n\t * @param {SnapshotOptions} options.snapshot options regarding snapshotting\r\n\t * @param {number} options.maxAge max age of cache items\r\n\t * @param {boolean} options.profile track and log detailed timing information for individual cache items\r\n\t * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\r\n\t * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\r\n\t */\r\n\tconstructor({\r\n\t\tcompiler,\r\n\t\tfs,\r\n\t\tcontext,\r\n\t\tcacheLocation,\r\n\t\tversion,\r\n\t\tlogger,\r\n\t\tsnapshot,\r\n\t\tmaxAge,\r\n\t\tprofile,\r\n\t\tallowCollectingMemory,\r\n\t\tcompression\r\n\t}) {\r\n\t\tthis.fileSerializer = createFileSerializer(\r\n\t\t\tfs,\r\n\t\t\tcompiler.options.output.hashFunction\r\n\t\t);\r\n\t\tthis.fileSystemInfo = new FileSystemInfo(fs, {\r\n\t\t\tmanagedPaths: snapshot.managedPaths,\r\n\t\t\timmutablePaths: snapshot.immutablePaths,\r\n\t\t\tlogger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\r\n\t\t\thashFunction: compiler.options.output.hashFunction\r\n\t\t});\r\n\t\tthis.compiler = compiler;\r\n\t\tthis.context = context;\r\n\t\tthis.cacheLocation = cacheLocation;\r\n\t\tthis.version = version;\r\n\t\tthis.logger = logger;\r\n\t\tthis.maxAge = maxAge;\r\n\t\tthis.profile = profile;\r\n\t\tthis.allowCollectingMemory = allowCollectingMemory;\r\n\t\tthis.compression = compression;\r\n\t\tthis._extension =\r\n\t\t\tcompression === \"brotli\"\r\n\t\t\t\t? \".pack.br\"\r\n\t\t\t\t: compression === \"gzip\"\r\n\t\t\t\t? \".pack.gz\"\r\n\t\t\t\t: \".pack\";\r\n\t\tthis.snapshot = snapshot;\r\n\t\t/** @type {Set<string>} */\r\n\t\tthis.buildDependencies = new Set();\r\n\t\t/** @type {LazySet<string>} */\r\n\t\tthis.newBuildDependencies = new LazySet();\r\n\t\t/** @type {Snapshot} */\r\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\r\n\t\t/** @type {Map<string, string | false>} */\r\n\t\tthis.resolveResults = undefined;\r\n\t\t/** @type {Snapshot} */\r\n\t\tthis.buildSnapshot = undefined;\r\n\t\t/** @type {Promise<Pack>} */\r\n\t\tthis.packPromise = this._openPack();\r\n\t\tthis.storePromise = Promise.resolve();\r\n\t}\r\n\r\n\t_getPack() {\r\n\t\tif (this.packPromise === undefined) {\r\n\t\t\tthis.packPromise = this.storePromise.then(() => this._openPack());\r\n\t\t}\r\n\t\treturn this.packPromise;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Promise<Pack>} the pack\r\n\t */\r\n\t_openPack() {\r\n\t\tconst { logger, profile, cacheLocation, version } = this;\r\n\t\t/** @type {Snapshot} */\r\n\t\tlet buildSnapshot;\r\n\t\t/** @type {Set<string>} */\r\n\t\tlet buildDependencies;\r\n\t\t/** @type {Set<string>} */\r\n\t\tlet newBuildDependencies;\r\n\t\t/** @type {Snapshot} */\r\n\t\tlet resolveBuildDependenciesSnapshot;\r\n\t\t/** @type {Map<string, string | false>} */\r\n\t\tlet resolveResults;\r\n\t\tlogger.time(\"restore cache container\");\r\n\t\treturn this.fileSerializer\r\n\t\t\t.deserialize(null, {\r\n\t\t\t\tfilename: `${cacheLocation}/index${this._extension}`,\r\n\t\t\t\textension: `${this._extension}`,\r\n\t\t\t\tlogger,\r\n\t\t\t\tprofile,\r\n\t\t\t\tretainedBuffer: this.allowCollectingMemory\r\n\t\t\t\t\t? allowCollectingMemory\r\n\t\t\t\t\t: undefined\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\tif (err.code !== \"ENOENT\") {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`\r\n\t\t\t\t\t);\r\n\t\t\t\t\tlogger.debug(err.stack);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.debug(\r\n\t\t\t\t\t\t`No pack exists at ${cacheLocation}${this._extension}: ${err}`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\treturn undefined;\r\n\t\t\t})\r\n\t\t\t.then(packContainer => {\r\n\t\t\t\tlogger.timeEnd(\"restore cache container\");\r\n\t\t\t\tif (!packContainer) return undefined;\r\n\t\t\t\tif (!(packContainer instanceof PackContainer)) {\r\n\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`,\r\n\t\t\t\t\t\tpackContainer\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (packContainer.version !== version) {\r\n\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\t\t\t\tlogger.time(\"check build dependencies\");\r\n\t\t\t\treturn Promise.all([\r\n\t\t\t\t\tnew Promise((resolve, reject) => {\r\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\r\n\t\t\t\t\t\t\tpackContainer.buildSnapshot,\r\n\t\t\t\t\t\t\t(err, valid) => {\r\n\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\r\n\t\t\t\t\t\t\t\t\treturn resolve(false);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (!valid) {\r\n\t\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\treturn resolve(false);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbuildSnapshot = packContainer.buildSnapshot;\r\n\t\t\t\t\t\t\t\treturn resolve(true);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tnew Promise((resolve, reject) => {\r\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\r\n\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot,\r\n\t\t\t\t\t\t\t(err, valid) => {\r\n\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\r\n\t\t\t\t\t\t\t\t\treturn resolve(false);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (valid) {\r\n\t\t\t\t\t\t\t\t\tresolveBuildDependenciesSnapshot =\r\n\t\t\t\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot;\r\n\t\t\t\t\t\t\t\t\tbuildDependencies = packContainer.buildDependencies;\r\n\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\r\n\t\t\t\t\t\t\t\t\treturn resolve(true);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t\"resolving of build dependencies is invalid, will re-resolve build dependencies\"\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.checkResolveResultsValid(\r\n\t\t\t\t\t\t\t\t\tpackContainer.resolveResults,\r\n\t\t\t\t\t\t\t\t\t(err, valid) => {\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\r\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(false);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (valid) {\r\n\t\t\t\t\t\t\t\t\t\t\tnewBuildDependencies = packContainer.buildDependencies;\r\n\t\t\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\r\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(true);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\treturn resolve(false);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t})\r\n\t\t\t\t])\r\n\t\t\t\t\t.catch(err => {\r\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\r\n\t\t\t\t\t\tthrow err;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.then(([buildSnapshotValid, resolveValid]) => {\r\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\r\n\t\t\t\t\t\tif (buildSnapshotValid && resolveValid) {\r\n\t\t\t\t\t\t\tlogger.time(\"restore cache content metadata\");\r\n\t\t\t\t\t\t\tconst d = packContainer.data();\r\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cache content metadata\");\r\n\t\t\t\t\t\t\treturn d;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\t});\r\n\t\t\t})\r\n\t\t\t.then(pack => {\r\n\t\t\t\tif (pack) {\r\n\t\t\t\t\tpack.maxAge = this.maxAge;\r\n\t\t\t\t\tthis.buildSnapshot = buildSnapshot;\r\n\t\t\t\t\tif (buildDependencies) this.buildDependencies = buildDependencies;\r\n\t\t\t\t\tif (newBuildDependencies)\r\n\t\t\t\t\t\tthis.newBuildDependencies.addAll(newBuildDependencies);\r\n\t\t\t\t\tthis.resolveResults = resolveResults;\r\n\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\r\n\t\t\t\t\t\tresolveBuildDependenciesSnapshot;\r\n\t\t\t\t\treturn pack;\r\n\t\t\t\t}\r\n\t\t\t\treturn new Pack(logger, this.maxAge);\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\tthis.logger.warn(\r\n\t\t\t\t\t`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`\r\n\t\t\t\t);\r\n\t\t\t\tthis.logger.debug(err.stack);\r\n\t\t\t\treturn new Pack(logger, this.maxAge);\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} identifier unique name for the resource\r\n\t * @param {Etag | null} etag etag of the resource\r\n\t * @param {any} data cached content\r\n\t * @returns {Promise<void>} promise\r\n\t */\r\n\tstore(identifier, etag, data) {\r\n\t\treturn this._getPack().then(pack => {\r\n\t\t\tpack.set(identifier, etag === null ? null : etag.toString(), data);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} identifier unique name for the resource\r\n\t * @param {Etag | null} etag etag of the resource\r\n\t * @returns {Promise<any>} promise to the cached content\r\n\t */\r\n\trestore(identifier, etag) {\r\n\t\treturn this._getPack()\r\n\t\t\t.then(pack =>\r\n\t\t\t\tpack.get(identifier, etag === null ? null : etag.toString())\r\n\t\t\t)\r\n\t\t\t.catch(err => {\r\n\t\t\t\tif (err && err.code !== \"ENOENT\") {\r\n\t\t\t\t\tthis.logger.warn(\r\n\t\t\t\t\t\t`Restoring failed for ${identifier} from pack: ${err}`\r\n\t\t\t\t\t);\r\n\t\t\t\t\tthis.logger.debug(err.stack);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t}\r\n\r\n\tstoreBuildDependencies(dependencies) {\r\n\t\tthis.newBuildDependencies.addAll(dependencies);\r\n\t}\r\n\r\n\tafterAllStored() {\r\n\t\tconst packPromise = this.packPromise;\r\n\t\tif (packPromise === undefined) return Promise.resolve();\r\n\t\tconst reportProgress = ProgressPlugin.getReporter(this.compiler);\r\n\t\treturn (this.storePromise = packPromise\r\n\t\t\t.then(pack => {\r\n\t\t\t\tpack.stopCapturingRequests();\r\n\t\t\t\tif (!pack.invalid) return;\r\n\t\t\t\tthis.packPromise = undefined;\r\n\t\t\t\tthis.logger.log(`Storing pack...`);\r\n\t\t\t\tlet promise;\r\n\t\t\t\tconst newBuildDependencies = new Set();\r\n\t\t\t\tfor (const dep of this.newBuildDependencies) {\r\n\t\t\t\t\tif (!this.buildDependencies.has(dep)) {\r\n\t\t\t\t\t\tnewBuildDependencies.add(dep);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (newBuildDependencies.size > 0 || !this.buildSnapshot) {\r\n\t\t\t\t\tif (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\r\n\t\t\t\t\tthis.logger.debug(\r\n\t\t\t\t\t\t`Capturing build dependencies... (${Array.from(\r\n\t\t\t\t\t\t\tnewBuildDependencies\r\n\t\t\t\t\t\t).join(\", \")})`\r\n\t\t\t\t\t);\r\n\t\t\t\t\tpromise = new Promise((resolve, reject) => {\r\n\t\t\t\t\t\tthis.logger.time(\"resolve build dependencies\");\r\n\t\t\t\t\t\tthis.fileSystemInfo.resolveBuildDependencies(\r\n\t\t\t\t\t\t\tthis.context,\r\n\t\t\t\t\t\t\tnewBuildDependencies,\r\n\t\t\t\t\t\t\t(err, result) => {\r\n\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"resolve build dependencies\");\r\n\t\t\t\t\t\t\t\tif (err) return reject(err);\r\n\r\n\t\t\t\t\t\t\t\tthis.logger.time(\"snapshot build dependencies\");\r\n\t\t\t\t\t\t\t\tconst {\r\n\t\t\t\t\t\t\t\t\tfiles,\r\n\t\t\t\t\t\t\t\t\tdirectories,\r\n\t\t\t\t\t\t\t\t\tmissing,\r\n\t\t\t\t\t\t\t\t\tresolveResults,\r\n\t\t\t\t\t\t\t\t\tresolveDependencies\r\n\t\t\t\t\t\t\t\t} = result;\r\n\t\t\t\t\t\t\t\tif (this.resolveResults) {\r\n\t\t\t\t\t\t\t\t\tfor (const [key, value] of resolveResults) {\r\n\t\t\t\t\t\t\t\t\t\tthis.resolveResults.set(key, value);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthis.resolveResults = resolveResults;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (reportProgress) {\r\n\t\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t\t0.6,\r\n\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\r\n\t\t\t\t\t\t\t\t\t\t\"resolving\"\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\r\n\t\t\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\t\t\tresolveDependencies.files,\r\n\t\t\t\t\t\t\t\t\tresolveDependencies.directories,\r\n\t\t\t\t\t\t\t\t\tresolveDependencies.missing,\r\n\t\t\t\t\t\t\t\t\tthis.snapshot.resolveBuildDependencies,\r\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\r\n\t\t\t\t\t\t\t\t\t\t\treturn reject(err);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\r\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\r\n\t\t\t\t\t\t\t\t\t\t\treturn reject(\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot resolve dependencies\")\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (this.resolveBuildDependenciesSnapshot) {\r\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\r\n\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot = snapshot;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (reportProgress) {\r\n\t\t\t\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t\t\t\t0.7,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\"modules\"\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\r\n\t\t\t\t\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\t\t\t\t\tfiles,\r\n\t\t\t\t\t\t\t\t\t\t\tdirectories,\r\n\t\t\t\t\t\t\t\t\t\t\tmissing,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.snapshot.buildDependencies,\r\n\t\t\t\t\t\t\t\t\t\t\t(err, snapshot) => {\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn reject(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot build dependencies\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\"Captured build dependencies\");\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.buildSnapshot) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot =\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot = snapshot;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpromise = Promise.resolve();\r\n\t\t\t\t}\r\n\t\t\t\treturn promise.then(() => {\r\n\t\t\t\t\tif (reportProgress) reportProgress(0.8, \"serialize pack\");\r\n\t\t\t\t\tthis.logger.time(`store pack`);\r\n\t\t\t\t\tconst updatedBuildDependencies = new Set(this.buildDependencies);\r\n\t\t\t\t\tfor (const dep of newBuildDependencies) {\r\n\t\t\t\t\t\tupdatedBuildDependencies.add(dep);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst content = new PackContainer(\r\n\t\t\t\t\t\tpack,\r\n\t\t\t\t\t\tthis.version,\r\n\t\t\t\t\t\tthis.buildSnapshot,\r\n\t\t\t\t\t\tupdatedBuildDependencies,\r\n\t\t\t\t\t\tthis.resolveResults,\r\n\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn this.fileSerializer\r\n\t\t\t\t\t\t.serialize(content, {\r\n\t\t\t\t\t\t\tfilename: `${this.cacheLocation}/index${this._extension}`,\r\n\t\t\t\t\t\t\textension: `${this._extension}`,\r\n\t\t\t\t\t\t\tlogger: this.logger,\r\n\t\t\t\t\t\t\tprofile: this.profile\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.then(() => {\r\n\t\t\t\t\t\t\tfor (const dep of newBuildDependencies) {\r\n\t\t\t\t\t\t\t\tthis.buildDependencies.add(dep);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis.newBuildDependencies.clear();\r\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\r\n\t\t\t\t\t\t\tconst stats = pack.getContentStats();\r\n\t\t\t\t\t\t\tthis.logger.log(\r\n\t\t\t\t\t\t\t\t\"Stored pack (%d items, %d files, %d MiB)\",\r\n\t\t\t\t\t\t\t\tpack.itemInfo.size,\r\n\t\t\t\t\t\t\t\tstats.count,\r\n\t\t\t\t\t\t\t\tMath.round(stats.size / 1024 / 1024)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.catch(err => {\r\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\r\n\t\t\t\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\r\n\t\t\t\t\t\t\tthis.logger.debug(err.stack);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\r\n\t\t\t\tthis.logger.debug(err.stack);\r\n\t\t\t}));\r\n\t}\r\n\r\n\tclear() {\r\n\t\tthis.fileSystemInfo.clear();\r\n\t\tthis.buildDependencies.clear();\r\n\t\tthis.newBuildDependencies.clear();\r\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\r\n\t\tthis.resolveResults = undefined;\r\n\t\tthis.buildSnapshot = undefined;\r\n\t\tthis.packPromise = undefined;\r\n\t}\r\n}\r\n\r\nmodule.exports = PackFileCacheStrategy;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}