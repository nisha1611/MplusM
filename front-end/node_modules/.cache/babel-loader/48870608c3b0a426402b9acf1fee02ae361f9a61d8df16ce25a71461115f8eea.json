{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\nconst MODULE_REFERENCE_REGEXP = /^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n\n/**\r\n * @typedef {Object} ExternalModuleInfo\r\n * @property {number} index\r\n * @property {Module} module\r\n */\n\n/**\r\n * @typedef {Object} ConcatenatedModuleInfo\r\n * @property {number} index\r\n * @property {Module} module\r\n * @property {Map<string, string>} exportMap mapping from export name to symbol\r\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\r\n * @property {string=} namespaceExportSymbol\r\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\r\n * @typedef {Object} ModuleReferenceOptions\r\n * @property {string[]} ids the properties/exports of the module\r\n * @property {boolean} call true, when this referenced export is called\r\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\r\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\r\n */\n\nclass ConcatenationScope {\n  /**\r\n   * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\r\n   * @param {ConcatenatedModuleInfo} currentModule the current module info\r\n   */\n  constructor(modulesMap, currentModule) {\n    this._currentModule = currentModule;\n    if (Array.isArray(modulesMap)) {\n      const map = new Map();\n      for (const info of modulesMap) {\n        map.set(info.module, info);\n      }\n      modulesMap = map;\n    }\n    this._modulesMap = modulesMap;\n  }\n\n  /**\r\n   * @param {Module} module the referenced module\r\n   * @returns {boolean} true, when it's in the scope\r\n   */\n  isModuleInScope(module) {\n    return this._modulesMap.has(module);\n  }\n\n  /**\r\n   *\r\n   * @param {string} exportName name of the export\r\n   * @param {string} symbol identifier of the export in source code\r\n   */\n  registerExport(exportName, symbol) {\n    if (!this._currentModule.exportMap) {\n      this._currentModule.exportMap = new Map();\n    }\n    if (!this._currentModule.exportMap.has(exportName)) {\n      this._currentModule.exportMap.set(exportName, symbol);\n    }\n  }\n\n  /**\r\n   *\r\n   * @param {string} exportName name of the export\r\n   * @param {string} expression expression to be used\r\n   */\n  registerRawExport(exportName, expression) {\n    if (!this._currentModule.rawExportMap) {\n      this._currentModule.rawExportMap = new Map();\n    }\n    if (!this._currentModule.rawExportMap.has(exportName)) {\n      this._currentModule.rawExportMap.set(exportName, expression);\n    }\n  }\n\n  /**\r\n   * @param {string} symbol identifier of the export in source code\r\n   */\n  registerNamespaceExport(symbol) {\n    this._currentModule.namespaceExportSymbol = symbol;\n  }\n\n  /**\r\n   *\r\n   * @param {Module} module the referenced module\r\n   * @param {Partial<ModuleReferenceOptions>} options options\r\n   * @returns {string} the reference as identifier\r\n   */\n  createModuleReference(module, _ref) {\n    let {\n      ids = undefined,\n      call = false,\n      directImport = false,\n      asiSafe = false\n    } = _ref;\n    const info = this._modulesMap.get(module);\n    const callFlag = call ? \"_call\" : \"\";\n    const directImportFlag = directImport ? \"_directImport\" : \"\";\n    const asiSafeFlag = asiSafe ? \"_asiSafe1\" : asiSafe === false ? \"_asiSafe0\" : \"\";\n    const exportData = ids ? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\") : \"ns\";\n    // a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n    return `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\n  }\n\n  /**\r\n   * @param {string} name the identifier\r\n   * @returns {boolean} true, when it's an module reference\r\n   */\n  static isModuleReference(name) {\n    return MODULE_REFERENCE_REGEXP.test(name);\n  }\n\n  /**\r\n   * @param {string} name the identifier\r\n   * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\r\n   */\n  static matchModuleReference(name) {\n    const match = MODULE_REFERENCE_REGEXP.exec(name);\n    if (!match) return null;\n    const index = +match[1];\n    const asiSafe = match[5];\n    return {\n      index,\n      ids: match[2] === \"ns\" ? [] : JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n      call: !!match[3],\n      directImport: !!match[4],\n      asiSafe: asiSafe ? asiSafe === \"1\" : undefined\n    };\n  }\n}\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\nmodule.exports = ConcatenationScope;","map":{"version":3,"names":["MODULE_REFERENCE_REGEXP","DEFAULT_EXPORT","NAMESPACE_OBJECT_EXPORT","ConcatenationScope","constructor","modulesMap","currentModule","_currentModule","Array","isArray","map","Map","info","set","module","_modulesMap","isModuleInScope","has","registerExport","exportName","symbol","exportMap","registerRawExport","expression","rawExportMap","registerNamespaceExport","namespaceExportSymbol","createModuleReference","ids","undefined","call","directImport","asiSafe","get","callFlag","directImportFlag","asiSafeFlag","exportData","Buffer","from","JSON","stringify","toString","index","isModuleReference","name","test","matchModuleReference","match","exec","parse","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/ConcatenationScope.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\n/** @typedef {import(\"./Module\")} Module */\r\n\r\nconst MODULE_REFERENCE_REGEXP =\r\n\t/^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\r\n\r\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\r\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\r\n\r\n/**\r\n * @typedef {Object} ExternalModuleInfo\r\n * @property {number} index\r\n * @property {Module} module\r\n */\r\n\r\n/**\r\n * @typedef {Object} ConcatenatedModuleInfo\r\n * @property {number} index\r\n * @property {Module} module\r\n * @property {Map<string, string>} exportMap mapping from export name to symbol\r\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\r\n * @property {string=} namespaceExportSymbol\r\n */\r\n\r\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\r\n\r\n/**\r\n * @typedef {Object} ModuleReferenceOptions\r\n * @property {string[]} ids the properties/exports of the module\r\n * @property {boolean} call true, when this referenced export is called\r\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\r\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\r\n */\r\n\r\nclass ConcatenationScope {\r\n\t/**\r\n\t * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\r\n\t * @param {ConcatenatedModuleInfo} currentModule the current module info\r\n\t */\r\n\tconstructor(modulesMap, currentModule) {\r\n\t\tthis._currentModule = currentModule;\r\n\t\tif (Array.isArray(modulesMap)) {\r\n\t\t\tconst map = new Map();\r\n\t\t\tfor (const info of modulesMap) {\r\n\t\t\t\tmap.set(info.module, info);\r\n\t\t\t}\r\n\t\t\tmodulesMap = map;\r\n\t\t}\r\n\t\tthis._modulesMap = modulesMap;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the referenced module\r\n\t * @returns {boolean} true, when it's in the scope\r\n\t */\r\n\tisModuleInScope(module) {\r\n\t\treturn this._modulesMap.has(module);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {string} exportName name of the export\r\n\t * @param {string} symbol identifier of the export in source code\r\n\t */\r\n\tregisterExport(exportName, symbol) {\r\n\t\tif (!this._currentModule.exportMap) {\r\n\t\t\tthis._currentModule.exportMap = new Map();\r\n\t\t}\r\n\t\tif (!this._currentModule.exportMap.has(exportName)) {\r\n\t\t\tthis._currentModule.exportMap.set(exportName, symbol);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {string} exportName name of the export\r\n\t * @param {string} expression expression to be used\r\n\t */\r\n\tregisterRawExport(exportName, expression) {\r\n\t\tif (!this._currentModule.rawExportMap) {\r\n\t\t\tthis._currentModule.rawExportMap = new Map();\r\n\t\t}\r\n\t\tif (!this._currentModule.rawExportMap.has(exportName)) {\r\n\t\t\tthis._currentModule.rawExportMap.set(exportName, expression);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} symbol identifier of the export in source code\r\n\t */\r\n\tregisterNamespaceExport(symbol) {\r\n\t\tthis._currentModule.namespaceExportSymbol = symbol;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Module} module the referenced module\r\n\t * @param {Partial<ModuleReferenceOptions>} options options\r\n\t * @returns {string} the reference as identifier\r\n\t */\r\n\tcreateModuleReference(\r\n\t\tmodule,\r\n\t\t{ ids = undefined, call = false, directImport = false, asiSafe = false }\r\n\t) {\r\n\t\tconst info = this._modulesMap.get(module);\r\n\t\tconst callFlag = call ? \"_call\" : \"\";\r\n\t\tconst directImportFlag = directImport ? \"_directImport\" : \"\";\r\n\t\tconst asiSafeFlag = asiSafe\r\n\t\t\t? \"_asiSafe1\"\r\n\t\t\t: asiSafe === false\r\n\t\t\t? \"_asiSafe0\"\r\n\t\t\t: \"\";\r\n\t\tconst exportData = ids\r\n\t\t\t? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\")\r\n\t\t\t: \"ns\";\r\n\t\t// a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\r\n\t\treturn `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} name the identifier\r\n\t * @returns {boolean} true, when it's an module reference\r\n\t */\r\n\tstatic isModuleReference(name) {\r\n\t\treturn MODULE_REFERENCE_REGEXP.test(name);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} name the identifier\r\n\t * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\r\n\t */\r\n\tstatic matchModuleReference(name) {\r\n\t\tconst match = MODULE_REFERENCE_REGEXP.exec(name);\r\n\t\tif (!match) return null;\r\n\t\tconst index = +match[1];\r\n\t\tconst asiSafe = match[5];\r\n\t\treturn {\r\n\t\t\tindex,\r\n\t\t\tids:\r\n\t\t\t\tmatch[2] === \"ns\"\r\n\t\t\t\t\t? []\r\n\t\t\t\t\t: JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\r\n\t\t\tcall: !!match[3],\r\n\t\t\tdirectImport: !!match[4],\r\n\t\t\tasiSafe: asiSafe ? asiSafe === \"1\" : undefined\r\n\t\t};\r\n\t}\r\n}\r\n\r\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\r\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\r\n\r\nmodule.exports = ConcatenationScope;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}