{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\r\n * @template T\r\n * @typedef {T | undefined} Cell<T>\r\n */\n\n/**\r\n * @template T\r\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\r\n */\n\n/**\r\n * @template K\r\n * @template V\r\n * @param {[K, InternalCell<V>]} pair the internal cell\r\n * @returns {[K, Cell<V>]} its “safe” representation\r\n */\nconst extractPair = pair => {\n  const key = pair[0];\n  const val = pair[1];\n  if (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n    return [key, undefined];\n  } else {\n    return (/** @type {[K, Cell<V>]} */pair\n    );\n  }\n};\n\n/**\r\n * @template K\r\n * @template V\r\n */\nclass StackedMap {\n  /**\r\n   * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\r\n   */\n  constructor(parentStack) {\n    /** @type {Map<K, InternalCell<V>>} */\n    this.map = new Map();\n    /** @type {Map<K, InternalCell<V>>[]} */\n    this.stack = parentStack === undefined ? [] : parentStack.slice();\n    this.stack.push(this.map);\n  }\n\n  /**\r\n   * @param {K} item the key of the element to add\r\n   * @param {V} value the value of the element to add\r\n   * @returns {void}\r\n   */\n  set(item, value) {\n    this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n  }\n\n  /**\r\n   * @param {K} item the item to delete\r\n   * @returns {void}\r\n   */\n  delete(item) {\n    if (this.stack.length > 1) {\n      this.map.set(item, TOMBSTONE);\n    } else {\n      this.map.delete(item);\n    }\n  }\n\n  /**\r\n   * @param {K} item the item to test\r\n   * @returns {boolean} true if the item exists in this set\r\n   */\n  has(item) {\n    const topValue = this.map.get(item);\n    if (topValue !== undefined) {\n      return topValue !== TOMBSTONE;\n    }\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value !== TOMBSTONE;\n        }\n      }\n      this.map.set(item, TOMBSTONE);\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {K} item the key of the element to return\r\n   * @returns {Cell<V>} the value of the element\r\n   */\n  get(item) {\n    const topValue = this.map.get(item);\n    if (topValue !== undefined) {\n      return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? undefined : topValue;\n    }\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value === TOMBSTONE || value === UNDEFINED_MARKER ? undefined : value;\n        }\n      }\n      this.map.set(item, TOMBSTONE);\n    }\n    return undefined;\n  }\n  _compress() {\n    if (this.stack.length === 1) return;\n    this.map = new Map();\n    for (const data of this.stack) {\n      for (const pair of data) {\n        if (pair[1] === TOMBSTONE) {\n          this.map.delete(pair[0]);\n        } else {\n          this.map.set(pair[0], pair[1]);\n        }\n      }\n    }\n    this.stack = [this.map];\n  }\n  asArray() {\n    this._compress();\n    return Array.from(this.map.keys());\n  }\n  asSet() {\n    this._compress();\n    return new Set(this.map.keys());\n  }\n  asPairArray() {\n    this._compress();\n    return Array.from(this.map.entries(), extractPair);\n  }\n  asMap() {\n    return new Map(this.asPairArray());\n  }\n  get size() {\n    this._compress();\n    return this.map.size;\n  }\n  createChild() {\n    return new StackedMap(this.stack);\n  }\n}\nmodule.exports = StackedMap;","map":{"version":3,"names":["TOMBSTONE","Symbol","UNDEFINED_MARKER","extractPair","pair","key","val","undefined","StackedMap","constructor","parentStack","map","Map","stack","slice","push","set","item","value","delete","length","has","topValue","get","i","_compress","data","asArray","Array","from","keys","asSet","Set","asPairArray","entries","asMap","size","createChild","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/util/StackedMap.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst TOMBSTONE = Symbol(\"tombstone\");\r\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\r\n\r\n/**\r\n * @template T\r\n * @typedef {T | undefined} Cell<T>\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\r\n */\r\n\r\n/**\r\n * @template K\r\n * @template V\r\n * @param {[K, InternalCell<V>]} pair the internal cell\r\n * @returns {[K, Cell<V>]} its “safe” representation\r\n */\r\nconst extractPair = pair => {\r\n\tconst key = pair[0];\r\n\tconst val = pair[1];\r\n\tif (val === UNDEFINED_MARKER || val === TOMBSTONE) {\r\n\t\treturn [key, undefined];\r\n\t} else {\r\n\t\treturn /** @type {[K, Cell<V>]} */ (pair);\r\n\t}\r\n};\r\n\r\n/**\r\n * @template K\r\n * @template V\r\n */\r\nclass StackedMap {\r\n\t/**\r\n\t * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\r\n\t */\r\n\tconstructor(parentStack) {\r\n\t\t/** @type {Map<K, InternalCell<V>>} */\r\n\t\tthis.map = new Map();\r\n\t\t/** @type {Map<K, InternalCell<V>>[]} */\r\n\t\tthis.stack = parentStack === undefined ? [] : parentStack.slice();\r\n\t\tthis.stack.push(this.map);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {K} item the key of the element to add\r\n\t * @param {V} value the value of the element to add\r\n\t * @returns {void}\r\n\t */\r\n\tset(item, value) {\r\n\t\tthis.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {K} item the item to delete\r\n\t * @returns {void}\r\n\t */\r\n\tdelete(item) {\r\n\t\tif (this.stack.length > 1) {\r\n\t\t\tthis.map.set(item, TOMBSTONE);\r\n\t\t} else {\r\n\t\t\tthis.map.delete(item);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {K} item the item to test\r\n\t * @returns {boolean} true if the item exists in this set\r\n\t */\r\n\thas(item) {\r\n\t\tconst topValue = this.map.get(item);\r\n\t\tif (topValue !== undefined) {\r\n\t\t\treturn topValue !== TOMBSTONE;\r\n\t\t}\r\n\t\tif (this.stack.length > 1) {\r\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\r\n\t\t\t\tconst value = this.stack[i].get(item);\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tthis.map.set(item, value);\r\n\t\t\t\t\treturn value !== TOMBSTONE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.map.set(item, TOMBSTONE);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {K} item the key of the element to return\r\n\t * @returns {Cell<V>} the value of the element\r\n\t */\r\n\tget(item) {\r\n\t\tconst topValue = this.map.get(item);\r\n\t\tif (topValue !== undefined) {\r\n\t\t\treturn topValue === TOMBSTONE || topValue === UNDEFINED_MARKER\r\n\t\t\t\t? undefined\r\n\t\t\t\t: topValue;\r\n\t\t}\r\n\t\tif (this.stack.length > 1) {\r\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\r\n\t\t\t\tconst value = this.stack[i].get(item);\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tthis.map.set(item, value);\r\n\t\t\t\t\treturn value === TOMBSTONE || value === UNDEFINED_MARKER\r\n\t\t\t\t\t\t? undefined\r\n\t\t\t\t\t\t: value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.map.set(item, TOMBSTONE);\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t_compress() {\r\n\t\tif (this.stack.length === 1) return;\r\n\t\tthis.map = new Map();\r\n\t\tfor (const data of this.stack) {\r\n\t\t\tfor (const pair of data) {\r\n\t\t\t\tif (pair[1] === TOMBSTONE) {\r\n\t\t\t\t\tthis.map.delete(pair[0]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.map.set(pair[0], pair[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.stack = [this.map];\r\n\t}\r\n\r\n\tasArray() {\r\n\t\tthis._compress();\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\tasSet() {\r\n\t\tthis._compress();\r\n\t\treturn new Set(this.map.keys());\r\n\t}\r\n\r\n\tasPairArray() {\r\n\t\tthis._compress();\r\n\t\treturn Array.from(this.map.entries(), extractPair);\r\n\t}\r\n\r\n\tasMap() {\r\n\t\treturn new Map(this.asPairArray());\r\n\t}\r\n\r\n\tget size() {\r\n\t\tthis._compress();\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n\tcreateChild() {\r\n\t\treturn new StackedMap(this.stack);\r\n\t}\r\n}\r\n\r\nmodule.exports = StackedMap;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}