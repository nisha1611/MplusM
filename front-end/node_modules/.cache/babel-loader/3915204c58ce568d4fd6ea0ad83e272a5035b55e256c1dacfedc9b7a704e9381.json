{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\n/** @type {WeakMap<object, WeakMap<object, object>>} */\nconst mergeCache = new WeakMap();\n/** @type {WeakMap<object, Map<string, Map<string|number|boolean, object>>>} */\nconst setPropertyCache = new WeakMap();\nconst DELETE = Symbol(\"DELETE\");\nconst DYNAMIC_INFO = Symbol(\"cleverMerge dynamic info\");\n\n/**\r\n * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.\r\n * @template T\r\n * @template O\r\n * @example\r\n * // performs cleverMerge(first, second), stores the result in WeakMap and returns result\r\n * cachedCleverMerge({a: 1}, {a: 2})\r\n * {a: 2}\r\n *  // when same arguments passed, gets the result from WeakMap and returns it.\r\n * cachedCleverMerge({a: 1}, {a: 2})\r\n * {a: 2}\r\n * @param {T} first first object\r\n * @param {O} second second object\r\n * @returns {T & O | T | O} merged object of first and second object\r\n */\nconst cachedCleverMerge = (first, second) => {\n  if (second === undefined) return first;\n  if (first === undefined) return second;\n  if (typeof second !== \"object\" || second === null) return second;\n  if (typeof first !== \"object\" || first === null) return first;\n  let innerCache = mergeCache.get(first);\n  if (innerCache === undefined) {\n    innerCache = new WeakMap();\n    mergeCache.set(first, innerCache);\n  }\n  const prevMerge = innerCache.get(second);\n  if (prevMerge !== undefined) return prevMerge;\n  const newMerge = _cleverMerge(first, second, true);\n  innerCache.set(second, newMerge);\n  return newMerge;\n};\n\n/**\r\n * @template T\r\n * @param {Partial<T>} obj object\r\n * @param {string} property property\r\n * @param {string|number|boolean} value assignment value\r\n * @returns {T} new object\r\n */\nconst cachedSetProperty = (obj, property, value) => {\n  let mapByProperty = setPropertyCache.get(obj);\n  if (mapByProperty === undefined) {\n    mapByProperty = new Map();\n    setPropertyCache.set(obj, mapByProperty);\n  }\n  let mapByValue = mapByProperty.get(property);\n  if (mapByValue === undefined) {\n    mapByValue = new Map();\n    mapByProperty.set(property, mapByValue);\n  }\n  let result = mapByValue.get(value);\n  if (result) return result;\n  result = {\n    ...obj,\n    [property]: value\n  };\n  mapByValue.set(value, result);\n  return result;\n};\n\n/**\r\n * @typedef {Object} ObjectParsedPropertyEntry\r\n * @property {any | undefined} base base value\r\n * @property {string | undefined} byProperty the name of the selector property\r\n * @property {Map<string, any>} byValues value depending on selector property, merged with base\r\n */\n\n/**\r\n * @typedef {Object} ParsedObject\r\n * @property {Map<string, ObjectParsedPropertyEntry>} static static properties (key is property name)\r\n * @property {{ byProperty: string, fn: Function } | undefined} dynamic dynamic part\r\n */\n\n/** @type {WeakMap<object, ParsedObject>} */\nconst parseCache = new WeakMap();\n\n/**\r\n * @param {object} obj the object\r\n * @returns {ParsedObject} parsed object\r\n */\nconst cachedParseObject = obj => {\n  const entry = parseCache.get(obj);\n  if (entry !== undefined) return entry;\n  const result = parseObject(obj);\n  parseCache.set(obj, result);\n  return result;\n};\n\n/**\r\n * @param {object} obj the object\r\n * @returns {ParsedObject} parsed object\r\n */\nconst parseObject = obj => {\n  const info = new Map();\n  let dynamicInfo;\n  const getInfo = p => {\n    const entry = info.get(p);\n    if (entry !== undefined) return entry;\n    const newEntry = {\n      base: undefined,\n      byProperty: undefined,\n      byValues: undefined\n    };\n    info.set(p, newEntry);\n    return newEntry;\n  };\n  for (const key of Object.keys(obj)) {\n    if (key.startsWith(\"by\")) {\n      const byProperty = key;\n      const byObj = obj[byProperty];\n      if (typeof byObj === \"object\") {\n        for (const byValue of Object.keys(byObj)) {\n          const obj = byObj[byValue];\n          for (const key of Object.keys(obj)) {\n            const entry = getInfo(key);\n            if (entry.byProperty === undefined) {\n              entry.byProperty = byProperty;\n              entry.byValues = new Map();\n            } else if (entry.byProperty !== byProperty) {\n              throw new Error(`${byProperty} and ${entry.byProperty} for a single property is not supported`);\n            }\n            entry.byValues.set(byValue, obj[key]);\n            if (byValue === \"default\") {\n              for (const otherByValue of Object.keys(byObj)) {\n                if (!entry.byValues.has(otherByValue)) entry.byValues.set(otherByValue, undefined);\n              }\n            }\n          }\n        }\n      } else if (typeof byObj === \"function\") {\n        if (dynamicInfo === undefined) {\n          dynamicInfo = {\n            byProperty: key,\n            fn: byObj\n          };\n        } else {\n          throw new Error(`${key} and ${dynamicInfo.byProperty} when both are functions is not supported`);\n        }\n      } else {\n        const entry = getInfo(key);\n        entry.base = obj[key];\n      }\n    } else {\n      const entry = getInfo(key);\n      entry.base = obj[key];\n    }\n  }\n  return {\n    static: info,\n    dynamic: dynamicInfo\n  };\n};\n\n/**\r\n * @param {Map<string, ObjectParsedPropertyEntry>} info static properties (key is property name)\r\n * @param {{ byProperty: string, fn: Function } | undefined} dynamicInfo dynamic part\r\n * @returns {object} the object\r\n */\nconst serializeObject = (info, dynamicInfo) => {\n  const obj = {};\n  // Setup byProperty structure\n  for (const entry of info.values()) {\n    if (entry.byProperty !== undefined) {\n      const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};\n      for (const byValue of entry.byValues.keys()) {\n        byObj[byValue] = byObj[byValue] || {};\n      }\n    }\n  }\n  for (const [key, entry] of info) {\n    if (entry.base !== undefined) {\n      obj[key] = entry.base;\n    }\n    // Fill byProperty structure\n    if (entry.byProperty !== undefined) {\n      const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};\n      for (const byValue of Object.keys(byObj)) {\n        const value = getFromByValues(entry.byValues, byValue);\n        if (value !== undefined) byObj[byValue][key] = value;\n      }\n    }\n  }\n  if (dynamicInfo !== undefined) {\n    obj[dynamicInfo.byProperty] = dynamicInfo.fn;\n  }\n  return obj;\n};\nconst VALUE_TYPE_UNDEFINED = 0;\nconst VALUE_TYPE_ATOM = 1;\nconst VALUE_TYPE_ARRAY_EXTEND = 2;\nconst VALUE_TYPE_OBJECT = 3;\nconst VALUE_TYPE_DELETE = 4;\n\n/**\r\n * @param {any} value a single value\r\n * @returns {VALUE_TYPE_UNDEFINED | VALUE_TYPE_ATOM | VALUE_TYPE_ARRAY_EXTEND | VALUE_TYPE_OBJECT | VALUE_TYPE_DELETE} value type\r\n */\nconst getValueType = value => {\n  if (value === undefined) {\n    return VALUE_TYPE_UNDEFINED;\n  } else if (value === DELETE) {\n    return VALUE_TYPE_DELETE;\n  } else if (Array.isArray(value)) {\n    if (value.lastIndexOf(\"...\") !== -1) return VALUE_TYPE_ARRAY_EXTEND;\n    return VALUE_TYPE_ATOM;\n  } else if (typeof value === \"object\" && value !== null && (!value.constructor || value.constructor === Object)) {\n    return VALUE_TYPE_OBJECT;\n  }\n  return VALUE_TYPE_ATOM;\n};\n\n/**\r\n * Merges two objects. Objects are deeply clever merged.\r\n * Arrays might reference the old value with \"...\".\r\n * Non-object values take preference over object values.\r\n * @template T\r\n * @template O\r\n * @param {T} first first object\r\n * @param {O} second second object\r\n * @returns {T & O | T | O} merged object of first and second object\r\n */\nconst cleverMerge = (first, second) => {\n  if (second === undefined) return first;\n  if (first === undefined) return second;\n  if (typeof second !== \"object\" || second === null) return second;\n  if (typeof first !== \"object\" || first === null) return first;\n  return _cleverMerge(first, second, false);\n};\n\n/**\r\n * Merges two objects. Objects are deeply clever merged.\r\n * @param {object} first first object\r\n * @param {object} second second object\r\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\r\n * @returns {object} merged object of first and second object\r\n */\nconst _cleverMerge = function (first, second) {\n  let internalCaching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const firstObject = internalCaching ? cachedParseObject(first) : parseObject(first);\n  const {\n    static: firstInfo,\n    dynamic: firstDynamicInfo\n  } = firstObject;\n\n  // If the first argument has a dynamic part we modify the dynamic part to merge the second argument\n  if (firstDynamicInfo !== undefined) {\n    let {\n      byProperty,\n      fn\n    } = firstDynamicInfo;\n    const fnInfo = fn[DYNAMIC_INFO];\n    if (fnInfo) {\n      second = internalCaching ? cachedCleverMerge(fnInfo[1], second) : cleverMerge(fnInfo[1], second);\n      fn = fnInfo[0];\n    }\n    const newFn = function () {\n      const fnResult = fn(...arguments);\n      return internalCaching ? cachedCleverMerge(fnResult, second) : cleverMerge(fnResult, second);\n    };\n    newFn[DYNAMIC_INFO] = [fn, second];\n    return serializeObject(firstObject.static, {\n      byProperty,\n      fn: newFn\n    });\n  }\n\n  // If the first part is static only, we merge the static parts and keep the dynamic part of the second argument\n  const secondObject = internalCaching ? cachedParseObject(second) : parseObject(second);\n  const {\n    static: secondInfo,\n    dynamic: secondDynamicInfo\n  } = secondObject;\n  /** @type {Map<string, ObjectParsedPropertyEntry>} */\n  const resultInfo = new Map();\n  for (const [key, firstEntry] of firstInfo) {\n    const secondEntry = secondInfo.get(key);\n    const entry = secondEntry !== undefined ? mergeEntries(firstEntry, secondEntry, internalCaching) : firstEntry;\n    resultInfo.set(key, entry);\n  }\n  for (const [key, secondEntry] of secondInfo) {\n    if (!firstInfo.has(key)) {\n      resultInfo.set(key, secondEntry);\n    }\n  }\n  return serializeObject(resultInfo, secondDynamicInfo);\n};\n\n/**\r\n * @param {ObjectParsedPropertyEntry} firstEntry a\r\n * @param {ObjectParsedPropertyEntry} secondEntry b\r\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\r\n * @returns {ObjectParsedPropertyEntry} new entry\r\n */\nconst mergeEntries = (firstEntry, secondEntry, internalCaching) => {\n  switch (getValueType(secondEntry.base)) {\n    case VALUE_TYPE_ATOM:\n    case VALUE_TYPE_DELETE:\n      // No need to consider firstEntry at all\n      // second value override everything\n      // = second.base + second.byProperty\n      return secondEntry;\n    case VALUE_TYPE_UNDEFINED:\n      if (!firstEntry.byProperty) {\n        // = first.base + second.byProperty\n        return {\n          base: firstEntry.base,\n          byProperty: secondEntry.byProperty,\n          byValues: secondEntry.byValues\n        };\n      } else if (firstEntry.byProperty !== secondEntry.byProperty) {\n        throw new Error(`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`);\n      } else {\n        // = first.base + (first.byProperty + second.byProperty)\n        // need to merge first and second byValues\n        const newByValues = new Map(firstEntry.byValues);\n        for (const [key, value] of secondEntry.byValues) {\n          const firstValue = getFromByValues(firstEntry.byValues, key);\n          newByValues.set(key, mergeSingleValue(firstValue, value, internalCaching));\n        }\n        return {\n          base: firstEntry.base,\n          byProperty: firstEntry.byProperty,\n          byValues: newByValues\n        };\n      }\n    default:\n      {\n        if (!firstEntry.byProperty) {\n          // The simple case\n          // = (first.base + second.base) + second.byProperty\n          return {\n            base: mergeSingleValue(firstEntry.base, secondEntry.base, internalCaching),\n            byProperty: secondEntry.byProperty,\n            byValues: secondEntry.byValues\n          };\n        }\n        let newBase;\n        const intermediateByValues = new Map(firstEntry.byValues);\n        for (const [key, value] of intermediateByValues) {\n          intermediateByValues.set(key, mergeSingleValue(value, secondEntry.base, internalCaching));\n        }\n        if (Array.from(firstEntry.byValues.values()).every(value => {\n          const type = getValueType(value);\n          return type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;\n        })) {\n          // = (first.base + second.base) + ((first.byProperty + second.base) + second.byProperty)\n          newBase = mergeSingleValue(firstEntry.base, secondEntry.base, internalCaching);\n        } else {\n          // = first.base + ((first.byProperty (+default) + second.base) + second.byProperty)\n          newBase = firstEntry.base;\n          if (!intermediateByValues.has(\"default\")) intermediateByValues.set(\"default\", secondEntry.base);\n        }\n        if (!secondEntry.byProperty) {\n          // = first.base + (first.byProperty + second.base)\n          return {\n            base: newBase,\n            byProperty: firstEntry.byProperty,\n            byValues: intermediateByValues\n          };\n        } else if (firstEntry.byProperty !== secondEntry.byProperty) {\n          throw new Error(`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`);\n        }\n        const newByValues = new Map(intermediateByValues);\n        for (const [key, value] of secondEntry.byValues) {\n          const firstValue = getFromByValues(intermediateByValues, key);\n          newByValues.set(key, mergeSingleValue(firstValue, value, internalCaching));\n        }\n        return {\n          base: newBase,\n          byProperty: firstEntry.byProperty,\n          byValues: newByValues\n        };\n      }\n  }\n};\n\n/**\r\n * @param {Map<string, any>} byValues all values\r\n * @param {string} key value of the selector\r\n * @returns {any | undefined} value\r\n */\nconst getFromByValues = (byValues, key) => {\n  if (key !== \"default\" && byValues.has(key)) {\n    return byValues.get(key);\n  }\n  return byValues.get(\"default\");\n};\n\n/**\r\n * @param {any} a value\r\n * @param {any} b value\r\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\r\n * @returns {any} value\r\n */\nconst mergeSingleValue = (a, b, internalCaching) => {\n  const bType = getValueType(b);\n  const aType = getValueType(a);\n  switch (bType) {\n    case VALUE_TYPE_DELETE:\n    case VALUE_TYPE_ATOM:\n      return b;\n    case VALUE_TYPE_OBJECT:\n      {\n        return aType !== VALUE_TYPE_OBJECT ? b : internalCaching ? cachedCleverMerge(a, b) : cleverMerge(a, b);\n      }\n    case VALUE_TYPE_UNDEFINED:\n      return a;\n    case VALUE_TYPE_ARRAY_EXTEND:\n      switch (aType !== VALUE_TYPE_ATOM ? aType : Array.isArray(a) ? VALUE_TYPE_ARRAY_EXTEND : VALUE_TYPE_OBJECT) {\n        case VALUE_TYPE_UNDEFINED:\n          return b;\n        case VALUE_TYPE_DELETE:\n          return b.filter(item => item !== \"...\");\n        case VALUE_TYPE_ARRAY_EXTEND:\n          {\n            const newArray = [];\n            for (const item of b) {\n              if (item === \"...\") {\n                for (const item of a) {\n                  newArray.push(item);\n                }\n              } else {\n                newArray.push(item);\n              }\n            }\n            return newArray;\n          }\n        case VALUE_TYPE_OBJECT:\n          return b.map(item => item === \"...\" ? a : item);\n        default:\n          throw new Error(\"Not implemented\");\n      }\n    default:\n      throw new Error(\"Not implemented\");\n  }\n};\n\n/**\r\n * @template T\r\n * @param {T} obj the object\r\n * @returns {T} the object without operations like \"...\" or DELETE\r\n */\nconst removeOperations = obj => {\n  const newObj = /** @type {T} */{};\n  for (const key of Object.keys(obj)) {\n    const value = obj[key];\n    const type = getValueType(value);\n    switch (type) {\n      case VALUE_TYPE_UNDEFINED:\n      case VALUE_TYPE_DELETE:\n        break;\n      case VALUE_TYPE_OBJECT:\n        newObj[key] = removeOperations(value);\n        break;\n      case VALUE_TYPE_ARRAY_EXTEND:\n        newObj[key] = value.filter(i => i !== \"...\");\n        break;\n      default:\n        newObj[key] = value;\n        break;\n    }\n  }\n  return newObj;\n};\n\n/**\r\n * @template T\r\n * @template {string} P\r\n * @param {T} obj the object\r\n * @param {P} byProperty the by description\r\n * @param  {...any} values values\r\n * @returns {Omit<T, P>} object with merged byProperty\r\n */\nconst resolveByProperty = function (obj, byProperty) {\n  if (typeof obj !== \"object\" || obj === null || !(byProperty in obj)) {\n    return obj;\n  }\n  const {\n    [byProperty]: _byValue,\n    ..._remaining\n  } = /** @type {object} */obj;\n  const remaining = /** @type {T} */_remaining;\n  const byValue = /** @type {Record<string, T> | function(...any[]): T} */\n  _byValue;\n  for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    values[_key - 2] = arguments[_key];\n  }\n  if (typeof byValue === \"object\") {\n    const key = values[0];\n    if (key in byValue) {\n      return cachedCleverMerge(remaining, byValue[key]);\n    } else if (\"default\" in byValue) {\n      return cachedCleverMerge(remaining, byValue.default);\n    } else {\n      return (/** @type {T} */remaining\n      );\n    }\n  } else if (typeof byValue === \"function\") {\n    const result = byValue.apply(null, values);\n    return cachedCleverMerge(remaining, resolveByProperty(result, byProperty, ...values));\n  }\n};\nexports.cachedSetProperty = cachedSetProperty;\nexports.cachedCleverMerge = cachedCleverMerge;\nexports.cleverMerge = cleverMerge;\nexports.resolveByProperty = resolveByProperty;\nexports.removeOperations = removeOperations;\nexports.DELETE = DELETE;","map":{"version":3,"names":["mergeCache","WeakMap","setPropertyCache","DELETE","Symbol","DYNAMIC_INFO","cachedCleverMerge","first","second","undefined","innerCache","get","set","prevMerge","newMerge","_cleverMerge","cachedSetProperty","obj","property","value","mapByProperty","Map","mapByValue","result","parseCache","cachedParseObject","entry","parseObject","info","dynamicInfo","getInfo","p","newEntry","base","byProperty","byValues","key","Object","keys","startsWith","byObj","byValue","Error","otherByValue","has","fn","static","dynamic","serializeObject","values","getFromByValues","VALUE_TYPE_UNDEFINED","VALUE_TYPE_ATOM","VALUE_TYPE_ARRAY_EXTEND","VALUE_TYPE_OBJECT","VALUE_TYPE_DELETE","getValueType","Array","isArray","lastIndexOf","constructor","cleverMerge","internalCaching","firstObject","firstInfo","firstDynamicInfo","fnInfo","newFn","fnResult","secondObject","secondInfo","secondDynamicInfo","resultInfo","firstEntry","secondEntry","mergeEntries","newByValues","firstValue","mergeSingleValue","newBase","intermediateByValues","from","every","type","a","b","bType","aType","filter","item","newArray","push","map","removeOperations","newObj","i","resolveByProperty","_byValue","_remaining","remaining","default","apply","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/util/cleverMerge.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\n/** @type {WeakMap<object, WeakMap<object, object>>} */\r\nconst mergeCache = new WeakMap();\r\n/** @type {WeakMap<object, Map<string, Map<string|number|boolean, object>>>} */\r\nconst setPropertyCache = new WeakMap();\r\nconst DELETE = Symbol(\"DELETE\");\r\nconst DYNAMIC_INFO = Symbol(\"cleverMerge dynamic info\");\r\n\r\n/**\r\n * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.\r\n * @template T\r\n * @template O\r\n * @example\r\n * // performs cleverMerge(first, second), stores the result in WeakMap and returns result\r\n * cachedCleverMerge({a: 1}, {a: 2})\r\n * {a: 2}\r\n *  // when same arguments passed, gets the result from WeakMap and returns it.\r\n * cachedCleverMerge({a: 1}, {a: 2})\r\n * {a: 2}\r\n * @param {T} first first object\r\n * @param {O} second second object\r\n * @returns {T & O | T | O} merged object of first and second object\r\n */\r\nconst cachedCleverMerge = (first, second) => {\r\n\tif (second === undefined) return first;\r\n\tif (first === undefined) return second;\r\n\tif (typeof second !== \"object\" || second === null) return second;\r\n\tif (typeof first !== \"object\" || first === null) return first;\r\n\r\n\tlet innerCache = mergeCache.get(first);\r\n\tif (innerCache === undefined) {\r\n\t\tinnerCache = new WeakMap();\r\n\t\tmergeCache.set(first, innerCache);\r\n\t}\r\n\tconst prevMerge = innerCache.get(second);\r\n\tif (prevMerge !== undefined) return prevMerge;\r\n\tconst newMerge = _cleverMerge(first, second, true);\r\n\tinnerCache.set(second, newMerge);\r\n\treturn newMerge;\r\n};\r\n\r\n/**\r\n * @template T\r\n * @param {Partial<T>} obj object\r\n * @param {string} property property\r\n * @param {string|number|boolean} value assignment value\r\n * @returns {T} new object\r\n */\r\nconst cachedSetProperty = (obj, property, value) => {\r\n\tlet mapByProperty = setPropertyCache.get(obj);\r\n\r\n\tif (mapByProperty === undefined) {\r\n\t\tmapByProperty = new Map();\r\n\t\tsetPropertyCache.set(obj, mapByProperty);\r\n\t}\r\n\r\n\tlet mapByValue = mapByProperty.get(property);\r\n\r\n\tif (mapByValue === undefined) {\r\n\t\tmapByValue = new Map();\r\n\t\tmapByProperty.set(property, mapByValue);\r\n\t}\r\n\r\n\tlet result = mapByValue.get(value);\r\n\r\n\tif (result) return result;\r\n\r\n\tresult = {\r\n\t\t...obj,\r\n\t\t[property]: value\r\n\t};\r\n\tmapByValue.set(value, result);\r\n\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * @typedef {Object} ObjectParsedPropertyEntry\r\n * @property {any | undefined} base base value\r\n * @property {string | undefined} byProperty the name of the selector property\r\n * @property {Map<string, any>} byValues value depending on selector property, merged with base\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsedObject\r\n * @property {Map<string, ObjectParsedPropertyEntry>} static static properties (key is property name)\r\n * @property {{ byProperty: string, fn: Function } | undefined} dynamic dynamic part\r\n */\r\n\r\n/** @type {WeakMap<object, ParsedObject>} */\r\nconst parseCache = new WeakMap();\r\n\r\n/**\r\n * @param {object} obj the object\r\n * @returns {ParsedObject} parsed object\r\n */\r\nconst cachedParseObject = obj => {\r\n\tconst entry = parseCache.get(obj);\r\n\tif (entry !== undefined) return entry;\r\n\tconst result = parseObject(obj);\r\n\tparseCache.set(obj, result);\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * @param {object} obj the object\r\n * @returns {ParsedObject} parsed object\r\n */\r\nconst parseObject = obj => {\r\n\tconst info = new Map();\r\n\tlet dynamicInfo;\r\n\tconst getInfo = p => {\r\n\t\tconst entry = info.get(p);\r\n\t\tif (entry !== undefined) return entry;\r\n\t\tconst newEntry = {\r\n\t\t\tbase: undefined,\r\n\t\t\tbyProperty: undefined,\r\n\t\t\tbyValues: undefined\r\n\t\t};\r\n\t\tinfo.set(p, newEntry);\r\n\t\treturn newEntry;\r\n\t};\r\n\tfor (const key of Object.keys(obj)) {\r\n\t\tif (key.startsWith(\"by\")) {\r\n\t\t\tconst byProperty = key;\r\n\t\t\tconst byObj = obj[byProperty];\r\n\t\t\tif (typeof byObj === \"object\") {\r\n\t\t\t\tfor (const byValue of Object.keys(byObj)) {\r\n\t\t\t\t\tconst obj = byObj[byValue];\r\n\t\t\t\t\tfor (const key of Object.keys(obj)) {\r\n\t\t\t\t\t\tconst entry = getInfo(key);\r\n\t\t\t\t\t\tif (entry.byProperty === undefined) {\r\n\t\t\t\t\t\t\tentry.byProperty = byProperty;\r\n\t\t\t\t\t\t\tentry.byValues = new Map();\r\n\t\t\t\t\t\t} else if (entry.byProperty !== byProperty) {\r\n\t\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\t`${byProperty} and ${entry.byProperty} for a single property is not supported`\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tentry.byValues.set(byValue, obj[key]);\r\n\t\t\t\t\t\tif (byValue === \"default\") {\r\n\t\t\t\t\t\t\tfor (const otherByValue of Object.keys(byObj)) {\r\n\t\t\t\t\t\t\t\tif (!entry.byValues.has(otherByValue))\r\n\t\t\t\t\t\t\t\t\tentry.byValues.set(otherByValue, undefined);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof byObj === \"function\") {\r\n\t\t\t\tif (dynamicInfo === undefined) {\r\n\t\t\t\t\tdynamicInfo = {\r\n\t\t\t\t\t\tbyProperty: key,\r\n\t\t\t\t\t\tfn: byObj\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`${key} and ${dynamicInfo.byProperty} when both are functions is not supported`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst entry = getInfo(key);\r\n\t\t\t\tentry.base = obj[key];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconst entry = getInfo(key);\r\n\t\t\tentry.base = obj[key];\r\n\t\t}\r\n\t}\r\n\treturn {\r\n\t\tstatic: info,\r\n\t\tdynamic: dynamicInfo\r\n\t};\r\n};\r\n\r\n/**\r\n * @param {Map<string, ObjectParsedPropertyEntry>} info static properties (key is property name)\r\n * @param {{ byProperty: string, fn: Function } | undefined} dynamicInfo dynamic part\r\n * @returns {object} the object\r\n */\r\nconst serializeObject = (info, dynamicInfo) => {\r\n\tconst obj = {};\r\n\t// Setup byProperty structure\r\n\tfor (const entry of info.values()) {\r\n\t\tif (entry.byProperty !== undefined) {\r\n\t\t\tconst byObj = (obj[entry.byProperty] = obj[entry.byProperty] || {});\r\n\t\t\tfor (const byValue of entry.byValues.keys()) {\r\n\t\t\t\tbyObj[byValue] = byObj[byValue] || {};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (const [key, entry] of info) {\r\n\t\tif (entry.base !== undefined) {\r\n\t\t\tobj[key] = entry.base;\r\n\t\t}\r\n\t\t// Fill byProperty structure\r\n\t\tif (entry.byProperty !== undefined) {\r\n\t\t\tconst byObj = (obj[entry.byProperty] = obj[entry.byProperty] || {});\r\n\t\t\tfor (const byValue of Object.keys(byObj)) {\r\n\t\t\t\tconst value = getFromByValues(entry.byValues, byValue);\r\n\t\t\t\tif (value !== undefined) byObj[byValue][key] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (dynamicInfo !== undefined) {\r\n\t\tobj[dynamicInfo.byProperty] = dynamicInfo.fn;\r\n\t}\r\n\treturn obj;\r\n};\r\n\r\nconst VALUE_TYPE_UNDEFINED = 0;\r\nconst VALUE_TYPE_ATOM = 1;\r\nconst VALUE_TYPE_ARRAY_EXTEND = 2;\r\nconst VALUE_TYPE_OBJECT = 3;\r\nconst VALUE_TYPE_DELETE = 4;\r\n\r\n/**\r\n * @param {any} value a single value\r\n * @returns {VALUE_TYPE_UNDEFINED | VALUE_TYPE_ATOM | VALUE_TYPE_ARRAY_EXTEND | VALUE_TYPE_OBJECT | VALUE_TYPE_DELETE} value type\r\n */\r\nconst getValueType = value => {\r\n\tif (value === undefined) {\r\n\t\treturn VALUE_TYPE_UNDEFINED;\r\n\t} else if (value === DELETE) {\r\n\t\treturn VALUE_TYPE_DELETE;\r\n\t} else if (Array.isArray(value)) {\r\n\t\tif (value.lastIndexOf(\"...\") !== -1) return VALUE_TYPE_ARRAY_EXTEND;\r\n\t\treturn VALUE_TYPE_ATOM;\r\n\t} else if (\r\n\t\ttypeof value === \"object\" &&\r\n\t\tvalue !== null &&\r\n\t\t(!value.constructor || value.constructor === Object)\r\n\t) {\r\n\t\treturn VALUE_TYPE_OBJECT;\r\n\t}\r\n\treturn VALUE_TYPE_ATOM;\r\n};\r\n\r\n/**\r\n * Merges two objects. Objects are deeply clever merged.\r\n * Arrays might reference the old value with \"...\".\r\n * Non-object values take preference over object values.\r\n * @template T\r\n * @template O\r\n * @param {T} first first object\r\n * @param {O} second second object\r\n * @returns {T & O | T | O} merged object of first and second object\r\n */\r\nconst cleverMerge = (first, second) => {\r\n\tif (second === undefined) return first;\r\n\tif (first === undefined) return second;\r\n\tif (typeof second !== \"object\" || second === null) return second;\r\n\tif (typeof first !== \"object\" || first === null) return first;\r\n\r\n\treturn _cleverMerge(first, second, false);\r\n};\r\n\r\n/**\r\n * Merges two objects. Objects are deeply clever merged.\r\n * @param {object} first first object\r\n * @param {object} second second object\r\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\r\n * @returns {object} merged object of first and second object\r\n */\r\nconst _cleverMerge = (first, second, internalCaching = false) => {\r\n\tconst firstObject = internalCaching\r\n\t\t? cachedParseObject(first)\r\n\t\t: parseObject(first);\r\n\tconst { static: firstInfo, dynamic: firstDynamicInfo } = firstObject;\r\n\r\n\t// If the first argument has a dynamic part we modify the dynamic part to merge the second argument\r\n\tif (firstDynamicInfo !== undefined) {\r\n\t\tlet { byProperty, fn } = firstDynamicInfo;\r\n\t\tconst fnInfo = fn[DYNAMIC_INFO];\r\n\t\tif (fnInfo) {\r\n\t\t\tsecond = internalCaching\r\n\t\t\t\t? cachedCleverMerge(fnInfo[1], second)\r\n\t\t\t\t: cleverMerge(fnInfo[1], second);\r\n\t\t\tfn = fnInfo[0];\r\n\t\t}\r\n\t\tconst newFn = (...args) => {\r\n\t\t\tconst fnResult = fn(...args);\r\n\t\t\treturn internalCaching\r\n\t\t\t\t? cachedCleverMerge(fnResult, second)\r\n\t\t\t\t: cleverMerge(fnResult, second);\r\n\t\t};\r\n\t\tnewFn[DYNAMIC_INFO] = [fn, second];\r\n\t\treturn serializeObject(firstObject.static, { byProperty, fn: newFn });\r\n\t}\r\n\r\n\t// If the first part is static only, we merge the static parts and keep the dynamic part of the second argument\r\n\tconst secondObject = internalCaching\r\n\t\t? cachedParseObject(second)\r\n\t\t: parseObject(second);\r\n\tconst { static: secondInfo, dynamic: secondDynamicInfo } = secondObject;\r\n\t/** @type {Map<string, ObjectParsedPropertyEntry>} */\r\n\tconst resultInfo = new Map();\r\n\tfor (const [key, firstEntry] of firstInfo) {\r\n\t\tconst secondEntry = secondInfo.get(key);\r\n\t\tconst entry =\r\n\t\t\tsecondEntry !== undefined\r\n\t\t\t\t? mergeEntries(firstEntry, secondEntry, internalCaching)\r\n\t\t\t\t: firstEntry;\r\n\t\tresultInfo.set(key, entry);\r\n\t}\r\n\tfor (const [key, secondEntry] of secondInfo) {\r\n\t\tif (!firstInfo.has(key)) {\r\n\t\t\tresultInfo.set(key, secondEntry);\r\n\t\t}\r\n\t}\r\n\treturn serializeObject(resultInfo, secondDynamicInfo);\r\n};\r\n\r\n/**\r\n * @param {ObjectParsedPropertyEntry} firstEntry a\r\n * @param {ObjectParsedPropertyEntry} secondEntry b\r\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\r\n * @returns {ObjectParsedPropertyEntry} new entry\r\n */\r\nconst mergeEntries = (firstEntry, secondEntry, internalCaching) => {\r\n\tswitch (getValueType(secondEntry.base)) {\r\n\t\tcase VALUE_TYPE_ATOM:\r\n\t\tcase VALUE_TYPE_DELETE:\r\n\t\t\t// No need to consider firstEntry at all\r\n\t\t\t// second value override everything\r\n\t\t\t// = second.base + second.byProperty\r\n\t\t\treturn secondEntry;\r\n\t\tcase VALUE_TYPE_UNDEFINED:\r\n\t\t\tif (!firstEntry.byProperty) {\r\n\t\t\t\t// = first.base + second.byProperty\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbase: firstEntry.base,\r\n\t\t\t\t\tbyProperty: secondEntry.byProperty,\r\n\t\t\t\t\tbyValues: secondEntry.byValues\r\n\t\t\t\t};\r\n\t\t\t} else if (firstEntry.byProperty !== secondEntry.byProperty) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\t// = first.base + (first.byProperty + second.byProperty)\r\n\t\t\t\t// need to merge first and second byValues\r\n\t\t\t\tconst newByValues = new Map(firstEntry.byValues);\r\n\t\t\t\tfor (const [key, value] of secondEntry.byValues) {\r\n\t\t\t\t\tconst firstValue = getFromByValues(firstEntry.byValues, key);\r\n\t\t\t\t\tnewByValues.set(\r\n\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\tmergeSingleValue(firstValue, value, internalCaching)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbase: firstEntry.base,\r\n\t\t\t\t\tbyProperty: firstEntry.byProperty,\r\n\t\t\t\t\tbyValues: newByValues\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\tdefault: {\r\n\t\t\tif (!firstEntry.byProperty) {\r\n\t\t\t\t// The simple case\r\n\t\t\t\t// = (first.base + second.base) + second.byProperty\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbase: mergeSingleValue(\r\n\t\t\t\t\t\tfirstEntry.base,\r\n\t\t\t\t\t\tsecondEntry.base,\r\n\t\t\t\t\t\tinternalCaching\r\n\t\t\t\t\t),\r\n\t\t\t\t\tbyProperty: secondEntry.byProperty,\r\n\t\t\t\t\tbyValues: secondEntry.byValues\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tlet newBase;\r\n\t\t\tconst intermediateByValues = new Map(firstEntry.byValues);\r\n\t\t\tfor (const [key, value] of intermediateByValues) {\r\n\t\t\t\tintermediateByValues.set(\r\n\t\t\t\t\tkey,\r\n\t\t\t\t\tmergeSingleValue(value, secondEntry.base, internalCaching)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (\r\n\t\t\t\tArray.from(firstEntry.byValues.values()).every(value => {\r\n\t\t\t\t\tconst type = getValueType(value);\r\n\t\t\t\t\treturn type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;\r\n\t\t\t\t})\r\n\t\t\t) {\r\n\t\t\t\t// = (first.base + second.base) + ((first.byProperty + second.base) + second.byProperty)\r\n\t\t\t\tnewBase = mergeSingleValue(\r\n\t\t\t\t\tfirstEntry.base,\r\n\t\t\t\t\tsecondEntry.base,\r\n\t\t\t\t\tinternalCaching\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\t// = first.base + ((first.byProperty (+default) + second.base) + second.byProperty)\r\n\t\t\t\tnewBase = firstEntry.base;\r\n\t\t\t\tif (!intermediateByValues.has(\"default\"))\r\n\t\t\t\t\tintermediateByValues.set(\"default\", secondEntry.base);\r\n\t\t\t}\r\n\t\t\tif (!secondEntry.byProperty) {\r\n\t\t\t\t// = first.base + (first.byProperty + second.base)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbase: newBase,\r\n\t\t\t\t\tbyProperty: firstEntry.byProperty,\r\n\t\t\t\t\tbyValues: intermediateByValues\r\n\t\t\t\t};\r\n\t\t\t} else if (firstEntry.byProperty !== secondEntry.byProperty) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tconst newByValues = new Map(intermediateByValues);\r\n\t\t\tfor (const [key, value] of secondEntry.byValues) {\r\n\t\t\t\tconst firstValue = getFromByValues(intermediateByValues, key);\r\n\t\t\t\tnewByValues.set(\r\n\t\t\t\t\tkey,\r\n\t\t\t\t\tmergeSingleValue(firstValue, value, internalCaching)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tbase: newBase,\r\n\t\t\t\tbyProperty: firstEntry.byProperty,\r\n\t\t\t\tbyValues: newByValues\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {Map<string, any>} byValues all values\r\n * @param {string} key value of the selector\r\n * @returns {any | undefined} value\r\n */\r\nconst getFromByValues = (byValues, key) => {\r\n\tif (key !== \"default\" && byValues.has(key)) {\r\n\t\treturn byValues.get(key);\r\n\t}\r\n\treturn byValues.get(\"default\");\r\n};\r\n\r\n/**\r\n * @param {any} a value\r\n * @param {any} b value\r\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\r\n * @returns {any} value\r\n */\r\nconst mergeSingleValue = (a, b, internalCaching) => {\r\n\tconst bType = getValueType(b);\r\n\tconst aType = getValueType(a);\r\n\tswitch (bType) {\r\n\t\tcase VALUE_TYPE_DELETE:\r\n\t\tcase VALUE_TYPE_ATOM:\r\n\t\t\treturn b;\r\n\t\tcase VALUE_TYPE_OBJECT: {\r\n\t\t\treturn aType !== VALUE_TYPE_OBJECT\r\n\t\t\t\t? b\r\n\t\t\t\t: internalCaching\r\n\t\t\t\t? cachedCleverMerge(a, b)\r\n\t\t\t\t: cleverMerge(a, b);\r\n\t\t}\r\n\t\tcase VALUE_TYPE_UNDEFINED:\r\n\t\t\treturn a;\r\n\t\tcase VALUE_TYPE_ARRAY_EXTEND:\r\n\t\t\tswitch (\r\n\t\t\t\taType !== VALUE_TYPE_ATOM\r\n\t\t\t\t\t? aType\r\n\t\t\t\t\t: Array.isArray(a)\r\n\t\t\t\t\t? VALUE_TYPE_ARRAY_EXTEND\r\n\t\t\t\t\t: VALUE_TYPE_OBJECT\r\n\t\t\t) {\r\n\t\t\t\tcase VALUE_TYPE_UNDEFINED:\r\n\t\t\t\t\treturn b;\r\n\t\t\t\tcase VALUE_TYPE_DELETE:\r\n\t\t\t\t\treturn b.filter(item => item !== \"...\");\r\n\t\t\t\tcase VALUE_TYPE_ARRAY_EXTEND: {\r\n\t\t\t\t\tconst newArray = [];\r\n\t\t\t\t\tfor (const item of b) {\r\n\t\t\t\t\t\tif (item === \"...\") {\r\n\t\t\t\t\t\t\tfor (const item of a) {\r\n\t\t\t\t\t\t\t\tnewArray.push(item);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewArray.push(item);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn newArray;\r\n\t\t\t\t}\r\n\t\t\t\tcase VALUE_TYPE_OBJECT:\r\n\t\t\t\t\treturn b.map(item => (item === \"...\" ? a : item));\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"Not implemented\");\r\n\t\t\t}\r\n\t\tdefault:\r\n\t\t\tthrow new Error(\"Not implemented\");\r\n\t}\r\n};\r\n\r\n/**\r\n * @template T\r\n * @param {T} obj the object\r\n * @returns {T} the object without operations like \"...\" or DELETE\r\n */\r\nconst removeOperations = obj => {\r\n\tconst newObj = /** @type {T} */ ({});\r\n\tfor (const key of Object.keys(obj)) {\r\n\t\tconst value = obj[key];\r\n\t\tconst type = getValueType(value);\r\n\t\tswitch (type) {\r\n\t\t\tcase VALUE_TYPE_UNDEFINED:\r\n\t\t\tcase VALUE_TYPE_DELETE:\r\n\t\t\t\tbreak;\r\n\t\t\tcase VALUE_TYPE_OBJECT:\r\n\t\t\t\tnewObj[key] = removeOperations(value);\r\n\t\t\t\tbreak;\r\n\t\t\tcase VALUE_TYPE_ARRAY_EXTEND:\r\n\t\t\t\tnewObj[key] = value.filter(i => i !== \"...\");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tnewObj[key] = value;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn newObj;\r\n};\r\n\r\n/**\r\n * @template T\r\n * @template {string} P\r\n * @param {T} obj the object\r\n * @param {P} byProperty the by description\r\n * @param  {...any} values values\r\n * @returns {Omit<T, P>} object with merged byProperty\r\n */\r\nconst resolveByProperty = (obj, byProperty, ...values) => {\r\n\tif (typeof obj !== \"object\" || obj === null || !(byProperty in obj)) {\r\n\t\treturn obj;\r\n\t}\r\n\tconst { [byProperty]: _byValue, ..._remaining } = /** @type {object} */ (obj);\r\n\tconst remaining = /** @type {T} */ (_remaining);\r\n\tconst byValue = /** @type {Record<string, T> | function(...any[]): T} */ (\r\n\t\t_byValue\r\n\t);\r\n\tif (typeof byValue === \"object\") {\r\n\t\tconst key = values[0];\r\n\t\tif (key in byValue) {\r\n\t\t\treturn cachedCleverMerge(remaining, byValue[key]);\r\n\t\t} else if (\"default\" in byValue) {\r\n\t\t\treturn cachedCleverMerge(remaining, byValue.default);\r\n\t\t} else {\r\n\t\t\treturn /** @type {T} */ (remaining);\r\n\t\t}\r\n\t} else if (typeof byValue === \"function\") {\r\n\t\tconst result = byValue.apply(null, values);\r\n\t\treturn cachedCleverMerge(\r\n\t\t\tremaining,\r\n\t\t\tresolveByProperty(result, byProperty, ...values)\r\n\t\t);\r\n\t}\r\n};\r\n\r\nexports.cachedSetProperty = cachedSetProperty;\r\nexports.cachedCleverMerge = cachedCleverMerge;\r\nexports.cleverMerge = cleverMerge;\r\nexports.resolveByProperty = resolveByProperty;\r\nexports.removeOperations = removeOperations;\r\nexports.DELETE = DELETE;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}