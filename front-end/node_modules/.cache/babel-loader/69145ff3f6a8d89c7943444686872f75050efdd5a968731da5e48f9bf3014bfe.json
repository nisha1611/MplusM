{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;\nconst util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\nconst constants_1 = require(\"./constants\");\nconst signingKeyCache = {};\nconst cacheQueue = [];\nconst createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;\nexports.createScope = createScope;\nconst getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {\n  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);\n  const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;\n  if (cacheKey in signingKeyCache) {\n    return signingKeyCache[cacheKey];\n  }\n  cacheQueue.push(cacheKey);\n  while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {\n    delete signingKeyCache[cacheQueue.shift()];\n  }\n  let key = `AWS4${credentials.secretAccessKey}`;\n  for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {\n    key = await hmac(sha256Constructor, key, signable);\n  }\n  return signingKeyCache[cacheKey] = key;\n};\nexports.getSigningKey = getSigningKey;\nconst clearCredentialCache = () => {\n  cacheQueue.length = 0;\n  Object.keys(signingKeyCache).forEach(cacheKey => {\n    delete signingKeyCache[cacheKey];\n  });\n};\nexports.clearCredentialCache = clearCredentialCache;\nconst hmac = (ctor, secret, data) => {\n  const hash = new ctor(secret);\n  hash.update(data);\n  return hash.digest();\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","clearCredentialCache","getSigningKey","createScope","util_hex_encoding_1","require","constants_1","signingKeyCache","cacheQueue","shortDate","region","service","KEY_TYPE_IDENTIFIER","sha256Constructor","credentials","credsHash","hmac","secretAccessKey","accessKeyId","cacheKey","toHex","sessionToken","push","length","MAX_CACHE_SIZE","shift","key","signable","keys","forEach","ctor","secret","data","hash","update","digest"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/signature-v4/dist-cjs/credentialDerivation.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;\r\nconst util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\r\nconst constants_1 = require(\"./constants\");\r\nconst signingKeyCache = {};\r\nconst cacheQueue = [];\r\nconst createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;\r\nexports.createScope = createScope;\r\nconst getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {\r\n    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);\r\n    const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;\r\n    if (cacheKey in signingKeyCache) {\r\n        return signingKeyCache[cacheKey];\r\n    }\r\n    cacheQueue.push(cacheKey);\r\n    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {\r\n        delete signingKeyCache[cacheQueue.shift()];\r\n    }\r\n    let key = `AWS4${credentials.secretAccessKey}`;\r\n    for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {\r\n        key = await hmac(sha256Constructor, key, signable);\r\n    }\r\n    return (signingKeyCache[cacheKey] = key);\r\n};\r\nexports.getSigningKey = getSigningKey;\r\nconst clearCredentialCache = () => {\r\n    cacheQueue.length = 0;\r\n    Object.keys(signingKeyCache).forEach((cacheKey) => {\r\n        delete signingKeyCache[cacheKey];\r\n    });\r\n};\r\nexports.clearCredentialCache = clearCredentialCache;\r\nconst hmac = (ctor, secret, data) => {\r\n    const hash = new ctor(secret);\r\n    hash.update(data);\r\n    return hash.digest();\r\n};\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAGF,OAAO,CAACG,aAAa,GAAGH,OAAO,CAACI,WAAW,GAAG,KAAK,CAAC;AACnF,MAAMC,mBAAmB,GAAGC,OAAO,CAAC,4BAA4B,CAAC;AACjE,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAME,eAAe,GAAG,CAAC,CAAC;AAC1B,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAML,WAAW,GAAG,CAACM,SAAS,EAAEC,MAAM,EAAEC,OAAO,KAAM,GAAEF,SAAU,IAAGC,MAAO,IAAGC,OAAQ,IAAGL,WAAW,CAACM,mBAAoB,EAAC;AAC1Hb,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjC,MAAMD,aAAa,GAAG,OAAOW,iBAAiB,EAAEC,WAAW,EAAEL,SAAS,EAAEC,MAAM,EAAEC,OAAO,KAAK;EACxF,MAAMI,SAAS,GAAG,MAAMC,IAAI,CAACH,iBAAiB,EAAEC,WAAW,CAACG,eAAe,EAAEH,WAAW,CAACI,WAAW,CAAC;EACrG,MAAMC,QAAQ,GAAI,GAAEV,SAAU,IAAGC,MAAO,IAAGC,OAAQ,IAAG,CAAC,CAAC,EAAEP,mBAAmB,CAACgB,KAAK,EAAEL,SAAS,CAAE,IAAGD,WAAW,CAACO,YAAa,EAAC;EAC7H,IAAIF,QAAQ,IAAIZ,eAAe,EAAE;IAC7B,OAAOA,eAAe,CAACY,QAAQ,CAAC;EACpC;EACAX,UAAU,CAACc,IAAI,CAACH,QAAQ,CAAC;EACzB,OAAOX,UAAU,CAACe,MAAM,GAAGjB,WAAW,CAACkB,cAAc,EAAE;IACnD,OAAOjB,eAAe,CAACC,UAAU,CAACiB,KAAK,EAAE,CAAC;EAC9C;EACA,IAAIC,GAAG,GAAI,OAAMZ,WAAW,CAACG,eAAgB,EAAC;EAC9C,KAAK,MAAMU,QAAQ,IAAI,CAAClB,SAAS,EAAEC,MAAM,EAAEC,OAAO,EAAEL,WAAW,CAACM,mBAAmB,CAAC,EAAE;IAClFc,GAAG,GAAG,MAAMV,IAAI,CAACH,iBAAiB,EAAEa,GAAG,EAAEC,QAAQ,CAAC;EACtD;EACA,OAAQpB,eAAe,CAACY,QAAQ,CAAC,GAAGO,GAAG;AAC3C,CAAC;AACD3B,OAAO,CAACG,aAAa,GAAGA,aAAa;AACrC,MAAMD,oBAAoB,GAAG,MAAM;EAC/BO,UAAU,CAACe,MAAM,GAAG,CAAC;EACrB1B,MAAM,CAAC+B,IAAI,CAACrB,eAAe,CAAC,CAACsB,OAAO,CAAEV,QAAQ,IAAK;IAC/C,OAAOZ,eAAe,CAACY,QAAQ,CAAC;EACpC,CAAC,CAAC;AACN,CAAC;AACDpB,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB;AACnD,MAAMe,IAAI,GAAG,CAACc,IAAI,EAAEC,MAAM,EAAEC,IAAI,KAAK;EACjC,MAAMC,IAAI,GAAG,IAAIH,IAAI,CAACC,MAAM,CAAC;EAC7BE,IAAI,CAACC,MAAM,CAACF,IAAI,CAAC;EACjB,OAAOC,IAAI,CAACE,MAAM,EAAE;AACxB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}