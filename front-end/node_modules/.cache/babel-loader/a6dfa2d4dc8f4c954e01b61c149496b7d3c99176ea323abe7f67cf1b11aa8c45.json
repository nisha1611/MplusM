{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies\r\n */\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/**\r\n * Prepare a set of path options for query population.\r\n *\r\n * @param {Query} query\r\n * @param {Object} options\r\n * @return {Array}\r\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));\n  }\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n\n/**\r\n * Prepare a set of path options for query population. This is the MongooseQuery\r\n * version\r\n *\r\n * @param {Query} query\r\n * @param {Object} options\r\n * @return {Array}\r\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));\n  }\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n\n/**\r\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\r\n * it returns an instance of the given model.\r\n *\r\n * @param {Model}  model\r\n * @param {Object} doc\r\n * @param {Object} fields\r\n *\r\n * @return {Document}\r\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\r\n * ignore\r\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ? {\n    populated: populatedIds\n  } : undefined;\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\r\n * ignore\r\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      // `_id: 1, name: 0` is a mixed inclusive/exclusive projection in\n      // MongoDB 4.0 and earlier, but not in later versions.\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\r\n * Set each path query option to lean\r\n *\r\n * @param {Object} option\r\n */\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n    option.options.lean = val;\n  };\n}","map":{"version":3,"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","opts","_localModel","model","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","_opts","skipId","isNew","willInit","defaults","createModelAndInit","populatedIds","callback","initOpts","populated","casted","$init","error","exclude","keyIndex","length","field","selected","excluded","stack","analyzeSchema","fieldName","paths","select","_id","startsWith","prefix","indexOf","push","addedPaths","eachPath","type","$isSchemaMap","endsWith","plusPath","hasPlusPath","addedPath","analyzePath","Array","isArray","$isMongooseArray","$isMongooseDocumentArray","caster","_addedPaths","discriminatorKey","pieces","split","cur","i","$skipDiscriminatorCheck","val","option","virtuals","assign","map","slice"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/queryhelpers.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies\r\n */\r\n\r\nconst checkEmbeddedDiscriminatorKeyProjection =\r\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\r\nconst get = require('./helpers/get');\r\nconst getDiscriminatorByValue =\r\n  require('./helpers/discriminator/getDiscriminatorByValue');\r\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\r\nconst clone = require('./helpers/clone');\r\n\r\n/**\r\n * Prepare a set of path options for query population.\r\n *\r\n * @param {Query} query\r\n * @param {Object} options\r\n * @return {Array}\r\n */\r\n\r\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\r\n  const _populate = query.options.populate;\r\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\r\n\r\n  // lean options should trickle through all queries\r\n  if (options.lean != null) {\r\n    pop\r\n      .filter(p => (p && p.options && p.options.lean) == null)\r\n      .forEach(makeLean(options.lean));\r\n  }\r\n\r\n  pop.forEach(opts => {\r\n    opts._localModel = query.model;\r\n  });\r\n\r\n  return pop;\r\n};\r\n\r\n/**\r\n * Prepare a set of path options for query population. This is the MongooseQuery\r\n * version\r\n *\r\n * @param {Query} query\r\n * @param {Object} options\r\n * @return {Array}\r\n */\r\n\r\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\r\n  const _populate = query._mongooseOptions.populate;\r\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\r\n\r\n  // lean options should trickle through all queries\r\n  if (options.lean != null) {\r\n    pop\r\n      .filter(p => (p && p.options && p.options.lean) == null)\r\n      .forEach(makeLean(options.lean));\r\n  }\r\n\r\n  const session = query && query.options && query.options.session || null;\r\n  if (session != null) {\r\n    pop.forEach(path => {\r\n      if (path.options == null) {\r\n        path.options = { session: session };\r\n        return;\r\n      }\r\n      if (!('session' in path.options)) {\r\n        path.options.session = session;\r\n      }\r\n    });\r\n  }\r\n\r\n  const projection = query._fieldsForExec();\r\n  pop.forEach(p => {\r\n    p._queryProjection = projection;\r\n  });\r\n  pop.forEach(opts => {\r\n    opts._localModel = query.model;\r\n  });\r\n\r\n  return pop;\r\n};\r\n\r\n/**\r\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\r\n * it returns an instance of the given model.\r\n *\r\n * @param {Model}  model\r\n * @param {Object} doc\r\n * @param {Object} fields\r\n *\r\n * @return {Document}\r\n */\r\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\r\n  model.hooks.execPreSync('createModel', doc);\r\n  const discriminatorMapping = model.schema ?\r\n    model.schema.discriminatorMapping :\r\n    null;\r\n\r\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\r\n    discriminatorMapping.key :\r\n    null;\r\n\r\n  const value = doc[key];\r\n  if (key && value && model.discriminators) {\r\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\r\n    if (discriminator) {\r\n      const _fields = clone(userProvidedFields);\r\n      exports.applyPaths(_fields, discriminator.schema);\r\n      return new discriminator(undefined, _fields, true);\r\n    }\r\n  }\r\n\r\n  const _opts = {\r\n    skipId: true,\r\n    isNew: false,\r\n    willInit: true\r\n  };\r\n  if (options != null && 'defaults' in options) {\r\n    _opts.defaults = options.defaults;\r\n  }\r\n  return new model(undefined, fields, _opts);\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\r\n  const initOpts = populatedIds ?\r\n    { populated: populatedIds } :\r\n    undefined;\r\n\r\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\r\n  try {\r\n    casted.$init(doc, initOpts, callback);\r\n  } catch (error) {\r\n    callback(error, casted);\r\n  }\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nexports.applyPaths = function applyPaths(fields, schema) {\r\n  // determine if query is selecting or excluding fields\r\n  let exclude;\r\n  let keys;\r\n  let keyIndex;\r\n\r\n  if (fields) {\r\n    keys = Object.keys(fields);\r\n    keyIndex = keys.length;\r\n\r\n    while (keyIndex--) {\r\n      if (keys[keyIndex][0] === '+') {\r\n        continue;\r\n      }\r\n      const field = fields[keys[keyIndex]];\r\n      // Skip `$meta` and `$slice`\r\n      if (!isDefiningProjection(field)) {\r\n        continue;\r\n      }\r\n      // `_id: 1, name: 0` is a mixed inclusive/exclusive projection in\r\n      // MongoDB 4.0 and earlier, but not in later versions.\r\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\r\n        continue;\r\n      }\r\n      exclude = !field;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // if selecting, apply default schematype select:true fields\r\n  // if excluding, apply schematype select:false fields\r\n\r\n  const selected = [];\r\n  const excluded = [];\r\n  const stack = [];\r\n\r\n  analyzeSchema(schema);\r\n\r\n  switch (exclude) {\r\n    case true:\r\n      for (const fieldName of excluded) {\r\n        fields[fieldName] = 0;\r\n      }\r\n      break;\r\n    case false:\r\n      if (schema &&\r\n          schema.paths['_id'] &&\r\n          schema.paths['_id'].options &&\r\n          schema.paths['_id'].options.select === false) {\r\n        fields._id = 0;\r\n      }\r\n\r\n      for (const fieldName of selected) {\r\n        fields[fieldName] = fields[fieldName] || 1;\r\n      }\r\n      break;\r\n    case undefined:\r\n      if (fields == null) {\r\n        break;\r\n      }\r\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\r\n      for (const key of Object.keys(fields || {})) {\r\n        if (key.startsWith('+')) {\r\n          delete fields[key];\r\n        }\r\n      }\r\n\r\n      // user didn't specify fields, implies returning all fields.\r\n      // only need to apply excluded fields and delete any plus paths\r\n      for (const fieldName of excluded) {\r\n        if (fields[fieldName] != null) {\r\n          // Skip applying default projections to fields with non-defining\r\n          // projections, like `$slice`\r\n          continue;\r\n        }\r\n        fields[fieldName] = 0;\r\n      }\r\n      break;\r\n  }\r\n\r\n  function analyzeSchema(schema, prefix) {\r\n    prefix || (prefix = '');\r\n\r\n    // avoid recursion\r\n    if (stack.indexOf(schema) !== -1) {\r\n      return [];\r\n    }\r\n    stack.push(schema);\r\n\r\n    const addedPaths = [];\r\n    schema.eachPath(function(path, type) {\r\n      if (prefix) path = prefix + '.' + path;\r\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\r\n        const plusPath = '+' + path;\r\n        const hasPlusPath = fields && plusPath in fields;\r\n        if (type.options && type.options.select === false && !hasPlusPath) {\r\n          excluded.push(path);\r\n        }\r\n        return;\r\n      }\r\n      let addedPath = analyzePath(path, type);\r\n      // arrays\r\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\r\n        addedPath = analyzePath(path, type.caster);\r\n      }\r\n      if (addedPath != null) {\r\n        addedPaths.push(addedPath);\r\n      }\r\n\r\n      // nested schemas\r\n      if (type.schema) {\r\n        const _addedPaths = analyzeSchema(type.schema, path);\r\n\r\n        // Special case: if discriminator key is the only field that would\r\n        // be projected in, remove it.\r\n        if (exclude === false) {\r\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\r\n            selected, _addedPaths);\r\n        }\r\n      }\r\n    });\r\n    stack.pop();\r\n    return addedPaths;\r\n  }\r\n\r\n  function analyzePath(path, type) {\r\n    const plusPath = '+' + path;\r\n    const hasPlusPath = fields && plusPath in fields;\r\n    if (hasPlusPath) {\r\n      // forced inclusion\r\n      delete fields[plusPath];\r\n    }\r\n\r\n    if (typeof type.selected !== 'boolean') {\r\n      return;\r\n    }\r\n\r\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\r\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\r\n    // fields counts as an exclusive projection. See gh-11546\r\n    if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\r\n      delete fields[path];\r\n      return;\r\n    }\r\n\r\n    if (hasPlusPath) {\r\n      // forced inclusion\r\n      delete fields[plusPath];\r\n\r\n      // if there are other fields being included, add this one\r\n      // if no other included fields, leave this out (implied inclusion)\r\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\r\n        fields[path] = 1;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // check for parent exclusions\r\n    const pieces = path.split('.');\r\n    let cur = '';\r\n    for (let i = 0; i < pieces.length; ++i) {\r\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\r\n      if (excluded.indexOf(cur) !== -1) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Special case: if user has included a parent path of a discriminator key,\r\n    // don't explicitly project in the discriminator key because that will\r\n    // project out everything else under the parent path\r\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\r\n      let cur = '';\r\n      for (let i = 0; i < pieces.length; ++i) {\r\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\r\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\r\n        if (projection && typeof projection !== 'object') {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    (type.selected ? selected : excluded).push(path);\r\n    return path;\r\n  }\r\n};\r\n\r\n/**\r\n * Set each path query option to lean\r\n *\r\n * @param {Object} option\r\n */\r\n\r\nfunction makeLean(val) {\r\n  return function(option) {\r\n    option.options || (option.options = {});\r\n\r\n    if (val != null && Array.isArray(val.virtuals)) {\r\n      val = Object.assign({}, val);\r\n      val.virtuals = val.virtuals.\r\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\r\n        map(path => path.slice(option.path.length + 1));\r\n    }\r\n\r\n    option.options.lean = val;\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}