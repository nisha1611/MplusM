{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst {\n  equals\n} = require(\"./util/ArrayHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst {\n  forEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Dependency\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */\n/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */\n\nconst UsageState = Object.freeze({\n  Unused: /** @type {0} */0,\n  OnlyPropertiesUsed: /** @type {1} */1,\n  NoInfo: /** @type {2} */2,\n  Unknown: /** @type {3} */3,\n  Used: /** @type {4} */4\n});\nconst RETURNS_TRUE = () => true;\nconst CIRCULAR = Symbol(\"circular target\");\nclass RestoreProvidedData {\n  constructor(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding) {\n    this.exports = exports;\n    this.otherProvided = otherProvided;\n    this.otherCanMangleProvide = otherCanMangleProvide;\n    this.otherTerminalBinding = otherTerminalBinding;\n  }\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this.exports);\n    write(this.otherProvided);\n    write(this.otherCanMangleProvide);\n    write(this.otherTerminalBinding);\n  }\n  static deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    return new RestoreProvidedData(read(), read(), read(), read());\n  }\n}\nmakeSerializable(RestoreProvidedData, \"webpack/lib/ModuleGraph\", \"RestoreProvidedData\");\nclass ExportsInfo {\n  constructor() {\n    /** @type {Map<string, ExportInfo>} */\n    this._exports = new Map();\n    this._otherExportsInfo = new ExportInfo(null);\n    this._sideEffectsOnlyInfo = new ExportInfo(\"*side effects only*\");\n    this._exportsAreOrdered = false;\n    /** @type {ExportsInfo=} */\n    this._redirectTo = undefined;\n  }\n\n  /**\r\n   * @returns {Iterable<ExportInfo>} all owned exports in any order\r\n   */\n  get ownedExports() {\n    return this._exports.values();\n  }\n\n  /**\r\n   * @returns {Iterable<ExportInfo>} all owned exports in order\r\n   */\n  get orderedOwnedExports() {\n    if (!this._exportsAreOrdered) {\n      this._sortExports();\n    }\n    return this._exports.values();\n  }\n\n  /**\r\n   * @returns {Iterable<ExportInfo>} all exports in any order\r\n   */\n  get exports() {\n    if (this._redirectTo !== undefined) {\n      const map = new Map(this._redirectTo._exports);\n      for (const [key, value] of this._exports) {\n        map.set(key, value);\n      }\n      return map.values();\n    }\n    return this._exports.values();\n  }\n\n  /**\r\n   * @returns {Iterable<ExportInfo>} all exports in order\r\n   */\n  get orderedExports() {\n    if (!this._exportsAreOrdered) {\n      this._sortExports();\n    }\n    if (this._redirectTo !== undefined) {\n      const map = new Map(Array.from(this._redirectTo.orderedExports, item => [item.name, item]));\n      for (const [key, value] of this._exports) {\n        map.set(key, value);\n      }\n      // sorting should be pretty fast as map contains\n      // a lot of presorted items\n      this._sortExportsMap(map);\n      return map.values();\n    }\n    return this._exports.values();\n  }\n\n  /**\r\n   * @returns {ExportInfo} the export info of unlisted exports\r\n   */\n  get otherExportsInfo() {\n    if (this._redirectTo !== undefined) return this._redirectTo.otherExportsInfo;\n    return this._otherExportsInfo;\n  }\n  _sortExportsMap(exports) {\n    if (exports.size > 1) {\n      const namesInOrder = [];\n      for (const entry of exports.values()) {\n        namesInOrder.push(entry.name);\n      }\n      namesInOrder.sort();\n      let i = 0;\n      for (const entry of exports.values()) {\n        const name = namesInOrder[i];\n        if (entry.name !== name) break;\n        i++;\n      }\n      for (; i < namesInOrder.length; i++) {\n        const name = namesInOrder[i];\n        const correctEntry = exports.get(name);\n        exports.delete(name);\n        exports.set(name, correctEntry);\n      }\n    }\n  }\n  _sortExports() {\n    this._sortExportsMap(this._exports);\n    this._exportsAreOrdered = true;\n  }\n  setRedirectNamedTo(exportsInfo) {\n    if (this._redirectTo === exportsInfo) return false;\n    this._redirectTo = exportsInfo;\n    return true;\n  }\n  setHasProvideInfo() {\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.provided === undefined) {\n        exportInfo.provided = false;\n      }\n      if (exportInfo.canMangleProvide === undefined) {\n        exportInfo.canMangleProvide = true;\n      }\n    }\n    if (this._redirectTo !== undefined) {\n      this._redirectTo.setHasProvideInfo();\n    } else {\n      if (this._otherExportsInfo.provided === undefined) {\n        this._otherExportsInfo.provided = false;\n      }\n      if (this._otherExportsInfo.canMangleProvide === undefined) {\n        this._otherExportsInfo.canMangleProvide = true;\n      }\n    }\n  }\n  setHasUseInfo() {\n    for (const exportInfo of this._exports.values()) {\n      exportInfo.setHasUseInfo();\n    }\n    this._sideEffectsOnlyInfo.setHasUseInfo();\n    if (this._redirectTo !== undefined) {\n      this._redirectTo.setHasUseInfo();\n    } else {\n      this._otherExportsInfo.setHasUseInfo();\n      if (this._otherExportsInfo.canMangleUse === undefined) {\n        this._otherExportsInfo.canMangleUse = true;\n      }\n    }\n  }\n\n  /**\r\n   * @param {string} name export name\r\n   * @returns {ExportInfo} export info for this name\r\n   */\n  getOwnExportInfo(name) {\n    const info = this._exports.get(name);\n    if (info !== undefined) return info;\n    const newInfo = new ExportInfo(name, this._otherExportsInfo);\n    this._exports.set(name, newInfo);\n    this._exportsAreOrdered = false;\n    return newInfo;\n  }\n\n  /**\r\n   * @param {string} name export name\r\n   * @returns {ExportInfo} export info for this name\r\n   */\n  getExportInfo(name) {\n    const info = this._exports.get(name);\n    if (info !== undefined) return info;\n    if (this._redirectTo !== undefined) return this._redirectTo.getExportInfo(name);\n    const newInfo = new ExportInfo(name, this._otherExportsInfo);\n    this._exports.set(name, newInfo);\n    this._exportsAreOrdered = false;\n    return newInfo;\n  }\n\n  /**\r\n   * @param {string} name export name\r\n   * @returns {ExportInfo} export info for this name\r\n   */\n  getReadOnlyExportInfo(name) {\n    const info = this._exports.get(name);\n    if (info !== undefined) return info;\n    if (this._redirectTo !== undefined) return this._redirectTo.getReadOnlyExportInfo(name);\n    return this._otherExportsInfo;\n  }\n\n  /**\r\n   * @param {string[]} name export name\r\n   * @returns {ExportInfo | undefined} export info for this name\r\n   */\n  getReadOnlyExportInfoRecursive(name) {\n    const exportInfo = this.getReadOnlyExportInfo(name[0]);\n    if (name.length === 1) return exportInfo;\n    if (!exportInfo.exportsInfo) return undefined;\n    return exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));\n  }\n\n  /**\r\n   * @param {string[]=} name the export name\r\n   * @returns {ExportsInfo | undefined} the nested exports info\r\n   */\n  getNestedExportsInfo(name) {\n    if (Array.isArray(name) && name.length > 0) {\n      const info = this.getReadOnlyExportInfo(name[0]);\n      if (!info.exportsInfo) return undefined;\n      return info.exportsInfo.getNestedExportsInfo(name.slice(1));\n    }\n    return this;\n  }\n\n  /**\r\n   * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)\r\n   * @param {Set<string>=} excludeExports list of unaffected exports\r\n   * @param {any=} targetKey use this as key for the target\r\n   * @param {ModuleGraphConnection=} targetModule set this module as target\r\n   * @param {number=} priority priority\r\n   * @returns {boolean} true, if this call changed something\r\n   */\n  setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority) {\n    let changed = false;\n    if (excludeExports) {\n      for (const name of excludeExports) {\n        // Make sure these entries exist, so they can get different info\n        this.getExportInfo(name);\n      }\n    }\n    for (const exportInfo of this._exports.values()) {\n      if (!canMangle && exportInfo.canMangleProvide !== false) {\n        exportInfo.canMangleProvide = false;\n        changed = true;\n      }\n      if (excludeExports && excludeExports.has(exportInfo.name)) continue;\n      if (exportInfo.provided !== true && exportInfo.provided !== null) {\n        exportInfo.provided = null;\n        changed = true;\n      }\n      if (targetKey) {\n        exportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);\n      }\n    }\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority)) {\n        changed = true;\n      }\n    } else {\n      if (this._otherExportsInfo.provided !== true && this._otherExportsInfo.provided !== null) {\n        this._otherExportsInfo.provided = null;\n        changed = true;\n      }\n      if (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {\n        this._otherExportsInfo.canMangleProvide = false;\n        changed = true;\n      }\n      if (targetKey) {\n        this._otherExportsInfo.setTarget(targetKey, targetModule, undefined, priority);\n      }\n    }\n    return changed;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, when something changed\r\n   */\n  setUsedInUnknownWay(runtime) {\n    let changed = false;\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.setUsedInUnknownWay(runtime)) {\n        changed = true;\n      }\n    }\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.setUsedInUnknownWay(runtime)) {\n        changed = true;\n      }\n    } else {\n      if (this._otherExportsInfo.setUsedConditionally(used => used < UsageState.Unknown, UsageState.Unknown, runtime)) {\n        changed = true;\n      }\n      if (this._otherExportsInfo.canMangleUse !== false) {\n        this._otherExportsInfo.canMangleUse = false;\n        changed = true;\n      }\n    }\n    return changed;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, when something changed\r\n   */\n  setUsedWithoutInfo(runtime) {\n    let changed = false;\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.setUsedWithoutInfo(runtime)) {\n        changed = true;\n      }\n    }\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.setUsedWithoutInfo(runtime)) {\n        changed = true;\n      }\n    } else {\n      if (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {\n        changed = true;\n      }\n      if (this._otherExportsInfo.canMangleUse !== false) {\n        this._otherExportsInfo.canMangleUse = false;\n        changed = true;\n      }\n    }\n    return changed;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, when something changed\r\n   */\n  setAllKnownExportsUsed(runtime) {\n    let changed = false;\n    for (const exportInfo of this._exports.values()) {\n      if (!exportInfo.provided) continue;\n      if (exportInfo.setUsed(UsageState.Used, runtime)) {\n        changed = true;\n      }\n    }\n    return changed;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, when something changed\r\n   */\n  setUsedForSideEffectsOnly(runtime) {\n    return this._sideEffectsOnlyInfo.setUsedConditionally(used => used === UsageState.Unused, UsageState.Used, runtime);\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, when the module exports are used in any way\r\n   */\n  isUsed(runtime) {\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.isUsed(runtime)) {\n        return true;\n      }\n    } else {\n      if (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n        return true;\n      }\n    }\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.getUsed(runtime) !== UsageState.Unused) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, when the module is used in any way\r\n   */\n  isModuleUsed(runtime) {\n    if (this.isUsed(runtime)) return true;\n    if (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused) return true;\n    return false;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)\r\n   */\n  getUsedExports(runtime) {\n    if (!this._redirectTo !== undefined) {\n      switch (this._otherExportsInfo.getUsed(runtime)) {\n        case UsageState.NoInfo:\n          return null;\n        case UsageState.Unknown:\n        case UsageState.OnlyPropertiesUsed:\n        case UsageState.Used:\n          return true;\n      }\n    }\n    const array = [];\n    if (!this._exportsAreOrdered) this._sortExports();\n    for (const exportInfo of this._exports.values()) {\n      switch (exportInfo.getUsed(runtime)) {\n        case UsageState.NoInfo:\n          return null;\n        case UsageState.Unknown:\n          return true;\n        case UsageState.OnlyPropertiesUsed:\n        case UsageState.Used:\n          array.push(exportInfo.name);\n      }\n    }\n    if (this._redirectTo !== undefined) {\n      const inner = this._redirectTo.getUsedExports(runtime);\n      if (inner === null) return null;\n      if (inner === true) return true;\n      if (inner !== false) {\n        for (const item of inner) {\n          array.push(item);\n        }\n      }\n    }\n    if (array.length === 0) {\n      switch (this._sideEffectsOnlyInfo.getUsed(runtime)) {\n        case UsageState.NoInfo:\n          return null;\n        case UsageState.Unused:\n          return false;\n      }\n    }\n    return new SortableSet(array);\n  }\n\n  /**\r\n   * @returns {null | true | string[]} list of exports when known\r\n   */\n  getProvidedExports() {\n    if (!this._redirectTo !== undefined) {\n      switch (this._otherExportsInfo.provided) {\n        case undefined:\n          return null;\n        case null:\n          return true;\n        case true:\n          return true;\n      }\n    }\n    const array = [];\n    if (!this._exportsAreOrdered) this._sortExports();\n    for (const exportInfo of this._exports.values()) {\n      switch (exportInfo.provided) {\n        case undefined:\n          return null;\n        case null:\n          return true;\n        case true:\n          array.push(exportInfo.name);\n      }\n    }\n    if (this._redirectTo !== undefined) {\n      const inner = this._redirectTo.getProvidedExports();\n      if (inner === null) return null;\n      if (inner === true) return true;\n      for (const item of inner) {\n        if (!array.includes(item)) {\n          array.push(item);\n        }\n      }\n    }\n    return array;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)\r\n   */\n  getRelevantExports(runtime) {\n    const list = [];\n    for (const exportInfo of this._exports.values()) {\n      const used = exportInfo.getUsed(runtime);\n      if (used === UsageState.Unused) continue;\n      if (exportInfo.provided === false) continue;\n      list.push(exportInfo);\n    }\n    if (this._redirectTo !== undefined) {\n      for (const exportInfo of this._redirectTo.getRelevantExports(runtime)) {\n        if (!this._exports.has(exportInfo.name)) list.push(exportInfo);\n      }\n    }\n    if (this._otherExportsInfo.provided !== false && this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n      list.push(this._otherExportsInfo);\n    }\n    return list;\n  }\n\n  /**\r\n   * @param {string | string[]} name the name of the export\r\n   * @returns {boolean | undefined | null} if the export is provided\r\n   */\n  isExportProvided(name) {\n    if (Array.isArray(name)) {\n      const info = this.getReadOnlyExportInfo(name[0]);\n      if (info.exportsInfo && name.length > 1) {\n        return info.exportsInfo.isExportProvided(name.slice(1));\n      }\n      return info.provided ? name.length === 1 || undefined : info.provided;\n    }\n    const info = this.getReadOnlyExportInfo(name);\n    return info.provided;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime runtime\r\n   * @returns {string} key representing the usage\r\n   */\n  getUsageKey(runtime) {\n    const key = [];\n    if (this._redirectTo !== undefined) {\n      key.push(this._redirectTo.getUsageKey(runtime));\n    } else {\n      key.push(this._otherExportsInfo.getUsed(runtime));\n    }\n    key.push(this._sideEffectsOnlyInfo.getUsed(runtime));\n    for (const exportInfo of this.orderedOwnedExports) {\n      key.push(exportInfo.getUsed(runtime));\n    }\n    return key.join(\"|\");\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtimeA first runtime\r\n   * @param {RuntimeSpec} runtimeB second runtime\r\n   * @returns {boolean} true, when equally used\r\n   */\n  isEquallyUsed(runtimeA, runtimeB) {\n    if (this._redirectTo !== undefined) {\n      if (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;\n    } else {\n      if (this._otherExportsInfo.getUsed(runtimeA) !== this._otherExportsInfo.getUsed(runtimeB)) {\n        return false;\n      }\n    }\n    if (this._sideEffectsOnlyInfo.getUsed(runtimeA) !== this._sideEffectsOnlyInfo.getUsed(runtimeB)) {\n      return false;\n    }\n    for (const exportInfo of this.ownedExports) {\n      if (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB)) return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * @param {string | string[]} name export name\r\n   * @param {RuntimeSpec} runtime check usage for this runtime only\r\n   * @returns {UsageStateType} usage status\r\n   */\n  getUsed(name, runtime) {\n    if (Array.isArray(name)) {\n      if (name.length === 0) return this.otherExportsInfo.getUsed(runtime);\n      let info = this.getReadOnlyExportInfo(name[0]);\n      if (info.exportsInfo && name.length > 1) {\n        return info.exportsInfo.getUsed(name.slice(1), runtime);\n      }\n      return info.getUsed(runtime);\n    }\n    let info = this.getReadOnlyExportInfo(name);\n    return info.getUsed(runtime);\n  }\n\n  /**\r\n   * @param {string | string[]} name the export name\r\n   * @param {RuntimeSpec} runtime check usage for this runtime only\r\n   * @returns {string | string[] | false} the used name\r\n   */\n  getUsedName(name, runtime) {\n    if (Array.isArray(name)) {\n      // TODO improve this\n      if (name.length === 0) {\n        if (!this.isUsed(runtime)) return false;\n        return name;\n      }\n      let info = this.getReadOnlyExportInfo(name[0]);\n      const x = info.getUsedName(name[0], runtime);\n      if (x === false) return false;\n      const arr = x === name[0] && name.length === 1 ? name : [x];\n      if (name.length === 1) {\n        return arr;\n      }\n      if (info.exportsInfo && info.getUsed(runtime) === UsageState.OnlyPropertiesUsed) {\n        const nested = info.exportsInfo.getUsedName(name.slice(1), runtime);\n        if (!nested) return false;\n        return arr.concat(nested);\n      } else {\n        return arr.concat(name.slice(1));\n      }\n    } else {\n      let info = this.getReadOnlyExportInfo(name);\n      const usedName = info.getUsedName(name, runtime);\n      return usedName;\n    }\n  }\n\n  /**\r\n   * @param {Hash} hash the hash\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {void}\r\n   */\n  updateHash(hash, runtime) {\n    this._updateHash(hash, runtime, new Set());\n  }\n\n  /**\r\n   * @param {Hash} hash the hash\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references\r\n   * @returns {void}\r\n   */\n  _updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n    const set = new Set(alreadyVisitedExportsInfo);\n    set.add(this);\n    for (const exportInfo of this.orderedExports) {\n      if (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {\n        exportInfo._updateHash(hash, runtime, set);\n      }\n    }\n    this._sideEffectsOnlyInfo._updateHash(hash, runtime, set);\n    this._otherExportsInfo._updateHash(hash, runtime, set);\n    if (this._redirectTo !== undefined) {\n      this._redirectTo._updateHash(hash, runtime, set);\n    }\n  }\n  getRestoreProvidedData() {\n    const otherProvided = this._otherExportsInfo.provided;\n    const otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;\n    const otherTerminalBinding = this._otherExportsInfo.terminalBinding;\n    const exports = [];\n    for (const exportInfo of this.orderedExports) {\n      if (exportInfo.provided !== otherProvided || exportInfo.canMangleProvide !== otherCanMangleProvide || exportInfo.terminalBinding !== otherTerminalBinding || exportInfo.exportsInfoOwned) {\n        exports.push({\n          name: exportInfo.name,\n          provided: exportInfo.provided,\n          canMangleProvide: exportInfo.canMangleProvide,\n          terminalBinding: exportInfo.terminalBinding,\n          exportsInfo: exportInfo.exportsInfoOwned ? exportInfo.exportsInfo.getRestoreProvidedData() : undefined\n        });\n      }\n    }\n    return new RestoreProvidedData(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding);\n  }\n  restoreProvided(_ref3) {\n    let {\n      otherProvided,\n      otherCanMangleProvide,\n      otherTerminalBinding,\n      exports\n    } = _ref3;\n    let wasEmpty = true;\n    for (const exportInfo of this._exports.values()) {\n      wasEmpty = false;\n      exportInfo.provided = otherProvided;\n      exportInfo.canMangleProvide = otherCanMangleProvide;\n      exportInfo.terminalBinding = otherTerminalBinding;\n    }\n    this._otherExportsInfo.provided = otherProvided;\n    this._otherExportsInfo.canMangleProvide = otherCanMangleProvide;\n    this._otherExportsInfo.terminalBinding = otherTerminalBinding;\n    for (const exp of exports) {\n      const exportInfo = this.getExportInfo(exp.name);\n      exportInfo.provided = exp.provided;\n      exportInfo.canMangleProvide = exp.canMangleProvide;\n      exportInfo.terminalBinding = exp.terminalBinding;\n      if (exp.exportsInfo) {\n        const exportsInfo = exportInfo.createNestedExportsInfo();\n        exportsInfo.restoreProvided(exp.exportsInfo);\n      }\n    }\n    if (wasEmpty) this._exportsAreOrdered = true;\n  }\n}\nclass ExportInfo {\n  /**\r\n   * @param {string} name the original name of the export\r\n   * @param {ExportInfo=} initFrom init values from this ExportInfo\r\n   */\n  constructor(name, initFrom) {\n    /** @type {string} */\n    this.name = name;\n    /** @private @type {string | null} */\n    this._usedName = initFrom ? initFrom._usedName : null;\n    /** @private @type {UsageStateType} */\n    this._globalUsed = initFrom ? initFrom._globalUsed : undefined;\n    /** @private @type {Map<string, RuntimeUsageStateType>} */\n    this._usedInRuntime = initFrom && initFrom._usedInRuntime ? new Map(initFrom._usedInRuntime) : undefined;\n    /** @private @type {boolean} */\n    this._hasUseInRuntimeInfo = initFrom ? initFrom._hasUseInRuntimeInfo : false;\n    /**\r\n     * true: it is provided\r\n     * false: it is not provided\r\n     * null: only the runtime knows if it is provided\r\n     * undefined: it was not determined if it is provided\r\n     * @type {boolean | null | undefined}\r\n     */\n    this.provided = initFrom ? initFrom.provided : undefined;\n    /**\r\n     * is the export a terminal binding that should be checked for export star conflicts\r\n     * @type {boolean}\r\n     */\n    this.terminalBinding = initFrom ? initFrom.terminalBinding : false;\n    /**\r\n     * true: it can be mangled\r\n     * false: is can not be mangled\r\n     * undefined: it was not determined if it can be mangled\r\n     * @type {boolean | undefined}\r\n     */\n    this.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;\n    /**\r\n     * true: it can be mangled\r\n     * false: is can not be mangled\r\n     * undefined: it was not determined if it can be mangled\r\n     * @type {boolean | undefined}\r\n     */\n    this.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;\n    /** @type {boolean} */\n    this.exportsInfoOwned = false;\n    /** @type {ExportsInfo=} */\n    this.exportsInfo = undefined;\n    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n    this._target = undefined;\n    if (initFrom && initFrom._target) {\n      this._target = new Map();\n      for (const [key, value] of initFrom._target) {\n        this._target.set(key, {\n          connection: value.connection,\n          export: value.export || [name],\n          priority: value.priority\n        });\n      }\n    }\n    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n    this._maxTarget = undefined;\n  }\n\n  // TODO webpack 5 remove\n  /** @private */\n  get used() {\n    throw new Error(\"REMOVED\");\n  }\n  /** @private */\n  get usedName() {\n    throw new Error(\"REMOVED\");\n  }\n  /**\r\n   * @private\r\n   * @param {*} v v\r\n   */\n  set used(v) {\n    throw new Error(\"REMOVED\");\n  }\n  /**\r\n   * @private\r\n   * @param {*} v v\r\n   */\n  set usedName(v) {\n    throw new Error(\"REMOVED\");\n  }\n  get canMangle() {\n    switch (this.canMangleProvide) {\n      case undefined:\n        return this.canMangleUse === false ? false : undefined;\n      case false:\n        return false;\n      case true:\n        switch (this.canMangleUse) {\n          case undefined:\n            return undefined;\n          case false:\n            return false;\n          case true:\n            return true;\n        }\n    }\n    throw new Error(`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`);\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime only apply to this runtime\r\n   * @returns {boolean} true, when something changed\r\n   */\n  setUsedInUnknownWay(runtime) {\n    let changed = false;\n    if (this.setUsedConditionally(used => used < UsageState.Unknown, UsageState.Unknown, runtime)) {\n      changed = true;\n    }\n    if (this.canMangleUse !== false) {\n      this.canMangleUse = false;\n      changed = true;\n    }\n    return changed;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime only apply to this runtime\r\n   * @returns {boolean} true, when something changed\r\n   */\n  setUsedWithoutInfo(runtime) {\n    let changed = false;\n    if (this.setUsed(UsageState.NoInfo, runtime)) {\n      changed = true;\n    }\n    if (this.canMangleUse !== false) {\n      this.canMangleUse = false;\n      changed = true;\n    }\n    return changed;\n  }\n  setHasUseInfo() {\n    if (!this._hasUseInRuntimeInfo) {\n      this._hasUseInRuntimeInfo = true;\n    }\n    if (this.canMangleUse === undefined) {\n      this.canMangleUse = true;\n    }\n    if (this.exportsInfoOwned) {\n      this.exportsInfo.setHasUseInfo();\n    }\n  }\n\n  /**\r\n   * @param {function(UsageStateType): boolean} condition compare with old value\r\n   * @param {UsageStateType} newValue set when condition is true\r\n   * @param {RuntimeSpec} runtime only apply to this runtime\r\n   * @returns {boolean} true when something has changed\r\n   */\n  setUsedConditionally(condition, newValue, runtime) {\n    if (runtime === undefined) {\n      if (this._globalUsed === undefined) {\n        this._globalUsed = newValue;\n        return true;\n      } else {\n        if (this._globalUsed !== newValue && condition(this._globalUsed)) {\n          this._globalUsed = newValue;\n          return true;\n        }\n      }\n    } else if (this._usedInRuntime === undefined) {\n      if (newValue !== UsageState.Unused && condition(UsageState.Unused)) {\n        this._usedInRuntime = new Map();\n        forEachRuntime(runtime, runtime => this._usedInRuntime.set(runtime, newValue));\n        return true;\n      }\n    } else {\n      let changed = false;\n      forEachRuntime(runtime, runtime => {\n        /** @type {UsageStateType} */\n        let oldValue = this._usedInRuntime.get(runtime);\n        if (oldValue === undefined) oldValue = UsageState.Unused;\n        if (newValue !== oldValue && condition(oldValue)) {\n          if (newValue === UsageState.Unused) {\n            this._usedInRuntime.delete(runtime);\n          } else {\n            this._usedInRuntime.set(runtime, newValue);\n          }\n          changed = true;\n        }\n      });\n      if (changed) {\n        if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {UsageStateType} newValue new value of the used state\r\n   * @param {RuntimeSpec} runtime only apply to this runtime\r\n   * @returns {boolean} true when something has changed\r\n   */\n  setUsed(newValue, runtime) {\n    if (runtime === undefined) {\n      if (this._globalUsed !== newValue) {\n        this._globalUsed = newValue;\n        return true;\n      }\n    } else if (this._usedInRuntime === undefined) {\n      if (newValue !== UsageState.Unused) {\n        this._usedInRuntime = new Map();\n        forEachRuntime(runtime, runtime => this._usedInRuntime.set(runtime, newValue));\n        return true;\n      }\n    } else {\n      let changed = false;\n      forEachRuntime(runtime, runtime => {\n        /** @type {UsageStateType} */\n        let oldValue = this._usedInRuntime.get(runtime);\n        if (oldValue === undefined) oldValue = UsageState.Unused;\n        if (newValue !== oldValue) {\n          if (newValue === UsageState.Unused) {\n            this._usedInRuntime.delete(runtime);\n          } else {\n            this._usedInRuntime.set(runtime, newValue);\n          }\n          changed = true;\n        }\n      });\n      if (changed) {\n        if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {any} key the key\r\n   * @returns {boolean} true, if something has changed\r\n   */\n  unsetTarget(key) {\n    if (!this._target) return false;\n    if (this._target.delete(key)) {\n      this._maxTarget = undefined;\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {any} key the key\r\n   * @param {ModuleGraphConnection} connection the target module if a single one\r\n   * @param {string[]=} exportName the exported name\r\n   * @param {number=} priority priority\r\n   * @returns {boolean} true, if something has changed\r\n   */\n  setTarget(key, connection, exportName) {\n    let priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (exportName) exportName = [...exportName];\n    if (!this._target) {\n      this._target = new Map();\n      this._target.set(key, {\n        connection,\n        export: exportName,\n        priority\n      });\n      return true;\n    }\n    const oldTarget = this._target.get(key);\n    if (!oldTarget) {\n      if (oldTarget === null && !connection) return false;\n      this._target.set(key, {\n        connection,\n        export: exportName,\n        priority\n      });\n      this._maxTarget = undefined;\n      return true;\n    }\n    if (oldTarget.connection !== connection || oldTarget.priority !== priority || (exportName ? !oldTarget.export || !equals(oldTarget.export, exportName) : oldTarget.export)) {\n      oldTarget.connection = connection;\n      oldTarget.export = exportName;\n      oldTarget.priority = priority;\n      this._maxTarget = undefined;\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime for this runtime\r\n   * @returns {UsageStateType} usage state\r\n   */\n  getUsed(runtime) {\n    if (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;\n    if (this._globalUsed !== undefined) return this._globalUsed;\n    if (this._usedInRuntime === undefined) {\n      return UsageState.Unused;\n    } else if (typeof runtime === \"string\") {\n      const value = this._usedInRuntime.get(runtime);\n      return value === undefined ? UsageState.Unused : value;\n    } else if (runtime === undefined) {\n      /** @type {UsageStateType} */\n      let max = UsageState.Unused;\n      for (const value of this._usedInRuntime.values()) {\n        if (value === UsageState.Used) {\n          return UsageState.Used;\n        }\n        if (max < value) max = value;\n      }\n      return max;\n    } else {\n      /** @type {UsageStateType} */\n      let max = UsageState.Unused;\n      for (const item of runtime) {\n        const value = this._usedInRuntime.get(item);\n        if (value !== undefined) {\n          if (value === UsageState.Used) {\n            return UsageState.Used;\n          }\n          if (max < value) max = value;\n        }\n      }\n      return max;\n    }\n  }\n\n  /**\r\n   * get used name\r\n   * @param {string | undefined} fallbackName fallback name for used exports with no name\r\n   * @param {RuntimeSpec} runtime check usage for this runtime only\r\n   * @returns {string | false} used name\r\n   */\n  getUsedName(fallbackName, runtime) {\n    if (this._hasUseInRuntimeInfo) {\n      if (this._globalUsed !== undefined) {\n        if (this._globalUsed === UsageState.Unused) return false;\n      } else {\n        if (this._usedInRuntime === undefined) return false;\n        if (typeof runtime === \"string\") {\n          if (!this._usedInRuntime.has(runtime)) {\n            return false;\n          }\n        } else if (runtime !== undefined) {\n          if (Array.from(runtime).every(runtime => !this._usedInRuntime.has(runtime))) {\n            return false;\n          }\n        }\n      }\n    }\n    if (this._usedName !== null) return this._usedName;\n    return this.name || fallbackName;\n  }\n\n  /**\r\n   * @returns {boolean} true, when a mangled name of this export is set\r\n   */\n  hasUsedName() {\n    return this._usedName !== null;\n  }\n\n  /**\r\n   * Sets the mangled name of this export\r\n   * @param {string} name the new name\r\n   * @returns {void}\r\n   */\n  setUsedName(name) {\n    this._usedName = name;\n  }\n\n  /**\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n   * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known\r\n   */\n  getTerminalBinding(moduleGraph) {\n    let resolveTargetFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETURNS_TRUE;\n    if (this.terminalBinding) return this;\n    const target = this.getTarget(moduleGraph, resolveTargetFilter);\n    if (!target) return undefined;\n    const exportsInfo = moduleGraph.getExportsInfo(target.module);\n    if (!target.export) return exportsInfo;\n    return exportsInfo.getReadOnlyExportInfoRecursive(target.export);\n  }\n  isReexport() {\n    return !this.terminalBinding && this._target && this._target.size > 0;\n  }\n  _getMaxTarget() {\n    if (this._maxTarget !== undefined) return this._maxTarget;\n    if (this._target.size <= 1) return this._maxTarget = this._target;\n    let maxPriority = -Infinity;\n    let minPriority = Infinity;\n    for (const {\n      priority\n    } of this._target.values()) {\n      if (maxPriority < priority) maxPriority = priority;\n      if (minPriority > priority) minPriority = priority;\n    }\n    // This should be very common\n    if (maxPriority === minPriority) return this._maxTarget = this._target;\n\n    // This is an edge case\n    const map = new Map();\n    for (const [key, value] of this._target) {\n      if (maxPriority === value.priority) {\n        map.set(key, value);\n      }\n    }\n    this._maxTarget = map;\n    return map;\n  }\n\n  /**\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {function(Module): boolean} validTargetModuleFilter a valid target module\r\n   * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\r\n   */\n  findTarget(moduleGraph, validTargetModuleFilter) {\n    return this._findTarget(moduleGraph, validTargetModuleFilter, new Set());\n  }\n\n  /**\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {function(Module): boolean} validTargetModuleFilter a valid target module\r\n   * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\r\n   * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\r\n   */\n  _findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {\n    if (!this._target || this._target.size === 0) return undefined;\n    let rawTarget = this._getMaxTarget().values().next().value;\n    if (!rawTarget) return undefined;\n    /** @type {{ module: Module, export: string[] | undefined }} */\n    let target = {\n      module: rawTarget.connection.module,\n      export: rawTarget.export\n    };\n    for (;;) {\n      if (validTargetModuleFilter(target.module)) return target;\n      const exportsInfo = moduleGraph.getExportsInfo(target.module);\n      const exportInfo = exportsInfo.getExportInfo(target.export[0]);\n      if (alreadyVisited.has(exportInfo)) return null;\n      const newTarget = exportInfo._findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited);\n      if (!newTarget) return false;\n      if (target.export.length === 1) {\n        target = newTarget;\n      } else {\n        target = {\n          module: newTarget.module,\n          export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)\n        };\n      }\n    }\n  }\n\n  /**\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n   * @returns {{ module: Module, export: string[] | undefined } | undefined} the target\r\n   */\n  getTarget(moduleGraph) {\n    let resolveTargetFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETURNS_TRUE;\n    const result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n    if (result === CIRCULAR) return undefined;\n    return result;\n  }\n\n  /**\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n   * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\r\n   * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target\r\n   */\n  _getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {\n    /**\r\n     * @param {{ connection: ModuleGraphConnection, export: string[] | undefined } | null} inputTarget unresolved target\r\n     * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references\r\n     * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | null} resolved target\r\n     */\n    const resolveTarget = (inputTarget, alreadyVisited) => {\n      if (!inputTarget) return null;\n      if (!inputTarget.export) {\n        return {\n          module: inputTarget.connection.module,\n          connection: inputTarget.connection,\n          export: undefined\n        };\n      }\n      /** @type {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }} */\n      let target = {\n        module: inputTarget.connection.module,\n        connection: inputTarget.connection,\n        export: inputTarget.export\n      };\n      if (!resolveTargetFilter(target)) return target;\n      let alreadyVisitedOwned = false;\n      for (;;) {\n        const exportsInfo = moduleGraph.getExportsInfo(target.module);\n        const exportInfo = exportsInfo.getExportInfo(target.export[0]);\n        if (!exportInfo) return target;\n        if (alreadyVisited.has(exportInfo)) return CIRCULAR;\n        const newTarget = exportInfo._getTarget(moduleGraph, resolveTargetFilter, alreadyVisited);\n        if (newTarget === CIRCULAR) return CIRCULAR;\n        if (!newTarget) return target;\n        if (target.export.length === 1) {\n          target = newTarget;\n          if (!target.export) return target;\n        } else {\n          target = {\n            module: newTarget.module,\n            connection: newTarget.connection,\n            export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)\n          };\n        }\n        if (!resolveTargetFilter(target)) return target;\n        if (!alreadyVisitedOwned) {\n          alreadyVisited = new Set(alreadyVisited);\n          alreadyVisitedOwned = true;\n        }\n        alreadyVisited.add(exportInfo);\n      }\n    };\n    if (!this._target || this._target.size === 0) return undefined;\n    if (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;\n    const newAlreadyVisited = new Set(alreadyVisited);\n    newAlreadyVisited.add(this);\n    const values = this._getMaxTarget().values();\n    const target = resolveTarget(values.next().value, newAlreadyVisited);\n    if (target === CIRCULAR) return CIRCULAR;\n    if (target === null) return undefined;\n    let result = values.next();\n    while (!result.done) {\n      const t = resolveTarget(result.value, newAlreadyVisited);\n      if (t === CIRCULAR) return CIRCULAR;\n      if (t === null) return undefined;\n      if (t.module !== target.module) return undefined;\n      if (!t.export !== !target.export) return undefined;\n      if (target.export && !equals(t.export, target.export)) return undefined;\n      result = values.next();\n    }\n    return target;\n  }\n\n  /**\r\n   * Move the target forward as long resolveTargetFilter is fulfilled\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n   * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection\r\n   * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved\r\n   */\n  moveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {\n    const target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n    if (target === CIRCULAR) return undefined;\n    if (!target) return undefined;\n    const originalTarget = this._getMaxTarget().values().next().value;\n    if (originalTarget.connection === target.connection && originalTarget.export === target.export) {\n      return undefined;\n    }\n    this._target.clear();\n    this._target.set(undefined, {\n      connection: updateOriginalConnection ? updateOriginalConnection(target) : target.connection,\n      export: target.export,\n      priority: 0\n    });\n    return target;\n  }\n  createNestedExportsInfo() {\n    if (this.exportsInfoOwned) return this.exportsInfo;\n    this.exportsInfoOwned = true;\n    const oldExportsInfo = this.exportsInfo;\n    this.exportsInfo = new ExportsInfo();\n    this.exportsInfo.setHasProvideInfo();\n    if (oldExportsInfo) {\n      this.exportsInfo.setRedirectNamedTo(oldExportsInfo);\n    }\n    return this.exportsInfo;\n  }\n  getNestedExportsInfo() {\n    return this.exportsInfo;\n  }\n  hasInfo(baseInfo, runtime) {\n    return this._usedName && this._usedName !== this.name || this.provided || this.terminalBinding || this.getUsed(runtime) !== baseInfo.getUsed(runtime);\n  }\n  updateHash(hash, runtime) {\n    this._updateHash(hash, runtime, new Set());\n  }\n  _updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n    hash.update(`${this._usedName || this.name}${this.getUsed(runtime)}${this.provided}${this.terminalBinding}`);\n    if (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {\n      this.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);\n    }\n  }\n  getUsedInfo() {\n    if (this._globalUsed !== undefined) {\n      switch (this._globalUsed) {\n        case UsageState.Unused:\n          return \"unused\";\n        case UsageState.NoInfo:\n          return \"no usage info\";\n        case UsageState.Unknown:\n          return \"maybe used (runtime-defined)\";\n        case UsageState.Used:\n          return \"used\";\n        case UsageState.OnlyPropertiesUsed:\n          return \"only properties used\";\n      }\n    } else if (this._usedInRuntime !== undefined) {\n      /** @type {Map<RuntimeUsageStateType, string[]>} */\n      const map = new Map();\n      for (const [runtime, used] of this._usedInRuntime) {\n        const list = map.get(used);\n        if (list !== undefined) list.push(runtime);else map.set(used, [runtime]);\n      }\n      const specificInfo = Array.from(map, _ref4 => {\n        let [used, runtimes] = _ref4;\n        switch (used) {\n          case UsageState.NoInfo:\n            return `no usage info in ${runtimes.join(\", \")}`;\n          case UsageState.Unknown:\n            return `maybe used in ${runtimes.join(\", \")} (runtime-defined)`;\n          case UsageState.Used:\n            return `used in ${runtimes.join(\", \")}`;\n          case UsageState.OnlyPropertiesUsed:\n            return `only properties used in ${runtimes.join(\", \")}`;\n        }\n      });\n      if (specificInfo.length > 0) {\n        return specificInfo.join(\"; \");\n      }\n    }\n    return this._hasUseInRuntimeInfo ? \"unused\" : \"no usage info\";\n  }\n  getProvidedInfo() {\n    switch (this.provided) {\n      case undefined:\n        return \"no provided info\";\n      case null:\n        return \"maybe provided (runtime-defined)\";\n      case true:\n        return \"provided\";\n      case false:\n        return \"not provided\";\n    }\n  }\n  getRenameInfo() {\n    if (this._usedName !== null && this._usedName !== this.name) {\n      return `renamed to ${JSON.stringify(this._usedName).slice(1, -1)}`;\n    }\n    switch (this.canMangleProvide) {\n      case undefined:\n        switch (this.canMangleUse) {\n          case undefined:\n            return \"missing provision and use info prevents renaming\";\n          case false:\n            return \"usage prevents renaming (no provision info)\";\n          case true:\n            return \"missing provision info prevents renaming\";\n        }\n        break;\n      case true:\n        switch (this.canMangleUse) {\n          case undefined:\n            return \"missing usage info prevents renaming\";\n          case false:\n            return \"usage prevents renaming\";\n          case true:\n            return \"could be renamed\";\n        }\n        break;\n      case false:\n        switch (this.canMangleUse) {\n          case undefined:\n            return \"provision prevents renaming (no use info)\";\n          case false:\n            return \"usage and provision prevents renaming\";\n          case true:\n            return \"provision prevents renaming\";\n        }\n        break;\n    }\n    throw new Error(`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`);\n  }\n}\nmodule.exports = ExportsInfo;\nmodule.exports.ExportInfo = ExportInfo;\nmodule.exports.UsageState = UsageState;","map":{"version":3,"names":["equals","require","SortableSet","makeSerializable","forEachRuntime","UsageState","Object","freeze","Unused","OnlyPropertiesUsed","NoInfo","Unknown","Used","RETURNS_TRUE","CIRCULAR","Symbol","RestoreProvidedData","constructor","exports","otherProvided","otherCanMangleProvide","otherTerminalBinding","serialize","write","deserialize","read","ExportsInfo","_exports","Map","_otherExportsInfo","ExportInfo","_sideEffectsOnlyInfo","_exportsAreOrdered","_redirectTo","undefined","ownedExports","values","orderedOwnedExports","_sortExports","map","key","value","set","orderedExports","Array","from","item","name","_sortExportsMap","otherExportsInfo","size","namesInOrder","entry","push","sort","i","length","correctEntry","get","delete","setRedirectNamedTo","exportsInfo","setHasProvideInfo","exportInfo","provided","canMangleProvide","setHasUseInfo","canMangleUse","getOwnExportInfo","info","newInfo","getExportInfo","getReadOnlyExportInfo","getReadOnlyExportInfoRecursive","slice","getNestedExportsInfo","isArray","setUnknownExportsProvided","canMangle","excludeExports","targetKey","targetModule","priority","changed","has","setTarget","setUsedInUnknownWay","runtime","setUsedConditionally","used","setUsedWithoutInfo","setUsed","setAllKnownExportsUsed","setUsedForSideEffectsOnly","isUsed","getUsed","isModuleUsed","getUsedExports","array","inner","getProvidedExports","includes","getRelevantExports","list","isExportProvided","getUsageKey","join","isEquallyUsed","runtimeA","runtimeB","getUsedName","x","arr","nested","concat","usedName","updateHash","hash","_updateHash","Set","alreadyVisitedExportsInfo","add","hasInfo","getRestoreProvidedData","terminalBinding","exportsInfoOwned","restoreProvided","wasEmpty","exp","createNestedExportsInfo","initFrom","_usedName","_globalUsed","_usedInRuntime","_hasUseInRuntimeInfo","_target","connection","export","_maxTarget","Error","v","condition","newValue","oldValue","unsetTarget","exportName","oldTarget","max","fallbackName","every","hasUsedName","setUsedName","getTerminalBinding","moduleGraph","resolveTargetFilter","target","getTarget","getExportsInfo","module","isReexport","_getMaxTarget","maxPriority","Infinity","minPriority","findTarget","validTargetModuleFilter","_findTarget","alreadyVisited","rawTarget","next","newTarget","result","_getTarget","resolveTarget","inputTarget","alreadyVisitedOwned","newAlreadyVisited","done","t","moveTarget","updateOriginalConnection","originalTarget","clear","oldExportsInfo","baseInfo","update","getUsedInfo","specificInfo","runtimes","getProvidedInfo","getRenameInfo","JSON","stringify"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/ExportsInfo.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { equals } = require(\"./util/ArrayHelpers\");\r\nconst SortableSet = require(\"./util/SortableSet\");\r\nconst makeSerializable = require(\"./util/makeSerializable\");\r\nconst { forEachRuntime } = require(\"./util/runtime\");\r\n\r\n/** @typedef {import(\"./Dependency\").RuntimeSpec} RuntimeSpec */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\r\n/** @typedef {import(\"./ModuleGraphConnection\")} ModuleGraphConnection */\r\n/** @typedef {import(\"./util/Hash\")} Hash */\r\n\r\n/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */\r\n/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */\r\n\r\nconst UsageState = Object.freeze({\r\n\tUnused: /** @type {0} */ (0),\r\n\tOnlyPropertiesUsed: /** @type {1} */ (1),\r\n\tNoInfo: /** @type {2} */ (2),\r\n\tUnknown: /** @type {3} */ (3),\r\n\tUsed: /** @type {4} */ (4)\r\n});\r\n\r\nconst RETURNS_TRUE = () => true;\r\n\r\nconst CIRCULAR = Symbol(\"circular target\");\r\n\r\nclass RestoreProvidedData {\r\n\tconstructor(\r\n\t\texports,\r\n\t\totherProvided,\r\n\t\totherCanMangleProvide,\r\n\t\totherTerminalBinding\r\n\t) {\r\n\t\tthis.exports = exports;\r\n\t\tthis.otherProvided = otherProvided;\r\n\t\tthis.otherCanMangleProvide = otherCanMangleProvide;\r\n\t\tthis.otherTerminalBinding = otherTerminalBinding;\r\n\t}\r\n\r\n\tserialize({ write }) {\r\n\t\twrite(this.exports);\r\n\t\twrite(this.otherProvided);\r\n\t\twrite(this.otherCanMangleProvide);\r\n\t\twrite(this.otherTerminalBinding);\r\n\t}\r\n\r\n\tstatic deserialize({ read }) {\r\n\t\treturn new RestoreProvidedData(read(), read(), read(), read());\r\n\t}\r\n}\r\n\r\nmakeSerializable(\r\n\tRestoreProvidedData,\r\n\t\"webpack/lib/ModuleGraph\",\r\n\t\"RestoreProvidedData\"\r\n);\r\n\r\nclass ExportsInfo {\r\n\tconstructor() {\r\n\t\t/** @type {Map<string, ExportInfo>} */\r\n\t\tthis._exports = new Map();\r\n\t\tthis._otherExportsInfo = new ExportInfo(null);\r\n\t\tthis._sideEffectsOnlyInfo = new ExportInfo(\"*side effects only*\");\r\n\t\tthis._exportsAreOrdered = false;\r\n\t\t/** @type {ExportsInfo=} */\r\n\t\tthis._redirectTo = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Iterable<ExportInfo>} all owned exports in any order\r\n\t */\r\n\tget ownedExports() {\r\n\t\treturn this._exports.values();\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Iterable<ExportInfo>} all owned exports in order\r\n\t */\r\n\tget orderedOwnedExports() {\r\n\t\tif (!this._exportsAreOrdered) {\r\n\t\t\tthis._sortExports();\r\n\t\t}\r\n\t\treturn this._exports.values();\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Iterable<ExportInfo>} all exports in any order\r\n\t */\r\n\tget exports() {\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tconst map = new Map(this._redirectTo._exports);\r\n\t\t\tfor (const [key, value] of this._exports) {\r\n\t\t\t\tmap.set(key, value);\r\n\t\t\t}\r\n\t\t\treturn map.values();\r\n\t\t}\r\n\t\treturn this._exports.values();\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Iterable<ExportInfo>} all exports in order\r\n\t */\r\n\tget orderedExports() {\r\n\t\tif (!this._exportsAreOrdered) {\r\n\t\t\tthis._sortExports();\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tconst map = new Map(\r\n\t\t\t\tArray.from(this._redirectTo.orderedExports, item => [item.name, item])\r\n\t\t\t);\r\n\t\t\tfor (const [key, value] of this._exports) {\r\n\t\t\t\tmap.set(key, value);\r\n\t\t\t}\r\n\t\t\t// sorting should be pretty fast as map contains\r\n\t\t\t// a lot of presorted items\r\n\t\t\tthis._sortExportsMap(map);\r\n\t\t\treturn map.values();\r\n\t\t}\r\n\t\treturn this._exports.values();\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {ExportInfo} the export info of unlisted exports\r\n\t */\r\n\tget otherExportsInfo() {\r\n\t\tif (this._redirectTo !== undefined)\r\n\t\t\treturn this._redirectTo.otherExportsInfo;\r\n\t\treturn this._otherExportsInfo;\r\n\t}\r\n\r\n\t_sortExportsMap(exports) {\r\n\t\tif (exports.size > 1) {\r\n\t\t\tconst namesInOrder = [];\r\n\t\t\tfor (const entry of exports.values()) {\r\n\t\t\t\tnamesInOrder.push(entry.name);\r\n\t\t\t}\r\n\t\t\tnamesInOrder.sort();\r\n\t\t\tlet i = 0;\r\n\t\t\tfor (const entry of exports.values()) {\r\n\t\t\t\tconst name = namesInOrder[i];\r\n\t\t\t\tif (entry.name !== name) break;\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tfor (; i < namesInOrder.length; i++) {\r\n\t\t\t\tconst name = namesInOrder[i];\r\n\t\t\t\tconst correctEntry = exports.get(name);\r\n\t\t\t\texports.delete(name);\r\n\t\t\t\texports.set(name, correctEntry);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t_sortExports() {\r\n\t\tthis._sortExportsMap(this._exports);\r\n\t\tthis._exportsAreOrdered = true;\r\n\t}\r\n\r\n\tsetRedirectNamedTo(exportsInfo) {\r\n\t\tif (this._redirectTo === exportsInfo) return false;\r\n\t\tthis._redirectTo = exportsInfo;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tsetHasProvideInfo() {\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tif (exportInfo.provided === undefined) {\r\n\t\t\t\texportInfo.provided = false;\r\n\t\t\t}\r\n\t\t\tif (exportInfo.canMangleProvide === undefined) {\r\n\t\t\t\texportInfo.canMangleProvide = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tthis._redirectTo.setHasProvideInfo();\r\n\t\t} else {\r\n\t\t\tif (this._otherExportsInfo.provided === undefined) {\r\n\t\t\t\tthis._otherExportsInfo.provided = false;\r\n\t\t\t}\r\n\t\t\tif (this._otherExportsInfo.canMangleProvide === undefined) {\r\n\t\t\t\tthis._otherExportsInfo.canMangleProvide = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tsetHasUseInfo() {\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\texportInfo.setHasUseInfo();\r\n\t\t}\r\n\t\tthis._sideEffectsOnlyInfo.setHasUseInfo();\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tthis._redirectTo.setHasUseInfo();\r\n\t\t} else {\r\n\t\t\tthis._otherExportsInfo.setHasUseInfo();\r\n\t\t\tif (this._otherExportsInfo.canMangleUse === undefined) {\r\n\t\t\t\tthis._otherExportsInfo.canMangleUse = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} name export name\r\n\t * @returns {ExportInfo} export info for this name\r\n\t */\r\n\tgetOwnExportInfo(name) {\r\n\t\tconst info = this._exports.get(name);\r\n\t\tif (info !== undefined) return info;\r\n\t\tconst newInfo = new ExportInfo(name, this._otherExportsInfo);\r\n\t\tthis._exports.set(name, newInfo);\r\n\t\tthis._exportsAreOrdered = false;\r\n\t\treturn newInfo;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} name export name\r\n\t * @returns {ExportInfo} export info for this name\r\n\t */\r\n\tgetExportInfo(name) {\r\n\t\tconst info = this._exports.get(name);\r\n\t\tif (info !== undefined) return info;\r\n\t\tif (this._redirectTo !== undefined)\r\n\t\t\treturn this._redirectTo.getExportInfo(name);\r\n\t\tconst newInfo = new ExportInfo(name, this._otherExportsInfo);\r\n\t\tthis._exports.set(name, newInfo);\r\n\t\tthis._exportsAreOrdered = false;\r\n\t\treturn newInfo;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} name export name\r\n\t * @returns {ExportInfo} export info for this name\r\n\t */\r\n\tgetReadOnlyExportInfo(name) {\r\n\t\tconst info = this._exports.get(name);\r\n\t\tif (info !== undefined) return info;\r\n\t\tif (this._redirectTo !== undefined)\r\n\t\t\treturn this._redirectTo.getReadOnlyExportInfo(name);\r\n\t\treturn this._otherExportsInfo;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string[]} name export name\r\n\t * @returns {ExportInfo | undefined} export info for this name\r\n\t */\r\n\tgetReadOnlyExportInfoRecursive(name) {\r\n\t\tconst exportInfo = this.getReadOnlyExportInfo(name[0]);\r\n\t\tif (name.length === 1) return exportInfo;\r\n\t\tif (!exportInfo.exportsInfo) return undefined;\r\n\t\treturn exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string[]=} name the export name\r\n\t * @returns {ExportsInfo | undefined} the nested exports info\r\n\t */\r\n\tgetNestedExportsInfo(name) {\r\n\t\tif (Array.isArray(name) && name.length > 0) {\r\n\t\t\tconst info = this.getReadOnlyExportInfo(name[0]);\r\n\t\t\tif (!info.exportsInfo) return undefined;\r\n\t\t\treturn info.exportsInfo.getNestedExportsInfo(name.slice(1));\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)\r\n\t * @param {Set<string>=} excludeExports list of unaffected exports\r\n\t * @param {any=} targetKey use this as key for the target\r\n\t * @param {ModuleGraphConnection=} targetModule set this module as target\r\n\t * @param {number=} priority priority\r\n\t * @returns {boolean} true, if this call changed something\r\n\t */\r\n\tsetUnknownExportsProvided(\r\n\t\tcanMangle,\r\n\t\texcludeExports,\r\n\t\ttargetKey,\r\n\t\ttargetModule,\r\n\t\tpriority\r\n\t) {\r\n\t\tlet changed = false;\r\n\t\tif (excludeExports) {\r\n\t\t\tfor (const name of excludeExports) {\r\n\t\t\t\t// Make sure these entries exist, so they can get different info\r\n\t\t\t\tthis.getExportInfo(name);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tif (!canMangle && exportInfo.canMangleProvide !== false) {\r\n\t\t\t\texportInfo.canMangleProvide = false;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\tif (excludeExports && excludeExports.has(exportInfo.name)) continue;\r\n\t\t\tif (exportInfo.provided !== true && exportInfo.provided !== null) {\r\n\t\t\t\texportInfo.provided = null;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\tif (targetKey) {\r\n\t\t\t\texportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tif (\r\n\t\t\t\tthis._redirectTo.setUnknownExportsProvided(\r\n\t\t\t\t\tcanMangle,\r\n\t\t\t\t\texcludeExports,\r\n\t\t\t\t\ttargetKey,\r\n\t\t\t\t\ttargetModule,\r\n\t\t\t\t\tpriority\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (\r\n\t\t\t\tthis._otherExportsInfo.provided !== true &&\r\n\t\t\t\tthis._otherExportsInfo.provided !== null\r\n\t\t\t) {\r\n\t\t\t\tthis._otherExportsInfo.provided = null;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\tif (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {\r\n\t\t\t\tthis._otherExportsInfo.canMangleProvide = false;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\tif (targetKey) {\r\n\t\t\t\tthis._otherExportsInfo.setTarget(\r\n\t\t\t\t\ttargetKey,\r\n\t\t\t\t\ttargetModule,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tpriority\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, when something changed\r\n\t */\r\n\tsetUsedInUnknownWay(runtime) {\r\n\t\tlet changed = false;\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tif (exportInfo.setUsedInUnknownWay(runtime)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tif (this._redirectTo.setUsedInUnknownWay(runtime)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (\r\n\t\t\t\tthis._otherExportsInfo.setUsedConditionally(\r\n\t\t\t\t\tused => used < UsageState.Unknown,\r\n\t\t\t\t\tUsageState.Unknown,\r\n\t\t\t\t\truntime\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\tif (this._otherExportsInfo.canMangleUse !== false) {\r\n\t\t\t\tthis._otherExportsInfo.canMangleUse = false;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, when something changed\r\n\t */\r\n\tsetUsedWithoutInfo(runtime) {\r\n\t\tlet changed = false;\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tif (exportInfo.setUsedWithoutInfo(runtime)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tif (this._redirectTo.setUsedWithoutInfo(runtime)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\tif (this._otherExportsInfo.canMangleUse !== false) {\r\n\t\t\t\tthis._otherExportsInfo.canMangleUse = false;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, when something changed\r\n\t */\r\n\tsetAllKnownExportsUsed(runtime) {\r\n\t\tlet changed = false;\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tif (!exportInfo.provided) continue;\r\n\t\t\tif (exportInfo.setUsed(UsageState.Used, runtime)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, when something changed\r\n\t */\r\n\tsetUsedForSideEffectsOnly(runtime) {\r\n\t\treturn this._sideEffectsOnlyInfo.setUsedConditionally(\r\n\t\t\tused => used === UsageState.Unused,\r\n\t\t\tUsageState.Used,\r\n\t\t\truntime\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, when the module exports are used in any way\r\n\t */\r\n\tisUsed(runtime) {\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tif (this._redirectTo.isUsed(runtime)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tif (exportInfo.getUsed(runtime) !== UsageState.Unused) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, when the module is used in any way\r\n\t */\r\n\tisModuleUsed(runtime) {\r\n\t\tif (this.isUsed(runtime)) return true;\r\n\t\tif (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused)\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)\r\n\t */\r\n\tgetUsedExports(runtime) {\r\n\t\tif (!this._redirectTo !== undefined) {\r\n\t\t\tswitch (this._otherExportsInfo.getUsed(runtime)) {\r\n\t\t\t\tcase UsageState.NoInfo:\r\n\t\t\t\t\treturn null;\r\n\t\t\t\tcase UsageState.Unknown:\r\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\r\n\t\t\t\tcase UsageState.Used:\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst array = [];\r\n\t\tif (!this._exportsAreOrdered) this._sortExports();\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tswitch (exportInfo.getUsed(runtime)) {\r\n\t\t\t\tcase UsageState.NoInfo:\r\n\t\t\t\t\treturn null;\r\n\t\t\t\tcase UsageState.Unknown:\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\r\n\t\t\t\tcase UsageState.Used:\r\n\t\t\t\t\tarray.push(exportInfo.name);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tconst inner = this._redirectTo.getUsedExports(runtime);\r\n\t\t\tif (inner === null) return null;\r\n\t\t\tif (inner === true) return true;\r\n\t\t\tif (inner !== false) {\r\n\t\t\t\tfor (const item of inner) {\r\n\t\t\t\t\tarray.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (array.length === 0) {\r\n\t\t\tswitch (this._sideEffectsOnlyInfo.getUsed(runtime)) {\r\n\t\t\t\tcase UsageState.NoInfo:\r\n\t\t\t\t\treturn null;\r\n\t\t\t\tcase UsageState.Unused:\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new SortableSet(array);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {null | true | string[]} list of exports when known\r\n\t */\r\n\tgetProvidedExports() {\r\n\t\tif (!this._redirectTo !== undefined) {\r\n\t\t\tswitch (this._otherExportsInfo.provided) {\r\n\t\t\t\tcase undefined:\r\n\t\t\t\t\treturn null;\r\n\t\t\t\tcase null:\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase true:\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst array = [];\r\n\t\tif (!this._exportsAreOrdered) this._sortExports();\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tswitch (exportInfo.provided) {\r\n\t\t\t\tcase undefined:\r\n\t\t\t\t\treturn null;\r\n\t\t\t\tcase null:\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase true:\r\n\t\t\t\t\tarray.push(exportInfo.name);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tconst inner = this._redirectTo.getProvidedExports();\r\n\t\t\tif (inner === null) return null;\r\n\t\t\tif (inner === true) return true;\r\n\t\t\tfor (const item of inner) {\r\n\t\t\t\tif (!array.includes(item)) {\r\n\t\t\t\t\tarray.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)\r\n\t */\r\n\tgetRelevantExports(runtime) {\r\n\t\tconst list = [];\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\tconst used = exportInfo.getUsed(runtime);\r\n\t\t\tif (used === UsageState.Unused) continue;\r\n\t\t\tif (exportInfo.provided === false) continue;\r\n\t\t\tlist.push(exportInfo);\r\n\t\t}\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tfor (const exportInfo of this._redirectTo.getRelevantExports(runtime)) {\r\n\t\t\t\tif (!this._exports.has(exportInfo.name)) list.push(exportInfo);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (\r\n\t\t\tthis._otherExportsInfo.provided !== false &&\r\n\t\t\tthis._otherExportsInfo.getUsed(runtime) !== UsageState.Unused\r\n\t\t) {\r\n\t\t\tlist.push(this._otherExportsInfo);\r\n\t\t}\r\n\t\treturn list;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string | string[]} name the name of the export\r\n\t * @returns {boolean | undefined | null} if the export is provided\r\n\t */\r\n\tisExportProvided(name) {\r\n\t\tif (Array.isArray(name)) {\r\n\t\t\tconst info = this.getReadOnlyExportInfo(name[0]);\r\n\t\t\tif (info.exportsInfo && name.length > 1) {\r\n\t\t\t\treturn info.exportsInfo.isExportProvided(name.slice(1));\r\n\t\t\t}\r\n\t\t\treturn info.provided ? name.length === 1 || undefined : info.provided;\r\n\t\t}\r\n\t\tconst info = this.getReadOnlyExportInfo(name);\r\n\t\treturn info.provided;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime runtime\r\n\t * @returns {string} key representing the usage\r\n\t */\r\n\tgetUsageKey(runtime) {\r\n\t\tconst key = [];\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tkey.push(this._redirectTo.getUsageKey(runtime));\r\n\t\t} else {\r\n\t\t\tkey.push(this._otherExportsInfo.getUsed(runtime));\r\n\t\t}\r\n\t\tkey.push(this._sideEffectsOnlyInfo.getUsed(runtime));\r\n\t\tfor (const exportInfo of this.orderedOwnedExports) {\r\n\t\t\tkey.push(exportInfo.getUsed(runtime));\r\n\t\t}\r\n\t\treturn key.join(\"|\");\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtimeA first runtime\r\n\t * @param {RuntimeSpec} runtimeB second runtime\r\n\t * @returns {boolean} true, when equally used\r\n\t */\r\n\tisEquallyUsed(runtimeA, runtimeB) {\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tif (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;\r\n\t\t} else {\r\n\t\t\tif (\r\n\t\t\t\tthis._otherExportsInfo.getUsed(runtimeA) !==\r\n\t\t\t\tthis._otherExportsInfo.getUsed(runtimeB)\r\n\t\t\t) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (\r\n\t\t\tthis._sideEffectsOnlyInfo.getUsed(runtimeA) !==\r\n\t\t\tthis._sideEffectsOnlyInfo.getUsed(runtimeB)\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (const exportInfo of this.ownedExports) {\r\n\t\t\tif (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string | string[]} name export name\r\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\r\n\t * @returns {UsageStateType} usage status\r\n\t */\r\n\tgetUsed(name, runtime) {\r\n\t\tif (Array.isArray(name)) {\r\n\t\t\tif (name.length === 0) return this.otherExportsInfo.getUsed(runtime);\r\n\t\t\tlet info = this.getReadOnlyExportInfo(name[0]);\r\n\t\t\tif (info.exportsInfo && name.length > 1) {\r\n\t\t\t\treturn info.exportsInfo.getUsed(name.slice(1), runtime);\r\n\t\t\t}\r\n\t\t\treturn info.getUsed(runtime);\r\n\t\t}\r\n\t\tlet info = this.getReadOnlyExportInfo(name);\r\n\t\treturn info.getUsed(runtime);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string | string[]} name the export name\r\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\r\n\t * @returns {string | string[] | false} the used name\r\n\t */\r\n\tgetUsedName(name, runtime) {\r\n\t\tif (Array.isArray(name)) {\r\n\t\t\t// TODO improve this\r\n\t\t\tif (name.length === 0) {\r\n\t\t\t\tif (!this.isUsed(runtime)) return false;\r\n\t\t\t\treturn name;\r\n\t\t\t}\r\n\t\t\tlet info = this.getReadOnlyExportInfo(name[0]);\r\n\t\t\tconst x = info.getUsedName(name[0], runtime);\r\n\t\t\tif (x === false) return false;\r\n\t\t\tconst arr = x === name[0] && name.length === 1 ? name : [x];\r\n\t\t\tif (name.length === 1) {\r\n\t\t\t\treturn arr;\r\n\t\t\t}\r\n\t\t\tif (\r\n\t\t\t\tinfo.exportsInfo &&\r\n\t\t\t\tinfo.getUsed(runtime) === UsageState.OnlyPropertiesUsed\r\n\t\t\t) {\r\n\t\t\t\tconst nested = info.exportsInfo.getUsedName(name.slice(1), runtime);\r\n\t\t\t\tif (!nested) return false;\r\n\t\t\t\treturn arr.concat(nested);\r\n\t\t\t} else {\r\n\t\t\t\treturn arr.concat(name.slice(1));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet info = this.getReadOnlyExportInfo(name);\r\n\t\t\tconst usedName = info.getUsedName(name, runtime);\r\n\t\t\treturn usedName;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Hash} hash the hash\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {void}\r\n\t */\r\n\tupdateHash(hash, runtime) {\r\n\t\tthis._updateHash(hash, runtime, new Set());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Hash} hash the hash\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references\r\n\t * @returns {void}\r\n\t */\r\n\t_updateHash(hash, runtime, alreadyVisitedExportsInfo) {\r\n\t\tconst set = new Set(alreadyVisitedExportsInfo);\r\n\t\tset.add(this);\r\n\t\tfor (const exportInfo of this.orderedExports) {\r\n\t\t\tif (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {\r\n\t\t\t\texportInfo._updateHash(hash, runtime, set);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._sideEffectsOnlyInfo._updateHash(hash, runtime, set);\r\n\t\tthis._otherExportsInfo._updateHash(hash, runtime, set);\r\n\t\tif (this._redirectTo !== undefined) {\r\n\t\t\tthis._redirectTo._updateHash(hash, runtime, set);\r\n\t\t}\r\n\t}\r\n\r\n\tgetRestoreProvidedData() {\r\n\t\tconst otherProvided = this._otherExportsInfo.provided;\r\n\t\tconst otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;\r\n\t\tconst otherTerminalBinding = this._otherExportsInfo.terminalBinding;\r\n\t\tconst exports = [];\r\n\t\tfor (const exportInfo of this.orderedExports) {\r\n\t\t\tif (\r\n\t\t\t\texportInfo.provided !== otherProvided ||\r\n\t\t\t\texportInfo.canMangleProvide !== otherCanMangleProvide ||\r\n\t\t\t\texportInfo.terminalBinding !== otherTerminalBinding ||\r\n\t\t\t\texportInfo.exportsInfoOwned\r\n\t\t\t) {\r\n\t\t\t\texports.push({\r\n\t\t\t\t\tname: exportInfo.name,\r\n\t\t\t\t\tprovided: exportInfo.provided,\r\n\t\t\t\t\tcanMangleProvide: exportInfo.canMangleProvide,\r\n\t\t\t\t\tterminalBinding: exportInfo.terminalBinding,\r\n\t\t\t\t\texportsInfo: exportInfo.exportsInfoOwned\r\n\t\t\t\t\t\t? exportInfo.exportsInfo.getRestoreProvidedData()\r\n\t\t\t\t\t\t: undefined\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new RestoreProvidedData(\r\n\t\t\texports,\r\n\t\t\totherProvided,\r\n\t\t\totherCanMangleProvide,\r\n\t\t\totherTerminalBinding\r\n\t\t);\r\n\t}\r\n\r\n\trestoreProvided({\r\n\t\totherProvided,\r\n\t\totherCanMangleProvide,\r\n\t\totherTerminalBinding,\r\n\t\texports\r\n\t}) {\r\n\t\tlet wasEmpty = true;\r\n\t\tfor (const exportInfo of this._exports.values()) {\r\n\t\t\twasEmpty = false;\r\n\t\t\texportInfo.provided = otherProvided;\r\n\t\t\texportInfo.canMangleProvide = otherCanMangleProvide;\r\n\t\t\texportInfo.terminalBinding = otherTerminalBinding;\r\n\t\t}\r\n\t\tthis._otherExportsInfo.provided = otherProvided;\r\n\t\tthis._otherExportsInfo.canMangleProvide = otherCanMangleProvide;\r\n\t\tthis._otherExportsInfo.terminalBinding = otherTerminalBinding;\r\n\t\tfor (const exp of exports) {\r\n\t\t\tconst exportInfo = this.getExportInfo(exp.name);\r\n\t\t\texportInfo.provided = exp.provided;\r\n\t\t\texportInfo.canMangleProvide = exp.canMangleProvide;\r\n\t\t\texportInfo.terminalBinding = exp.terminalBinding;\r\n\t\t\tif (exp.exportsInfo) {\r\n\t\t\t\tconst exportsInfo = exportInfo.createNestedExportsInfo();\r\n\t\t\t\texportsInfo.restoreProvided(exp.exportsInfo);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (wasEmpty) this._exportsAreOrdered = true;\r\n\t}\r\n}\r\n\r\nclass ExportInfo {\r\n\t/**\r\n\t * @param {string} name the original name of the export\r\n\t * @param {ExportInfo=} initFrom init values from this ExportInfo\r\n\t */\r\n\tconstructor(name, initFrom) {\r\n\t\t/** @type {string} */\r\n\t\tthis.name = name;\r\n\t\t/** @private @type {string | null} */\r\n\t\tthis._usedName = initFrom ? initFrom._usedName : null;\r\n\t\t/** @private @type {UsageStateType} */\r\n\t\tthis._globalUsed = initFrom ? initFrom._globalUsed : undefined;\r\n\t\t/** @private @type {Map<string, RuntimeUsageStateType>} */\r\n\t\tthis._usedInRuntime =\r\n\t\t\tinitFrom && initFrom._usedInRuntime\r\n\t\t\t\t? new Map(initFrom._usedInRuntime)\r\n\t\t\t\t: undefined;\r\n\t\t/** @private @type {boolean} */\r\n\t\tthis._hasUseInRuntimeInfo = initFrom\r\n\t\t\t? initFrom._hasUseInRuntimeInfo\r\n\t\t\t: false;\r\n\t\t/**\r\n\t\t * true: it is provided\r\n\t\t * false: it is not provided\r\n\t\t * null: only the runtime knows if it is provided\r\n\t\t * undefined: it was not determined if it is provided\r\n\t\t * @type {boolean | null | undefined}\r\n\t\t */\r\n\t\tthis.provided = initFrom ? initFrom.provided : undefined;\r\n\t\t/**\r\n\t\t * is the export a terminal binding that should be checked for export star conflicts\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.terminalBinding = initFrom ? initFrom.terminalBinding : false;\r\n\t\t/**\r\n\t\t * true: it can be mangled\r\n\t\t * false: is can not be mangled\r\n\t\t * undefined: it was not determined if it can be mangled\r\n\t\t * @type {boolean | undefined}\r\n\t\t */\r\n\t\tthis.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;\r\n\t\t/**\r\n\t\t * true: it can be mangled\r\n\t\t * false: is can not be mangled\r\n\t\t * undefined: it was not determined if it can be mangled\r\n\t\t * @type {boolean | undefined}\r\n\t\t */\r\n\t\tthis.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;\r\n\t\t/** @type {boolean} */\r\n\t\tthis.exportsInfoOwned = false;\r\n\t\t/** @type {ExportsInfo=} */\r\n\t\tthis.exportsInfo = undefined;\r\n\t\t/** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\r\n\t\tthis._target = undefined;\r\n\t\tif (initFrom && initFrom._target) {\r\n\t\t\tthis._target = new Map();\r\n\t\t\tfor (const [key, value] of initFrom._target) {\r\n\t\t\t\tthis._target.set(key, {\r\n\t\t\t\t\tconnection: value.connection,\r\n\t\t\t\t\texport: value.export || [name],\r\n\t\t\t\t\tpriority: value.priority\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t/** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\r\n\t\tthis._maxTarget = undefined;\r\n\t}\r\n\r\n\t// TODO webpack 5 remove\r\n\t/** @private */\r\n\tget used() {\r\n\t\tthrow new Error(\"REMOVED\");\r\n\t}\r\n\t/** @private */\r\n\tget usedName() {\r\n\t\tthrow new Error(\"REMOVED\");\r\n\t}\r\n\t/**\r\n\t * @private\r\n\t * @param {*} v v\r\n\t */\r\n\tset used(v) {\r\n\t\tthrow new Error(\"REMOVED\");\r\n\t}\r\n\t/**\r\n\t * @private\r\n\t * @param {*} v v\r\n\t */\r\n\tset usedName(v) {\r\n\t\tthrow new Error(\"REMOVED\");\r\n\t}\r\n\r\n\tget canMangle() {\r\n\t\tswitch (this.canMangleProvide) {\r\n\t\t\tcase undefined:\r\n\t\t\t\treturn this.canMangleUse === false ? false : undefined;\r\n\t\t\tcase false:\r\n\t\t\t\treturn false;\r\n\t\t\tcase true:\r\n\t\t\t\tswitch (this.canMangleUse) {\r\n\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t}\r\n\t\tthrow new Error(\r\n\t\t\t`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime only apply to this runtime\r\n\t * @returns {boolean} true, when something changed\r\n\t */\r\n\tsetUsedInUnknownWay(runtime) {\r\n\t\tlet changed = false;\r\n\t\tif (\r\n\t\t\tthis.setUsedConditionally(\r\n\t\t\t\tused => used < UsageState.Unknown,\r\n\t\t\t\tUsageState.Unknown,\r\n\t\t\t\truntime\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\tchanged = true;\r\n\t\t}\r\n\t\tif (this.canMangleUse !== false) {\r\n\t\t\tthis.canMangleUse = false;\r\n\t\t\tchanged = true;\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime only apply to this runtime\r\n\t * @returns {boolean} true, when something changed\r\n\t */\r\n\tsetUsedWithoutInfo(runtime) {\r\n\t\tlet changed = false;\r\n\t\tif (this.setUsed(UsageState.NoInfo, runtime)) {\r\n\t\t\tchanged = true;\r\n\t\t}\r\n\t\tif (this.canMangleUse !== false) {\r\n\t\t\tthis.canMangleUse = false;\r\n\t\t\tchanged = true;\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tsetHasUseInfo() {\r\n\t\tif (!this._hasUseInRuntimeInfo) {\r\n\t\t\tthis._hasUseInRuntimeInfo = true;\r\n\t\t}\r\n\t\tif (this.canMangleUse === undefined) {\r\n\t\t\tthis.canMangleUse = true;\r\n\t\t}\r\n\t\tif (this.exportsInfoOwned) {\r\n\t\t\tthis.exportsInfo.setHasUseInfo();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {function(UsageStateType): boolean} condition compare with old value\r\n\t * @param {UsageStateType} newValue set when condition is true\r\n\t * @param {RuntimeSpec} runtime only apply to this runtime\r\n\t * @returns {boolean} true when something has changed\r\n\t */\r\n\tsetUsedConditionally(condition, newValue, runtime) {\r\n\t\tif (runtime === undefined) {\r\n\t\t\tif (this._globalUsed === undefined) {\r\n\t\t\t\tthis._globalUsed = newValue;\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\tif (this._globalUsed !== newValue && condition(this._globalUsed)) {\r\n\t\t\t\t\tthis._globalUsed = newValue;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (this._usedInRuntime === undefined) {\r\n\t\t\tif (newValue !== UsageState.Unused && condition(UsageState.Unused)) {\r\n\t\t\t\tthis._usedInRuntime = new Map();\r\n\t\t\t\tforEachRuntime(runtime, runtime =>\r\n\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue)\r\n\t\t\t\t);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet changed = false;\r\n\t\t\tforEachRuntime(runtime, runtime => {\r\n\t\t\t\t/** @type {UsageStateType} */\r\n\t\t\t\tlet oldValue = this._usedInRuntime.get(runtime);\r\n\t\t\t\tif (oldValue === undefined) oldValue = UsageState.Unused;\r\n\t\t\t\tif (newValue !== oldValue && condition(oldValue)) {\r\n\t\t\t\t\tif (newValue === UsageState.Unused) {\r\n\t\t\t\t\t\tthis._usedInRuntime.delete(runtime);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif (changed) {\r\n\t\t\t\tif (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {UsageStateType} newValue new value of the used state\r\n\t * @param {RuntimeSpec} runtime only apply to this runtime\r\n\t * @returns {boolean} true when something has changed\r\n\t */\r\n\tsetUsed(newValue, runtime) {\r\n\t\tif (runtime === undefined) {\r\n\t\t\tif (this._globalUsed !== newValue) {\r\n\t\t\t\tthis._globalUsed = newValue;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if (this._usedInRuntime === undefined) {\r\n\t\t\tif (newValue !== UsageState.Unused) {\r\n\t\t\t\tthis._usedInRuntime = new Map();\r\n\t\t\t\tforEachRuntime(runtime, runtime =>\r\n\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue)\r\n\t\t\t\t);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet changed = false;\r\n\t\t\tforEachRuntime(runtime, runtime => {\r\n\t\t\t\t/** @type {UsageStateType} */\r\n\t\t\t\tlet oldValue = this._usedInRuntime.get(runtime);\r\n\t\t\t\tif (oldValue === undefined) oldValue = UsageState.Unused;\r\n\t\t\t\tif (newValue !== oldValue) {\r\n\t\t\t\t\tif (newValue === UsageState.Unused) {\r\n\t\t\t\t\t\tthis._usedInRuntime.delete(runtime);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif (changed) {\r\n\t\t\t\tif (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {any} key the key\r\n\t * @returns {boolean} true, if something has changed\r\n\t */\r\n\tunsetTarget(key) {\r\n\t\tif (!this._target) return false;\r\n\t\tif (this._target.delete(key)) {\r\n\t\t\tthis._maxTarget = undefined;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {any} key the key\r\n\t * @param {ModuleGraphConnection} connection the target module if a single one\r\n\t * @param {string[]=} exportName the exported name\r\n\t * @param {number=} priority priority\r\n\t * @returns {boolean} true, if something has changed\r\n\t */\r\n\tsetTarget(key, connection, exportName, priority = 0) {\r\n\t\tif (exportName) exportName = [...exportName];\r\n\t\tif (!this._target) {\r\n\t\t\tthis._target = new Map();\r\n\t\t\tthis._target.set(key, { connection, export: exportName, priority });\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tconst oldTarget = this._target.get(key);\r\n\t\tif (!oldTarget) {\r\n\t\t\tif (oldTarget === null && !connection) return false;\r\n\t\t\tthis._target.set(key, { connection, export: exportName, priority });\r\n\t\t\tthis._maxTarget = undefined;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (\r\n\t\t\toldTarget.connection !== connection ||\r\n\t\t\toldTarget.priority !== priority ||\r\n\t\t\t(exportName\r\n\t\t\t\t? !oldTarget.export || !equals(oldTarget.export, exportName)\r\n\t\t\t\t: oldTarget.export)\r\n\t\t) {\r\n\t\t\toldTarget.connection = connection;\r\n\t\t\toldTarget.export = exportName;\r\n\t\t\toldTarget.priority = priority;\r\n\t\t\tthis._maxTarget = undefined;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime for this runtime\r\n\t * @returns {UsageStateType} usage state\r\n\t */\r\n\tgetUsed(runtime) {\r\n\t\tif (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;\r\n\t\tif (this._globalUsed !== undefined) return this._globalUsed;\r\n\t\tif (this._usedInRuntime === undefined) {\r\n\t\t\treturn UsageState.Unused;\r\n\t\t} else if (typeof runtime === \"string\") {\r\n\t\t\tconst value = this._usedInRuntime.get(runtime);\r\n\t\t\treturn value === undefined ? UsageState.Unused : value;\r\n\t\t} else if (runtime === undefined) {\r\n\t\t\t/** @type {UsageStateType} */\r\n\t\t\tlet max = UsageState.Unused;\r\n\t\t\tfor (const value of this._usedInRuntime.values()) {\r\n\t\t\t\tif (value === UsageState.Used) {\r\n\t\t\t\t\treturn UsageState.Used;\r\n\t\t\t\t}\r\n\t\t\t\tif (max < value) max = value;\r\n\t\t\t}\r\n\t\t\treturn max;\r\n\t\t} else {\r\n\t\t\t/** @type {UsageStateType} */\r\n\t\t\tlet max = UsageState.Unused;\r\n\t\t\tfor (const item of runtime) {\r\n\t\t\t\tconst value = this._usedInRuntime.get(item);\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tif (value === UsageState.Used) {\r\n\t\t\t\t\t\treturn UsageState.Used;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (max < value) max = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn max;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * get used name\r\n\t * @param {string | undefined} fallbackName fallback name for used exports with no name\r\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\r\n\t * @returns {string | false} used name\r\n\t */\r\n\tgetUsedName(fallbackName, runtime) {\r\n\t\tif (this._hasUseInRuntimeInfo) {\r\n\t\t\tif (this._globalUsed !== undefined) {\r\n\t\t\t\tif (this._globalUsed === UsageState.Unused) return false;\r\n\t\t\t} else {\r\n\t\t\t\tif (this._usedInRuntime === undefined) return false;\r\n\t\t\t\tif (typeof runtime === \"string\") {\r\n\t\t\t\t\tif (!this._usedInRuntime.has(runtime)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (runtime !== undefined) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tArray.from(runtime).every(\r\n\t\t\t\t\t\t\truntime => !this._usedInRuntime.has(runtime)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._usedName !== null) return this._usedName;\r\n\t\treturn this.name || fallbackName;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {boolean} true, when a mangled name of this export is set\r\n\t */\r\n\thasUsedName() {\r\n\t\treturn this._usedName !== null;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the mangled name of this export\r\n\t * @param {string} name the new name\r\n\t * @returns {void}\r\n\t */\r\n\tsetUsedName(name) {\r\n\t\tthis._usedName = name;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n\t * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known\r\n\t */\r\n\tgetTerminalBinding(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {\r\n\t\tif (this.terminalBinding) return this;\r\n\t\tconst target = this.getTarget(moduleGraph, resolveTargetFilter);\r\n\t\tif (!target) return undefined;\r\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\r\n\t\tif (!target.export) return exportsInfo;\r\n\t\treturn exportsInfo.getReadOnlyExportInfoRecursive(target.export);\r\n\t}\r\n\r\n\tisReexport() {\r\n\t\treturn !this.terminalBinding && this._target && this._target.size > 0;\r\n\t}\r\n\r\n\t_getMaxTarget() {\r\n\t\tif (this._maxTarget !== undefined) return this._maxTarget;\r\n\t\tif (this._target.size <= 1) return (this._maxTarget = this._target);\r\n\t\tlet maxPriority = -Infinity;\r\n\t\tlet minPriority = Infinity;\r\n\t\tfor (const { priority } of this._target.values()) {\r\n\t\t\tif (maxPriority < priority) maxPriority = priority;\r\n\t\t\tif (minPriority > priority) minPriority = priority;\r\n\t\t}\r\n\t\t// This should be very common\r\n\t\tif (maxPriority === minPriority) return (this._maxTarget = this._target);\r\n\r\n\t\t// This is an edge case\r\n\t\tconst map = new Map();\r\n\t\tfor (const [key, value] of this._target) {\r\n\t\t\tif (maxPriority === value.priority) {\r\n\t\t\t\tmap.set(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._maxTarget = map;\r\n\t\treturn map;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {function(Module): boolean} validTargetModuleFilter a valid target module\r\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\r\n\t */\r\n\tfindTarget(moduleGraph, validTargetModuleFilter) {\r\n\t\treturn this._findTarget(moduleGraph, validTargetModuleFilter, new Set());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {function(Module): boolean} validTargetModuleFilter a valid target module\r\n\t * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\r\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\r\n\t */\r\n\t_findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {\r\n\t\tif (!this._target || this._target.size === 0) return undefined;\r\n\t\tlet rawTarget = this._getMaxTarget().values().next().value;\r\n\t\tif (!rawTarget) return undefined;\r\n\t\t/** @type {{ module: Module, export: string[] | undefined }} */\r\n\t\tlet target = {\r\n\t\t\tmodule: rawTarget.connection.module,\r\n\t\t\texport: rawTarget.export\r\n\t\t};\r\n\t\tfor (;;) {\r\n\t\t\tif (validTargetModuleFilter(target.module)) return target;\r\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\r\n\t\t\tconst exportInfo = exportsInfo.getExportInfo(target.export[0]);\r\n\t\t\tif (alreadyVisited.has(exportInfo)) return null;\r\n\t\t\tconst newTarget = exportInfo._findTarget(\r\n\t\t\t\tmoduleGraph,\r\n\t\t\t\tvalidTargetModuleFilter,\r\n\t\t\t\talreadyVisited\r\n\t\t\t);\r\n\t\t\tif (!newTarget) return false;\r\n\t\t\tif (target.export.length === 1) {\r\n\t\t\t\ttarget = newTarget;\r\n\t\t\t} else {\r\n\t\t\t\ttarget = {\r\n\t\t\t\t\tmodule: newTarget.module,\r\n\t\t\t\t\texport: newTarget.export\r\n\t\t\t\t\t\t? newTarget.export.concat(target.export.slice(1))\r\n\t\t\t\t\t\t: target.export.slice(1)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined} the target\r\n\t */\r\n\tgetTarget(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {\r\n\t\tconst result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\r\n\t\tif (result === CIRCULAR) return undefined;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n\t * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\r\n\t * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target\r\n\t */\r\n\t_getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {\r\n\t\t/**\r\n\t\t * @param {{ connection: ModuleGraphConnection, export: string[] | undefined } | null} inputTarget unresolved target\r\n\t\t * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references\r\n\t\t * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | null} resolved target\r\n\t\t */\r\n\t\tconst resolveTarget = (inputTarget, alreadyVisited) => {\r\n\t\t\tif (!inputTarget) return null;\r\n\t\t\tif (!inputTarget.export) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmodule: inputTarget.connection.module,\r\n\t\t\t\t\tconnection: inputTarget.connection,\r\n\t\t\t\t\texport: undefined\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t/** @type {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }} */\r\n\t\t\tlet target = {\r\n\t\t\t\tmodule: inputTarget.connection.module,\r\n\t\t\t\tconnection: inputTarget.connection,\r\n\t\t\t\texport: inputTarget.export\r\n\t\t\t};\r\n\t\t\tif (!resolveTargetFilter(target)) return target;\r\n\t\t\tlet alreadyVisitedOwned = false;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\r\n\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(target.export[0]);\r\n\t\t\t\tif (!exportInfo) return target;\r\n\t\t\t\tif (alreadyVisited.has(exportInfo)) return CIRCULAR;\r\n\t\t\t\tconst newTarget = exportInfo._getTarget(\r\n\t\t\t\t\tmoduleGraph,\r\n\t\t\t\t\tresolveTargetFilter,\r\n\t\t\t\t\talreadyVisited\r\n\t\t\t\t);\r\n\t\t\t\tif (newTarget === CIRCULAR) return CIRCULAR;\r\n\t\t\t\tif (!newTarget) return target;\r\n\t\t\t\tif (target.export.length === 1) {\r\n\t\t\t\t\ttarget = newTarget;\r\n\t\t\t\t\tif (!target.export) return target;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget = {\r\n\t\t\t\t\t\tmodule: newTarget.module,\r\n\t\t\t\t\t\tconnection: newTarget.connection,\r\n\t\t\t\t\t\texport: newTarget.export\r\n\t\t\t\t\t\t\t? newTarget.export.concat(target.export.slice(1))\r\n\t\t\t\t\t\t\t: target.export.slice(1)\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tif (!resolveTargetFilter(target)) return target;\r\n\t\t\t\tif (!alreadyVisitedOwned) {\r\n\t\t\t\t\talreadyVisited = new Set(alreadyVisited);\r\n\t\t\t\t\talreadyVisitedOwned = true;\r\n\t\t\t\t}\r\n\t\t\t\talreadyVisited.add(exportInfo);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif (!this._target || this._target.size === 0) return undefined;\r\n\t\tif (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;\r\n\t\tconst newAlreadyVisited = new Set(alreadyVisited);\r\n\t\tnewAlreadyVisited.add(this);\r\n\t\tconst values = this._getMaxTarget().values();\r\n\t\tconst target = resolveTarget(values.next().value, newAlreadyVisited);\r\n\t\tif (target === CIRCULAR) return CIRCULAR;\r\n\t\tif (target === null) return undefined;\r\n\t\tlet result = values.next();\r\n\t\twhile (!result.done) {\r\n\t\t\tconst t = resolveTarget(result.value, newAlreadyVisited);\r\n\t\t\tif (t === CIRCULAR) return CIRCULAR;\r\n\t\t\tif (t === null) return undefined;\r\n\t\t\tif (t.module !== target.module) return undefined;\r\n\t\t\tif (!t.export !== !target.export) return undefined;\r\n\t\t\tif (target.export && !equals(t.export, target.export)) return undefined;\r\n\t\t\tresult = values.next();\r\n\t\t}\r\n\t\treturn target;\r\n\t}\r\n\r\n\t/**\r\n\t * Move the target forward as long resolveTargetFilter is fulfilled\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\r\n\t * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection\r\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved\r\n\t */\r\n\tmoveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {\r\n\t\tconst target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\r\n\t\tif (target === CIRCULAR) return undefined;\r\n\t\tif (!target) return undefined;\r\n\t\tconst originalTarget = this._getMaxTarget().values().next().value;\r\n\t\tif (\r\n\t\t\toriginalTarget.connection === target.connection &&\r\n\t\t\toriginalTarget.export === target.export\r\n\t\t) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tthis._target.clear();\r\n\t\tthis._target.set(undefined, {\r\n\t\t\tconnection: updateOriginalConnection\r\n\t\t\t\t? updateOriginalConnection(target)\r\n\t\t\t\t: target.connection,\r\n\t\t\texport: target.export,\r\n\t\t\tpriority: 0\r\n\t\t});\r\n\t\treturn target;\r\n\t}\r\n\r\n\tcreateNestedExportsInfo() {\r\n\t\tif (this.exportsInfoOwned) return this.exportsInfo;\r\n\t\tthis.exportsInfoOwned = true;\r\n\t\tconst oldExportsInfo = this.exportsInfo;\r\n\t\tthis.exportsInfo = new ExportsInfo();\r\n\t\tthis.exportsInfo.setHasProvideInfo();\r\n\t\tif (oldExportsInfo) {\r\n\t\t\tthis.exportsInfo.setRedirectNamedTo(oldExportsInfo);\r\n\t\t}\r\n\t\treturn this.exportsInfo;\r\n\t}\r\n\r\n\tgetNestedExportsInfo() {\r\n\t\treturn this.exportsInfo;\r\n\t}\r\n\r\n\thasInfo(baseInfo, runtime) {\r\n\t\treturn (\r\n\t\t\t(this._usedName && this._usedName !== this.name) ||\r\n\t\t\tthis.provided ||\r\n\t\t\tthis.terminalBinding ||\r\n\t\t\tthis.getUsed(runtime) !== baseInfo.getUsed(runtime)\r\n\t\t);\r\n\t}\r\n\r\n\tupdateHash(hash, runtime) {\r\n\t\tthis._updateHash(hash, runtime, new Set());\r\n\t}\r\n\r\n\t_updateHash(hash, runtime, alreadyVisitedExportsInfo) {\r\n\t\thash.update(\r\n\t\t\t`${this._usedName || this.name}${this.getUsed(runtime)}${this.provided}${\r\n\t\t\t\tthis.terminalBinding\r\n\t\t\t}`\r\n\t\t);\r\n\t\tif (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {\r\n\t\t\tthis.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);\r\n\t\t}\r\n\t}\r\n\r\n\tgetUsedInfo() {\r\n\t\tif (this._globalUsed !== undefined) {\r\n\t\t\tswitch (this._globalUsed) {\r\n\t\t\t\tcase UsageState.Unused:\r\n\t\t\t\t\treturn \"unused\";\r\n\t\t\t\tcase UsageState.NoInfo:\r\n\t\t\t\t\treturn \"no usage info\";\r\n\t\t\t\tcase UsageState.Unknown:\r\n\t\t\t\t\treturn \"maybe used (runtime-defined)\";\r\n\t\t\t\tcase UsageState.Used:\r\n\t\t\t\t\treturn \"used\";\r\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\r\n\t\t\t\t\treturn \"only properties used\";\r\n\t\t\t}\r\n\t\t} else if (this._usedInRuntime !== undefined) {\r\n\t\t\t/** @type {Map<RuntimeUsageStateType, string[]>} */\r\n\t\t\tconst map = new Map();\r\n\t\t\tfor (const [runtime, used] of this._usedInRuntime) {\r\n\t\t\t\tconst list = map.get(used);\r\n\t\t\t\tif (list !== undefined) list.push(runtime);\r\n\t\t\t\telse map.set(used, [runtime]);\r\n\t\t\t}\r\n\t\t\tconst specificInfo = Array.from(map, ([used, runtimes]) => {\r\n\t\t\t\tswitch (used) {\r\n\t\t\t\t\tcase UsageState.NoInfo:\r\n\t\t\t\t\t\treturn `no usage info in ${runtimes.join(\", \")}`;\r\n\t\t\t\t\tcase UsageState.Unknown:\r\n\t\t\t\t\t\treturn `maybe used in ${runtimes.join(\", \")} (runtime-defined)`;\r\n\t\t\t\t\tcase UsageState.Used:\r\n\t\t\t\t\t\treturn `used in ${runtimes.join(\", \")}`;\r\n\t\t\t\t\tcase UsageState.OnlyPropertiesUsed:\r\n\t\t\t\t\t\treturn `only properties used in ${runtimes.join(\", \")}`;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif (specificInfo.length > 0) {\r\n\t\t\t\treturn specificInfo.join(\"; \");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._hasUseInRuntimeInfo ? \"unused\" : \"no usage info\";\r\n\t}\r\n\r\n\tgetProvidedInfo() {\r\n\t\tswitch (this.provided) {\r\n\t\t\tcase undefined:\r\n\t\t\t\treturn \"no provided info\";\r\n\t\t\tcase null:\r\n\t\t\t\treturn \"maybe provided (runtime-defined)\";\r\n\t\t\tcase true:\r\n\t\t\t\treturn \"provided\";\r\n\t\t\tcase false:\r\n\t\t\t\treturn \"not provided\";\r\n\t\t}\r\n\t}\r\n\r\n\tgetRenameInfo() {\r\n\t\tif (this._usedName !== null && this._usedName !== this.name) {\r\n\t\t\treturn `renamed to ${JSON.stringify(this._usedName).slice(1, -1)}`;\r\n\t\t}\r\n\t\tswitch (this.canMangleProvide) {\r\n\t\t\tcase undefined:\r\n\t\t\t\tswitch (this.canMangleUse) {\r\n\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\treturn \"missing provision and use info prevents renaming\";\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\treturn \"usage prevents renaming (no provision info)\";\r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\treturn \"missing provision info prevents renaming\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase true:\r\n\t\t\t\tswitch (this.canMangleUse) {\r\n\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\treturn \"missing usage info prevents renaming\";\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\treturn \"usage prevents renaming\";\r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\treturn \"could be renamed\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase false:\r\n\t\t\t\tswitch (this.canMangleUse) {\r\n\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\treturn \"provision prevents renaming (no use info)\";\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\treturn \"usage and provision prevents renaming\";\r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\treturn \"provision prevents renaming\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tthrow new Error(\r\n\t\t\t`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = ExportsInfo;\r\nmodule.exports.ExportInfo = ExportInfo;\r\nmodule.exports.UsageState = UsageState;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}