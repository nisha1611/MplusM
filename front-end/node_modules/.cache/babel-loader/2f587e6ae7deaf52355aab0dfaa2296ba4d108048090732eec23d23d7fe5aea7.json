{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\nconst modifiedPaths = require('./common').modifiedPaths;\n\n/**\r\n * Applies validators and defaults to update and findOneAndUpdate operations,\r\n * specifically passing a null doc as `this` to validators and defaults\r\n *\r\n * @param {Query} query\r\n * @param {Schema} schema\r\n * @param {Object} castedDoc\r\n * @param {Object} options\r\n * @method runValidatorsOnUpdate\r\n * @api private\r\n */\n\nmodule.exports = function (query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' || key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n  const alreadyValidated = [];\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(v, function (err) {\n            if (err) {\n              err.path = updates[i] + '.$in.' + i;\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] && schemaPath.$isMongooseArray) {\n        return;\n      }\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(v, function (err) {\n            if (err) {\n              if (err.errors) {\n                for (const key of Object.keys(err.errors)) {\n                  const _err = err.errors[key];\n                  _err.path = updates[i] + '.' + key;\n                  validationErrors.push(_err);\n                }\n              } else {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n            }\n            return callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      } else {\n        validatorsToExecute.push(function (callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n          schemaPath.doValidate(v, function (err) {\n            if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {\n              return callback(null);\n            }\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function (callback) {\n        schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null, {\n            updateValidator: true\n          });\n        });\n      }\n    }\n  }\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function () {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n    return;\n  }\n  return function (callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function () {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n      return callback(err);\n    }\n    callback(null);\n  }\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function (err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};","map":{"version":3,"names":["ValidationError","require","cleanPositionalOperators","flatten","modifiedPaths","module","exports","query","schema","castedDoc","options","callback","keys","Object","updatedKeys","updatedValues","isPull","arrayAtomicUpdates","numKeys","length","hasDollarUpdate","modified","currentUpdate","key","i","startsWith","_keys","ii","$each","concat","flat","paths","numPaths","j","updatedPath","includes","undefined","updates","numUpdates","validatorsToExecute","validationErrors","alreadyValidated","context","iter","v","schemaPath","_getSchema","instance","path","Array","isArray","$in","forEach","push","doValidate","err","updateValidator","$isMongooseArray","$isMongooseDocumentArrayElement","$__","errors","_err","storeSubdocValidationError","arrayUpdates","arrayUpdate","$isMongooseDocumentArray","getValidationCallback","atomicUpdate","numValidators","_done","validator","validationError","addError"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/updateValidators.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst ValidationError = require('../error/validation');\r\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\r\nconst flatten = require('./common').flatten;\r\nconst modifiedPaths = require('./common').modifiedPaths;\r\n\r\n/**\r\n * Applies validators and defaults to update and findOneAndUpdate operations,\r\n * specifically passing a null doc as `this` to validators and defaults\r\n *\r\n * @param {Query} query\r\n * @param {Schema} schema\r\n * @param {Object} castedDoc\r\n * @param {Object} options\r\n * @method runValidatorsOnUpdate\r\n * @api private\r\n */\r\n\r\nmodule.exports = function(query, schema, castedDoc, options, callback) {\r\n  const keys = Object.keys(castedDoc || {});\r\n  let updatedKeys = {};\r\n  let updatedValues = {};\r\n  const isPull = {};\r\n  const arrayAtomicUpdates = {};\r\n  const numKeys = keys.length;\r\n  let hasDollarUpdate = false;\r\n  const modified = {};\r\n  let currentUpdate;\r\n  let key;\r\n  let i;\r\n\r\n  for (i = 0; i < numKeys; ++i) {\r\n    if (keys[i].startsWith('$')) {\r\n      hasDollarUpdate = true;\r\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\r\n        const _keys = Object.keys(castedDoc[keys[i]]);\r\n        for (let ii = 0; ii < _keys.length; ++ii) {\r\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\r\n          if (currentUpdate && currentUpdate.$each) {\r\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\r\n              concat(currentUpdate.$each);\r\n          } else {\r\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\r\n              concat([currentUpdate]);\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n      modifiedPaths(castedDoc[keys[i]], '', modified);\r\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\r\n      const paths = Object.keys(flat);\r\n      const numPaths = paths.length;\r\n      for (let j = 0; j < numPaths; ++j) {\r\n        const updatedPath = cleanPositionalOperators(paths[j]);\r\n        key = keys[i];\r\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\r\n        // for the rest of the logic, it will get handled later.\r\n        if (updatedPath.includes('$')) {\r\n          continue;\r\n        }\r\n        if (key === '$set' || key === '$setOnInsert' ||\r\n            key === '$pull' || key === '$pullAll') {\r\n          updatedValues[updatedPath] = flat[paths[j]];\r\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\r\n        } else if (key === '$unset') {\r\n          updatedValues[updatedPath] = undefined;\r\n        }\r\n        updatedKeys[updatedPath] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!hasDollarUpdate) {\r\n    modifiedPaths(castedDoc, '', modified);\r\n    updatedValues = flatten(castedDoc, null, null, schema);\r\n    updatedKeys = Object.keys(updatedValues);\r\n  }\r\n\r\n  const updates = Object.keys(updatedValues);\r\n  const numUpdates = updates.length;\r\n  const validatorsToExecute = [];\r\n  const validationErrors = [];\r\n\r\n  const alreadyValidated = [];\r\n\r\n  const context = query;\r\n  function iter(i, v) {\r\n    const schemaPath = schema._getSchema(updates[i]);\r\n    if (schemaPath == null) {\r\n      return;\r\n    }\r\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\r\n      return;\r\n    }\r\n\r\n    if (v && Array.isArray(v.$in)) {\r\n      v.$in.forEach((v, i) => {\r\n        validatorsToExecute.push(function(callback) {\r\n          schemaPath.doValidate(\r\n            v,\r\n            function(err) {\r\n              if (err) {\r\n                err.path = updates[i] + '.$in.' + i;\r\n                validationErrors.push(err);\r\n              }\r\n              callback(null);\r\n            },\r\n            context,\r\n            { updateValidator: true });\r\n        });\r\n      });\r\n    } else {\r\n      if (isPull[updates[i]] &&\r\n          schemaPath.$isMongooseArray) {\r\n        return;\r\n      }\r\n\r\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\r\n        alreadyValidated.push(updates[i]);\r\n        validatorsToExecute.push(function(callback) {\r\n          schemaPath.doValidate(v, function(err) {\r\n            if (err) {\r\n              if (err.errors) {\r\n                for (const key of Object.keys(err.errors)) {\r\n                  const _err = err.errors[key];\r\n                  _err.path = updates[i] + '.' + key;\r\n                  validationErrors.push(_err);\r\n                }\r\n              } else {\r\n                err.path = updates[i];\r\n                validationErrors.push(err);\r\n              }\r\n            }\r\n\r\n            return callback(null);\r\n          }, context, { updateValidator: true });\r\n        });\r\n      } else {\r\n        validatorsToExecute.push(function(callback) {\r\n          for (const path of alreadyValidated) {\r\n            if (updates[i].startsWith(path + '.')) {\r\n              return callback(null);\r\n            }\r\n          }\r\n\r\n          schemaPath.doValidate(v, function(err) {\r\n            if (schemaPath.schema != null &&\r\n                schemaPath.schema.options.storeSubdocValidationError === false &&\r\n                err instanceof ValidationError) {\r\n              return callback(null);\r\n            }\r\n\r\n            if (err) {\r\n              err.path = updates[i];\r\n              validationErrors.push(err);\r\n            }\r\n            callback(null);\r\n          }, context, { updateValidator: true });\r\n        });\r\n      }\r\n    }\r\n  }\r\n  for (i = 0; i < numUpdates; ++i) {\r\n    iter(i, updatedValues[updates[i]]);\r\n  }\r\n\r\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\r\n  for (const arrayUpdate of arrayUpdates) {\r\n    let schemaPath = schema._getSchema(arrayUpdate);\r\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\r\n      validatorsToExecute.push(function(callback) {\r\n        schemaPath.doValidate(\r\n          arrayAtomicUpdates[arrayUpdate],\r\n          getValidationCallback(arrayUpdate, validationErrors, callback),\r\n          options && options.context === 'query' ? query : null);\r\n      });\r\n    } else {\r\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\r\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\r\n        validatorsToExecute.push(function(callback) {\r\n          schemaPath.doValidate(\r\n            atomicUpdate,\r\n            getValidationCallback(arrayUpdate, validationErrors, callback),\r\n            options && options.context === 'query' ? query : null,\r\n            { updateValidator: true });\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  if (callback != null) {\r\n    let numValidators = validatorsToExecute.length;\r\n    if (numValidators === 0) {\r\n      return _done(callback);\r\n    }\r\n    for (const validator of validatorsToExecute) {\r\n      validator(function() {\r\n        if (--numValidators <= 0) {\r\n          _done(callback);\r\n        }\r\n      });\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  return function(callback) {\r\n    let numValidators = validatorsToExecute.length;\r\n    if (numValidators === 0) {\r\n      return _done(callback);\r\n    }\r\n    for (const validator of validatorsToExecute) {\r\n      validator(function() {\r\n        if (--numValidators <= 0) {\r\n          _done(callback);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  function _done(callback) {\r\n    if (validationErrors.length) {\r\n      const err = new ValidationError(null);\r\n\r\n      for (const validationError of validationErrors) {\r\n        err.addError(validationError.path, validationError);\r\n      }\r\n\r\n      return callback(err);\r\n    }\r\n    callback(null);\r\n  }\r\n\r\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\r\n    return function(err) {\r\n      if (err) {\r\n        err.path = arrayUpdate;\r\n        validationErrors.push(err);\r\n      }\r\n      callback(null);\r\n    };\r\n  }\r\n};\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}