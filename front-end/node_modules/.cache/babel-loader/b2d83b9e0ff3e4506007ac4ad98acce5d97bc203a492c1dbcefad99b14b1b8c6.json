{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DBRef = exports.isDBRefLike = void 0;\nvar utils_1 = require(\"./parser/utils\");\n/** @internal */\nfunction isDBRefLike(value) {\n  return (0, utils_1.isObjectLike)(value) && value.$id != null && typeof value.$ref === 'string' && (value.$db == null || typeof value.$db === 'string');\n}\nexports.isDBRefLike = isDBRefLike;\n/**\r\n * A class representation of the BSON DBRef type.\r\n * @public\r\n * @category BSONType\r\n */\nvar DBRef = /** @class */function () {\n  /**\r\n   * @param collection - the collection name.\r\n   * @param oid - the reference ObjectId.\r\n   * @param db - optional db name, if omitted the reference is local to the current db.\r\n   */\n  function DBRef(collection, oid, db, fields) {\n    if (!(this instanceof DBRef)) return new DBRef(collection, oid, db, fields);\n    // check if namespace has been provided\n    var parts = collection.split('.');\n    if (parts.length === 2) {\n      db = parts.shift();\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      collection = parts.shift();\n    }\n    this.collection = collection;\n    this.oid = oid;\n    this.db = db;\n    this.fields = fields || {};\n  }\n  Object.defineProperty(DBRef.prototype, \"namespace\", {\n    // Property provided for compatibility with the 1.x parser\n    // the 1.x parser used a \"namespace\" property, while 4.x uses \"collection\"\n    /** @internal */\n    get: function () {\n      return this.collection;\n    },\n    set: function (value) {\n      this.collection = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DBRef.prototype.toJSON = function () {\n    var o = Object.assign({\n      $ref: this.collection,\n      $id: this.oid\n    }, this.fields);\n    if (this.db != null) o.$db = this.db;\n    return o;\n  };\n  /** @internal */\n  DBRef.prototype.toExtendedJSON = function (options) {\n    options = options || {};\n    var o = {\n      $ref: this.collection,\n      $id: this.oid\n    };\n    if (options.legacy) {\n      return o;\n    }\n    if (this.db) o.$db = this.db;\n    o = Object.assign(o, this.fields);\n    return o;\n  };\n  /** @internal */\n  DBRef.fromExtendedJSON = function (doc) {\n    var copy = Object.assign({}, doc);\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n  };\n  /** @internal */\n  DBRef.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {\n    return this.inspect();\n  };\n  DBRef.prototype.inspect = function () {\n    // NOTE: if OID is an ObjectId class it will just print the oid string.\n    var oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();\n    return \"new DBRef(\\\"\".concat(this.namespace, \"\\\", new ObjectId(\\\"\").concat(String(oid), \"\\\")\").concat(this.db ? \", \\\"\".concat(this.db, \"\\\"\") : '', \")\");\n  };\n  return DBRef;\n}();\nexports.DBRef = DBRef;\nObject.defineProperty(DBRef.prototype, '_bsontype', {\n  value: 'DBRef'\n});","map":{"version":3,"mappings":"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","names":["isDBRefLike","value","$id","$ref","$db","exports","collection","oid","db","fields","DBRef","parts","split","length","shift","Object","o","assign","options","legacy","doc","copy","Symbol","for","inspect","undefined","toString","namespace","String","defineProperty","prototype"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\db_ref.ts"],"sourcesContent":["import type { Document } from './bson';\r\nimport type { EJSONOptions } from './extended_json';\r\nimport type { ObjectId } from './objectid';\r\nimport { isObjectLike } from './parser/utils';\r\n\r\n/** @public */\r\nexport interface DBRefLike {\r\n  $ref: string;\r\n  $id: ObjectId;\r\n  $db?: string;\r\n}\r\n\r\n/** @internal */\r\nexport function isDBRefLike(value: unknown): value is DBRefLike {\r\n  return (\r\n    isObjectLike(value) &&\r\n    value.$id != null &&\r\n    typeof value.$ref === 'string' &&\r\n    (value.$db == null || typeof value.$db === 'string')\r\n  );\r\n}\r\n\r\n/**\r\n * A class representation of the BSON DBRef type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport class DBRef {\r\n  _bsontype!: 'DBRef';\r\n\r\n  collection!: string;\r\n  oid!: ObjectId;\r\n  db?: string;\r\n  fields!: Document;\r\n\r\n  /**\r\n   * @param collection - the collection name.\r\n   * @param oid - the reference ObjectId.\r\n   * @param db - optional db name, if omitted the reference is local to the current db.\r\n   */\r\n  constructor(collection: string, oid: ObjectId, db?: string, fields?: Document) {\r\n    if (!(this instanceof DBRef)) return new DBRef(collection, oid, db, fields);\r\n\r\n    // check if namespace has been provided\r\n    const parts = collection.split('.');\r\n    if (parts.length === 2) {\r\n      db = parts.shift();\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      collection = parts.shift()!;\r\n    }\r\n\r\n    this.collection = collection;\r\n    this.oid = oid;\r\n    this.db = db;\r\n    this.fields = fields || {};\r\n  }\r\n\r\n  // Property provided for compatibility with the 1.x parser\r\n  // the 1.x parser used a \"namespace\" property, while 4.x uses \"collection\"\r\n\r\n  /** @internal */\r\n  get namespace(): string {\r\n    return this.collection;\r\n  }\r\n\r\n  set namespace(value: string) {\r\n    this.collection = value;\r\n  }\r\n\r\n  toJSON(): DBRefLike & Document {\r\n    const o = Object.assign(\r\n      {\r\n        $ref: this.collection,\r\n        $id: this.oid\r\n      },\r\n      this.fields\r\n    );\r\n\r\n    if (this.db != null) o.$db = this.db;\r\n    return o;\r\n  }\r\n\r\n  /** @internal */\r\n  toExtendedJSON(options?: EJSONOptions): DBRefLike {\r\n    options = options || {};\r\n    let o: DBRefLike = {\r\n      $ref: this.collection,\r\n      $id: this.oid\r\n    };\r\n\r\n    if (options.legacy) {\r\n      return o;\r\n    }\r\n\r\n    if (this.db) o.$db = this.db;\r\n    o = Object.assign(o, this.fields);\r\n    return o;\r\n  }\r\n\r\n  /** @internal */\r\n  static fromExtendedJSON(doc: DBRefLike): DBRef {\r\n    const copy = Object.assign({}, doc) as Partial<DBRefLike>;\r\n    delete copy.$ref;\r\n    delete copy.$id;\r\n    delete copy.$db;\r\n    return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\r\n  }\r\n\r\n  /** @internal */\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    // NOTE: if OID is an ObjectId class it will just print the oid string.\r\n    const oid =\r\n      this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();\r\n    return `new DBRef(\"${this.namespace}\", new ObjectId(\"${String(oid)}\")${\r\n      this.db ? `, \"${this.db}\"` : ''\r\n    })`;\r\n  }\r\n}\r\n\r\nObject.defineProperty(DBRef.prototype, '_bsontype', { value: 'DBRef' });\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}