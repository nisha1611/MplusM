{"ast":null,"code":"'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/**\r\n * Like `schema.path()`, except with a document, because impossible to\r\n * determine path type without knowing the embedded discriminator key.\r\n * @param {Schema} schema\r\n * @param {Object} [update]\r\n * @param {Object} [filter]\r\n * @param {String} path\r\n * @param {Object} [options]\r\n * @api private\r\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath = discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n      if (discriminatorKey == null) {\n        continue;\n      }\n      const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n  return {\n    type: type,\n    schematype: schematype\n  };\n};","map":{"version":3,"names":["cleanPositionalOperators","require","get","getDiscriminatorByValue","updatedPathsByArrayFilter","module","exports","getEmbeddedDiscriminatorPath","schema","update","filter","path","options","parts","split","schematype","type","arrayFilters","Array","isArray","updatedPathsByFilter","i","length","subpath","slice","join","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","key","discriminatorValuePath","discriminatorFilterPath","replace","discriminatorKey","wrapperPath","$elemMatch","filterKey","Object","keys","schemaKey","arrayFilterKey","find","hasOwnProperty","discriminatorSchema","caster","rest","_getPathType"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\r\n\r\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\r\nconst get = require('../get');\r\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\r\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\r\n\r\n/**\r\n * Like `schema.path()`, except with a document, because impossible to\r\n * determine path type without knowing the embedded discriminator key.\r\n * @param {Schema} schema\r\n * @param {Object} [update]\r\n * @param {Object} [filter]\r\n * @param {String} path\r\n * @param {Object} [options]\r\n * @api private\r\n */\r\n\r\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\r\n  const parts = path.split('.');\r\n  let schematype = null;\r\n  let type = 'adhocOrUndefined';\r\n\r\n  filter = filter || {};\r\n  update = update || {};\r\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\r\n    options.arrayFilters : [];\r\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\r\n\r\n  for (let i = 0; i < parts.length; ++i) {\r\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\r\n    schematype = schema.path(subpath);\r\n    if (schematype == null) {\r\n      continue;\r\n    }\r\n\r\n    type = schema.pathType(subpath);\r\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\r\n        schematype.schema.discriminators != null) {\r\n      const key = get(schematype, 'schema.options.discriminatorKey');\r\n      const discriminatorValuePath = subpath + '.' + key;\r\n      const discriminatorFilterPath =\r\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\r\n      let discriminatorKey = null;\r\n\r\n      if (discriminatorValuePath in filter) {\r\n        discriminatorKey = filter[discriminatorValuePath];\r\n      }\r\n      if (discriminatorFilterPath in filter) {\r\n        discriminatorKey = filter[discriminatorFilterPath];\r\n      }\r\n\r\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\r\n      if (schematype.$isMongooseDocumentArrayElement &&\r\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\r\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\r\n      }\r\n\r\n      if (discriminatorValuePath in update) {\r\n        discriminatorKey = update[discriminatorValuePath];\r\n      }\r\n\r\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\r\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\r\n        const arrayFilterKey = filterKey + '.' + key;\r\n        if (schemaKey === discriminatorFilterPath) {\r\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\r\n          if (filter != null) {\r\n            discriminatorKey = filter[arrayFilterKey];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (discriminatorKey == null) {\r\n        continue;\r\n      }\r\n\r\n      const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;\r\n\r\n      const rest = parts.slice(i + 1).join('.');\r\n      schematype = discriminatorSchema.path(rest);\r\n      if (schematype != null) {\r\n        type = discriminatorSchema._getPathType(rest);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { type: type, schematype: schematype };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}