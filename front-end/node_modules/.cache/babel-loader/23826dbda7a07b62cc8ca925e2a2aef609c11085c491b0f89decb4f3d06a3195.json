{"ast":null,"code":"import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { connect, constants } from \"http2\";\nimport { getTransformedHeaders } from \"./get-transformed-headers\";\nimport { writeRequestBody } from \"./write-request-body\";\nexport class NodeHttp2Handler {\n  constructor(options) {\n    this.metadata = {\n      handlerProtocol: \"h2\"\n    };\n    this.configProvider = new Promise((resolve, reject) => {\n      if (typeof options === \"function\") {\n        options().then(opts => {\n          resolve(opts || {});\n        }).catch(reject);\n      } else {\n        resolve(options || {});\n      }\n    });\n    this.sessionCache = new Map();\n  }\n  destroy() {\n    for (const sessions of this.sessionCache.values()) {\n      sessions.forEach(session => this.destroySession(session));\n    }\n    this.sessionCache.clear();\n  }\n  async handle(request) {\n    let {\n      abortSignal\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.config) {\n      this.config = await this.configProvider;\n    }\n    const {\n      requestTimeout,\n      disableConcurrentStreams\n    } = this.config;\n    return new Promise((resolve, rejectOriginal) => {\n      let fulfilled = false;\n      if (abortSignal?.aborted) {\n        fulfilled = true;\n        const abortError = new Error(\"Request aborted\");\n        abortError.name = \"AbortError\";\n        rejectOriginal(abortError);\n        return;\n      }\n      const {\n        hostname,\n        method,\n        port,\n        protocol,\n        path,\n        query\n      } = request;\n      const authority = `${protocol}//${hostname}${port ? `:${port}` : \"\"}`;\n      const session = this.getSession(authority, disableConcurrentStreams || false);\n      const reject = err => {\n        if (disableConcurrentStreams) {\n          this.destroySession(session);\n        }\n        fulfilled = true;\n        rejectOriginal(err);\n      };\n      const queryString = buildQueryString(query || {});\n      const req = session.request({\n        ...request.headers,\n        [constants.HTTP2_HEADER_PATH]: queryString ? `${path}?${queryString}` : path,\n        [constants.HTTP2_HEADER_METHOD]: method\n      });\n      session.ref();\n      req.on(\"response\", headers => {\n        const httpResponse = new HttpResponse({\n          statusCode: headers[\":status\"] || -1,\n          headers: getTransformedHeaders(headers),\n          body: req\n        });\n        fulfilled = true;\n        resolve({\n          response: httpResponse\n        });\n        if (disableConcurrentStreams) {\n          session.close();\n          this.deleteSessionFromCache(authority, session);\n        }\n      });\n      if (requestTimeout) {\n        req.setTimeout(requestTimeout, () => {\n          req.close();\n          const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);\n          timeoutError.name = \"TimeoutError\";\n          reject(timeoutError);\n        });\n      }\n      if (abortSignal) {\n        abortSignal.onabort = () => {\n          req.close();\n          const abortError = new Error(\"Request aborted\");\n          abortError.name = \"AbortError\";\n          reject(abortError);\n        };\n      }\n      req.on(\"frameError\", (type, code, id) => {\n        reject(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));\n      });\n      req.on(\"error\", reject);\n      req.on(\"aborted\", () => {\n        reject(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));\n      });\n      req.on(\"close\", () => {\n        session.unref();\n        if (disableConcurrentStreams) {\n          session.destroy();\n        }\n        if (!fulfilled) {\n          reject(new Error(\"Unexpected error: http2 request did not get a response\"));\n        }\n      });\n      writeRequestBody(req, request);\n    });\n  }\n  getSession(authority, disableConcurrentStreams) {\n    const sessionCache = this.sessionCache;\n    const existingSessions = sessionCache.get(authority) || [];\n    if (existingSessions.length > 0 && !disableConcurrentStreams) return existingSessions[0];\n    const newSession = connect(authority);\n    newSession.unref();\n    const destroySessionCb = () => {\n      this.destroySession(newSession);\n      this.deleteSessionFromCache(authority, newSession);\n    };\n    newSession.on(\"goaway\", destroySessionCb);\n    newSession.on(\"error\", destroySessionCb);\n    newSession.on(\"frameError\", destroySessionCb);\n    newSession.on(\"close\", () => this.deleteSessionFromCache(authority, newSession));\n    if (this.config?.sessionTimeout) {\n      newSession.setTimeout(this.config.sessionTimeout, destroySessionCb);\n    }\n    existingSessions.push(newSession);\n    sessionCache.set(authority, existingSessions);\n    return newSession;\n  }\n  destroySession(session) {\n    if (!session.destroyed) {\n      session.destroy();\n    }\n  }\n  deleteSessionFromCache(authority, session) {\n    const existingSessions = this.sessionCache.get(authority) || [];\n    if (!existingSessions.includes(session)) {\n      return;\n    }\n    this.sessionCache.set(authority, existingSessions.filter(s => s !== session));\n  }\n}","map":{"version":3,"names":["HttpResponse","buildQueryString","connect","constants","getTransformedHeaders","writeRequestBody","NodeHttp2Handler","constructor","options","metadata","handlerProtocol","configProvider","Promise","resolve","reject","then","opts","catch","sessionCache","Map","destroy","sessions","values","forEach","session","destroySession","clear","handle","request","abortSignal","config","requestTimeout","disableConcurrentStreams","rejectOriginal","fulfilled","aborted","abortError","Error","name","hostname","method","port","protocol","path","query","authority","getSession","err","queryString","req","headers","HTTP2_HEADER_PATH","HTTP2_HEADER_METHOD","ref","on","httpResponse","statusCode","body","response","close","deleteSessionFromCache","setTimeout","timeoutError","onabort","type","code","id","rstCode","unref","existingSessions","get","length","newSession","destroySessionCb","sessionTimeout","push","set","destroyed","includes","filter","s"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/node-http-handler/dist-es/node-http2-handler.js"],"sourcesContent":["import { HttpResponse } from \"@aws-sdk/protocol-http\";\r\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\r\nimport { connect, constants } from \"http2\";\r\nimport { getTransformedHeaders } from \"./get-transformed-headers\";\r\nimport { writeRequestBody } from \"./write-request-body\";\r\nexport class NodeHttp2Handler {\r\n    constructor(options) {\r\n        this.metadata = { handlerProtocol: \"h2\" };\r\n        this.configProvider = new Promise((resolve, reject) => {\r\n            if (typeof options === \"function\") {\r\n                options()\r\n                    .then((opts) => {\r\n                    resolve(opts || {});\r\n                })\r\n                    .catch(reject);\r\n            }\r\n            else {\r\n                resolve(options || {});\r\n            }\r\n        });\r\n        this.sessionCache = new Map();\r\n    }\r\n    destroy() {\r\n        for (const sessions of this.sessionCache.values()) {\r\n            sessions.forEach((session) => this.destroySession(session));\r\n        }\r\n        this.sessionCache.clear();\r\n    }\r\n    async handle(request, { abortSignal } = {}) {\r\n        if (!this.config) {\r\n            this.config = await this.configProvider;\r\n        }\r\n        const { requestTimeout, disableConcurrentStreams } = this.config;\r\n        return new Promise((resolve, rejectOriginal) => {\r\n            let fulfilled = false;\r\n            if (abortSignal?.aborted) {\r\n                fulfilled = true;\r\n                const abortError = new Error(\"Request aborted\");\r\n                abortError.name = \"AbortError\";\r\n                rejectOriginal(abortError);\r\n                return;\r\n            }\r\n            const { hostname, method, port, protocol, path, query } = request;\r\n            const authority = `${protocol}//${hostname}${port ? `:${port}` : \"\"}`;\r\n            const session = this.getSession(authority, disableConcurrentStreams || false);\r\n            const reject = (err) => {\r\n                if (disableConcurrentStreams) {\r\n                    this.destroySession(session);\r\n                }\r\n                fulfilled = true;\r\n                rejectOriginal(err);\r\n            };\r\n            const queryString = buildQueryString(query || {});\r\n            const req = session.request({\r\n                ...request.headers,\r\n                [constants.HTTP2_HEADER_PATH]: queryString ? `${path}?${queryString}` : path,\r\n                [constants.HTTP2_HEADER_METHOD]: method,\r\n            });\r\n            session.ref();\r\n            req.on(\"response\", (headers) => {\r\n                const httpResponse = new HttpResponse({\r\n                    statusCode: headers[\":status\"] || -1,\r\n                    headers: getTransformedHeaders(headers),\r\n                    body: req,\r\n                });\r\n                fulfilled = true;\r\n                resolve({ response: httpResponse });\r\n                if (disableConcurrentStreams) {\r\n                    session.close();\r\n                    this.deleteSessionFromCache(authority, session);\r\n                }\r\n            });\r\n            if (requestTimeout) {\r\n                req.setTimeout(requestTimeout, () => {\r\n                    req.close();\r\n                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);\r\n                    timeoutError.name = \"TimeoutError\";\r\n                    reject(timeoutError);\r\n                });\r\n            }\r\n            if (abortSignal) {\r\n                abortSignal.onabort = () => {\r\n                    req.close();\r\n                    const abortError = new Error(\"Request aborted\");\r\n                    abortError.name = \"AbortError\";\r\n                    reject(abortError);\r\n                };\r\n            }\r\n            req.on(\"frameError\", (type, code, id) => {\r\n                reject(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));\r\n            });\r\n            req.on(\"error\", reject);\r\n            req.on(\"aborted\", () => {\r\n                reject(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));\r\n            });\r\n            req.on(\"close\", () => {\r\n                session.unref();\r\n                if (disableConcurrentStreams) {\r\n                    session.destroy();\r\n                }\r\n                if (!fulfilled) {\r\n                    reject(new Error(\"Unexpected error: http2 request did not get a response\"));\r\n                }\r\n            });\r\n            writeRequestBody(req, request);\r\n        });\r\n    }\r\n    getSession(authority, disableConcurrentStreams) {\r\n        const sessionCache = this.sessionCache;\r\n        const existingSessions = sessionCache.get(authority) || [];\r\n        if (existingSessions.length > 0 && !disableConcurrentStreams)\r\n            return existingSessions[0];\r\n        const newSession = connect(authority);\r\n        newSession.unref();\r\n        const destroySessionCb = () => {\r\n            this.destroySession(newSession);\r\n            this.deleteSessionFromCache(authority, newSession);\r\n        };\r\n        newSession.on(\"goaway\", destroySessionCb);\r\n        newSession.on(\"error\", destroySessionCb);\r\n        newSession.on(\"frameError\", destroySessionCb);\r\n        newSession.on(\"close\", () => this.deleteSessionFromCache(authority, newSession));\r\n        if (this.config?.sessionTimeout) {\r\n            newSession.setTimeout(this.config.sessionTimeout, destroySessionCb);\r\n        }\r\n        existingSessions.push(newSession);\r\n        sessionCache.set(authority, existingSessions);\r\n        return newSession;\r\n    }\r\n    destroySession(session) {\r\n        if (!session.destroyed) {\r\n            session.destroy();\r\n        }\r\n    }\r\n    deleteSessionFromCache(authority, session) {\r\n        const existingSessions = this.sessionCache.get(authority) || [];\r\n        if (!existingSessions.includes(session)) {\r\n            return;\r\n        }\r\n        this.sessionCache.set(authority, existingSessions.filter((s) => s !== session));\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}