{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQueryTester = exports.createOperationTester = exports.createQueryOperation = exports.containsOperation = exports.numericalOperation = exports.numericalOperationCreator = exports.NopeOperation = exports.createEqualsOperation = exports.EqualsOperation = exports.createTester = exports.NestedOperation = exports.QueryOperation = exports.NamedGroupOperation = exports.BaseOperation = void 0;\nconst utils_1 = require(\"./utils\");\n/**\r\n * Walks through each value given the context - used for nested operations. E.g:\r\n * { \"person.address\": { $eq: \"blarg\" }}\r\n */\nconst walkKeyPathValues = (item, keyPath, next, depth, key, owner) => {\n  const currentKey = keyPath[depth];\n  // if array, then try matching. Might fall through for cases like:\n  // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\n  if ((0, utils_1.isArray)(item) && isNaN(Number(currentKey))) {\n    for (let i = 0, {\n        length\n      } = item; i < length; i++) {\n      // if FALSE is returned, then terminate walker. For operations, this simply\n      // means that the search critera was met.\n      if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\n        return false;\n      }\n    }\n  }\n  if (depth === keyPath.length || item == null) {\n    return next(item, key, owner, depth === 0);\n  }\n  return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);\n};\nclass BaseOperation {\n  constructor(params, owneryQuery, options, name) {\n    this.params = params;\n    this.owneryQuery = owneryQuery;\n    this.options = options;\n    this.name = name;\n    this.init();\n  }\n  init() {}\n  reset() {\n    this.done = false;\n    this.keep = false;\n  }\n}\nexports.BaseOperation = BaseOperation;\nclass GroupOperation extends BaseOperation {\n  constructor(params, owneryQuery, options, children) {\n    super(params, owneryQuery, options);\n    this.children = children;\n  }\n  /**\r\n   */\n  reset() {\n    this.keep = false;\n    this.done = false;\n    for (let i = 0, {\n        length\n      } = this.children; i < length; i++) {\n      this.children[i].reset();\n    }\n  }\n  /**\r\n   */\n  childrenNext(item, key, owner, root) {\n    let done = true;\n    let keep = true;\n    for (let i = 0, {\n        length\n      } = this.children; i < length; i++) {\n      const childOperation = this.children[i];\n      if (!childOperation.done) {\n        childOperation.next(item, key, owner, root);\n      }\n      if (!childOperation.keep) {\n        keep = false;\n      }\n      if (childOperation.done) {\n        if (!childOperation.keep) {\n          break;\n        }\n      } else {\n        done = false;\n      }\n    }\n    this.done = done;\n    this.keep = keep;\n  }\n}\nclass NamedGroupOperation extends GroupOperation {\n  constructor(params, owneryQuery, options, children, name) {\n    super(params, owneryQuery, options, children);\n    this.name = name;\n  }\n}\nexports.NamedGroupOperation = NamedGroupOperation;\nclass QueryOperation extends GroupOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  /**\r\n   */\n  next(item, key, parent, root) {\n    this.childrenNext(item, key, parent, root);\n  }\n}\nexports.QueryOperation = QueryOperation;\nclass NestedOperation extends GroupOperation {\n  constructor(keyPath, params, owneryQuery, options, children) {\n    super(params, owneryQuery, options, children);\n    this.keyPath = keyPath;\n    this.propop = true;\n    /**\r\n     */\n    this._nextNestedValue = (value, key, owner, root) => {\n      this.childrenNext(value, key, owner, root);\n      return !this.done;\n    };\n  }\n  /**\r\n   */\n  next(item, key, parent) {\n    walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);\n  }\n}\nexports.NestedOperation = NestedOperation;\nconst createTester = (a, compare) => {\n  if (a instanceof Function) {\n    return a;\n  }\n  if (a instanceof RegExp) {\n    return b => {\n      const result = typeof b === \"string\" && a.test(b);\n      a.lastIndex = 0;\n      return result;\n    };\n  }\n  const comparableA = (0, utils_1.comparable)(a);\n  return b => compare(comparableA, (0, utils_1.comparable)(b));\n};\nexports.createTester = createTester;\nclass EqualsOperation extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._test = (0, exports.createTester)(this.params, this.options.compare);\n  }\n  next(item, key, parent) {\n    if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\n      if (this._test(item, key, parent)) {\n        this.done = true;\n        this.keep = true;\n      }\n    }\n  }\n}\nexports.EqualsOperation = EqualsOperation;\nconst createEqualsOperation = (params, owneryQuery, options) => new EqualsOperation(params, owneryQuery, options);\nexports.createEqualsOperation = createEqualsOperation;\nclass NopeOperation extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  next() {\n    this.done = true;\n    this.keep = false;\n  }\n}\nexports.NopeOperation = NopeOperation;\nconst numericalOperationCreator = createNumericalOperation => (params, owneryQuery, options, name) => {\n  if (params == null) {\n    return new NopeOperation(params, owneryQuery, options, name);\n  }\n  return createNumericalOperation(params, owneryQuery, options, name);\n};\nexports.numericalOperationCreator = numericalOperationCreator;\nconst numericalOperation = createTester => (0, exports.numericalOperationCreator)((params, owneryQuery, options, name) => {\n  const typeofParams = typeof (0, utils_1.comparable)(params);\n  const test = createTester(params);\n  return new EqualsOperation(b => {\n    return typeof (0, utils_1.comparable)(b) === typeofParams && test(b);\n  }, owneryQuery, options, name);\n});\nexports.numericalOperation = numericalOperation;\nconst createNamedOperation = (name, params, parentQuery, options) => {\n  const operationCreator = options.operations[name];\n  if (!operationCreator) {\n    throwUnsupportedOperation(name);\n  }\n  return operationCreator(params, parentQuery, options, name);\n};\nconst throwUnsupportedOperation = name => {\n  throw new Error(`Unsupported operation: ${name}`);\n};\nconst containsOperation = (query, options) => {\n  for (const key in query) {\n    if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\") return true;\n  }\n  return false;\n};\nexports.containsOperation = containsOperation;\nconst createNestedOperation = (keyPath, nestedQuery, parentKey, owneryQuery, options) => {\n  if ((0, exports.containsOperation)(nestedQuery, options)) {\n    const [selfOperations, nestedOperations] = createQueryOperations(nestedQuery, parentKey, options);\n    if (nestedOperations.length) {\n      throw new Error(`Property queries must contain only operations, or exact objects.`);\n    }\n    return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);\n  }\n  return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [new EqualsOperation(nestedQuery, owneryQuery, options)]);\n};\nconst createQueryOperation = function (query) {\n  let owneryQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let {\n    compare,\n    operations\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = {\n    compare: compare || utils_1.equals,\n    operations: Object.assign({}, operations || {})\n  };\n  const [selfOperations, nestedOperations] = createQueryOperations(query, null, options);\n  const ops = [];\n  if (selfOperations.length) {\n    ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));\n  }\n  ops.push(...nestedOperations);\n  if (ops.length === 1) {\n    return ops[0];\n  }\n  return new QueryOperation(query, owneryQuery, options, ops);\n};\nexports.createQueryOperation = createQueryOperation;\nconst createQueryOperations = (query, parentKey, options) => {\n  const selfOperations = [];\n  const nestedOperations = [];\n  if (!(0, utils_1.isVanillaObject)(query)) {\n    selfOperations.push(new EqualsOperation(query, query, options));\n    return [selfOperations, nestedOperations];\n  }\n  for (const key in query) {\n    if (options.operations.hasOwnProperty(key)) {\n      const op = createNamedOperation(key, query[key], query, options);\n      if (op) {\n        if (!op.propop && parentKey && !options.operations[parentKey]) {\n          throw new Error(`Malformed query. ${key} cannot be matched against property.`);\n        }\n      }\n      // probably just a flag for another operation (like $options)\n      if (op != null) {\n        selfOperations.push(op);\n      }\n    } else if (key.charAt(0) === \"$\") {\n      throwUnsupportedOperation(key);\n    } else {\n      nestedOperations.push(createNestedOperation(key.split(\".\"), query[key], key, query, options));\n    }\n  }\n  return [selfOperations, nestedOperations];\n};\nconst createOperationTester = operation => (item, key, owner) => {\n  operation.reset();\n  operation.next(item, key, owner);\n  return operation.keep;\n};\nexports.createOperationTester = createOperationTester;\nconst createQueryTester = function (query) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (0, exports.createOperationTester)((0, exports.createQueryOperation)(query, null, options));\n};\nexports.createQueryTester = createQueryTester;","map":{"version":3,"mappings":"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","names":["walkKeyPathValues","item","keyPath","next","depth","key","owner","currentKey","isNaN","Number","i","length","BaseOperation","constructor","params","owneryQuery","options","name","init","reset","done","keep","exports","GroupOperation","children","childrenNext","root","childOperation","NamedGroupOperation","QueryOperation","parent","NestedOperation","value","_nextNestedValue","createTester","a","compare","Function","RegExp","b","result","test","lastIndex","comparableA","EqualsOperation","_test","Array","isArray","hasOwnProperty","createEqualsOperation","NopeOperation","numericalOperationCreator","createNumericalOperation","numericalOperation","typeofParams","createNamedOperation","parentQuery","operationCreator","operations","throwUnsupportedOperation","Error","containsOperation","query","charAt","createNestedOperation","nestedQuery","parentKey","selfOperations","nestedOperations","createQueryOperations","createQueryOperation","utils_1","Object","assign","ops","push","op","propop","split","createOperationTester","operation","createQueryTester"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\sift\\src\\core.ts"],"sourcesContent":["import {\r\n  isArray,\r\n  Key,\r\n  Comparator,\r\n  isVanillaObject,\r\n  comparable,\r\n  equals\r\n} from \"./utils\";\r\n\r\nexport interface Operation<TItem> {\r\n  readonly keep: boolean;\r\n  readonly done: boolean;\r\n  propop: boolean;\r\n  reset();\r\n  next(item: TItem, key?: Key, owner?: any, root?: boolean);\r\n}\r\n\r\nexport type Tester = (\r\n  item: any,\r\n  key?: Key,\r\n  owner?: any,\r\n  root?: boolean\r\n) => boolean;\r\n\r\nexport interface NamedOperation {\r\n  name: string;\r\n}\r\n\r\nexport type OperationCreator<TItem> = (\r\n  params: any,\r\n  parentQuery: any,\r\n  options: Options,\r\n  name: string\r\n) => Operation<TItem>;\r\n\r\nexport type BasicValueQuery<TValue> = {\r\n  $eq?: TValue;\r\n  $ne?: TValue;\r\n  $lt?: TValue;\r\n  $gt?: TValue;\r\n  $lte?: TValue;\r\n  $gte?: TValue;\r\n  $in?: TValue[];\r\n  $nin?: TValue[];\r\n  $all?: TValue[];\r\n  $mod?: [number, number];\r\n  $exists?: boolean;\r\n  $regex?: string | RegExp;\r\n  $size?: number;\r\n  $where?: ((this: TValue, obj: TValue) => boolean) | string;\r\n  $options?: \"i\" | \"g\" | \"m\" | \"u\";\r\n  $type?: Function;\r\n  $not?: NestedQuery<TValue>;\r\n  $or?: NestedQuery<TValue>[];\r\n  $nor?: NestedQuery<TValue>[];\r\n  $and?: NestedQuery<TValue>[];\r\n};\r\n\r\nexport type ArrayValueQuery<TValue> = {\r\n  $elemMatch?: Query<TValue>;\r\n} & BasicValueQuery<TValue>;\r\ntype Unpacked<T> = T extends (infer U)[] ? U : T;\r\n\r\nexport type ValueQuery<TValue> = TValue extends Array<any>\r\n  ? ArrayValueQuery<Unpacked<TValue>>\r\n  : BasicValueQuery<TValue>;\r\n\r\ntype NotObject = string | number | Date | boolean | Array<any>;\r\nexport type ShapeQuery<TItemSchema> = TItemSchema extends NotObject\r\n  ? {}\r\n  : { [k in keyof TItemSchema]?: TItemSchema[k] | ValueQuery<TItemSchema[k]> };\r\n\r\nexport type NestedQuery<TItemSchema> = ValueQuery<TItemSchema> &\r\n  ShapeQuery<TItemSchema>;\r\nexport type Query<TItemSchema> =\r\n  | TItemSchema\r\n  | RegExp\r\n  | NestedQuery<TItemSchema>;\r\n\r\nexport type QueryOperators<TValue = any> = keyof ValueQuery<TValue>;\r\n\r\n/**\r\n * Walks through each value given the context - used for nested operations. E.g:\r\n * { \"person.address\": { $eq: \"blarg\" }}\r\n */\r\n\r\nconst walkKeyPathValues = (\r\n  item: any,\r\n  keyPath: Key[],\r\n  next: Tester,\r\n  depth: number,\r\n  key: Key,\r\n  owner: any\r\n) => {\r\n  const currentKey = keyPath[depth];\r\n\r\n  // if array, then try matching. Might fall through for cases like:\r\n  // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\r\n  if (isArray(item) && isNaN(Number(currentKey))) {\r\n    for (let i = 0, { length } = item; i < length; i++) {\r\n      // if FALSE is returned, then terminate walker. For operations, this simply\r\n      // means that the search critera was met.\r\n      if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (depth === keyPath.length || item == null) {\r\n    return next(item, key, owner, depth === 0);\r\n  }\r\n\r\n  return walkKeyPathValues(\r\n    item[currentKey],\r\n    keyPath,\r\n    next,\r\n    depth + 1,\r\n    currentKey,\r\n    item\r\n  );\r\n};\r\n\r\nexport abstract class BaseOperation<TParams, TItem = any>\r\n  implements Operation<TItem> {\r\n  keep: boolean;\r\n  done: boolean;\r\n  abstract propop: boolean;\r\n  constructor(\r\n    readonly params: TParams,\r\n    readonly owneryQuery: any,\r\n    readonly options: Options,\r\n    readonly name?: string\r\n  ) {\r\n    this.init();\r\n  }\r\n  protected init() {}\r\n  reset() {\r\n    this.done = false;\r\n    this.keep = false;\r\n  }\r\n  abstract next(item: any, key: Key, parent: any, root: boolean);\r\n}\r\n\r\nabstract class GroupOperation extends BaseOperation<any> {\r\n  keep: boolean;\r\n  done: boolean;\r\n\r\n  constructor(\r\n    params: any,\r\n    owneryQuery: any,\r\n    options: Options,\r\n    public readonly children: Operation<any>[]\r\n  ) {\r\n    super(params, owneryQuery, options);\r\n  }\r\n\r\n  /**\r\n   */\r\n\r\n  reset() {\r\n    this.keep = false;\r\n    this.done = false;\r\n    for (let i = 0, { length } = this.children; i < length; i++) {\r\n      this.children[i].reset();\r\n    }\r\n  }\r\n\r\n  abstract next(item: any, key: Key, owner: any, root: boolean);\r\n\r\n  /**\r\n   */\r\n\r\n  protected childrenNext(item: any, key: Key, owner: any, root: boolean) {\r\n    let done = true;\r\n    let keep = true;\r\n    for (let i = 0, { length } = this.children; i < length; i++) {\r\n      const childOperation = this.children[i];\r\n      if (!childOperation.done) {\r\n        childOperation.next(item, key, owner, root);\r\n      }\r\n      if (!childOperation.keep) {\r\n        keep = false;\r\n      }\r\n      if (childOperation.done) {\r\n        if (!childOperation.keep) {\r\n          break;\r\n        }\r\n      } else {\r\n        done = false;\r\n      }\r\n    }\r\n    this.done = done;\r\n    this.keep = keep;\r\n  }\r\n}\r\n\r\nexport abstract class NamedGroupOperation extends GroupOperation\r\n  implements NamedOperation {\r\n  abstract propop: boolean;\r\n  constructor(\r\n    params: any,\r\n    owneryQuery: any,\r\n    options: Options,\r\n    children: Operation<any>[],\r\n    readonly name: string\r\n  ) {\r\n    super(params, owneryQuery, options, children);\r\n  }\r\n}\r\n\r\nexport class QueryOperation<TItem> extends GroupOperation {\r\n  readonly propop = true;\r\n  /**\r\n   */\r\n\r\n  next(item: TItem, key: Key, parent: any, root: boolean) {\r\n    this.childrenNext(item, key, parent, root);\r\n  }\r\n}\r\n\r\nexport class NestedOperation extends GroupOperation {\r\n  readonly propop = true;\r\n  constructor(\r\n    readonly keyPath: Key[],\r\n    params: any,\r\n    owneryQuery: any,\r\n    options: Options,\r\n    children: Operation<any>[]\r\n  ) {\r\n    super(params, owneryQuery, options, children);\r\n  }\r\n  /**\r\n   */\r\n\r\n  next(item: any, key: Key, parent: any) {\r\n    walkKeyPathValues(\r\n      item,\r\n      this.keyPath,\r\n      this._nextNestedValue,\r\n      0,\r\n      key,\r\n      parent\r\n    );\r\n  }\r\n\r\n  /**\r\n   */\r\n\r\n  private _nextNestedValue = (\r\n    value: any,\r\n    key: Key,\r\n    owner: any,\r\n    root: boolean\r\n  ) => {\r\n    this.childrenNext(value, key, owner, root);\r\n    return !this.done;\r\n  };\r\n}\r\n\r\nexport const createTester = (a, compare: Comparator) => {\r\n  if (a instanceof Function) {\r\n    return a;\r\n  }\r\n  if (a instanceof RegExp) {\r\n    return b => {\r\n      const result = typeof b === \"string\" && a.test(b);\r\n      a.lastIndex = 0;\r\n      return result;\r\n    };\r\n  }\r\n  const comparableA = comparable(a);\r\n  return b => compare(comparableA, comparable(b));\r\n};\r\n\r\nexport class EqualsOperation<TParam> extends BaseOperation<TParam> {\r\n  readonly propop = true;\r\n  private _test: Tester;\r\n  init() {\r\n    this._test = createTester(this.params, this.options.compare);\r\n  }\r\n  next(item, key: Key, parent: any) {\r\n    if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\r\n      if (this._test(item, key, parent)) {\r\n        this.done = true;\r\n        this.keep = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const createEqualsOperation = (\r\n  params: any,\r\n  owneryQuery: any,\r\n  options: Options\r\n) => new EqualsOperation(params, owneryQuery, options);\r\n\r\nexport class NopeOperation<TParam> extends BaseOperation<TParam> {\r\n  readonly propop = true;\r\n  next() {\r\n    this.done = true;\r\n    this.keep = false;\r\n  }\r\n}\r\n\r\nexport const numericalOperationCreator = (\r\n  createNumericalOperation: OperationCreator<any>\r\n) => (params: any, owneryQuery: any, options: Options, name: string) => {\r\n  if (params == null) {\r\n    return new NopeOperation(params, owneryQuery, options, name);\r\n  }\r\n\r\n  return createNumericalOperation(params, owneryQuery, options, name);\r\n};\r\n\r\nexport const numericalOperation = (createTester: (any) => Tester) =>\r\n  numericalOperationCreator(\r\n    (params: any, owneryQuery: Query<any>, options: Options, name: string) => {\r\n      const typeofParams = typeof comparable(params);\r\n      const test = createTester(params);\r\n      return new EqualsOperation(\r\n        b => {\r\n          return typeof comparable(b) === typeofParams && test(b);\r\n        },\r\n        owneryQuery,\r\n        options,\r\n        name\r\n      );\r\n    }\r\n  );\r\n\r\nexport type Options = {\r\n  operations: {\r\n    [identifier: string]: OperationCreator<any>;\r\n  };\r\n  compare: (a, b) => boolean;\r\n};\r\n\r\nconst createNamedOperation = (\r\n  name: string,\r\n  params: any,\r\n  parentQuery: any,\r\n  options: Options\r\n) => {\r\n  const operationCreator = options.operations[name];\r\n  if (!operationCreator) {\r\n    throwUnsupportedOperation(name);\r\n  }\r\n  return operationCreator(params, parentQuery, options, name);\r\n};\r\n\r\nconst throwUnsupportedOperation = (name: string) => {\r\n  throw new Error(`Unsupported operation: ${name}`);\r\n};\r\n\r\nexport const containsOperation = (query: any, options: Options) => {\r\n  for (const key in query) {\r\n    if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\")\r\n      return true;\r\n  }\r\n  return false;\r\n};\r\nconst createNestedOperation = (\r\n  keyPath: Key[],\r\n  nestedQuery: any,\r\n  parentKey: string,\r\n  owneryQuery: any,\r\n  options: Options\r\n) => {\r\n  if (containsOperation(nestedQuery, options)) {\r\n    const [selfOperations, nestedOperations] = createQueryOperations(\r\n      nestedQuery,\r\n      parentKey,\r\n      options\r\n    );\r\n    if (nestedOperations.length) {\r\n      throw new Error(\r\n        `Property queries must contain only operations, or exact objects.`\r\n      );\r\n    }\r\n    return new NestedOperation(\r\n      keyPath,\r\n      nestedQuery,\r\n      owneryQuery,\r\n      options,\r\n      selfOperations\r\n    );\r\n  }\r\n  return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [\r\n    new EqualsOperation(nestedQuery, owneryQuery, options)\r\n  ]);\r\n};\r\n\r\nexport const createQueryOperation = <TItem, TSchema = TItem>(\r\n  query: Query<TSchema>,\r\n  owneryQuery: any = null,\r\n  { compare, operations }: Partial<Options> = {}\r\n): QueryOperation<TItem> => {\r\n  const options = {\r\n    compare: compare || equals,\r\n    operations: Object.assign({}, operations || {})\r\n  };\r\n\r\n  const [selfOperations, nestedOperations] = createQueryOperations(\r\n    query,\r\n    null,\r\n    options\r\n  );\r\n\r\n  const ops = [];\r\n\r\n  if (selfOperations.length) {\r\n    ops.push(\r\n      new NestedOperation([], query, owneryQuery, options, selfOperations)\r\n    );\r\n  }\r\n\r\n  ops.push(...nestedOperations);\r\n\r\n  if (ops.length === 1) {\r\n    return ops[0];\r\n  }\r\n  return new QueryOperation(query, owneryQuery, options, ops);\r\n};\r\n\r\nconst createQueryOperations = (\r\n  query: any,\r\n  parentKey: string,\r\n  options: Options\r\n) => {\r\n  const selfOperations = [];\r\n  const nestedOperations = [];\r\n  if (!isVanillaObject(query)) {\r\n    selfOperations.push(new EqualsOperation(query, query, options));\r\n    return [selfOperations, nestedOperations];\r\n  }\r\n  for (const key in query) {\r\n    if (options.operations.hasOwnProperty(key)) {\r\n      const op = createNamedOperation(key, query[key], query, options);\r\n\r\n      if (op) {\r\n        if (!op.propop && parentKey && !options.operations[parentKey]) {\r\n          throw new Error(\r\n            `Malformed query. ${key} cannot be matched against property.`\r\n          );\r\n        }\r\n      }\r\n\r\n      // probably just a flag for another operation (like $options)\r\n      if (op != null) {\r\n        selfOperations.push(op);\r\n      }\r\n    } else if (key.charAt(0) === \"$\") {\r\n      throwUnsupportedOperation(key);\r\n    } else {\r\n      nestedOperations.push(\r\n        createNestedOperation(key.split(\".\"), query[key], key, query, options)\r\n      );\r\n    }\r\n  }\r\n\r\n  return [selfOperations, nestedOperations];\r\n};\r\n\r\nexport const createOperationTester = <TItem>(operation: Operation<TItem>) => (\r\n  item: TItem,\r\n  key?: Key,\r\n  owner?: any\r\n) => {\r\n  operation.reset();\r\n  operation.next(item, key, owner);\r\n  return operation.keep;\r\n};\r\n\r\nexport const createQueryTester = <TItem, TSchema = TItem>(\r\n  query: Query<TSchema>,\r\n  options: Partial<Options> = {}\r\n) => {\r\n  return createOperationTester(\r\n    createQueryOperation<TItem, TSchema>(query, null, options)\r\n  );\r\n};\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}