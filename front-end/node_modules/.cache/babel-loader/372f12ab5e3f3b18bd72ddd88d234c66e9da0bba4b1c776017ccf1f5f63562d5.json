{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst ExternalModule = require(\"../ExternalModule\");\nconst Template = require(\"../Template\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\n/**\r\n * @typedef {Object} AmdLibraryPluginOptions\r\n * @property {LibraryType} type\r\n * @property {boolean=} requireAsWrapper\r\n */\n\n/**\r\n * @typedef {Object} AmdLibraryPluginParsed\r\n * @property {string} name\r\n */\n\n/**\r\n * @typedef {AmdLibraryPluginParsed} T\r\n * @extends {AbstractLibraryPlugin<AmdLibraryPluginParsed>}\r\n */\nclass AmdLibraryPlugin extends AbstractLibraryPlugin {\n  /**\r\n   * @param {AmdLibraryPluginOptions} options the plugin options\r\n   */\n  constructor(options) {\n    super({\n      pluginName: \"AmdLibraryPlugin\",\n      type: options.type\n    });\n    this.requireAsWrapper = options.requireAsWrapper;\n  }\n\n  /**\r\n   * @param {LibraryOptions} library normalized library option\r\n   * @returns {T | false} preprocess as needed by overriding\r\n   */\n  parseOptions(library) {\n    const {\n      name\n    } = library;\n    if (this.requireAsWrapper) {\n      if (name) {\n        throw new Error(`AMD library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    } else {\n      if (name && typeof name !== \"string\") {\n        throw new Error(`AMD library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    }\n    return {\n      name: /** @type {string=} */name\n    };\n  }\n\n  /**\r\n   * @param {Source} source source\r\n   * @param {RenderContext} renderContext render context\r\n   * @param {LibraryContext<T>} libraryContext context\r\n   * @returns {Source} source with library export\r\n   */\n  render(source, _ref, _ref2) {\n    let {\n      chunkGraph,\n      chunk,\n      runtimeTemplate\n    } = _ref;\n    let {\n      options,\n      compilation\n    } = _ref2;\n    const modern = runtimeTemplate.supportsArrowFunction();\n    const modules = chunkGraph.getChunkModules(chunk).filter(m => m instanceof ExternalModule);\n    const externals = /** @type {ExternalModule[]} */modules;\n    const externalsDepsArray = JSON.stringify(externals.map(m => typeof m.request === \"object\" && !Array.isArray(m.request) ? m.request.amd : m.request));\n    const externalsArguments = externals.map(m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${chunkGraph.getModuleId(m)}`)}__`).join(\", \");\n    const iife = runtimeTemplate.isIIFE();\n    const fnStart = (modern ? `(${externalsArguments}) => {` : `function(${externalsArguments}) {`) + (iife || !chunk.hasRuntime() ? \" return \" : \"\\n\");\n    const fnEnd = iife ? \";\\n}\" : \"\\n}\";\n    if (this.requireAsWrapper) {\n      return new ConcatSource(`require(${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);\n    } else if (options.name) {\n      const name = compilation.getPath(options.name, {\n        chunk\n      });\n      return new ConcatSource(`define(${JSON.stringify(name)}, ${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);\n    } else if (externalsArguments) {\n      return new ConcatSource(`define(${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);\n    } else {\n      return new ConcatSource(`define(${fnStart}`, source, `${fnEnd});`);\n    }\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Hash} hash hash\r\n   * @param {ChunkHashContext} chunkHashContext chunk hash context\r\n   * @param {LibraryContext<T>} libraryContext context\r\n   * @returns {void}\r\n   */\n  chunkHash(chunk, hash, chunkHashContext, _ref3) {\n    let {\n      options,\n      compilation\n    } = _ref3;\n    hash.update(\"AmdLibraryPlugin\");\n    if (this.requireAsWrapper) {\n      hash.update(\"requireAsWrapper\");\n    } else if (options.name) {\n      hash.update(\"named\");\n      const name = compilation.getPath(options.name, {\n        chunk\n      });\n      hash.update(name);\n    }\n  }\n}\nmodule.exports = AmdLibraryPlugin;","map":{"version":3,"names":["ConcatSource","require","ExternalModule","Template","AbstractLibraryPlugin","AmdLibraryPlugin","constructor","options","pluginName","type","requireAsWrapper","parseOptions","library","name","Error","COMMON_LIBRARY_NAME_MESSAGE","render","source","chunkGraph","chunk","runtimeTemplate","compilation","modern","supportsArrowFunction","modules","getChunkModules","filter","m","externals","externalsDepsArray","JSON","stringify","map","request","Array","isArray","amd","externalsArguments","toIdentifier","getModuleId","join","iife","isIIFE","fnStart","hasRuntime","fnEnd","getPath","chunkHash","hash","chunkHashContext","update","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/library/AmdLibraryPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { ConcatSource } = require(\"webpack-sources\");\r\nconst ExternalModule = require(\"../ExternalModule\");\r\nconst Template = require(\"../Template\");\r\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\r\n\r\n/** @typedef {import(\"webpack-sources\").Source} Source */\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\r\n/** @typedef {import(\"../Chunk\")} Chunk */\r\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\r\n/** @typedef {import(\"../Compiler\")} Compiler */\r\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\r\n/** @typedef {import(\"../util/Hash\")} Hash */\r\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\r\n\r\n/**\r\n * @typedef {Object} AmdLibraryPluginOptions\r\n * @property {LibraryType} type\r\n * @property {boolean=} requireAsWrapper\r\n */\r\n\r\n/**\r\n * @typedef {Object} AmdLibraryPluginParsed\r\n * @property {string} name\r\n */\r\n\r\n/**\r\n * @typedef {AmdLibraryPluginParsed} T\r\n * @extends {AbstractLibraryPlugin<AmdLibraryPluginParsed>}\r\n */\r\nclass AmdLibraryPlugin extends AbstractLibraryPlugin {\r\n\t/**\r\n\t * @param {AmdLibraryPluginOptions} options the plugin options\r\n\t */\r\n\tconstructor(options) {\r\n\t\tsuper({\r\n\t\t\tpluginName: \"AmdLibraryPlugin\",\r\n\t\t\ttype: options.type\r\n\t\t});\r\n\t\tthis.requireAsWrapper = options.requireAsWrapper;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {LibraryOptions} library normalized library option\r\n\t * @returns {T | false} preprocess as needed by overriding\r\n\t */\r\n\tparseOptions(library) {\r\n\t\tconst { name } = library;\r\n\t\tif (this.requireAsWrapper) {\r\n\t\t\tif (name) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`AMD library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (name && typeof name !== \"string\") {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`AMD library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tname: /** @type {string=} */ (name)\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Source} source source\r\n\t * @param {RenderContext} renderContext render context\r\n\t * @param {LibraryContext<T>} libraryContext context\r\n\t * @returns {Source} source with library export\r\n\t */\r\n\trender(\r\n\t\tsource,\r\n\t\t{ chunkGraph, chunk, runtimeTemplate },\r\n\t\t{ options, compilation }\r\n\t) {\r\n\t\tconst modern = runtimeTemplate.supportsArrowFunction();\r\n\t\tconst modules = chunkGraph\r\n\t\t\t.getChunkModules(chunk)\r\n\t\t\t.filter(m => m instanceof ExternalModule);\r\n\t\tconst externals = /** @type {ExternalModule[]} */ (modules);\r\n\t\tconst externalsDepsArray = JSON.stringify(\r\n\t\t\texternals.map(m =>\r\n\t\t\t\ttypeof m.request === \"object\" && !Array.isArray(m.request)\r\n\t\t\t\t\t? m.request.amd\r\n\t\t\t\t\t: m.request\r\n\t\t\t)\r\n\t\t);\r\n\t\tconst externalsArguments = externals\r\n\t\t\t.map(\r\n\t\t\t\tm =>\r\n\t\t\t\t\t`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(\r\n\t\t\t\t\t\t`${chunkGraph.getModuleId(m)}`\r\n\t\t\t\t\t)}__`\r\n\t\t\t)\r\n\t\t\t.join(\", \");\r\n\r\n\t\tconst iife = runtimeTemplate.isIIFE();\r\n\t\tconst fnStart =\r\n\t\t\t(modern\r\n\t\t\t\t? `(${externalsArguments}) => {`\r\n\t\t\t\t: `function(${externalsArguments}) {`) +\r\n\t\t\t(iife || !chunk.hasRuntime() ? \" return \" : \"\\n\");\r\n\t\tconst fnEnd = iife ? \";\\n}\" : \"\\n}\";\r\n\r\n\t\tif (this.requireAsWrapper) {\r\n\t\t\treturn new ConcatSource(\r\n\t\t\t\t`require(${externalsDepsArray}, ${fnStart}`,\r\n\t\t\t\tsource,\r\n\t\t\t\t`${fnEnd});`\r\n\t\t\t);\r\n\t\t} else if (options.name) {\r\n\t\t\tconst name = compilation.getPath(options.name, {\r\n\t\t\t\tchunk\r\n\t\t\t});\r\n\r\n\t\t\treturn new ConcatSource(\r\n\t\t\t\t`define(${JSON.stringify(name)}, ${externalsDepsArray}, ${fnStart}`,\r\n\t\t\t\tsource,\r\n\t\t\t\t`${fnEnd});`\r\n\t\t\t);\r\n\t\t} else if (externalsArguments) {\r\n\t\t\treturn new ConcatSource(\r\n\t\t\t\t`define(${externalsDepsArray}, ${fnStart}`,\r\n\t\t\t\tsource,\r\n\t\t\t\t`${fnEnd});`\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn new ConcatSource(`define(${fnStart}`, source, `${fnEnd});`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Hash} hash hash\r\n\t * @param {ChunkHashContext} chunkHashContext chunk hash context\r\n\t * @param {LibraryContext<T>} libraryContext context\r\n\t * @returns {void}\r\n\t */\r\n\tchunkHash(chunk, hash, chunkHashContext, { options, compilation }) {\r\n\t\thash.update(\"AmdLibraryPlugin\");\r\n\t\tif (this.requireAsWrapper) {\r\n\t\t\thash.update(\"requireAsWrapper\");\r\n\t\t} else if (options.name) {\r\n\t\t\thash.update(\"named\");\r\n\t\t\tconst name = compilation.getPath(options.name, {\r\n\t\t\t\tchunk\r\n\t\t\t});\r\n\t\t\thash.update(name);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = AmdLibraryPlugin;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}