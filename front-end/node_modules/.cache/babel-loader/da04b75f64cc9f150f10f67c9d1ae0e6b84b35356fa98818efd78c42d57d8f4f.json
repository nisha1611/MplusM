{"ast":null,"code":"'use strict';\n\nconst symbols = require('../../schema/symbols');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/*!\r\n * ignore\r\n */\n\nmodule.exports = applyHooks;\n\n/*!\r\n * ignore\r\n */\n\napplyHooks.middlewareFunctions = ['deleteOne', 'save', 'validate', 'remove', 'updateOne', 'init'];\n\n/*!\r\n * ignore\r\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => [fn, `$__${fn}`]));\n\n/**\r\n * Register hooks for this model\r\n *\r\n * @param {Model} model\r\n * @param {Schema} schema\r\n * @param {Object} options\r\n * @api private\r\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n    applyHooks(childModel, type.schema, options);\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key], childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.filter(hook => {\n    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n      return !!hook['document'];\n    }\n    if (hook.name === 'remove' || hook.name === 'init') {\n      return hook['document'] == null || !!hook['document'];\n    }\n    if (hook.query != null || hook.document != null) {\n      return hook.document !== false;\n    }\n    return true;\n  }).filter(hook => {\n    // If user has overwritten the method, don't apply built-in middleware\n    if (schema.methods[hook.name]) {\n      return !hook.fn[symbols.builtInMiddleware];\n    }\n    return true;\n  });\n  model._middleware = middleware;\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n  for (const method of ['save', 'validate', 'remove', 'deleteOne']) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ? args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this, argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}","map":{"version":3,"names":["symbols","require","promiseOrCallback","module","exports","applyHooks","middlewareFunctions","alreadyHookedFunctions","Set","flatMap","fn","model","schema","options","kareemOptions","useErrorHandlers","numCallbackParams","nullResultByDefault","contextParameter","objToDecorate","decorateDoc","prototype","$appliedHooks","key","Object","keys","paths","type","childModel","$isSingleNested","caster","$isMongooseDocumentArray","Constructor","discriminators","middleware","s","hooks","filter","hook","name","query","document","methods","builtInMiddleware","_middleware","$__originalValidate","$__validate","method","toWrap","wrapped","createWrapper","$__init","createWrapperSync","customMethods","customMethodOptions","assign","checkForPromise","has","hasHooks","originalMethod","args","Array","slice","call","arguments","cb","pop","argsWithoutCallback","length","callback","apply","concat","events"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/model/applyHooks.js"],"sourcesContent":["'use strict';\r\n\r\nconst symbols = require('../../schema/symbols');\r\nconst promiseOrCallback = require('../promiseOrCallback');\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nmodule.exports = applyHooks;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\napplyHooks.middlewareFunctions = [\r\n  'deleteOne',\r\n  'save',\r\n  'validate',\r\n  'remove',\r\n  'updateOne',\r\n  'init'\r\n];\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\r\n\r\n/**\r\n * Register hooks for this model\r\n *\r\n * @param {Model} model\r\n * @param {Schema} schema\r\n * @param {Object} options\r\n * @api private\r\n */\r\n\r\nfunction applyHooks(model, schema, options) {\r\n  options = options || {};\r\n\r\n  const kareemOptions = {\r\n    useErrorHandlers: true,\r\n    numCallbackParams: 1,\r\n    nullResultByDefault: true,\r\n    contextParameter: true\r\n  };\r\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\r\n\r\n  model.$appliedHooks = true;\r\n  for (const key of Object.keys(schema.paths)) {\r\n    const type = schema.paths[key];\r\n    let childModel = null;\r\n    if (type.$isSingleNested) {\r\n      childModel = type.caster;\r\n    } else if (type.$isMongooseDocumentArray) {\r\n      childModel = type.Constructor;\r\n    } else {\r\n      continue;\r\n    }\r\n\r\n    if (childModel.$appliedHooks) {\r\n      continue;\r\n    }\r\n\r\n    applyHooks(childModel, type.schema, options);\r\n    if (childModel.discriminators != null) {\r\n      const keys = Object.keys(childModel.discriminators);\r\n      for (const key of keys) {\r\n        applyHooks(childModel.discriminators[key],\r\n          childModel.discriminators[key].schema, options);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Built-in hooks rely on hooking internal functions in order to support\r\n  // promises and make it so that `doc.save.toString()` provides meaningful\r\n  // information.\r\n\r\n  const middleware = schema.s.hooks.\r\n    filter(hook => {\r\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\r\n        return !!hook['document'];\r\n      }\r\n      if (hook.name === 'remove' || hook.name === 'init') {\r\n        return hook['document'] == null || !!hook['document'];\r\n      }\r\n      if (hook.query != null || hook.document != null) {\r\n        return hook.document !== false;\r\n      }\r\n      return true;\r\n    }).\r\n    filter(hook => {\r\n      // If user has overwritten the method, don't apply built-in middleware\r\n      if (schema.methods[hook.name]) {\r\n        return !hook.fn[symbols.builtInMiddleware];\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n  model._middleware = middleware;\r\n\r\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\r\n\r\n  for (const method of ['save', 'validate', 'remove', 'deleteOne']) {\r\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\r\n    const wrapped = middleware.\r\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\r\n    objToDecorate[`$__${method}`] = wrapped;\r\n  }\r\n  objToDecorate.$__init = middleware.\r\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\r\n\r\n  // Support hooks for custom methods\r\n  const customMethods = Object.keys(schema.methods);\r\n  const customMethodOptions = Object.assign({}, kareemOptions, {\r\n    // Only use `checkForPromise` for custom methods, because mongoose\r\n    // query thunks are not as consistent as I would like about returning\r\n    // a nullish value rather than the query. If a query thunk returns\r\n    // a query, `checkForPromise` causes infinite recursion\r\n    checkForPromise: true\r\n  });\r\n  for (const method of customMethods) {\r\n    if (alreadyHookedFunctions.has(method)) {\r\n      continue;\r\n    }\r\n    if (!middleware.hasHooks(method)) {\r\n      // Don't wrap if there are no hooks for the custom method to avoid\r\n      // surprises. Also, `createWrapper()` enforces consistent async,\r\n      // so wrapping a sync method would break it.\r\n      continue;\r\n    }\r\n    const originalMethod = objToDecorate[method];\r\n    objToDecorate[method] = function() {\r\n      const args = Array.prototype.slice.call(arguments);\r\n      const cb = args.slice(-1).pop();\r\n      const argsWithoutCallback = typeof cb === 'function' ?\r\n        args.slice(0, args.length - 1) : args;\r\n      return promiseOrCallback(cb, callback => {\r\n        return this[`$__${method}`].apply(this,\r\n          argsWithoutCallback.concat([callback]));\r\n      }, model.events);\r\n    };\r\n    objToDecorate[`$__${method}`] = middleware.\r\n      createWrapper(method, originalMethod, null, customMethodOptions);\r\n  }\r\n}\r\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAC/C,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,sBAAsB,CAAC;;AAEzD;AACA;AACA;;AAEAE,MAAM,CAACC,OAAO,GAAGC,UAAU;;AAE3B;AACA;AACA;;AAEAA,UAAU,CAACC,mBAAmB,GAAG,CAC/B,WAAW,EACX,MAAM,EACN,UAAU,EACV,QAAQ,EACR,WAAW,EACX,MAAM,CACP;;AAED;AACA;AACA;;AAEA,MAAMC,sBAAsB,GAAG,IAAIC,GAAG,CAACH,UAAU,CAACC,mBAAmB,CAACG,OAAO,CAACC,EAAE,IAAK,CAACA,EAAE,EAAG,MAAKA,EAAG,EAAC,CAAE,CAAC,CAAC;;AAExG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASL,UAAU,CAACM,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAE;EAC1CA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,MAAMC,aAAa,GAAG;IACpBC,gBAAgB,EAAE,IAAI;IACtBC,iBAAiB,EAAE,CAAC;IACpBC,mBAAmB,EAAE,IAAI;IACzBC,gBAAgB,EAAE;EACpB,CAAC;EACD,MAAMC,aAAa,GAAGN,OAAO,CAACO,WAAW,GAAGT,KAAK,GAAGA,KAAK,CAACU,SAAS;EAEnEV,KAAK,CAACW,aAAa,GAAG,IAAI;EAC1B,KAAK,MAAMC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACb,MAAM,CAACc,KAAK,CAAC,EAAE;IAC3C,MAAMC,IAAI,GAAGf,MAAM,CAACc,KAAK,CAACH,GAAG,CAAC;IAC9B,IAAIK,UAAU,GAAG,IAAI;IACrB,IAAID,IAAI,CAACE,eAAe,EAAE;MACxBD,UAAU,GAAGD,IAAI,CAACG,MAAM;IAC1B,CAAC,MAAM,IAAIH,IAAI,CAACI,wBAAwB,EAAE;MACxCH,UAAU,GAAGD,IAAI,CAACK,WAAW;IAC/B,CAAC,MAAM;MACL;IACF;IAEA,IAAIJ,UAAU,CAACN,aAAa,EAAE;MAC5B;IACF;IAEAjB,UAAU,CAACuB,UAAU,EAAED,IAAI,CAACf,MAAM,EAAEC,OAAO,CAAC;IAC5C,IAAIe,UAAU,CAACK,cAAc,IAAI,IAAI,EAAE;MACrC,MAAMR,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACG,UAAU,CAACK,cAAc,CAAC;MACnD,KAAK,MAAMV,GAAG,IAAIE,IAAI,EAAE;QACtBpB,UAAU,CAACuB,UAAU,CAACK,cAAc,CAACV,GAAG,CAAC,EACvCK,UAAU,CAACK,cAAc,CAACV,GAAG,CAAC,CAACX,MAAM,EAAEC,OAAO,CAAC;MACnD;IACF;EACF;;EAEA;EACA;EACA;;EAEA,MAAMqB,UAAU,GAAGtB,MAAM,CAACuB,CAAC,CAACC,KAAK,CAC/BC,MAAM,CAACC,IAAI,IAAI;IACb,IAAIA,IAAI,CAACC,IAAI,KAAK,WAAW,IAAID,IAAI,CAACC,IAAI,KAAK,WAAW,EAAE;MAC1D,OAAO,CAAC,CAACD,IAAI,CAAC,UAAU,CAAC;IAC3B;IACA,IAAIA,IAAI,CAACC,IAAI,KAAK,QAAQ,IAAID,IAAI,CAACC,IAAI,KAAK,MAAM,EAAE;MAClD,OAAOD,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,CAACA,IAAI,CAAC,UAAU,CAAC;IACvD;IACA,IAAIA,IAAI,CAACE,KAAK,IAAI,IAAI,IAAIF,IAAI,CAACG,QAAQ,IAAI,IAAI,EAAE;MAC/C,OAAOH,IAAI,CAACG,QAAQ,KAAK,KAAK;IAChC;IACA,OAAO,IAAI;EACb,CAAC,CAAC,CACFJ,MAAM,CAACC,IAAI,IAAI;IACb;IACA,IAAI1B,MAAM,CAAC8B,OAAO,CAACJ,IAAI,CAACC,IAAI,CAAC,EAAE;MAC7B,OAAO,CAACD,IAAI,CAAC5B,EAAE,CAACV,OAAO,CAAC2C,iBAAiB,CAAC;IAC5C;IAEA,OAAO,IAAI;EACb,CAAC,CAAC;EAEJhC,KAAK,CAACiC,WAAW,GAAGV,UAAU;EAE9Bf,aAAa,CAAC0B,mBAAmB,GAAG1B,aAAa,CAAC0B,mBAAmB,IAAI1B,aAAa,CAAC2B,WAAW;EAElG,KAAK,MAAMC,MAAM,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,WAAW,CAAC,EAAE;IAChE,MAAMC,MAAM,GAAGD,MAAM,KAAK,UAAU,GAAG,qBAAqB,GAAI,MAAKA,MAAO,EAAC;IAC7E,MAAME,OAAO,GAAGf,UAAU,CACxBgB,aAAa,CAACH,MAAM,EAAE5B,aAAa,CAAC6B,MAAM,CAAC,EAAE,IAAI,EAAElC,aAAa,CAAC;IACnEK,aAAa,CAAE,MAAK4B,MAAO,EAAC,CAAC,GAAGE,OAAO;EACzC;EACA9B,aAAa,CAACgC,OAAO,GAAGjB,UAAU,CAChCkB,iBAAiB,CAAC,MAAM,EAAEjC,aAAa,CAACgC,OAAO,EAAE,IAAI,EAAErC,aAAa,CAAC;;EAEvE;EACA,MAAMuC,aAAa,GAAG7B,MAAM,CAACC,IAAI,CAACb,MAAM,CAAC8B,OAAO,CAAC;EACjD,MAAMY,mBAAmB,GAAG9B,MAAM,CAAC+B,MAAM,CAAC,CAAC,CAAC,EAAEzC,aAAa,EAAE;IAC3D;IACA;IACA;IACA;IACA0C,eAAe,EAAE;EACnB,CAAC,CAAC;EACF,KAAK,MAAMT,MAAM,IAAIM,aAAa,EAAE;IAClC,IAAI9C,sBAAsB,CAACkD,GAAG,CAACV,MAAM,CAAC,EAAE;MACtC;IACF;IACA,IAAI,CAACb,UAAU,CAACwB,QAAQ,CAACX,MAAM,CAAC,EAAE;MAChC;MACA;MACA;MACA;IACF;IACA,MAAMY,cAAc,GAAGxC,aAAa,CAAC4B,MAAM,CAAC;IAC5C5B,aAAa,CAAC4B,MAAM,CAAC,GAAG,YAAW;MACjC,MAAMa,IAAI,GAAGC,KAAK,CAACxC,SAAS,CAACyC,KAAK,CAACC,IAAI,CAACC,SAAS,CAAC;MAClD,MAAMC,EAAE,GAAGL,IAAI,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACI,GAAG,EAAE;MAC/B,MAAMC,mBAAmB,GAAG,OAAOF,EAAE,KAAK,UAAU,GAClDL,IAAI,CAACE,KAAK,CAAC,CAAC,EAAEF,IAAI,CAACQ,MAAM,GAAG,CAAC,CAAC,GAAGR,IAAI;MACvC,OAAO1D,iBAAiB,CAAC+D,EAAE,EAAEI,QAAQ,IAAI;QACvC,OAAO,IAAI,CAAE,MAAKtB,MAAO,EAAC,CAAC,CAACuB,KAAK,CAAC,IAAI,EACpCH,mBAAmB,CAACI,MAAM,CAAC,CAACF,QAAQ,CAAC,CAAC,CAAC;MAC3C,CAAC,EAAE1D,KAAK,CAAC6D,MAAM,CAAC;IAClB,CAAC;IACDrD,aAAa,CAAE,MAAK4B,MAAO,EAAC,CAAC,GAAGb,UAAU,CACxCgB,aAAa,CAACH,MAAM,EAAEY,cAAc,EAAE,IAAI,EAAEL,mBAAmB,CAAC;EACpE;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}