{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst download_1 = require(\"./download\");\nconst upload_1 = require(\"./upload\");\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\r\n * Constructor for a streaming GridFS interface\r\n * @public\r\n */\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = {\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\r\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\r\n   * buffers to GridFS. The stream's 'id' property contains the resulting\r\n   * file's id.\r\n   *\r\n   * @param filename - The value of the 'filename' key in the files doc\r\n   * @param options - Optional settings.\r\n   */\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, options);\n  }\n  /**\r\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\r\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\r\n   * file's id.\r\n   */\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, {\n      ...options,\n      id\n    });\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, options);\n  }\n  delete(id, callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      const {\n        deletedCount\n      } = await this.s._filesCollection.deleteOne({\n        _id: id\n      });\n      // Delete orphaned chunks before returning FileNotFound\n      await this.s._chunksCollection.deleteMany({\n        files_id: id\n      });\n      if (deletedCount === 0) {\n        // TODO(NODE-3483): Replace with more appropriate error\n        // Consider creating new error MongoGridFSFileNotFoundError\n        throw new error_1.MongoRuntimeError(`File not found for id ${id}`);\n      }\n    }, callback);\n  }\n  /** Convenience wrapper around find on the files collection */\n  find(filter, options) {\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\r\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\r\n   * file with the given name from GridFS. If there are multiple files with\r\n   * the same name, this will stream the most recent file with the given name\r\n   * (as determined by the `uploadDate` field). You can set the `revision`\r\n   * option to change this behavior.\r\n   */\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, {\n      ...options,\n      sort,\n      skip\n    });\n  }\n  rename(id, filename, callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      const filter = {\n        _id: id\n      };\n      const update = {\n        $set: {\n          filename\n        }\n      };\n      const {\n        matchedCount\n      } = await this.s._filesCollection.updateOne(filter, update);\n      if (matchedCount === 0) {\n        throw new error_1.MongoRuntimeError(`File with id ${id} not found`);\n      }\n    }, callback);\n  }\n  drop(callback) {\n    return (0, utils_1.maybeCallback)(async () => {\n      await this.s._filesCollection.drop();\n      await this.s._chunksCollection.drop();\n    }, callback);\n  }\n  /** Get the Db scoped logger. */\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n}\nexports.GridFSBucket = GridFSBucket;\n/**\r\n * When the first call to openUploadStream is made, the upload stream will\r\n * check to see if it needs to create the proper indexes on the chunks and\r\n * files collections. This event is fired either when 1) it determines that\r\n * no index creation is necessary, 2) when it successfully creates the\r\n * necessary indexes.\r\n * @event\r\n */\nGridFSBucket.INDEX = 'index';","map":{"version":3,"mappings":"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","names":["DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","GridFSBucket","mongo_types_1","constructor","db","options","setMaxListeners","privateOptions","writeConcern","write_concern_1","fromOptions","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","openUploadStream","filename","upload_1","openUploadStreamWithId","id","openDownloadStream","download_1","readPreference","_id","delete","callback","deletedCount","deleteOne","deleteMany","files_id","error_1","find","filter","openDownloadStreamByName","sort","uploadDate","skip","undefined","revision","rename","update","$set","matchedCount","updateOne","drop","getLogger","logger","exports"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\gridfs\\index.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\r\nimport type { Collection } from '../collection';\r\nimport type { FindCursor } from '../cursor/find_cursor';\r\nimport type { Db } from '../db';\r\nimport { MongoRuntimeError } from '../error';\r\nimport type { Logger } from '../logger';\r\nimport { Filter, TypedEventEmitter } from '../mongo_types';\r\nimport type { ReadPreference } from '../read_preference';\r\nimport type { Sort } from '../sort';\r\nimport { Callback, maybeCallback } from '../utils';\r\nimport { WriteConcern, WriteConcernOptions } from '../write_concern';\r\nimport type { FindOptions } from './../operations/find';\r\nimport {\r\n  GridFSBucketReadStream,\r\n  GridFSBucketReadStreamOptions,\r\n  GridFSBucketReadStreamOptionsWithRevision,\r\n  GridFSFile\r\n} from './download';\r\nimport { GridFSBucketWriteStream, GridFSBucketWriteStreamOptions, GridFSChunk } from './upload';\r\n\r\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS: {\r\n  bucketName: string;\r\n  chunkSizeBytes: number;\r\n} = {\r\n  bucketName: 'fs',\r\n  chunkSizeBytes: 255 * 1024\r\n};\r\n\r\n/** @public */\r\nexport interface GridFSBucketOptions extends WriteConcernOptions {\r\n  /** The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot. */\r\n  bucketName?: string;\r\n  /** Number of bytes stored in each chunk. Defaults to 255KB */\r\n  chunkSizeBytes?: number;\r\n  /** Read preference to be passed to read operations */\r\n  readPreference?: ReadPreference;\r\n}\r\n\r\n/** @internal */\r\nexport interface GridFSBucketPrivate {\r\n  db: Db;\r\n  options: {\r\n    bucketName: string;\r\n    chunkSizeBytes: number;\r\n    readPreference?: ReadPreference;\r\n    writeConcern: WriteConcern | undefined;\r\n  };\r\n  _chunksCollection: Collection<GridFSChunk>;\r\n  _filesCollection: Collection<GridFSFile>;\r\n  checkedIndexes: boolean;\r\n  calledOpenUploadStream: boolean;\r\n}\r\n\r\n/** @public */\r\nexport type GridFSBucketEvents = {\r\n  index(): void;\r\n};\r\n\r\n/**\r\n * Constructor for a streaming GridFS interface\r\n * @public\r\n */\r\nexport class GridFSBucket extends TypedEventEmitter<GridFSBucketEvents> {\r\n  /** @internal */\r\n  s: GridFSBucketPrivate;\r\n\r\n  /**\r\n   * When the first call to openUploadStream is made, the upload stream will\r\n   * check to see if it needs to create the proper indexes on the chunks and\r\n   * files collections. This event is fired either when 1) it determines that\r\n   * no index creation is necessary, 2) when it successfully creates the\r\n   * necessary indexes.\r\n   * @event\r\n   */\r\n  static readonly INDEX = 'index' as const;\r\n\r\n  constructor(db: Db, options?: GridFSBucketOptions) {\r\n    super();\r\n    this.setMaxListeners(0);\r\n    const privateOptions = {\r\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\r\n      ...options,\r\n      writeConcern: WriteConcern.fromOptions(options)\r\n    };\r\n    this.s = {\r\n      db,\r\n      options: privateOptions,\r\n      _chunksCollection: db.collection<GridFSChunk>(privateOptions.bucketName + '.chunks'),\r\n      _filesCollection: db.collection<GridFSFile>(privateOptions.bucketName + '.files'),\r\n      checkedIndexes: false,\r\n      calledOpenUploadStream: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\r\n   * buffers to GridFS. The stream's 'id' property contains the resulting\r\n   * file's id.\r\n   *\r\n   * @param filename - The value of the 'filename' key in the files doc\r\n   * @param options - Optional settings.\r\n   */\r\n\r\n  openUploadStream(\r\n    filename: string,\r\n    options?: GridFSBucketWriteStreamOptions\r\n  ): GridFSBucketWriteStream {\r\n    return new GridFSBucketWriteStream(this, filename, options);\r\n  }\r\n\r\n  /**\r\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\r\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\r\n   * file's id.\r\n   */\r\n  openUploadStreamWithId(\r\n    id: ObjectId,\r\n    filename: string,\r\n    options?: GridFSBucketWriteStreamOptions\r\n  ): GridFSBucketWriteStream {\r\n    return new GridFSBucketWriteStream(this, filename, { ...options, id });\r\n  }\r\n\r\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\r\n  openDownloadStream(\r\n    id: ObjectId,\r\n    options?: GridFSBucketReadStreamOptions\r\n  ): GridFSBucketReadStream {\r\n    return new GridFSBucketReadStream(\r\n      this.s._chunksCollection,\r\n      this.s._filesCollection,\r\n      this.s.options.readPreference,\r\n      { _id: id },\r\n      options\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Deletes a file with the given id\r\n   *\r\n   * @param id - The id of the file doc\r\n   */\r\n  delete(id: ObjectId): Promise<void>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  delete(id: ObjectId, callback: Callback<void>): void;\r\n  delete(id: ObjectId, callback?: Callback<void>): Promise<void> | void {\r\n    return maybeCallback(async () => {\r\n      const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id });\r\n\r\n      // Delete orphaned chunks before returning FileNotFound\r\n      await this.s._chunksCollection.deleteMany({ files_id: id });\r\n\r\n      if (deletedCount === 0) {\r\n        // TODO(NODE-3483): Replace with more appropriate error\r\n        // Consider creating new error MongoGridFSFileNotFoundError\r\n        throw new MongoRuntimeError(`File not found for id ${id}`);\r\n      }\r\n    }, callback);\r\n  }\r\n\r\n  /** Convenience wrapper around find on the files collection */\r\n  find(filter?: Filter<GridFSFile>, options?: FindOptions): FindCursor<GridFSFile> {\r\n    filter ??= {};\r\n    options = options ?? {};\r\n    return this.s._filesCollection.find(filter, options);\r\n  }\r\n\r\n  /**\r\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\r\n   * file with the given name from GridFS. If there are multiple files with\r\n   * the same name, this will stream the most recent file with the given name\r\n   * (as determined by the `uploadDate` field). You can set the `revision`\r\n   * option to change this behavior.\r\n   */\r\n  openDownloadStreamByName(\r\n    filename: string,\r\n    options?: GridFSBucketReadStreamOptionsWithRevision\r\n  ): GridFSBucketReadStream {\r\n    let sort: Sort = { uploadDate: -1 };\r\n    let skip = undefined;\r\n    if (options && options.revision != null) {\r\n      if (options.revision >= 0) {\r\n        sort = { uploadDate: 1 };\r\n        skip = options.revision;\r\n      } else {\r\n        skip = -options.revision - 1;\r\n      }\r\n    }\r\n    return new GridFSBucketReadStream(\r\n      this.s._chunksCollection,\r\n      this.s._filesCollection,\r\n      this.s.options.readPreference,\r\n      { filename },\r\n      { ...options, sort, skip }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Renames the file with the given _id to the given string\r\n   *\r\n   * @param id - the id of the file to rename\r\n   * @param filename - new name for the file\r\n   */\r\n  rename(id: ObjectId, filename: string): Promise<void>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  rename(id: ObjectId, filename: string, callback: Callback<void>): void;\r\n  rename(id: ObjectId, filename: string, callback?: Callback<void>): Promise<void> | void {\r\n    return maybeCallback(async () => {\r\n      const filter = { _id: id };\r\n      const update = { $set: { filename } };\r\n      const { matchedCount } = await this.s._filesCollection.updateOne(filter, update);\r\n      if (matchedCount === 0) {\r\n        throw new MongoRuntimeError(`File with id ${id} not found`);\r\n      }\r\n    }, callback);\r\n  }\r\n\r\n  /** Removes this bucket's files collection, followed by its chunks collection. */\r\n  drop(): Promise<void>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  drop(callback: Callback<void>): void;\r\n  drop(callback?: Callback<void>): Promise<void> | void {\r\n    return maybeCallback(async () => {\r\n      await this.s._filesCollection.drop();\r\n      await this.s._chunksCollection.drop();\r\n    }, callback);\r\n  }\r\n\r\n  /** Get the Db scoped logger. */\r\n  getLogger(): Logger {\r\n    return this.s.db.s.logger;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}