{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils');\n\n// internal\nvar reEscComments = /\\\\#/g;\n// note that '^^' is used in place of escaped comments\nvar reUnescapeComments = /\\^\\^/g;\nvar reComments = /#.*$/;\nvar reEscapeChars = /[.|\\-[\\]()\\\\]/g;\nvar reAsterisk = /\\*/g;\nmodule.exports = add;\n\n/**\r\n * Converts file patterns or regular expressions to nodemon\r\n * compatible RegExp matching rules. Note: the `rules` argument\r\n * object is modified to include the new rule and new RegExp\r\n *\r\n * ### Example:\r\n *\r\n *     var rules = { watch: [], ignore: [] };\r\n *     add(rules, 'watch', '*.js');\r\n *     add(rules, 'ignore', '/public/');\r\n *     add(rules, 'watch', ':(\\d)*\\.js'); // note: string based regexp\r\n *     add(rules, 'watch', /\\d*\\.js/);\r\n *\r\n * @param {Object} rules containing `watch` and `ignore`. Also updated during\r\n *                       execution\r\n * @param {String} which must be either \"watch\" or \"ignore\"\r\n * @param {String|RegExp} the actual rule.\r\n */\nfunction add(rules, which, rule) {\n  if (!{\n    ignore: 1,\n    watch: 1\n  }[which]) {\n    throw new Error('rules/index.js#add requires \"ignore\" or \"watch\" as the ' + 'first argument');\n  }\n  if (Array.isArray(rule)) {\n    rule.forEach(function (rule) {\n      add(rules, which, rule);\n    });\n    return;\n  }\n\n  // support the rule being a RegExp, but reformat it to\n  // the custom :<regexp> format that we're working with.\n  if (rule instanceof RegExp) {\n    // rule = ':' + rule.toString().replace(/^\\/(.*?)\\/$/g, '$1');\n    utils.log.error('RegExp format no longer supported, but globs are.');\n    return;\n  }\n\n  // remove comments and trim lines\n  // this mess of replace methods is escaping \"\\#\" to allow for emacs temp files\n\n  // first up strip comments and remove blank head or tails\n  rule = (rule || '').replace(reEscComments, '^^').replace(reComments, '').replace(reUnescapeComments, '#').trim();\n  var regexp = false;\n  if (typeof rule === 'string' && rule.substring(0, 1) === ':') {\n    rule = rule.substring(1);\n    utils.log.error('RegExp no longer supported: ' + rule);\n    regexp = true;\n  } else if (rule.length === 0) {\n    // blank line (or it was a comment)\n    return;\n  }\n  if (regexp) {\n    // rules[which].push(rule);\n  } else {\n    // rule = rule.replace(reEscapeChars, '\\\\$&')\n    // .replace(reAsterisk, '.*');\n\n    rules[which].push(rule);\n    // compile a regexp of all the rules for this ignore or watch\n    var re = rules[which].map(function (rule) {\n      return rule.replace(reEscapeChars, '\\\\$&').replace(reAsterisk, '.*');\n    }).join('|');\n\n    // used for the directory matching\n    rules[which].re = new RegExp(re);\n  }\n}","map":{"version":3,"names":["utils","require","reEscComments","reUnescapeComments","reComments","reEscapeChars","reAsterisk","module","exports","add","rules","which","rule","ignore","watch","Error","Array","isArray","forEach","RegExp","log","error","replace","trim","regexp","substring","length","push","re","map","join"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/nodemon/lib/rules/add.js"],"sourcesContent":["'use strict';\r\n\r\nvar utils = require('../utils');\r\n\r\n// internal\r\nvar reEscComments = /\\\\#/g;\r\n// note that '^^' is used in place of escaped comments\r\nvar reUnescapeComments = /\\^\\^/g;\r\nvar reComments = /#.*$/;\r\nvar reEscapeChars = /[.|\\-[\\]()\\\\]/g;\r\nvar reAsterisk = /\\*/g;\r\n\r\nmodule.exports = add;\r\n\r\n/**\r\n * Converts file patterns or regular expressions to nodemon\r\n * compatible RegExp matching rules. Note: the `rules` argument\r\n * object is modified to include the new rule and new RegExp\r\n *\r\n * ### Example:\r\n *\r\n *     var rules = { watch: [], ignore: [] };\r\n *     add(rules, 'watch', '*.js');\r\n *     add(rules, 'ignore', '/public/');\r\n *     add(rules, 'watch', ':(\\d)*\\.js'); // note: string based regexp\r\n *     add(rules, 'watch', /\\d*\\.js/);\r\n *\r\n * @param {Object} rules containing `watch` and `ignore`. Also updated during\r\n *                       execution\r\n * @param {String} which must be either \"watch\" or \"ignore\"\r\n * @param {String|RegExp} the actual rule.\r\n */\r\nfunction add(rules, which, rule) {\r\n  if (!{ ignore: 1, watch: 1}[which]) {\r\n    throw new Error('rules/index.js#add requires \"ignore\" or \"watch\" as the ' +\r\n      'first argument');\r\n  }\r\n\r\n  if (Array.isArray(rule)) {\r\n    rule.forEach(function (rule) {\r\n      add(rules, which, rule);\r\n    });\r\n    return;\r\n  }\r\n\r\n  // support the rule being a RegExp, but reformat it to\r\n  // the custom :<regexp> format that we're working with.\r\n  if (rule instanceof RegExp) {\r\n    // rule = ':' + rule.toString().replace(/^\\/(.*?)\\/$/g, '$1');\r\n    utils.log.error('RegExp format no longer supported, but globs are.');\r\n    return;\r\n  }\r\n\r\n  // remove comments and trim lines\r\n  // this mess of replace methods is escaping \"\\#\" to allow for emacs temp files\r\n\r\n  // first up strip comments and remove blank head or tails\r\n  rule = (rule || '').replace(reEscComments, '^^')\r\n             .replace(reComments, '')\r\n             .replace(reUnescapeComments, '#').trim();\r\n\r\n  var regexp = false;\r\n\r\n  if (typeof rule === 'string' && rule.substring(0, 1) === ':') {\r\n    rule = rule.substring(1);\r\n    utils.log.error('RegExp no longer supported: ' + rule);\r\n    regexp = true;\r\n  } else if (rule.length === 0) {\r\n    // blank line (or it was a comment)\r\n    return;\r\n  }\r\n\r\n  if (regexp) {\r\n    // rules[which].push(rule);\r\n  } else {\r\n    // rule = rule.replace(reEscapeChars, '\\\\$&')\r\n    // .replace(reAsterisk, '.*');\r\n\r\n    rules[which].push(rule);\r\n    // compile a regexp of all the rules for this ignore or watch\r\n    var re = rules[which].map(function (rule) {\r\n      return rule.replace(reEscapeChars, '\\\\$&')\r\n                 .replace(reAsterisk, '.*');\r\n    }).join('|');\r\n\r\n    // used for the directory matching\r\n    rules[which].re = new RegExp(re);\r\n  }\r\n}\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,KAAK,GAAGC,OAAO,CAAC,UAAU,CAAC;;AAE/B;AACA,IAAIC,aAAa,GAAG,MAAM;AAC1B;AACA,IAAIC,kBAAkB,GAAG,OAAO;AAChC,IAAIC,UAAU,GAAG,MAAM;AACvB,IAAIC,aAAa,GAAG,gBAAgB;AACpC,IAAIC,UAAU,GAAG,KAAK;AAEtBC,MAAM,CAACC,OAAO,GAAGC,GAAG;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAG,CAACC,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAE;EAC/B,IAAI,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAC,CAACH,KAAK,CAAC,EAAE;IAClC,MAAM,IAAII,KAAK,CAAC,yDAAyD,GACvE,gBAAgB,CAAC;EACrB;EAEA,IAAIC,KAAK,CAACC,OAAO,CAACL,IAAI,CAAC,EAAE;IACvBA,IAAI,CAACM,OAAO,CAAC,UAAUN,IAAI,EAAE;MAC3BH,GAAG,CAACC,KAAK,EAAEC,KAAK,EAAEC,IAAI,CAAC;IACzB,CAAC,CAAC;IACF;EACF;;EAEA;EACA;EACA,IAAIA,IAAI,YAAYO,MAAM,EAAE;IAC1B;IACAnB,KAAK,CAACoB,GAAG,CAACC,KAAK,CAAC,mDAAmD,CAAC;IACpE;EACF;;EAEA;EACA;;EAEA;EACAT,IAAI,GAAG,CAACA,IAAI,IAAI,EAAE,EAAEU,OAAO,CAACpB,aAAa,EAAE,IAAI,CAAC,CACpCoB,OAAO,CAAClB,UAAU,EAAE,EAAE,CAAC,CACvBkB,OAAO,CAACnB,kBAAkB,EAAE,GAAG,CAAC,CAACoB,IAAI,EAAE;EAEnD,IAAIC,MAAM,GAAG,KAAK;EAElB,IAAI,OAAOZ,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACa,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;IAC5Db,IAAI,GAAGA,IAAI,CAACa,SAAS,CAAC,CAAC,CAAC;IACxBzB,KAAK,CAACoB,GAAG,CAACC,KAAK,CAAC,8BAA8B,GAAGT,IAAI,CAAC;IACtDY,MAAM,GAAG,IAAI;EACf,CAAC,MAAM,IAAIZ,IAAI,CAACc,MAAM,KAAK,CAAC,EAAE;IAC5B;IACA;EACF;EAEA,IAAIF,MAAM,EAAE;IACV;EAAA,CACD,MAAM;IACL;IACA;;IAEAd,KAAK,CAACC,KAAK,CAAC,CAACgB,IAAI,CAACf,IAAI,CAAC;IACvB;IACA,IAAIgB,EAAE,GAAGlB,KAAK,CAACC,KAAK,CAAC,CAACkB,GAAG,CAAC,UAAUjB,IAAI,EAAE;MACxC,OAAOA,IAAI,CAACU,OAAO,CAACjB,aAAa,EAAE,MAAM,CAAC,CAC9BiB,OAAO,CAAChB,UAAU,EAAE,IAAI,CAAC;IACvC,CAAC,CAAC,CAACwB,IAAI,CAAC,GAAG,CAAC;;IAEZ;IACApB,KAAK,CAACC,KAAK,CAAC,CAACiB,EAAE,GAAG,IAAIT,MAAM,CAACS,EAAE,CAAC;EAClC;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}