{"ast":null,"code":"'use strict';\n\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\nmodule.exports = assignRawDocsToIdStructure;\n\n/**\r\n * Assign `vals` returned by mongo query to the `rawIds`\r\n * structure returned from utils.getVals() honoring\r\n * query sort order if specified by user.\r\n *\r\n * This can be optimized.\r\n *\r\n * Rules:\r\n *\r\n *   if the value of the path is not an array, use findOne rules, else find.\r\n *   for findOne the results are assigned directly to doc path (including null results).\r\n *   for find, if user specified sort order, results are assigned directly\r\n *   else documents are put back in original order of array if found in results\r\n *\r\n * @param {Array} rawIds\r\n * @param {Array} resultDocs\r\n * @param {Array} resultOrder\r\n * @param {Object} options\r\n * @param {Boolean} recursed\r\n * @api private\r\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n  let i = 0;\n  const len = rawIds.length;\n  const hasResultArrays = Object.values(resultOrder).find(o => Array.isArray(o));\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = utils.clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (hasResultArrays) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function (doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}","map":{"version":3,"names":["leanPopulateMap","require","modelSymbol","utils","module","exports","assignRawDocsToIdStructure","rawIds","resultDocs","resultOrder","options","recursed","newOrder","sorting","sort","length","nullIfNotFound","$nullIfNotFound","doc","sid","id","isMongooseArray","__array","i","len","hasResultArrays","Object","values","find","o","Array","isArray","push","String","clone","lean","_model","get","set","constructor","hydrate","_doc","_resultOrder","retainNullValues","forEach"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"],"sourcesContent":["'use strict';\r\n\r\nconst leanPopulateMap = require('./leanPopulateMap');\r\nconst modelSymbol = require('../symbols').modelSymbol;\r\nconst utils = require('../../utils');\r\n\r\nmodule.exports = assignRawDocsToIdStructure;\r\n\r\n/**\r\n * Assign `vals` returned by mongo query to the `rawIds`\r\n * structure returned from utils.getVals() honoring\r\n * query sort order if specified by user.\r\n *\r\n * This can be optimized.\r\n *\r\n * Rules:\r\n *\r\n *   if the value of the path is not an array, use findOne rules, else find.\r\n *   for findOne the results are assigned directly to doc path (including null results).\r\n *   for find, if user specified sort order, results are assigned directly\r\n *   else documents are put back in original order of array if found in results\r\n *\r\n * @param {Array} rawIds\r\n * @param {Array} resultDocs\r\n * @param {Array} resultOrder\r\n * @param {Object} options\r\n * @param {Boolean} recursed\r\n * @api private\r\n */\r\n\r\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\r\n  // honor user specified sort order\r\n  const newOrder = [];\r\n  const sorting = options.sort && rawIds.length > 1;\r\n  const nullIfNotFound = options.$nullIfNotFound;\r\n  let doc;\r\n  let sid;\r\n  let id;\r\n\r\n  if (utils.isMongooseArray(rawIds)) {\r\n    rawIds = rawIds.__array;\r\n  }\r\n\r\n  let i = 0;\r\n  const len = rawIds.length;\r\n  const hasResultArrays = Object.values(resultOrder).find(o => Array.isArray(o));\r\n\r\n  for (i = 0; i < len; ++i) {\r\n    id = rawIds[i];\r\n\r\n    if (Array.isArray(id)) {\r\n      // handle [ [id0, id2], [id3] ]\r\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\r\n      newOrder.push(id);\r\n      continue;\r\n    }\r\n\r\n    if (id === null && !sorting) {\r\n      // keep nulls for findOne unless sorting, which always\r\n      // removes them (backward compat)\r\n      newOrder.push(id);\r\n      continue;\r\n    }\r\n\r\n    sid = String(id);\r\n    doc = resultDocs[sid];\r\n    // If user wants separate copies of same doc, use this option\r\n    if (options.clone && doc != null) {\r\n      if (options.lean) {\r\n        const _model = leanPopulateMap.get(doc);\r\n        doc = utils.clone(doc);\r\n        leanPopulateMap.set(doc, _model);\r\n      } else {\r\n        doc = doc.constructor.hydrate(doc._doc);\r\n      }\r\n    }\r\n\r\n    if (recursed) {\r\n      if (doc) {\r\n        if (sorting) {\r\n          const _resultOrder = resultOrder[sid];\r\n          if (hasResultArrays) {\r\n            // If result arrays, rely on the MongoDB server response for ordering\r\n            newOrder.push(doc);\r\n          } else {\r\n            newOrder[_resultOrder] = doc;\r\n          }\r\n        } else {\r\n          newOrder.push(doc);\r\n        }\r\n      } else if (id != null && id[modelSymbol] != null) {\r\n        newOrder.push(id);\r\n      } else {\r\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\r\n      }\r\n    } else {\r\n      // apply findOne behavior - if document in results, assign, else assign null\r\n      newOrder[i] = doc || null;\r\n    }\r\n  }\r\n\r\n  rawIds.length = 0;\r\n  if (newOrder.length) {\r\n    // reassign the documents based on corrected order\r\n\r\n    // forEach skips over sparse entries in arrays so we\r\n    // can safely use this to our advantage dealing with sorted\r\n    // result sets too.\r\n    newOrder.forEach(function(doc, i) {\r\n      rawIds[i] = doc;\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}