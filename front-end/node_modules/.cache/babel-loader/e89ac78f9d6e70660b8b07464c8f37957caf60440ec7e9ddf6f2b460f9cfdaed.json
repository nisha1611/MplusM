{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst {\n  HookMap,\n  SyncWaterfallHook,\n  SyncBailHook\n} = require(\"tapable\");\n\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"tapable\").Hook} Hook */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsAsset} StatsAsset */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunk} StatsChunk */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunkGroup} StatsChunkGroup */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsCompilation} StatsCompilation */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModule} StatsModule */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModuleReason} StatsModuleReason */\n\n/**\r\n * @typedef {Object} PrintedElement\r\n * @property {string} element\r\n * @property {string} content\r\n */\n\n/**\r\n * @typedef {Object} KnownStatsPrinterContext\r\n * @property {string=} type\r\n * @property {StatsCompilation=} compilation\r\n * @property {StatsChunkGroup=} chunkGroup\r\n * @property {StatsAsset=} asset\r\n * @property {StatsModule=} module\r\n * @property {StatsChunk=} chunk\r\n * @property {StatsModuleReason=} moduleReason\r\n * @property {(str: string) => string=} bold\r\n * @property {(str: string) => string=} yellow\r\n * @property {(str: string) => string=} red\r\n * @property {(str: string) => string=} green\r\n * @property {(str: string) => string=} magenta\r\n * @property {(str: string) => string=} cyan\r\n * @property {(file: string, oversize?: boolean) => string=} formatFilename\r\n * @property {(id: string) => string=} formatModuleId\r\n * @property {(id: string, direction?: \"parent\"|\"child\"|\"sibling\") => string=} formatChunkId\r\n * @property {(size: number) => string=} formatSize\r\n * @property {(dateTime: number) => string=} formatDateTime\r\n * @property {(flag: string) => string=} formatFlag\r\n * @property {(time: number, boldQuantity?: boolean) => string=} formatTime\r\n * @property {string=} chunkGroupKind\r\n */\n\n/** @typedef {KnownStatsPrinterContext & Record<string, any>} StatsPrinterContext */\n\nclass StatsPrinter {\n  constructor() {\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>} */\n      sortElements: new HookMap(() => new SyncBailHook([\"elements\", \"context\"])),\n      /** @type {HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string>>} */\n      printElements: new HookMap(() => new SyncBailHook([\"printedElements\", \"context\"])),\n      /** @type {HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>} */\n      sortItems: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n      /** @type {HookMap<SyncBailHook<[any, StatsPrinterContext], string>>} */\n      getItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n      /** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>} */\n      printItems: new HookMap(() => new SyncBailHook([\"printedItems\", \"context\"])),\n      /** @type {HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>} */\n      print: new HookMap(() => new SyncBailHook([\"object\", \"context\"])),\n      /** @type {HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>} */\n      result: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"]))\n    });\n    /** @type {Map<HookMap<Hook>, Map<string, Hook[]>>} */\n    this._levelHookCache = new Map();\n    this._inPrint = false;\n  }\n\n  /**\r\n   * get all level hooks\r\n   * @private\r\n   * @template {Hook} T\r\n   * @param {HookMap<T>} hookMap HookMap\r\n   * @param {string} type type\r\n   * @returns {T[]} hooks\r\n   */\n  _getAllLevelHooks(hookMap, type) {\n    let cache = /** @type {Map<string, T[]>} */\n    this._levelHookCache.get(hookMap);\n    if (cache === undefined) {\n      cache = new Map();\n      this._levelHookCache.set(hookMap, cache);\n    }\n    const cacheEntry = cache.get(type);\n    if (cacheEntry !== undefined) {\n      return cacheEntry;\n    }\n    /** @type {T[]} */\n    const hooks = [];\n    const typeParts = type.split(\".\");\n    for (let i = 0; i < typeParts.length; i++) {\n      const hook = hookMap.get(typeParts.slice(i).join(\".\"));\n      if (hook) {\n        hooks.push(hook);\n      }\n    }\n    cache.set(type, hooks);\n    return hooks;\n  }\n\n  /**\r\n   * Run `fn` for each level\r\n   * @private\r\n   * @template T\r\n   * @template R\r\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap HookMap\r\n   * @param {string} type type\r\n   * @param {(hook: SyncBailHook<T, R>) => R} fn function\r\n   * @returns {R} result of `fn`\r\n   */\n  _forEachLevel(hookMap, type, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, type)) {\n      const result = fn(hook);\n      if (result !== undefined) return result;\n    }\n  }\n\n  /**\r\n   * Run `fn` for each level\r\n   * @private\r\n   * @template T\r\n   * @param {HookMap<SyncWaterfallHook<T>>} hookMap HookMap\r\n   * @param {string} type type\r\n   * @param {AsArray<T>[0]} data data\r\n   * @param {(hook: SyncWaterfallHook<T>, data: AsArray<T>[0]) => AsArray<T>[0]} fn function\r\n   * @returns {AsArray<T>[0]} result of `fn`\r\n   */\n  _forEachLevelWaterfall(hookMap, type, data, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, type)) {\n      data = fn(hook, data);\n    }\n    return data;\n  }\n\n  /**\r\n   * @param {string} type The type\r\n   * @param {Object} object Object to print\r\n   * @param {Object=} baseContext The base context\r\n   * @returns {string} printed result\r\n   */\n  print(type, object, baseContext) {\n    if (this._inPrint) {\n      return this._print(type, object, baseContext);\n    } else {\n      try {\n        this._inPrint = true;\n        return this._print(type, object, baseContext);\n      } finally {\n        this._levelHookCache.clear();\n        this._inPrint = false;\n      }\n    }\n  }\n\n  /**\r\n   * @private\r\n   * @param {string} type type\r\n   * @param {Object} object object\r\n   * @param {Object=} baseContext context\r\n   * @returns {string} printed result\r\n   */\n  _print(type, object, baseContext) {\n    const context = {\n      ...baseContext,\n      type,\n      [type]: object\n    };\n    let printResult = this._forEachLevel(this.hooks.print, type, hook => hook.call(object, context));\n    if (printResult === undefined) {\n      if (Array.isArray(object)) {\n        const sortedItems = object.slice();\n        this._forEachLevel(this.hooks.sortItems, type, h => h.call(sortedItems, context));\n        const printedItems = sortedItems.map((item, i) => {\n          const itemContext = {\n            ...context,\n            _index: i\n          };\n          const itemName = this._forEachLevel(this.hooks.getItemName, `${type}[]`, h => h.call(item, itemContext));\n          if (itemName) itemContext[itemName] = item;\n          return this.print(itemName ? `${type}[].${itemName}` : `${type}[]`, item, itemContext);\n        });\n        printResult = this._forEachLevel(this.hooks.printItems, type, h => h.call(printedItems, context));\n        if (printResult === undefined) {\n          const result = printedItems.filter(Boolean);\n          if (result.length > 0) printResult = result.join(\"\\n\");\n        }\n      } else if (object !== null && typeof object === \"object\") {\n        const elements = Object.keys(object).filter(key => object[key] !== undefined);\n        this._forEachLevel(this.hooks.sortElements, type, h => h.call(elements, context));\n        const printedElements = elements.map(element => {\n          const content = this.print(`${type}.${element}`, object[element], {\n            ...context,\n            _parent: object,\n            _element: element,\n            [element]: object[element]\n          });\n          return {\n            element,\n            content\n          };\n        });\n        printResult = this._forEachLevel(this.hooks.printElements, type, h => h.call(printedElements, context));\n        if (printResult === undefined) {\n          const result = printedElements.map(e => e.content).filter(Boolean);\n          if (result.length > 0) printResult = result.join(\"\\n\");\n        }\n      }\n    }\n    return this._forEachLevelWaterfall(this.hooks.result, type, printResult, (h, r) => h.call(r, context));\n  }\n}\nmodule.exports = StatsPrinter;","map":{"version":3,"names":["HookMap","SyncWaterfallHook","SyncBailHook","require","StatsPrinter","constructor","hooks","Object","freeze","sortElements","printElements","sortItems","getItemName","printItems","print","result","_levelHookCache","Map","_inPrint","_getAllLevelHooks","hookMap","type","cache","get","undefined","set","cacheEntry","typeParts","split","i","length","hook","slice","join","push","_forEachLevel","fn","_forEachLevelWaterfall","data","object","baseContext","_print","clear","context","printResult","call","Array","isArray","sortedItems","h","printedItems","map","item","itemContext","_index","itemName","filter","Boolean","elements","keys","key","printedElements","element","content","_parent","_element","e","r","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/stats/StatsPrinter.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { HookMap, SyncWaterfallHook, SyncBailHook } = require(\"tapable\");\r\n\r\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\r\n/** @typedef {import(\"tapable\").Hook} Hook */\r\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsAsset} StatsAsset */\r\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunk} StatsChunk */\r\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunkGroup} StatsChunkGroup */\r\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsCompilation} StatsCompilation */\r\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModule} StatsModule */\r\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModuleReason} StatsModuleReason */\r\n\r\n/**\r\n * @typedef {Object} PrintedElement\r\n * @property {string} element\r\n * @property {string} content\r\n */\r\n\r\n/**\r\n * @typedef {Object} KnownStatsPrinterContext\r\n * @property {string=} type\r\n * @property {StatsCompilation=} compilation\r\n * @property {StatsChunkGroup=} chunkGroup\r\n * @property {StatsAsset=} asset\r\n * @property {StatsModule=} module\r\n * @property {StatsChunk=} chunk\r\n * @property {StatsModuleReason=} moduleReason\r\n * @property {(str: string) => string=} bold\r\n * @property {(str: string) => string=} yellow\r\n * @property {(str: string) => string=} red\r\n * @property {(str: string) => string=} green\r\n * @property {(str: string) => string=} magenta\r\n * @property {(str: string) => string=} cyan\r\n * @property {(file: string, oversize?: boolean) => string=} formatFilename\r\n * @property {(id: string) => string=} formatModuleId\r\n * @property {(id: string, direction?: \"parent\"|\"child\"|\"sibling\") => string=} formatChunkId\r\n * @property {(size: number) => string=} formatSize\r\n * @property {(dateTime: number) => string=} formatDateTime\r\n * @property {(flag: string) => string=} formatFlag\r\n * @property {(time: number, boldQuantity?: boolean) => string=} formatTime\r\n * @property {string=} chunkGroupKind\r\n */\r\n\r\n/** @typedef {KnownStatsPrinterContext & Record<string, any>} StatsPrinterContext */\r\n\r\nclass StatsPrinter {\r\n\tconstructor() {\r\n\t\tthis.hooks = Object.freeze({\r\n\t\t\t/** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>} */\r\n\t\t\tsortElements: new HookMap(\r\n\t\t\t\t() => new SyncBailHook([\"elements\", \"context\"])\r\n\t\t\t),\r\n\t\t\t/** @type {HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string>>} */\r\n\t\t\tprintElements: new HookMap(\r\n\t\t\t\t() => new SyncBailHook([\"printedElements\", \"context\"])\r\n\t\t\t),\r\n\t\t\t/** @type {HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>} */\r\n\t\t\tsortItems: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\r\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsPrinterContext], string>>} */\r\n\t\t\tgetItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\r\n\t\t\t/** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>} */\r\n\t\t\tprintItems: new HookMap(\r\n\t\t\t\t() => new SyncBailHook([\"printedItems\", \"context\"])\r\n\t\t\t),\r\n\t\t\t/** @type {HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>} */\r\n\t\t\tprint: new HookMap(() => new SyncBailHook([\"object\", \"context\"])),\r\n\t\t\t/** @type {HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>} */\r\n\t\t\tresult: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"]))\r\n\t\t});\r\n\t\t/** @type {Map<HookMap<Hook>, Map<string, Hook[]>>} */\r\n\t\tthis._levelHookCache = new Map();\r\n\t\tthis._inPrint = false;\r\n\t}\r\n\r\n\t/**\r\n\t * get all level hooks\r\n\t * @private\r\n\t * @template {Hook} T\r\n\t * @param {HookMap<T>} hookMap HookMap\r\n\t * @param {string} type type\r\n\t * @returns {T[]} hooks\r\n\t */\r\n\t_getAllLevelHooks(hookMap, type) {\r\n\t\tlet cache = /** @type {Map<string, T[]>} */ (\r\n\t\t\tthis._levelHookCache.get(hookMap)\r\n\t\t);\r\n\t\tif (cache === undefined) {\r\n\t\t\tcache = new Map();\r\n\t\t\tthis._levelHookCache.set(hookMap, cache);\r\n\t\t}\r\n\t\tconst cacheEntry = cache.get(type);\r\n\t\tif (cacheEntry !== undefined) {\r\n\t\t\treturn cacheEntry;\r\n\t\t}\r\n\t\t/** @type {T[]} */\r\n\t\tconst hooks = [];\r\n\t\tconst typeParts = type.split(\".\");\r\n\t\tfor (let i = 0; i < typeParts.length; i++) {\r\n\t\t\tconst hook = hookMap.get(typeParts.slice(i).join(\".\"));\r\n\t\t\tif (hook) {\r\n\t\t\t\thooks.push(hook);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcache.set(type, hooks);\r\n\t\treturn hooks;\r\n\t}\r\n\r\n\t/**\r\n\t * Run `fn` for each level\r\n\t * @private\r\n\t * @template T\r\n\t * @template R\r\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap HookMap\r\n\t * @param {string} type type\r\n\t * @param {(hook: SyncBailHook<T, R>) => R} fn function\r\n\t * @returns {R} result of `fn`\r\n\t */\r\n\t_forEachLevel(hookMap, type, fn) {\r\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, type)) {\r\n\t\t\tconst result = fn(hook);\r\n\t\t\tif (result !== undefined) return result;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Run `fn` for each level\r\n\t * @private\r\n\t * @template T\r\n\t * @param {HookMap<SyncWaterfallHook<T>>} hookMap HookMap\r\n\t * @param {string} type type\r\n\t * @param {AsArray<T>[0]} data data\r\n\t * @param {(hook: SyncWaterfallHook<T>, data: AsArray<T>[0]) => AsArray<T>[0]} fn function\r\n\t * @returns {AsArray<T>[0]} result of `fn`\r\n\t */\r\n\t_forEachLevelWaterfall(hookMap, type, data, fn) {\r\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, type)) {\r\n\t\t\tdata = fn(hook, data);\r\n\t\t}\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} type The type\r\n\t * @param {Object} object Object to print\r\n\t * @param {Object=} baseContext The base context\r\n\t * @returns {string} printed result\r\n\t */\r\n\tprint(type, object, baseContext) {\r\n\t\tif (this._inPrint) {\r\n\t\t\treturn this._print(type, object, baseContext);\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\tthis._inPrint = true;\r\n\t\t\t\treturn this._print(type, object, baseContext);\r\n\t\t\t} finally {\r\n\t\t\t\tthis._levelHookCache.clear();\r\n\t\t\t\tthis._inPrint = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * @param {string} type type\r\n\t * @param {Object} object object\r\n\t * @param {Object=} baseContext context\r\n\t * @returns {string} printed result\r\n\t */\r\n\t_print(type, object, baseContext) {\r\n\t\tconst context = {\r\n\t\t\t...baseContext,\r\n\t\t\ttype,\r\n\t\t\t[type]: object\r\n\t\t};\r\n\r\n\t\tlet printResult = this._forEachLevel(this.hooks.print, type, hook =>\r\n\t\t\thook.call(object, context)\r\n\t\t);\r\n\t\tif (printResult === undefined) {\r\n\t\t\tif (Array.isArray(object)) {\r\n\t\t\t\tconst sortedItems = object.slice();\r\n\t\t\t\tthis._forEachLevel(this.hooks.sortItems, type, h =>\r\n\t\t\t\t\th.call(sortedItems, context)\r\n\t\t\t\t);\r\n\t\t\t\tconst printedItems = sortedItems.map((item, i) => {\r\n\t\t\t\t\tconst itemContext = {\r\n\t\t\t\t\t\t...context,\r\n\t\t\t\t\t\t_index: i\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst itemName = this._forEachLevel(\r\n\t\t\t\t\t\tthis.hooks.getItemName,\r\n\t\t\t\t\t\t`${type}[]`,\r\n\t\t\t\t\t\th => h.call(item, itemContext)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (itemName) itemContext[itemName] = item;\r\n\t\t\t\t\treturn this.print(\r\n\t\t\t\t\t\titemName ? `${type}[].${itemName}` : `${type}[]`,\r\n\t\t\t\t\t\titem,\r\n\t\t\t\t\t\titemContext\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t\tprintResult = this._forEachLevel(this.hooks.printItems, type, h =>\r\n\t\t\t\t\th.call(printedItems, context)\r\n\t\t\t\t);\r\n\t\t\t\tif (printResult === undefined) {\r\n\t\t\t\t\tconst result = printedItems.filter(Boolean);\r\n\t\t\t\t\tif (result.length > 0) printResult = result.join(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t} else if (object !== null && typeof object === \"object\") {\r\n\t\t\t\tconst elements = Object.keys(object).filter(\r\n\t\t\t\t\tkey => object[key] !== undefined\r\n\t\t\t\t);\r\n\t\t\t\tthis._forEachLevel(this.hooks.sortElements, type, h =>\r\n\t\t\t\t\th.call(elements, context)\r\n\t\t\t\t);\r\n\t\t\t\tconst printedElements = elements.map(element => {\r\n\t\t\t\t\tconst content = this.print(`${type}.${element}`, object[element], {\r\n\t\t\t\t\t\t...context,\r\n\t\t\t\t\t\t_parent: object,\r\n\t\t\t\t\t\t_element: element,\r\n\t\t\t\t\t\t[element]: object[element]\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn { element, content };\r\n\t\t\t\t});\r\n\t\t\t\tprintResult = this._forEachLevel(this.hooks.printElements, type, h =>\r\n\t\t\t\t\th.call(printedElements, context)\r\n\t\t\t\t);\r\n\t\t\t\tif (printResult === undefined) {\r\n\t\t\t\t\tconst result = printedElements.map(e => e.content).filter(Boolean);\r\n\t\t\t\t\tif (result.length > 0) printResult = result.join(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this._forEachLevelWaterfall(\r\n\t\t\tthis.hooks.result,\r\n\t\t\ttype,\r\n\t\t\tprintResult,\r\n\t\t\t(h, r) => h.call(r, context)\r\n\t\t);\r\n\t}\r\n}\r\nmodule.exports = StatsPrinter;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}