{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\n/**\r\n * @typedef {Object} GroupOptions\r\n * @property {boolean=} groupChildren\r\n * @property {boolean=} force\r\n * @property {number=} targetGroupCount\r\n */\n\n/**\r\n * @template T\r\n * @template R\r\n * @typedef {Object} GroupConfig\r\n * @property {function(T): string[]} getKeys\r\n * @property {function(string, (R | T)[], T[]): R} createGroup\r\n * @property {function(string, T[]): GroupOptions=} getOptions\r\n */\n\n/**\r\n * @template T\r\n * @template R\r\n * @typedef {Object} ItemWithGroups\r\n * @property {T} item\r\n * @property {Set<Group<T, R>>} groups\r\n */\n\n/**\r\n * @template T\r\n * @template R\r\n * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group\r\n */\n\n/**\r\n * @template T\r\n * @template R\r\n * @param {T[]} items the list of items\r\n * @param {GroupConfig<T, R>[]} groupConfigs configuration\r\n * @returns {(R | T)[]} grouped items\r\n */\nconst smartGrouping = (items, groupConfigs) => {\n  /** @type {Set<ItemWithGroups<T, R>>} */\n  const itemsWithGroups = new Set();\n  /** @type {Map<string, Group<T, R>>} */\n  const allGroups = new Map();\n  for (const item of items) {\n    /** @type {Set<Group<T, R>>} */\n    const groups = new Set();\n    for (let i = 0; i < groupConfigs.length; i++) {\n      const groupConfig = groupConfigs[i];\n      const keys = groupConfig.getKeys(item);\n      if (keys) {\n        for (const name of keys) {\n          const key = `${i}:${name}`;\n          let group = allGroups.get(key);\n          if (group === undefined) {\n            allGroups.set(key, group = {\n              config: groupConfig,\n              name,\n              alreadyGrouped: false,\n              items: undefined\n            });\n          }\n          groups.add(group);\n        }\n      }\n    }\n    itemsWithGroups.add({\n      item,\n      groups\n    });\n  }\n  /**\r\n   * @param {Set<ItemWithGroups<T, R>>} itemsWithGroups input items with groups\r\n   * @returns {(T | R)[]} groups items\r\n   */\n  const runGrouping = itemsWithGroups => {\n    const totalSize = itemsWithGroups.size;\n    for (const entry of itemsWithGroups) {\n      for (const group of entry.groups) {\n        if (group.alreadyGrouped) continue;\n        const items = group.items;\n        if (items === undefined) {\n          group.items = new Set([entry]);\n        } else {\n          items.add(entry);\n        }\n      }\n    }\n    /** @type {Map<Group<T, R>, { items: Set<ItemWithGroups<T, R>>, options: GroupOptions | false | undefined, used: boolean }>} */\n    const groupMap = new Map();\n    for (const group of allGroups.values()) {\n      if (group.items) {\n        const items = group.items;\n        group.items = undefined;\n        groupMap.set(group, {\n          items,\n          options: undefined,\n          used: false\n        });\n      }\n    }\n    /** @type {(T | R)[]} */\n    const results = [];\n    for (;;) {\n      /** @type {Group<T, R>} */\n      let bestGroup = undefined;\n      let bestGroupSize = -1;\n      let bestGroupItems = undefined;\n      let bestGroupOptions = undefined;\n      for (const [group, state] of groupMap) {\n        const {\n          items,\n          used\n        } = state;\n        let options = state.options;\n        if (options === undefined) {\n          const groupConfig = group.config;\n          state.options = options = groupConfig.getOptions && groupConfig.getOptions(group.name, Array.from(items, _ref => {\n            let {\n              item\n            } = _ref;\n            return item;\n          })) || false;\n        }\n        const force = options && options.force;\n        if (!force) {\n          if (bestGroupOptions && bestGroupOptions.force) continue;\n          if (used) continue;\n          if (items.size <= 1 || totalSize - items.size <= 1) {\n            continue;\n          }\n        }\n        const targetGroupCount = options && options.targetGroupCount || 4;\n        let sizeValue = force ? items.size : Math.min(items.size, totalSize * 2 / targetGroupCount + itemsWithGroups.size - items.size);\n        if (sizeValue > bestGroupSize || force && (!bestGroupOptions || !bestGroupOptions.force)) {\n          bestGroup = group;\n          bestGroupSize = sizeValue;\n          bestGroupItems = items;\n          bestGroupOptions = options;\n        }\n      }\n      if (bestGroup === undefined) {\n        break;\n      }\n      const items = new Set(bestGroupItems);\n      const options = bestGroupOptions;\n      const groupChildren = !options || options.groupChildren !== false;\n      for (const item of items) {\n        itemsWithGroups.delete(item);\n        // Remove all groups that items have from the map to not select them again\n        for (const group of item.groups) {\n          const state = groupMap.get(group);\n          if (state !== undefined) {\n            state.items.delete(item);\n            if (state.items.size === 0) {\n              groupMap.delete(group);\n            } else {\n              state.options = undefined;\n              if (groupChildren) {\n                state.used = true;\n              }\n            }\n          }\n        }\n      }\n      groupMap.delete(bestGroup);\n      const key = bestGroup.name;\n      const groupConfig = bestGroup.config;\n      const allItems = Array.from(items, _ref2 => {\n        let {\n          item\n        } = _ref2;\n        return item;\n      });\n      bestGroup.alreadyGrouped = true;\n      const children = groupChildren ? runGrouping(items) : allItems;\n      bestGroup.alreadyGrouped = false;\n      results.push(groupConfig.createGroup(key, children, allItems));\n    }\n    for (const {\n      item\n    } of itemsWithGroups) {\n      results.push(item);\n    }\n    return results;\n  };\n  return runGrouping(itemsWithGroups);\n};\nmodule.exports = smartGrouping;","map":{"version":3,"names":["smartGrouping","items","groupConfigs","itemsWithGroups","Set","allGroups","Map","item","groups","i","length","groupConfig","keys","getKeys","name","key","group","get","undefined","set","config","alreadyGrouped","add","runGrouping","totalSize","size","entry","groupMap","values","options","used","results","bestGroup","bestGroupSize","bestGroupItems","bestGroupOptions","state","getOptions","Array","from","force","targetGroupCount","sizeValue","Math","min","groupChildren","delete","allItems","children","push","createGroup","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/util/smartGrouping.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\n/**\r\n * @typedef {Object} GroupOptions\r\n * @property {boolean=} groupChildren\r\n * @property {boolean=} force\r\n * @property {number=} targetGroupCount\r\n */\r\n\r\n/**\r\n * @template T\r\n * @template R\r\n * @typedef {Object} GroupConfig\r\n * @property {function(T): string[]} getKeys\r\n * @property {function(string, (R | T)[], T[]): R} createGroup\r\n * @property {function(string, T[]): GroupOptions=} getOptions\r\n */\r\n\r\n/**\r\n * @template T\r\n * @template R\r\n * @typedef {Object} ItemWithGroups\r\n * @property {T} item\r\n * @property {Set<Group<T, R>>} groups\r\n */\r\n\r\n/**\r\n * @template T\r\n * @template R\r\n * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group\r\n */\r\n\r\n/**\r\n * @template T\r\n * @template R\r\n * @param {T[]} items the list of items\r\n * @param {GroupConfig<T, R>[]} groupConfigs configuration\r\n * @returns {(R | T)[]} grouped items\r\n */\r\nconst smartGrouping = (items, groupConfigs) => {\r\n\t/** @type {Set<ItemWithGroups<T, R>>} */\r\n\tconst itemsWithGroups = new Set();\r\n\t/** @type {Map<string, Group<T, R>>} */\r\n\tconst allGroups = new Map();\r\n\tfor (const item of items) {\r\n\t\t/** @type {Set<Group<T, R>>} */\r\n\t\tconst groups = new Set();\r\n\t\tfor (let i = 0; i < groupConfigs.length; i++) {\r\n\t\t\tconst groupConfig = groupConfigs[i];\r\n\t\t\tconst keys = groupConfig.getKeys(item);\r\n\t\t\tif (keys) {\r\n\t\t\t\tfor (const name of keys) {\r\n\t\t\t\t\tconst key = `${i}:${name}`;\r\n\t\t\t\t\tlet group = allGroups.get(key);\r\n\t\t\t\t\tif (group === undefined) {\r\n\t\t\t\t\t\tallGroups.set(\r\n\t\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\t\t(group = {\r\n\t\t\t\t\t\t\t\tconfig: groupConfig,\r\n\t\t\t\t\t\t\t\tname,\r\n\t\t\t\t\t\t\t\talreadyGrouped: false,\r\n\t\t\t\t\t\t\t\titems: undefined\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroups.add(group);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\titemsWithGroups.add({\r\n\t\t\titem,\r\n\t\t\tgroups\r\n\t\t});\r\n\t}\r\n\t/**\r\n\t * @param {Set<ItemWithGroups<T, R>>} itemsWithGroups input items with groups\r\n\t * @returns {(T | R)[]} groups items\r\n\t */\r\n\tconst runGrouping = itemsWithGroups => {\r\n\t\tconst totalSize = itemsWithGroups.size;\r\n\t\tfor (const entry of itemsWithGroups) {\r\n\t\t\tfor (const group of entry.groups) {\r\n\t\t\t\tif (group.alreadyGrouped) continue;\r\n\t\t\t\tconst items = group.items;\r\n\t\t\t\tif (items === undefined) {\r\n\t\t\t\t\tgroup.items = new Set([entry]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\titems.add(entry);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/** @type {Map<Group<T, R>, { items: Set<ItemWithGroups<T, R>>, options: GroupOptions | false | undefined, used: boolean }>} */\r\n\t\tconst groupMap = new Map();\r\n\t\tfor (const group of allGroups.values()) {\r\n\t\t\tif (group.items) {\r\n\t\t\t\tconst items = group.items;\r\n\t\t\t\tgroup.items = undefined;\r\n\t\t\t\tgroupMap.set(group, {\r\n\t\t\t\t\titems,\r\n\t\t\t\t\toptions: undefined,\r\n\t\t\t\t\tused: false\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t/** @type {(T | R)[]} */\r\n\t\tconst results = [];\r\n\t\tfor (;;) {\r\n\t\t\t/** @type {Group<T, R>} */\r\n\t\t\tlet bestGroup = undefined;\r\n\t\t\tlet bestGroupSize = -1;\r\n\t\t\tlet bestGroupItems = undefined;\r\n\t\t\tlet bestGroupOptions = undefined;\r\n\t\t\tfor (const [group, state] of groupMap) {\r\n\t\t\t\tconst { items, used } = state;\r\n\t\t\t\tlet options = state.options;\r\n\t\t\t\tif (options === undefined) {\r\n\t\t\t\t\tconst groupConfig = group.config;\r\n\t\t\t\t\tstate.options = options =\r\n\t\t\t\t\t\t(groupConfig.getOptions &&\r\n\t\t\t\t\t\t\tgroupConfig.getOptions(\r\n\t\t\t\t\t\t\t\tgroup.name,\r\n\t\t\t\t\t\t\t\tArray.from(items, ({ item }) => item)\r\n\t\t\t\t\t\t\t)) ||\r\n\t\t\t\t\t\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst force = options && options.force;\r\n\t\t\t\tif (!force) {\r\n\t\t\t\t\tif (bestGroupOptions && bestGroupOptions.force) continue;\r\n\t\t\t\t\tif (used) continue;\r\n\t\t\t\t\tif (items.size <= 1 || totalSize - items.size <= 1) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst targetGroupCount = (options && options.targetGroupCount) || 4;\r\n\t\t\t\tlet sizeValue = force\r\n\t\t\t\t\t? items.size\r\n\t\t\t\t\t: Math.min(\r\n\t\t\t\t\t\t\titems.size,\r\n\t\t\t\t\t\t\t(totalSize * 2) / targetGroupCount +\r\n\t\t\t\t\t\t\t\titemsWithGroups.size -\r\n\t\t\t\t\t\t\t\titems.size\r\n\t\t\t\t\t  );\r\n\t\t\t\tif (\r\n\t\t\t\t\tsizeValue > bestGroupSize ||\r\n\t\t\t\t\t(force && (!bestGroupOptions || !bestGroupOptions.force))\r\n\t\t\t\t) {\r\n\t\t\t\t\tbestGroup = group;\r\n\t\t\t\t\tbestGroupSize = sizeValue;\r\n\t\t\t\t\tbestGroupItems = items;\r\n\t\t\t\t\tbestGroupOptions = options;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (bestGroup === undefined) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tconst items = new Set(bestGroupItems);\r\n\t\t\tconst options = bestGroupOptions;\r\n\r\n\t\t\tconst groupChildren = !options || options.groupChildren !== false;\r\n\r\n\t\t\tfor (const item of items) {\r\n\t\t\t\titemsWithGroups.delete(item);\r\n\t\t\t\t// Remove all groups that items have from the map to not select them again\r\n\t\t\t\tfor (const group of item.groups) {\r\n\t\t\t\t\tconst state = groupMap.get(group);\r\n\t\t\t\t\tif (state !== undefined) {\r\n\t\t\t\t\t\tstate.items.delete(item);\r\n\t\t\t\t\t\tif (state.items.size === 0) {\r\n\t\t\t\t\t\t\tgroupMap.delete(group);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstate.options = undefined;\r\n\t\t\t\t\t\t\tif (groupChildren) {\r\n\t\t\t\t\t\t\t\tstate.used = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tgroupMap.delete(bestGroup);\r\n\r\n\t\t\tconst key = bestGroup.name;\r\n\t\t\tconst groupConfig = bestGroup.config;\r\n\r\n\t\t\tconst allItems = Array.from(items, ({ item }) => item);\r\n\r\n\t\t\tbestGroup.alreadyGrouped = true;\r\n\t\t\tconst children = groupChildren ? runGrouping(items) : allItems;\r\n\t\t\tbestGroup.alreadyGrouped = false;\r\n\r\n\t\t\tresults.push(groupConfig.createGroup(key, children, allItems));\r\n\t\t}\r\n\t\tfor (const { item } of itemsWithGroups) {\r\n\t\t\tresults.push(item);\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\treturn runGrouping(itemsWithGroups);\r\n};\r\n\r\nmodule.exports = smartGrouping;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}