{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Sergey Melyukov @smelukov\r\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  SyncBailHook\n} = require(\"tapable\");\nconst Compilation = require(\"../lib/Compilation\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst {\n  join\n} = require(\"./util/fs\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").CleanOptions} CleanOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").StatsCallback} StatsCallback */\n\n/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */\n/** @typedef {Map<string, number>} Assets */\n/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */\n\n/**\r\n * @typedef {Object} CleanPluginCompilationHooks\r\n * @property {SyncBailHook<[string], boolean>} keep when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config\r\n */\n\nconst validate = createSchemaValidation(undefined, () => {\n  const {\n    definitions\n  } = require(\"../schemas/WebpackOptions.json\");\n  return {\n    definitions,\n    oneOf: [{\n      $ref: \"#/definitions/CleanOptions\"\n    }]\n  };\n}, {\n  name: \"Clean Plugin\",\n  baseDataPath: \"options\"\n});\nconst _10sec = 10 * 1000;\n\n/**\r\n * marge assets map 2 into map 1\r\n * @param {Assets} as1 assets\r\n * @param {Assets} as2 assets\r\n * @returns {void}\r\n */\nconst mergeAssets = (as1, as2) => {\n  for (const [key, value1] of as2) {\n    const value2 = as1.get(key);\n    if (!value2 || value1 > value2) as1.set(key, value1);\n  }\n};\n\n/**\r\n * @param {OutputFileSystem} fs filesystem\r\n * @param {string} outputPath output path\r\n * @param {Map<string, number>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)\r\n * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there\r\n * @returns {void}\r\n */\nconst getDiffToFs = (fs, outputPath, currentAssets, callback) => {\n  const directories = new Set();\n  // get directories of assets\n  for (const [asset] of currentAssets) {\n    directories.add(asset.replace(/(^|\\/)[^/]*$/, \"\"));\n  }\n  // and all parent directories\n  for (const directory of directories) {\n    directories.add(directory.replace(/(^|\\/)[^/]*$/, \"\"));\n  }\n  const diff = new Set();\n  asyncLib.forEachLimit(directories, 10, (directory, callback) => {\n    fs.readdir(join(fs, outputPath, directory), (err, entries) => {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        if (err.code === \"ENOTDIR\") {\n          diff.add(directory);\n          return callback();\n        }\n        return callback(err);\n      }\n      for (const entry of entries) {\n        const file = /** @type {string} */entry;\n        const filename = directory ? `${directory}/${file}` : file;\n        if (!directories.has(filename) && !currentAssets.has(filename)) {\n          diff.add(filename);\n        }\n      }\n      callback();\n    });\n  }, err => {\n    if (err) return callback(err);\n    callback(null, diff);\n  });\n};\n\n/**\r\n * @param {Assets} currentAssets assets list\r\n * @param {Assets} oldAssets old assets list\r\n * @returns {Set<string>} diff\r\n */\nconst getDiffToOldAssets = (currentAssets, oldAssets) => {\n  const diff = new Set();\n  const now = Date.now();\n  for (const [asset, ts] of oldAssets) {\n    if (ts >= now) continue;\n    if (!currentAssets.has(asset)) diff.add(asset);\n  }\n  return diff;\n};\n\n/**\r\n * @param {OutputFileSystem} fs filesystem\r\n * @param {string} filename path to file\r\n * @param {StatsCallback} callback callback for provided filename\r\n * @returns {void}\r\n */\nconst doStat = (fs, filename, callback) => {\n  if (\"lstat\" in fs) {\n    fs.lstat(filename, callback);\n  } else {\n    fs.stat(filename, callback);\n  }\n};\n\n/**\r\n * @param {OutputFileSystem} fs filesystem\r\n * @param {string} outputPath output path\r\n * @param {boolean} dry only log instead of fs modification\r\n * @param {Logger} logger logger\r\n * @param {Set<string>} diff filenames of the assets that shouldn't be there\r\n * @param {function(string): boolean} isKept check if the entry is ignored\r\n * @param {function(Error=, Assets=): void} callback callback\r\n * @returns {void}\r\n */\nconst applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {\n  const log = msg => {\n    if (dry) {\n      logger.info(msg);\n    } else {\n      logger.log(msg);\n    }\n  };\n  /** @typedef {{ type: \"check\" | \"unlink\" | \"rmdir\", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */\n  /** @type {Job[]} */\n  const jobs = Array.from(diff.keys(), filename => ({\n    type: \"check\",\n    filename,\n    parent: undefined\n  }));\n  /** @type {Assets} */\n  const keptAssets = new Map();\n  processAsyncTree(jobs, 10, (_ref, push, callback) => {\n    let {\n      type,\n      filename,\n      parent\n    } = _ref;\n    const handleError = err => {\n      if (err.code === \"ENOENT\") {\n        log(`${filename} was removed during cleaning by something else`);\n        handleParent();\n        return callback();\n      }\n      return callback(err);\n    };\n    const handleParent = () => {\n      if (parent && --parent.remaining === 0) push(parent.job);\n    };\n    const path = join(fs, outputPath, filename);\n    switch (type) {\n      case \"check\":\n        if (isKept(filename)) {\n          keptAssets.set(filename, 0);\n          // do not decrement parent entry as we don't want to delete the parent\n          log(`${filename} will be kept`);\n          return process.nextTick(callback);\n        }\n        doStat(fs, path, (err, stats) => {\n          if (err) return handleError(err);\n          if (!stats.isDirectory()) {\n            push({\n              type: \"unlink\",\n              filename,\n              parent\n            });\n            return callback();\n          }\n          fs.readdir(path, (err, entries) => {\n            if (err) return handleError(err);\n            /** @type {Job} */\n            const deleteJob = {\n              type: \"rmdir\",\n              filename,\n              parent\n            };\n            if (entries.length === 0) {\n              push(deleteJob);\n            } else {\n              const parentToken = {\n                remaining: entries.length,\n                job: deleteJob\n              };\n              for (const entry of entries) {\n                const file = /** @type {string} */entry;\n                if (file.startsWith(\".\")) {\n                  log(`${filename} will be kept (dot-files will never be removed)`);\n                  continue;\n                }\n                push({\n                  type: \"check\",\n                  filename: `${filename}/${file}`,\n                  parent: parentToken\n                });\n              }\n            }\n            return callback();\n          });\n        });\n        break;\n      case \"rmdir\":\n        log(`${filename} will be removed`);\n        if (dry) {\n          handleParent();\n          return process.nextTick(callback);\n        }\n        if (!fs.rmdir) {\n          logger.warn(`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`);\n          return process.nextTick(callback);\n        }\n        fs.rmdir(path, err => {\n          if (err) return handleError(err);\n          handleParent();\n          callback();\n        });\n        break;\n      case \"unlink\":\n        log(`${filename} will be removed`);\n        if (dry) {\n          handleParent();\n          return process.nextTick(callback);\n        }\n        if (!fs.unlink) {\n          logger.warn(`${filename} can't be removed because output file system doesn't support removing files (rmdir)`);\n          return process.nextTick(callback);\n        }\n        fs.unlink(path, err => {\n          if (err) return handleError(err);\n          handleParent();\n          callback();\n        });\n        break;\n    }\n  }, err => {\n    if (err) return callback(err);\n    callback(undefined, keptAssets);\n  });\n};\n\n/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\nclass CleanPlugin {\n  /**\r\n   * @param {Compilation} compilation the compilation\r\n   * @returns {CleanPluginCompilationHooks} the attached hooks\r\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n    let hooks = compilationHooksMap.get(compilation);\n    if (hooks === undefined) {\n      hooks = {\n        /** @type {SyncBailHook<[string], boolean>} */\n        keep: new SyncBailHook([\"ignore\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n    return hooks;\n  }\n\n  /** @param {CleanOptions} options options */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = {\n      dry: false,\n      ...options\n    };\n  }\n\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler the compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    const {\n      dry,\n      keep\n    } = this.options;\n    const keepFn = typeof keep === \"function\" ? keep : typeof keep === \"string\" ? path => path.startsWith(keep) : typeof keep === \"object\" && keep.test ? path => keep.test(path) : () => false;\n\n    // We assume that no external modification happens while the compiler is active\n    // So we can store the old assets and only diff to them to avoid fs access on\n    // incremental builds\n    /** @type {undefined|Assets} */\n    let oldAssets;\n    compiler.hooks.emit.tapAsync({\n      name: \"CleanPlugin\",\n      stage: 100\n    }, (compilation, callback) => {\n      const hooks = CleanPlugin.getCompilationHooks(compilation);\n      const logger = compilation.getLogger(\"webpack.CleanPlugin\");\n      const fs = compiler.outputFileSystem;\n      if (!fs.readdir) {\n        return callback(new Error(\"CleanPlugin: Output filesystem doesn't support listing directories (readdir)\"));\n      }\n\n      /** @type {Assets} */\n      const currentAssets = new Map();\n      const now = Date.now();\n      for (const asset of Object.keys(compilation.assets)) {\n        if (/^[A-Za-z]:\\\\|^\\/|^\\\\\\\\/.test(asset)) continue;\n        let normalizedAsset;\n        let newNormalizedAsset = asset.replace(/\\\\/g, \"/\");\n        do {\n          normalizedAsset = newNormalizedAsset;\n          newNormalizedAsset = normalizedAsset.replace(/(^|\\/)(?!\\.\\.)[^/]+\\/\\.\\.\\//g, \"$1\");\n        } while (newNormalizedAsset !== normalizedAsset);\n        if (normalizedAsset.startsWith(\"../\")) continue;\n        const assetInfo = compilation.assetsInfo.get(asset);\n        if (assetInfo && assetInfo.hotModuleReplacement) {\n          currentAssets.set(normalizedAsset, now + _10sec);\n        } else {\n          currentAssets.set(normalizedAsset, 0);\n        }\n      }\n      const outputPath = compilation.getPath(compiler.outputPath, {});\n      const isKept = path => {\n        const result = hooks.keep.call(path);\n        if (result !== undefined) return result;\n        return keepFn(path);\n      };\n\n      /**\r\n       * @param {Error=} err err\r\n       * @param {Set<string>=} diff diff\r\n       */\n      const diffCallback = (err, diff) => {\n        if (err) {\n          oldAssets = undefined;\n          callback(err);\n          return;\n        }\n        applyDiff(fs, outputPath, dry, logger, diff, isKept, (err, keptAssets) => {\n          if (err) {\n            oldAssets = undefined;\n          } else {\n            if (oldAssets) mergeAssets(currentAssets, oldAssets);\n            oldAssets = currentAssets;\n            if (keptAssets) mergeAssets(oldAssets, keptAssets);\n          }\n          callback(err);\n        });\n      };\n      if (oldAssets) {\n        diffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));\n      } else {\n        getDiffToFs(fs, outputPath, currentAssets, diffCallback);\n      }\n    });\n  }\n}\nmodule.exports = CleanPlugin;","map":{"version":3,"names":["asyncLib","require","SyncBailHook","Compilation","createSchemaValidation","join","processAsyncTree","validate","undefined","definitions","oneOf","$ref","name","baseDataPath","_10sec","mergeAssets","as1","as2","key","value1","value2","get","set","getDiffToFs","fs","outputPath","currentAssets","callback","directories","Set","asset","add","replace","directory","diff","forEachLimit","readdir","err","entries","code","entry","file","filename","has","getDiffToOldAssets","oldAssets","now","Date","ts","doStat","lstat","stat","applyDiff","dry","logger","isKept","log","msg","info","jobs","Array","from","keys","type","parent","keptAssets","Map","push","handleError","handleParent","remaining","job","path","process","nextTick","stats","isDirectory","deleteJob","length","parentToken","startsWith","rmdir","warn","unlink","compilationHooksMap","WeakMap","CleanPlugin","getCompilationHooks","compilation","TypeError","hooks","keep","constructor","options","apply","compiler","keepFn","test","emit","tapAsync","stage","getLogger","outputFileSystem","Error","Object","assets","normalizedAsset","newNormalizedAsset","assetInfo","assetsInfo","hotModuleReplacement","getPath","result","call","diffCallback","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/CleanPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Sergey Melyukov @smelukov\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst asyncLib = require(\"neo-async\");\r\nconst { SyncBailHook } = require(\"tapable\");\r\nconst Compilation = require(\"../lib/Compilation\");\r\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\r\nconst { join } = require(\"./util/fs\");\r\nconst processAsyncTree = require(\"./util/processAsyncTree\");\r\n\r\n/** @typedef {import(\"../declarations/WebpackOptions\").CleanOptions} CleanOptions */\r\n/** @typedef {import(\"./Compiler\")} Compiler */\r\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\r\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\r\n/** @typedef {import(\"./util/fs\").StatsCallback} StatsCallback */\r\n\r\n/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */\r\n/** @typedef {Map<string, number>} Assets */\r\n/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */\r\n\r\n/**\r\n * @typedef {Object} CleanPluginCompilationHooks\r\n * @property {SyncBailHook<[string], boolean>} keep when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config\r\n */\r\n\r\nconst validate = createSchemaValidation(\r\n\tundefined,\r\n\t() => {\r\n\t\tconst { definitions } = require(\"../schemas/WebpackOptions.json\");\r\n\t\treturn {\r\n\t\t\tdefinitions,\r\n\t\t\toneOf: [{ $ref: \"#/definitions/CleanOptions\" }]\r\n\t\t};\r\n\t},\r\n\t{\r\n\t\tname: \"Clean Plugin\",\r\n\t\tbaseDataPath: \"options\"\r\n\t}\r\n);\r\nconst _10sec = 10 * 1000;\r\n\r\n/**\r\n * marge assets map 2 into map 1\r\n * @param {Assets} as1 assets\r\n * @param {Assets} as2 assets\r\n * @returns {void}\r\n */\r\nconst mergeAssets = (as1, as2) => {\r\n\tfor (const [key, value1] of as2) {\r\n\t\tconst value2 = as1.get(key);\r\n\t\tif (!value2 || value1 > value2) as1.set(key, value1);\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {OutputFileSystem} fs filesystem\r\n * @param {string} outputPath output path\r\n * @param {Map<string, number>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)\r\n * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there\r\n * @returns {void}\r\n */\r\nconst getDiffToFs = (fs, outputPath, currentAssets, callback) => {\r\n\tconst directories = new Set();\r\n\t// get directories of assets\r\n\tfor (const [asset] of currentAssets) {\r\n\t\tdirectories.add(asset.replace(/(^|\\/)[^/]*$/, \"\"));\r\n\t}\r\n\t// and all parent directories\r\n\tfor (const directory of directories) {\r\n\t\tdirectories.add(directory.replace(/(^|\\/)[^/]*$/, \"\"));\r\n\t}\r\n\tconst diff = new Set();\r\n\tasyncLib.forEachLimit(\r\n\t\tdirectories,\r\n\t\t10,\r\n\t\t(directory, callback) => {\r\n\t\t\tfs.readdir(join(fs, outputPath, directory), (err, entries) => {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tif (err.code === \"ENOENT\") return callback();\r\n\t\t\t\t\tif (err.code === \"ENOTDIR\") {\r\n\t\t\t\t\t\tdiff.add(directory);\r\n\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn callback(err);\r\n\t\t\t\t}\r\n\t\t\t\tfor (const entry of entries) {\r\n\t\t\t\t\tconst file = /** @type {string} */ (entry);\r\n\t\t\t\t\tconst filename = directory ? `${directory}/${file}` : file;\r\n\t\t\t\t\tif (!directories.has(filename) && !currentAssets.has(filename)) {\r\n\t\t\t\t\t\tdiff.add(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcallback();\r\n\t\t\t});\r\n\t\t},\r\n\t\terr => {\r\n\t\t\tif (err) return callback(err);\r\n\r\n\t\t\tcallback(null, diff);\r\n\t\t}\r\n\t);\r\n};\r\n\r\n/**\r\n * @param {Assets} currentAssets assets list\r\n * @param {Assets} oldAssets old assets list\r\n * @returns {Set<string>} diff\r\n */\r\nconst getDiffToOldAssets = (currentAssets, oldAssets) => {\r\n\tconst diff = new Set();\r\n\tconst now = Date.now();\r\n\tfor (const [asset, ts] of oldAssets) {\r\n\t\tif (ts >= now) continue;\r\n\t\tif (!currentAssets.has(asset)) diff.add(asset);\r\n\t}\r\n\treturn diff;\r\n};\r\n\r\n/**\r\n * @param {OutputFileSystem} fs filesystem\r\n * @param {string} filename path to file\r\n * @param {StatsCallback} callback callback for provided filename\r\n * @returns {void}\r\n */\r\nconst doStat = (fs, filename, callback) => {\r\n\tif (\"lstat\" in fs) {\r\n\t\tfs.lstat(filename, callback);\r\n\t} else {\r\n\t\tfs.stat(filename, callback);\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {OutputFileSystem} fs filesystem\r\n * @param {string} outputPath output path\r\n * @param {boolean} dry only log instead of fs modification\r\n * @param {Logger} logger logger\r\n * @param {Set<string>} diff filenames of the assets that shouldn't be there\r\n * @param {function(string): boolean} isKept check if the entry is ignored\r\n * @param {function(Error=, Assets=): void} callback callback\r\n * @returns {void}\r\n */\r\nconst applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {\r\n\tconst log = msg => {\r\n\t\tif (dry) {\r\n\t\t\tlogger.info(msg);\r\n\t\t} else {\r\n\t\t\tlogger.log(msg);\r\n\t\t}\r\n\t};\r\n\t/** @typedef {{ type: \"check\" | \"unlink\" | \"rmdir\", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */\r\n\t/** @type {Job[]} */\r\n\tconst jobs = Array.from(diff.keys(), filename => ({\r\n\t\ttype: \"check\",\r\n\t\tfilename,\r\n\t\tparent: undefined\r\n\t}));\r\n\t/** @type {Assets} */\r\n\tconst keptAssets = new Map();\r\n\tprocessAsyncTree(\r\n\t\tjobs,\r\n\t\t10,\r\n\t\t({ type, filename, parent }, push, callback) => {\r\n\t\t\tconst handleError = err => {\r\n\t\t\t\tif (err.code === \"ENOENT\") {\r\n\t\t\t\t\tlog(`${filename} was removed during cleaning by something else`);\r\n\t\t\t\t\thandleParent();\r\n\t\t\t\t\treturn callback();\r\n\t\t\t\t}\r\n\t\t\t\treturn callback(err);\r\n\t\t\t};\r\n\t\t\tconst handleParent = () => {\r\n\t\t\t\tif (parent && --parent.remaining === 0) push(parent.job);\r\n\t\t\t};\r\n\t\t\tconst path = join(fs, outputPath, filename);\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase \"check\":\r\n\t\t\t\t\tif (isKept(filename)) {\r\n\t\t\t\t\t\tkeptAssets.set(filename, 0);\r\n\t\t\t\t\t\t// do not decrement parent entry as we don't want to delete the parent\r\n\t\t\t\t\t\tlog(`${filename} will be kept`);\r\n\t\t\t\t\t\treturn process.nextTick(callback);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdoStat(fs, path, (err, stats) => {\r\n\t\t\t\t\t\tif (err) return handleError(err);\r\n\t\t\t\t\t\tif (!stats.isDirectory()) {\r\n\t\t\t\t\t\t\tpush({\r\n\t\t\t\t\t\t\t\ttype: \"unlink\",\r\n\t\t\t\t\t\t\t\tfilename,\r\n\t\t\t\t\t\t\t\tparent\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfs.readdir(path, (err, entries) => {\r\n\t\t\t\t\t\t\tif (err) return handleError(err);\r\n\t\t\t\t\t\t\t/** @type {Job} */\r\n\t\t\t\t\t\t\tconst deleteJob = {\r\n\t\t\t\t\t\t\t\ttype: \"rmdir\",\r\n\t\t\t\t\t\t\t\tfilename,\r\n\t\t\t\t\t\t\t\tparent\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tif (entries.length === 0) {\r\n\t\t\t\t\t\t\t\tpush(deleteJob);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tconst parentToken = {\r\n\t\t\t\t\t\t\t\t\tremaining: entries.length,\r\n\t\t\t\t\t\t\t\t\tjob: deleteJob\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tfor (const entry of entries) {\r\n\t\t\t\t\t\t\t\t\tconst file = /** @type {string} */ (entry);\r\n\t\t\t\t\t\t\t\t\tif (file.startsWith(\".\")) {\r\n\t\t\t\t\t\t\t\t\t\tlog(\r\n\t\t\t\t\t\t\t\t\t\t\t`${filename} will be kept (dot-files will never be removed)`\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tpush({\r\n\t\t\t\t\t\t\t\t\t\ttype: \"check\",\r\n\t\t\t\t\t\t\t\t\t\tfilename: `${filename}/${file}`,\r\n\t\t\t\t\t\t\t\t\t\tparent: parentToken\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"rmdir\":\r\n\t\t\t\t\tlog(`${filename} will be removed`);\r\n\t\t\t\t\tif (dry) {\r\n\t\t\t\t\t\thandleParent();\r\n\t\t\t\t\t\treturn process.nextTick(callback);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!fs.rmdir) {\r\n\t\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\t`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn process.nextTick(callback);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfs.rmdir(path, err => {\r\n\t\t\t\t\t\tif (err) return handleError(err);\r\n\t\t\t\t\t\thandleParent();\r\n\t\t\t\t\t\tcallback();\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"unlink\":\r\n\t\t\t\t\tlog(`${filename} will be removed`);\r\n\t\t\t\t\tif (dry) {\r\n\t\t\t\t\t\thandleParent();\r\n\t\t\t\t\t\treturn process.nextTick(callback);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!fs.unlink) {\r\n\t\t\t\t\t\tlogger.warn(\r\n\t\t\t\t\t\t\t`${filename} can't be removed because output file system doesn't support removing files (rmdir)`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn process.nextTick(callback);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfs.unlink(path, err => {\r\n\t\t\t\t\t\tif (err) return handleError(err);\r\n\t\t\t\t\t\thandleParent();\r\n\t\t\t\t\t\tcallback();\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t},\r\n\t\terr => {\r\n\t\t\tif (err) return callback(err);\r\n\t\t\tcallback(undefined, keptAssets);\r\n\t\t}\r\n\t);\r\n};\r\n\r\n/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */\r\nconst compilationHooksMap = new WeakMap();\r\n\r\nclass CleanPlugin {\r\n\t/**\r\n\t * @param {Compilation} compilation the compilation\r\n\t * @returns {CleanPluginCompilationHooks} the attached hooks\r\n\t */\r\n\tstatic getCompilationHooks(compilation) {\r\n\t\tif (!(compilation instanceof Compilation)) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\r\n\t\t\t);\r\n\t\t}\r\n\t\tlet hooks = compilationHooksMap.get(compilation);\r\n\t\tif (hooks === undefined) {\r\n\t\t\thooks = {\r\n\t\t\t\t/** @type {SyncBailHook<[string], boolean>} */\r\n\t\t\t\tkeep: new SyncBailHook([\"ignore\"])\r\n\t\t\t};\r\n\t\t\tcompilationHooksMap.set(compilation, hooks);\r\n\t\t}\r\n\t\treturn hooks;\r\n\t}\r\n\r\n\t/** @param {CleanOptions} options options */\r\n\tconstructor(options = {}) {\r\n\t\tvalidate(options);\r\n\t\tthis.options = { dry: false, ...options };\r\n\t}\r\n\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler the compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tconst { dry, keep } = this.options;\r\n\r\n\t\tconst keepFn =\r\n\t\t\ttypeof keep === \"function\"\r\n\t\t\t\t? keep\r\n\t\t\t\t: typeof keep === \"string\"\r\n\t\t\t\t? path => path.startsWith(keep)\r\n\t\t\t\t: typeof keep === \"object\" && keep.test\r\n\t\t\t\t? path => keep.test(path)\r\n\t\t\t\t: () => false;\r\n\r\n\t\t// We assume that no external modification happens while the compiler is active\r\n\t\t// So we can store the old assets and only diff to them to avoid fs access on\r\n\t\t// incremental builds\r\n\t\t/** @type {undefined|Assets} */\r\n\t\tlet oldAssets;\r\n\r\n\t\tcompiler.hooks.emit.tapAsync(\r\n\t\t\t{\r\n\t\t\t\tname: \"CleanPlugin\",\r\n\t\t\t\tstage: 100\r\n\t\t\t},\r\n\t\t\t(compilation, callback) => {\r\n\t\t\t\tconst hooks = CleanPlugin.getCompilationHooks(compilation);\r\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.CleanPlugin\");\r\n\t\t\t\tconst fs = compiler.outputFileSystem;\r\n\r\n\t\t\t\tif (!fs.readdir) {\r\n\t\t\t\t\treturn callback(\r\n\t\t\t\t\t\tnew Error(\r\n\t\t\t\t\t\t\t\"CleanPlugin: Output filesystem doesn't support listing directories (readdir)\"\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/** @type {Assets} */\r\n\t\t\t\tconst currentAssets = new Map();\r\n\t\t\t\tconst now = Date.now();\r\n\t\t\t\tfor (const asset of Object.keys(compilation.assets)) {\r\n\t\t\t\t\tif (/^[A-Za-z]:\\\\|^\\/|^\\\\\\\\/.test(asset)) continue;\r\n\t\t\t\t\tlet normalizedAsset;\r\n\t\t\t\t\tlet newNormalizedAsset = asset.replace(/\\\\/g, \"/\");\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tnormalizedAsset = newNormalizedAsset;\r\n\t\t\t\t\t\tnewNormalizedAsset = normalizedAsset.replace(\r\n\t\t\t\t\t\t\t/(^|\\/)(?!\\.\\.)[^/]+\\/\\.\\.\\//g,\r\n\t\t\t\t\t\t\t\"$1\"\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t} while (newNormalizedAsset !== normalizedAsset);\r\n\t\t\t\t\tif (normalizedAsset.startsWith(\"../\")) continue;\r\n\t\t\t\t\tconst assetInfo = compilation.assetsInfo.get(asset);\r\n\t\t\t\t\tif (assetInfo && assetInfo.hotModuleReplacement) {\r\n\t\t\t\t\t\tcurrentAssets.set(normalizedAsset, now + _10sec);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentAssets.set(normalizedAsset, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst outputPath = compilation.getPath(compiler.outputPath, {});\r\n\r\n\t\t\t\tconst isKept = path => {\r\n\t\t\t\t\tconst result = hooks.keep.call(path);\r\n\t\t\t\t\tif (result !== undefined) return result;\r\n\t\t\t\t\treturn keepFn(path);\r\n\t\t\t\t};\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {Error=} err err\r\n\t\t\t\t * @param {Set<string>=} diff diff\r\n\t\t\t\t */\r\n\t\t\t\tconst diffCallback = (err, diff) => {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\toldAssets = undefined;\r\n\t\t\t\t\t\tcallback(err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tapplyDiff(\r\n\t\t\t\t\t\tfs,\r\n\t\t\t\t\t\toutputPath,\r\n\t\t\t\t\t\tdry,\r\n\t\t\t\t\t\tlogger,\r\n\t\t\t\t\t\tdiff,\r\n\t\t\t\t\t\tisKept,\r\n\t\t\t\t\t\t(err, keptAssets) => {\r\n\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\toldAssets = undefined;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (oldAssets) mergeAssets(currentAssets, oldAssets);\r\n\t\t\t\t\t\t\t\toldAssets = currentAssets;\r\n\t\t\t\t\t\t\t\tif (keptAssets) mergeAssets(oldAssets, keptAssets);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcallback(err);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (oldAssets) {\r\n\t\t\t\t\tdiffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tgetDiffToFs(fs, outputPath, currentAssets, diffCallback);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = CleanPlugin;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}