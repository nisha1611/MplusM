{"ast":null,"code":"'use strict';\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, {\n          $match: match\n        });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({\n        $match: match\n      });\n    }\n  }\n};","map":{"version":3,"names":["module","exports","prepareDiscriminatorPipeline","pipeline","schema","prefix","discriminatorMapping","isRoot","originalPipeline","filterKey","length","key","discriminatorValue","value","$match","undefined","$geoNear","query","$search","match","splice","unshift"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js"],"sourcesContent":["'use strict';\r\n\r\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\r\n  const discriminatorMapping = schema && schema.discriminatorMapping;\r\n  prefix = prefix || '';\r\n\r\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\r\n    const originalPipeline = pipeline;\r\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\r\n    const discriminatorValue = discriminatorMapping.value;\r\n\r\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\r\n    // key, add the discriminator key to it. This allows for potential\r\n    // aggregation query optimizations not to be disturbed by this feature.\r\n    if (originalPipeline[0] != null &&\r\n        originalPipeline[0].$match &&\r\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\r\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\r\n      // `originalPipeline` is a ref, so there's no need for\r\n      // aggregate._pipeline = originalPipeline\r\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\r\n      originalPipeline[0].$geoNear.query =\r\n          originalPipeline[0].$geoNear.query || {};\r\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\r\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\r\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\r\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\r\n      } else {\r\n        const match = {};\r\n        match[filterKey] = discriminatorValue;\r\n        originalPipeline.splice(1, 0, { $match: match });\r\n      }\r\n    } else {\r\n      const match = {};\r\n      match[filterKey] = discriminatorValue;\r\n      originalPipeline.unshift({ $match: match });\r\n    }\r\n  }\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,SAASC,4BAA4B,CAACC,QAAQ,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAC/E,MAAMC,oBAAoB,GAAGF,MAAM,IAAIA,MAAM,CAACE,oBAAoB;EAClED,MAAM,GAAGA,MAAM,IAAI,EAAE;EAErB,IAAIC,oBAAoB,IAAI,CAACA,oBAAoB,CAACC,MAAM,EAAE;IACxD,MAAMC,gBAAgB,GAAGL,QAAQ;IACjC,MAAMM,SAAS,GAAG,CAACJ,MAAM,CAACK,MAAM,GAAG,CAAC,GAAGL,MAAM,GAAG,GAAG,GAAGA,MAAM,IAAIC,oBAAoB,CAACK,GAAG;IACxF,MAAMC,kBAAkB,GAAGN,oBAAoB,CAACO,KAAK;;IAErD;IACA;IACA;IACA,IAAIL,gBAAgB,CAAC,CAAC,CAAC,IAAI,IAAI,IAC3BA,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,KACzBN,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,KAAKM,SAAS,IAAIP,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,KAAKG,kBAAkB,CAAC,EAAE;MACzHJ,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,GAAGG,kBAAkB;MAC1D;MACA;IACF,CAAC,MAAM,IAAIJ,gBAAgB,CAAC,CAAC,CAAC,IAAI,IAAI,IAAIA,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,EAAE;MACtER,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,CAACC,KAAK,GAC9BT,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,CAACC,KAAK,IAAI,CAAC,CAAC;MAC5CT,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,CAACC,KAAK,CAACR,SAAS,CAAC,GAAGG,kBAAkB;IACpE,CAAC,MAAM,IAAIJ,gBAAgB,CAAC,CAAC,CAAC,IAAI,IAAI,IAAIA,gBAAgB,CAAC,CAAC,CAAC,CAACU,OAAO,EAAE;MACrE,IAAIV,gBAAgB,CAAC,CAAC,CAAC,IAAIA,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,IAAI,IAAI,EAAE;QAC7DN,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,GAAGD,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,IAAIG,kBAAkB;MACrG,CAAC,MAAM;QACL,MAAMO,KAAK,GAAG,CAAC,CAAC;QAChBA,KAAK,CAACV,SAAS,CAAC,GAAGG,kBAAkB;QACrCJ,gBAAgB,CAACY,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE;UAAEN,MAAM,EAAEK;QAAM,CAAC,CAAC;MAClD;IACF,CAAC,MAAM;MACL,MAAMA,KAAK,GAAG,CAAC,CAAC;MAChBA,KAAK,CAACV,SAAS,CAAC,GAAGG,kBAAkB;MACrCJ,gBAAgB,CAACa,OAAO,CAAC;QAAEP,MAAM,EAAEK;MAAM,CAAC,CAAC;IAC7C;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}