{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst {\n  intersect\n} = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n  compareModulesByIdentifier,\n  compareChunkGroupsByIndex,\n  compareModulesById\n} = require(\"./util/comparators\");\nconst {\n  createArrayToSetDeprecationSet\n} = require(\"./util/deprecation\");\nconst {\n  mergeRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\r\n * @typedef {Object} WithId an object who has an id property *\r\n * @property {string | number} id the id of the object\r\n */\n\n/**\r\n * @deprecated\r\n * @typedef {Object} ChunkMaps\r\n * @property {Record<string|number, string>} hash\r\n * @property {Record<string|number, Record<string, string>>} contentHash\r\n * @property {Record<string|number, string>} name\r\n */\n\n/**\r\n * @deprecated\r\n * @typedef {Object} ChunkModuleMaps\r\n * @property {Record<string|number, (string|number)[]>} id\r\n * @property {Record<string|number, string>} hash\r\n */\n\nlet debugId = 1000;\n\n/**\r\n * A Chunk is a unit of encapsulation for Modules.\r\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\r\n */\nclass Chunk {\n  /**\r\n   * @param {string=} name of chunk being created, is optional (for subclasses)\r\n   * @param {boolean} backCompat enable backward-compatibility\r\n   */\n  constructor(name) {\n    let backCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    /** @type {number | string | null} */\n    this.id = null;\n    /** @type {(number|string)[] | null} */\n    this.ids = null;\n    /** @type {number} */\n    this.debugId = debugId++;\n    /** @type {string} */\n    this.name = name;\n    /** @type {SortableSet<string>} */\n    this.idNameHints = new SortableSet();\n    /** @type {boolean} */\n    this.preventIntegration = false;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n    this.filenameTemplate = undefined;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n    this.cssFilenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n    this._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n    /** @type {RuntimeSpec} */\n    this.runtime = undefined;\n    /** @type {Set<string>} */\n    this.files = backCompat ? new ChunkFilesSet() : new Set();\n    /** @type {Set<string>} */\n    this.auxiliaryFiles = new Set();\n    /** @type {boolean} */\n    this.rendered = false;\n    /** @type {string=} */\n    this.hash = undefined;\n    /** @type {Record<string, string>} */\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n    this.renderedHash = undefined;\n    /** @type {string=} */\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n    this.extraAsync = false;\n  }\n\n  // TODO remove in webpack 6\n  // BACKWARD-COMPAT START\n  get entryModule() {\n    const entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, \"Chunk.entryModule\", \"DEP_WEBPACK_CHUNK_ENTRY_MODULE\").getChunkEntryModulesIterable(this));\n    if (entryModules.length === 0) {\n      return undefined;\n    } else if (entryModules.length === 1) {\n      return entryModules[0];\n    } else {\n      throw new Error(\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\");\n    }\n  }\n\n  /**\r\n   * @returns {boolean} true, if the chunk contains an entry module\r\n   */\n  hasEntryModule() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasEntryModule\", \"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\").getNumberOfEntryModules(this) > 0;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {boolean} true, if the chunk could be added\r\n   */\n  addModule(module) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.addModule\", \"DEP_WEBPACK_CHUNK_ADD_MODULE\");\n    if (chunkGraph.isModuleInChunk(module, this)) return false;\n    chunkGraph.connectChunkAndModule(this, module);\n    return true;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {void}\r\n   */\n  removeModule(module) {\n    ChunkGraph.getChunkGraphForChunk(this, \"Chunk.removeModule\", \"DEP_WEBPACK_CHUNK_REMOVE_MODULE\").disconnectChunkAndModule(this, module);\n  }\n\n  /**\r\n   * @returns {number} the number of module which are contained in this chunk\r\n   */\n  getNumberOfModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getNumberOfModules\", \"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\").getNumberOfChunkModules(this);\n  }\n  get modulesIterable() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesIterable\", \"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\");\n    return chunkGraph.getOrderedChunkModulesIterable(this, compareModulesByIdentifier);\n  }\n\n  /**\r\n   * @param {Chunk} otherChunk the chunk to compare with\r\n   * @returns {-1|0|1} the comparison result\r\n   */\n  compareTo(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.compareTo\", \"DEP_WEBPACK_CHUNK_COMPARE_TO\");\n    return chunkGraph.compareChunks(this, otherChunk);\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {boolean} true, if the chunk contains the module\r\n   */\n  containsModule(module) {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.containsModule\", \"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\").isModuleInChunk(module, this);\n  }\n\n  /**\r\n   * @returns {Module[]} the modules for this chunk\r\n   */\n  getModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getModules\", \"DEP_WEBPACK_CHUNK_GET_MODULES\").getChunkModules(this);\n  }\n\n  /**\r\n   * @returns {void}\r\n   */\n  remove() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.remove\", \"DEP_WEBPACK_CHUNK_REMOVE\");\n    chunkGraph.disconnectChunk(this);\n    this.disconnectFromGroups();\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {Chunk} otherChunk the target chunk\r\n   * @returns {void}\r\n   */\n  moveModule(module, otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.moveModule\", \"DEP_WEBPACK_CHUNK_MOVE_MODULE\");\n    chunkGraph.disconnectChunkAndModule(this, module);\n    chunkGraph.connectChunkAndModule(otherChunk, module);\n  }\n\n  /**\r\n   * @param {Chunk} otherChunk the other chunk\r\n   * @returns {boolean} true, if the specified chunk has been integrated\r\n   */\n  integrate(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integrate\", \"DEP_WEBPACK_CHUNK_INTEGRATE\");\n    if (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n      chunkGraph.integrateChunks(this, otherChunk);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\r\n   * @param {Chunk} otherChunk the other chunk\r\n   * @returns {boolean} true, if chunks could be integrated\r\n   */\n  canBeIntegrated(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.canBeIntegrated\", \"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\");\n    return chunkGraph.canChunksBeIntegrated(this, otherChunk);\n  }\n\n  /**\r\n   * @returns {boolean} true, if this chunk contains no module\r\n   */\n  isEmpty() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.isEmpty\", \"DEP_WEBPACK_CHUNK_IS_EMPTY\");\n    return chunkGraph.getNumberOfChunkModules(this) === 0;\n  }\n\n  /**\r\n   * @returns {number} total size of all modules in this chunk\r\n   */\n  modulesSize() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesSize\", \"DEP_WEBPACK_CHUNK_MODULES_SIZE\");\n    return chunkGraph.getChunkModulesSize(this);\n  }\n\n  /**\r\n   * @param {ChunkSizeOptions} options options object\r\n   * @returns {number} total size of this chunk\r\n   */\n  size() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.size\", \"DEP_WEBPACK_CHUNK_SIZE\");\n    return chunkGraph.getChunkSize(this, options);\n  }\n\n  /**\r\n   * @param {Chunk} otherChunk the other chunk\r\n   * @param {ChunkSizeOptions} options options object\r\n   * @returns {number} total size of the chunk or false if the chunk can't be integrated\r\n   */\n  integratedSize(otherChunk, options) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integratedSize\", \"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\");\n    return chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n  }\n\n  /**\r\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\r\n   * @returns {ChunkModuleMaps} module map information\r\n   */\n  getChunkModuleMaps(filterFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getChunkModuleMaps\", \"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\");\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkModuleHashMap = Object.create(null);\n    for (const asyncChunk of this.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n      for (const module of chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n          const moduleId = chunkGraph.getModuleId(module);\n          array.push(moduleId);\n          chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(module, undefined);\n        }\n      }\n    }\n    return {\n      id: chunkModuleIdMap,\n      hash: chunkModuleHashMap\n    };\n  }\n\n  /**\r\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\r\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\r\n   * @returns {boolean} return true if module exists in graph\r\n   */\n  hasModuleInGraph(filterFn, filterChunkFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasModuleInGraph\", \"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\");\n    return chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n  }\n\n  /**\r\n   * @deprecated\r\n   * @param {boolean} realHash whether the full hash or the rendered hash is to be used\r\n   * @returns {ChunkMaps} the chunk map information\r\n   */\n  getChunkMaps(realHash) {\n    /** @type {Record<string|number, string>} */\n    const chunkHashMap = Object.create(null);\n    /** @type {Record<string|number, Record<string, string>>} */\n    const chunkContentHashMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkNameMap = Object.create(null);\n    for (const chunk of this.getAllAsyncChunks()) {\n      chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n      for (const key of Object.keys(chunk.contentHash)) {\n        if (!chunkContentHashMap[key]) {\n          chunkContentHashMap[key] = Object.create(null);\n        }\n        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n      }\n      if (chunk.name) {\n        chunkNameMap[chunk.id] = chunk.name;\n      }\n    }\n    return {\n      hash: chunkHashMap,\n      contentHash: chunkContentHashMap,\n      name: chunkNameMap\n    };\n  }\n  // BACKWARD-COMPAT END\n\n  /**\r\n   * @returns {boolean} whether or not the Chunk will have a runtime\r\n   */\n  hasRuntime() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @returns {boolean} whether or not this chunk can be an initial chunk\r\n   */\n  canBeInitial() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial()) return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * @returns {boolean} whether this chunk can only be an initial chunk\r\n   */\n  isOnlyInitial() {\n    if (this._groups.size <= 0) return false;\n    for (const chunkGroup of this._groups) {\n      if (!chunkGroup.isInitial()) return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * @returns {EntryOptions | undefined} the entry options for this chunk\r\n   */\n  getEntryOptions() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint) {\n        return chunkGroup.options;\n      }\n    }\n    return undefined;\n  }\n\n  /**\r\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\r\n   * @returns {void}\r\n   */\n  addGroup(chunkGroup) {\n    this._groups.add(chunkGroup);\n  }\n\n  /**\r\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\r\n   * @returns {void}\r\n   */\n  removeGroup(chunkGroup) {\n    this._groups.delete(chunkGroup);\n  }\n\n  /**\r\n   * @param {ChunkGroup} chunkGroup the chunkGroup to check\r\n   * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\r\n   */\n  isInGroup(chunkGroup) {\n    return this._groups.has(chunkGroup);\n  }\n\n  /**\r\n   * @returns {number} the amount of groups that the said chunk is in\r\n   */\n  getNumberOfGroups() {\n    return this._groups.size;\n  }\n\n  /**\r\n   * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\r\n   */\n  get groupsIterable() {\n    this._groups.sort();\n    return this._groups;\n  }\n\n  /**\r\n   * @returns {void}\r\n   */\n  disconnectFromGroups() {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.removeChunk(this);\n    }\n  }\n\n  /**\r\n   * @param {Chunk} newChunk the new chunk that will be split out of\r\n   * @returns {void}\r\n   */\n  split(newChunk) {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.insertChunk(newChunk, this);\n      newChunk.addGroup(chunkGroup);\n    }\n    for (const idHint of this.idNameHints) {\n      newChunk.idNameHints.add(idHint);\n    }\n    newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n  }\n\n  /**\r\n   * @param {Hash} hash hash (will be modified)\r\n   * @param {ChunkGraph} chunkGraph the chunk graph\r\n   * @returns {void}\r\n   */\n  updateHash(hash, chunkGraph) {\n    hash.update(`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `);\n    const xor = new StringXor();\n    for (const m of chunkGraph.getChunkModulesIterable(this)) {\n      xor.add(chunkGraph.getModuleHash(m, this.runtime));\n    }\n    xor.updateHash(hash);\n    const entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n    for (const [m, chunkGroup] of entryModules) {\n      hash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n    }\n  }\n\n  /**\r\n   * @returns {Set<Chunk>} a set of all the async chunks\r\n   */\n  getAllAsyncChunks() {\n    const queue = new Set();\n    const chunks = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    const initialQueue = new Set(this.groupsIterable);\n    for (const chunkGroup of initialQueue) {\n      for (const child of chunkGroup.childrenIterable) {\n        if (child instanceof Entrypoint) {\n          initialQueue.add(child);\n        } else {\n          queue.add(child);\n        }\n      }\n    }\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          chunks.add(chunk);\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return chunks;\n  }\n\n  /**\r\n   * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\r\n   */\n  getAllInitialChunks() {\n    const chunks = new Set();\n    const queue = new Set(this.groupsIterable);\n    for (const group of queue) {\n      if (group.isInitial()) {\n        for (const c of group.chunks) chunks.add(c);\n        for (const g of group.childrenIterable) queue.add(g);\n      }\n    }\n    return chunks;\n  }\n\n  /**\r\n   * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\r\n   */\n  getAllReferencedChunks() {\n    const queue = new Set(this.groupsIterable);\n    const chunks = new Set();\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        chunks.add(chunk);\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return chunks;\n  }\n\n  /**\r\n   * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\r\n   */\n  getAllReferencedAsyncEntrypoints() {\n    const queue = new Set(this.groupsIterable);\n    const entrypoints = new Set();\n    for (const chunkGroup of queue) {\n      for (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n        entrypoints.add(entrypoint);\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return entrypoints;\n  }\n\n  /**\r\n   * @returns {boolean} true, if the chunk references async chunks\r\n   */\n  hasAsyncChunks() {\n    const queue = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    for (const chunkGroup of this.groupsIterable) {\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          return true;\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {ChunkGraph} chunkGraph the chunk graph\r\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\r\n   * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\r\n   */\n  getChildIdsByOrders(chunkGraph, filterFn) {\n    /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n    const lists = new Map();\n    for (const group of this.groupsIterable) {\n      if (group.chunks[group.chunks.length - 1] === this) {\n        for (const childGroup of group.childrenIterable) {\n          for (const key of Object.keys(childGroup.options)) {\n            if (key.endsWith(\"Order\")) {\n              const name = key.slice(0, key.length - \"Order\".length);\n              let list = lists.get(name);\n              if (list === undefined) {\n                list = [];\n                lists.set(name, list);\n              }\n              list.push({\n                order: childGroup.options[key],\n                group: childGroup\n              });\n            }\n          }\n        }\n      }\n    }\n    /** @type {Record<string, (string | number)[]>} */\n    const result = Object.create(null);\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      /** @type {Set<string | number>} */\n      const chunkIdSet = new Set();\n      for (const item of list) {\n        for (const chunk of item.group.chunks) {\n          if (filterFn && !filterFn(chunk, chunkGraph)) continue;\n          chunkIdSet.add(chunk.id);\n        }\n      }\n      if (chunkIdSet.size > 0) {\n        result[name] = Array.from(chunkIdSet);\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * @param {ChunkGraph} chunkGraph the chunk graph\r\n   * @param {string} type option name\r\n   * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\r\n   */\n  getChildrenOfTypeInOrder(chunkGraph, type) {\n    const list = [];\n    for (const group of this.groupsIterable) {\n      for (const childGroup of group.childrenIterable) {\n        const order = childGroup.options[type];\n        if (order === undefined) continue;\n        list.push({\n          order,\n          group,\n          childGroup\n        });\n      }\n    }\n    if (list.length === 0) return undefined;\n    list.sort((a, b) => {\n      const cmp = b.order - a.order;\n      if (cmp !== 0) return cmp;\n      return a.group.compareTo(chunkGraph, b.group);\n    });\n    const result = [];\n    let lastEntry;\n    for (const {\n      group,\n      childGroup\n    } of list) {\n      if (lastEntry && lastEntry.onChunks === group.chunks) {\n        for (const chunk of childGroup.chunks) {\n          lastEntry.chunks.add(chunk);\n        }\n      } else {\n        result.push(lastEntry = {\n          onChunks: group.chunks,\n          chunks: new Set(childGroup.chunks)\n        });\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * @param {ChunkGraph} chunkGraph the chunk graph\r\n   * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\r\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\r\n   * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\r\n   */\n  getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n    /** @type {Record<string|number, Record<string, (string | number)[]>>} */\n    const chunkMaps = Object.create(null);\n\n    /**\r\n     * @param {Chunk} chunk a chunk\r\n     * @returns {void}\r\n     */\n    const addChildIdsByOrdersToMap = chunk => {\n      const data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n      for (const key of Object.keys(data)) {\n        let chunkMap = chunkMaps[key];\n        if (chunkMap === undefined) {\n          chunkMaps[key] = chunkMap = Object.create(null);\n        }\n        chunkMap[chunk.id] = data[key];\n      }\n    };\n    if (includeDirectChildren) {\n      /** @type {Set<Chunk>} */\n      const chunks = new Set();\n      for (const chunkGroup of this.groupsIterable) {\n        for (const chunk of chunkGroup.chunks) {\n          chunks.add(chunk);\n        }\n      }\n      for (const chunk of chunks) {\n        addChildIdsByOrdersToMap(chunk);\n      }\n    }\n    for (const chunk of this.getAllAsyncChunks()) {\n      addChildIdsByOrdersToMap(chunk);\n    }\n    return chunkMaps;\n  }\n}\nmodule.exports = Chunk;","map":{"version":3,"names":["ChunkGraph","require","Entrypoint","intersect","SortableSet","StringXor","compareModulesByIdentifier","compareChunkGroupsByIndex","compareModulesById","createArrayToSetDeprecationSet","mergeRuntime","ChunkFilesSet","debugId","Chunk","constructor","name","backCompat","id","ids","idNameHints","preventIntegration","filenameTemplate","undefined","cssFilenameTemplate","_groups","runtime","files","Set","auxiliaryFiles","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","entryModule","entryModules","Array","from","getChunkGraphForChunk","getChunkEntryModulesIterable","length","Error","hasEntryModule","getNumberOfEntryModules","addModule","module","chunkGraph","isModuleInChunk","connectChunkAndModule","removeModule","disconnectChunkAndModule","getNumberOfModules","getNumberOfChunkModules","modulesIterable","getOrderedChunkModulesIterable","compareTo","otherChunk","compareChunks","containsModule","getModules","getChunkModules","remove","disconnectChunk","disconnectFromGroups","moveModule","integrate","canChunksBeIntegrated","integrateChunks","canBeIntegrated","isEmpty","modulesSize","getChunkModulesSize","size","options","getChunkSize","integratedSize","getIntegratedChunksSize","getChunkModuleMaps","filterFn","chunkModuleIdMap","chunkModuleHashMap","asyncChunk","getAllAsyncChunks","array","moduleId","getModuleId","push","getRenderedModuleHash","hasModuleInGraph","filterChunkFn","getChunkMaps","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","chunk","key","keys","hasRuntime","chunkGroup","getRuntimeChunk","canBeInitial","isInitial","isOnlyInitial","getEntryOptions","addGroup","add","removeGroup","delete","isInGroup","has","getNumberOfGroups","groupsIterable","sort","removeChunk","split","newChunk","insertChunk","idHint","updateHash","update","join","xor","m","getChunkModulesIterable","getModuleHash","getChunkEntryModulesWithChunkGroupIterable","queue","chunks","initialChunks","g","initialQueue","child","childrenIterable","getAllInitialChunks","group","c","getAllReferencedChunks","getAllReferencedAsyncEntrypoints","entrypoints","entrypoint","asyncEntrypointsIterable","hasAsyncChunks","getChildIdsByOrders","lists","Map","childGroup","endsWith","slice","list","get","set","order","result","a","b","cmp","chunkIdSet","item","getChildrenOfTypeInOrder","type","lastEntry","onChunks","getChildIdsByOrdersMap","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","data","chunkMap","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/Chunk.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst ChunkGraph = require(\"./ChunkGraph\");\r\nconst Entrypoint = require(\"./Entrypoint\");\r\nconst { intersect } = require(\"./util/SetHelpers\");\r\nconst SortableSet = require(\"./util/SortableSet\");\r\nconst StringXor = require(\"./util/StringXor\");\r\nconst {\r\n\tcompareModulesByIdentifier,\r\n\tcompareChunkGroupsByIndex,\r\n\tcompareModulesById\r\n} = require(\"./util/comparators\");\r\nconst { createArrayToSetDeprecationSet } = require(\"./util/deprecation\");\r\nconst { mergeRuntime } = require(\"./util/runtime\");\r\n\r\n/** @typedef {import(\"webpack-sources\").Source} Source */\r\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\r\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\r\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\r\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\r\n/** @typedef {import(\"./Compilation\")} Compilation */\r\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\r\n/** @typedef {import(\"./Compilation\").PathData} PathData */\r\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\r\n/** @typedef {import(\"./util/Hash\")} Hash */\r\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\r\n\r\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\r\n\r\n/**\r\n * @typedef {Object} WithId an object who has an id property *\r\n * @property {string | number} id the id of the object\r\n */\r\n\r\n/**\r\n * @deprecated\r\n * @typedef {Object} ChunkMaps\r\n * @property {Record<string|number, string>} hash\r\n * @property {Record<string|number, Record<string, string>>} contentHash\r\n * @property {Record<string|number, string>} name\r\n */\r\n\r\n/**\r\n * @deprecated\r\n * @typedef {Object} ChunkModuleMaps\r\n * @property {Record<string|number, (string|number)[]>} id\r\n * @property {Record<string|number, string>} hash\r\n */\r\n\r\nlet debugId = 1000;\r\n\r\n/**\r\n * A Chunk is a unit of encapsulation for Modules.\r\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\r\n */\r\nclass Chunk {\r\n\t/**\r\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\r\n\t * @param {boolean} backCompat enable backward-compatibility\r\n\t */\r\n\tconstructor(name, backCompat = true) {\r\n\t\t/** @type {number | string | null} */\r\n\t\tthis.id = null;\r\n\t\t/** @type {(number|string)[] | null} */\r\n\t\tthis.ids = null;\r\n\t\t/** @type {number} */\r\n\t\tthis.debugId = debugId++;\r\n\t\t/** @type {string} */\r\n\t\tthis.name = name;\r\n\t\t/** @type {SortableSet<string>} */\r\n\t\tthis.idNameHints = new SortableSet();\r\n\t\t/** @type {boolean} */\r\n\t\tthis.preventIntegration = false;\r\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\r\n\t\tthis.filenameTemplate = undefined;\r\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\r\n\t\tthis.cssFilenameTemplate = undefined;\r\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\r\n\t\tthis._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\r\n\t\t/** @type {RuntimeSpec} */\r\n\t\tthis.runtime = undefined;\r\n\t\t/** @type {Set<string>} */\r\n\t\tthis.files = backCompat ? new ChunkFilesSet() : new Set();\r\n\t\t/** @type {Set<string>} */\r\n\t\tthis.auxiliaryFiles = new Set();\r\n\t\t/** @type {boolean} */\r\n\t\tthis.rendered = false;\r\n\t\t/** @type {string=} */\r\n\t\tthis.hash = undefined;\r\n\t\t/** @type {Record<string, string>} */\r\n\t\tthis.contentHash = Object.create(null);\r\n\t\t/** @type {string=} */\r\n\t\tthis.renderedHash = undefined;\r\n\t\t/** @type {string=} */\r\n\t\tthis.chunkReason = undefined;\r\n\t\t/** @type {boolean} */\r\n\t\tthis.extraAsync = false;\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t// BACKWARD-COMPAT START\r\n\tget entryModule() {\r\n\t\tconst entryModules = Array.from(\r\n\t\t\tChunkGraph.getChunkGraphForChunk(\r\n\t\t\t\tthis,\r\n\t\t\t\t\"Chunk.entryModule\",\r\n\t\t\t\t\"DEP_WEBPACK_CHUNK_ENTRY_MODULE\"\r\n\t\t\t).getChunkEntryModulesIterable(this)\r\n\t\t);\r\n\t\tif (entryModules.length === 0) {\r\n\t\t\treturn undefined;\r\n\t\t} else if (entryModules.length === 1) {\r\n\t\t\treturn entryModules[0];\r\n\t\t} else {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\"\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {boolean} true, if the chunk contains an entry module\r\n\t */\r\n\thasEntryModule() {\r\n\t\treturn (\r\n\t\t\tChunkGraph.getChunkGraphForChunk(\r\n\t\t\t\tthis,\r\n\t\t\t\t\"Chunk.hasEntryModule\",\r\n\t\t\t\t\"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\"\r\n\t\t\t).getNumberOfEntryModules(this) > 0\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {boolean} true, if the chunk could be added\r\n\t */\r\n\taddModule(module) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.addModule\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_ADD_MODULE\"\r\n\t\t);\r\n\t\tif (chunkGraph.isModuleInChunk(module, this)) return false;\r\n\t\tchunkGraph.connectChunkAndModule(this, module);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {void}\r\n\t */\r\n\tremoveModule(module) {\r\n\t\tChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.removeModule\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE_MODULE\"\r\n\t\t).disconnectChunkAndModule(this, module);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} the number of module which are contained in this chunk\r\n\t */\r\n\tgetNumberOfModules() {\r\n\t\treturn ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.getNumberOfModules\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\"\r\n\t\t).getNumberOfChunkModules(this);\r\n\t}\r\n\r\n\tget modulesIterable() {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.modulesIterable\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\"\r\n\t\t);\r\n\t\treturn chunkGraph.getOrderedChunkModulesIterable(\r\n\t\t\tthis,\r\n\t\t\tcompareModulesByIdentifier\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} otherChunk the chunk to compare with\r\n\t * @returns {-1|0|1} the comparison result\r\n\t */\r\n\tcompareTo(otherChunk) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.compareTo\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_COMPARE_TO\"\r\n\t\t);\r\n\t\treturn chunkGraph.compareChunks(this, otherChunk);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {boolean} true, if the chunk contains the module\r\n\t */\r\n\tcontainsModule(module) {\r\n\t\treturn ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.containsModule\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\"\r\n\t\t).isModuleInChunk(module, this);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Module[]} the modules for this chunk\r\n\t */\r\n\tgetModules() {\r\n\t\treturn ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.getModules\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_MODULES\"\r\n\t\t).getChunkModules(this);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void}\r\n\t */\r\n\tremove() {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.remove\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE\"\r\n\t\t);\r\n\t\tchunkGraph.disconnectChunk(this);\r\n\t\tthis.disconnectFromGroups();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {Chunk} otherChunk the target chunk\r\n\t * @returns {void}\r\n\t */\r\n\tmoveModule(module, otherChunk) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.moveModule\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_MOVE_MODULE\"\r\n\t\t);\r\n\t\tchunkGraph.disconnectChunkAndModule(this, module);\r\n\t\tchunkGraph.connectChunkAndModule(otherChunk, module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} otherChunk the other chunk\r\n\t * @returns {boolean} true, if the specified chunk has been integrated\r\n\t */\r\n\tintegrate(otherChunk) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.integrate\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATE\"\r\n\t\t);\r\n\t\tif (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\r\n\t\t\tchunkGraph.integrateChunks(this, otherChunk);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} otherChunk the other chunk\r\n\t * @returns {boolean} true, if chunks could be integrated\r\n\t */\r\n\tcanBeIntegrated(otherChunk) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.canBeIntegrated\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\"\r\n\t\t);\r\n\t\treturn chunkGraph.canChunksBeIntegrated(this, otherChunk);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {boolean} true, if this chunk contains no module\r\n\t */\r\n\tisEmpty() {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.isEmpty\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_IS_EMPTY\"\r\n\t\t);\r\n\t\treturn chunkGraph.getNumberOfChunkModules(this) === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} total size of all modules in this chunk\r\n\t */\r\n\tmodulesSize() {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.modulesSize\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_SIZE\"\r\n\t\t);\r\n\t\treturn chunkGraph.getChunkModulesSize(this);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkSizeOptions} options options object\r\n\t * @returns {number} total size of this chunk\r\n\t */\r\n\tsize(options = {}) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.size\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_SIZE\"\r\n\t\t);\r\n\t\treturn chunkGraph.getChunkSize(this, options);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} otherChunk the other chunk\r\n\t * @param {ChunkSizeOptions} options options object\r\n\t * @returns {number} total size of the chunk or false if the chunk can't be integrated\r\n\t */\r\n\tintegratedSize(otherChunk, options) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.integratedSize\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\"\r\n\t\t);\r\n\t\treturn chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\r\n\t * @returns {ChunkModuleMaps} module map information\r\n\t */\r\n\tgetChunkModuleMaps(filterFn) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.getChunkModuleMaps\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\"\r\n\t\t);\r\n\t\t/** @type {Record<string|number, (string|number)[]>} */\r\n\t\tconst chunkModuleIdMap = Object.create(null);\r\n\t\t/** @type {Record<string|number, string>} */\r\n\t\tconst chunkModuleHashMap = Object.create(null);\r\n\r\n\t\tfor (const asyncChunk of this.getAllAsyncChunks()) {\r\n\t\t\t/** @type {(string|number)[]} */\r\n\t\t\tlet array;\r\n\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\r\n\t\t\t\tasyncChunk,\r\n\t\t\t\tcompareModulesById(chunkGraph)\r\n\t\t\t)) {\r\n\t\t\t\tif (filterFn(module)) {\r\n\t\t\t\t\tif (array === undefined) {\r\n\t\t\t\t\t\tarray = [];\r\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\r\n\t\t\t\t\tarray.push(moduleId);\r\n\t\t\t\t\tchunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\tundefined\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tid: chunkModuleIdMap,\r\n\t\t\thash: chunkModuleHashMap\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\r\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\r\n\t * @returns {boolean} return true if module exists in graph\r\n\t */\r\n\thasModuleInGraph(filterFn, filterChunkFn) {\r\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\r\n\t\t\tthis,\r\n\t\t\t\"Chunk.hasModuleInGraph\",\r\n\t\t\t\"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\"\r\n\t\t);\r\n\t\treturn chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * @param {boolean} realHash whether the full hash or the rendered hash is to be used\r\n\t * @returns {ChunkMaps} the chunk map information\r\n\t */\r\n\tgetChunkMaps(realHash) {\r\n\t\t/** @type {Record<string|number, string>} */\r\n\t\tconst chunkHashMap = Object.create(null);\r\n\t\t/** @type {Record<string|number, Record<string, string>>} */\r\n\t\tconst chunkContentHashMap = Object.create(null);\r\n\t\t/** @type {Record<string|number, string>} */\r\n\t\tconst chunkNameMap = Object.create(null);\r\n\r\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\r\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\r\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\r\n\t\t\t\tif (!chunkContentHashMap[key]) {\r\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\r\n\t\t\t\t}\r\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\r\n\t\t\t}\r\n\t\t\tif (chunk.name) {\r\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\thash: chunkHashMap,\r\n\t\t\tcontentHash: chunkContentHashMap,\r\n\t\t\tname: chunkNameMap\r\n\t\t};\r\n\t}\r\n\t// BACKWARD-COMPAT END\r\n\r\n\t/**\r\n\t * @returns {boolean} whether or not the Chunk will have a runtime\r\n\t */\r\n\thasRuntime() {\r\n\t\tfor (const chunkGroup of this._groups) {\r\n\t\t\tif (\r\n\t\t\t\tchunkGroup instanceof Entrypoint &&\r\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\r\n\t\t\t) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\r\n\t */\r\n\tcanBeInitial() {\r\n\t\tfor (const chunkGroup of this._groups) {\r\n\t\t\tif (chunkGroup.isInitial()) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {boolean} whether this chunk can only be an initial chunk\r\n\t */\r\n\tisOnlyInitial() {\r\n\t\tif (this._groups.size <= 0) return false;\r\n\t\tfor (const chunkGroup of this._groups) {\r\n\t\t\tif (!chunkGroup.isInitial()) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {EntryOptions | undefined} the entry options for this chunk\r\n\t */\r\n\tgetEntryOptions() {\r\n\t\tfor (const chunkGroup of this._groups) {\r\n\t\t\tif (chunkGroup instanceof Entrypoint) {\r\n\t\t\t\treturn chunkGroup.options;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\r\n\t * @returns {void}\r\n\t */\r\n\taddGroup(chunkGroup) {\r\n\t\tthis._groups.add(chunkGroup);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\r\n\t * @returns {void}\r\n\t */\r\n\tremoveGroup(chunkGroup) {\r\n\t\tthis._groups.delete(chunkGroup);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\r\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\r\n\t */\r\n\tisInGroup(chunkGroup) {\r\n\t\treturn this._groups.has(chunkGroup);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} the amount of groups that the said chunk is in\r\n\t */\r\n\tgetNumberOfGroups() {\r\n\t\treturn this._groups.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\r\n\t */\r\n\tget groupsIterable() {\r\n\t\tthis._groups.sort();\r\n\t\treturn this._groups;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectFromGroups() {\r\n\t\tfor (const chunkGroup of this._groups) {\r\n\t\t\tchunkGroup.removeChunk(this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} newChunk the new chunk that will be split out of\r\n\t * @returns {void}\r\n\t */\r\n\tsplit(newChunk) {\r\n\t\tfor (const chunkGroup of this._groups) {\r\n\t\t\tchunkGroup.insertChunk(newChunk, this);\r\n\t\t\tnewChunk.addGroup(chunkGroup);\r\n\t\t}\r\n\t\tfor (const idHint of this.idNameHints) {\r\n\t\t\tnewChunk.idNameHints.add(idHint);\r\n\t\t}\r\n\t\tnewChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Hash} hash hash (will be modified)\r\n\t * @param {ChunkGraph} chunkGraph the chunk graph\r\n\t * @returns {void}\r\n\t */\r\n\tupdateHash(hash, chunkGraph) {\r\n\t\thash.update(\r\n\t\t\t`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `\r\n\t\t);\r\n\t\tconst xor = new StringXor();\r\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(this)) {\r\n\t\t\txor.add(chunkGraph.getModuleHash(m, this.runtime));\r\n\t\t}\r\n\t\txor.updateHash(hash);\r\n\t\tconst entryModules =\r\n\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\r\n\t\tfor (const [m, chunkGroup] of entryModules) {\r\n\t\t\thash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Set<Chunk>} a set of all the async chunks\r\n\t */\r\n\tgetAllAsyncChunks() {\r\n\t\tconst queue = new Set();\r\n\t\tconst chunks = new Set();\r\n\r\n\t\tconst initialChunks = intersect(\r\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\r\n\t\t);\r\n\r\n\t\tconst initialQueue = new Set(this.groupsIterable);\r\n\r\n\t\tfor (const chunkGroup of initialQueue) {\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tif (child instanceof Entrypoint) {\r\n\t\t\t\t\tinitialQueue.add(child);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tqueue.add(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const chunkGroup of queue) {\r\n\t\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\t\tif (!initialChunks.has(chunk)) {\r\n\t\t\t\t\tchunks.add(chunk);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tqueue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chunks;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\r\n\t */\r\n\tgetAllInitialChunks() {\r\n\t\tconst chunks = new Set();\r\n\t\tconst queue = new Set(this.groupsIterable);\r\n\t\tfor (const group of queue) {\r\n\t\t\tif (group.isInitial()) {\r\n\t\t\t\tfor (const c of group.chunks) chunks.add(c);\r\n\t\t\t\tfor (const g of group.childrenIterable) queue.add(g);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn chunks;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\r\n\t */\r\n\tgetAllReferencedChunks() {\r\n\t\tconst queue = new Set(this.groupsIterable);\r\n\t\tconst chunks = new Set();\r\n\r\n\t\tfor (const chunkGroup of queue) {\r\n\t\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\t\tchunks.add(chunk);\r\n\t\t\t}\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tqueue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chunks;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\r\n\t */\r\n\tgetAllReferencedAsyncEntrypoints() {\r\n\t\tconst queue = new Set(this.groupsIterable);\r\n\t\tconst entrypoints = new Set();\r\n\r\n\t\tfor (const chunkGroup of queue) {\r\n\t\t\tfor (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\r\n\t\t\t\tentrypoints.add(entrypoint);\r\n\t\t\t}\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tqueue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn entrypoints;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {boolean} true, if the chunk references async chunks\r\n\t */\r\n\thasAsyncChunks() {\r\n\t\tconst queue = new Set();\r\n\r\n\t\tconst initialChunks = intersect(\r\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\r\n\t\t);\r\n\r\n\t\tfor (const chunkGroup of this.groupsIterable) {\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tqueue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const chunkGroup of queue) {\r\n\t\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\t\tif (!initialChunks.has(chunk)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tqueue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGraph} chunkGraph the chunk graph\r\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\r\n\t * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\r\n\t */\r\n\tgetChildIdsByOrders(chunkGraph, filterFn) {\r\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\r\n\t\tconst lists = new Map();\r\n\t\tfor (const group of this.groupsIterable) {\r\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\r\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\r\n\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\r\n\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\r\n\t\t\t\t\t\t\tconst name = key.slice(0, key.length - \"Order\".length);\r\n\t\t\t\t\t\t\tlet list = lists.get(name);\r\n\t\t\t\t\t\t\tif (list === undefined) {\r\n\t\t\t\t\t\t\t\tlist = [];\r\n\t\t\t\t\t\t\t\tlists.set(name, list);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tlist.push({\r\n\t\t\t\t\t\t\t\torder: childGroup.options[key],\r\n\t\t\t\t\t\t\t\tgroup: childGroup\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t/** @type {Record<string, (string | number)[]>} */\r\n\t\tconst result = Object.create(null);\r\n\t\tfor (const [name, list] of lists) {\r\n\t\t\tlist.sort((a, b) => {\r\n\t\t\t\tconst cmp = b.order - a.order;\r\n\t\t\t\tif (cmp !== 0) return cmp;\r\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\r\n\t\t\t});\r\n\t\t\t/** @type {Set<string | number>} */\r\n\t\t\tconst chunkIdSet = new Set();\r\n\t\t\tfor (const item of list) {\r\n\t\t\t\tfor (const chunk of item.group.chunks) {\r\n\t\t\t\t\tif (filterFn && !filterFn(chunk, chunkGraph)) continue;\r\n\t\t\t\t\tchunkIdSet.add(chunk.id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (chunkIdSet.size > 0) {\r\n\t\t\t\tresult[name] = Array.from(chunkIdSet);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGraph} chunkGraph the chunk graph\r\n\t * @param {string} type option name\r\n\t * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\r\n\t */\r\n\tgetChildrenOfTypeInOrder(chunkGraph, type) {\r\n\t\tconst list = [];\r\n\t\tfor (const group of this.groupsIterable) {\r\n\t\t\tfor (const childGroup of group.childrenIterable) {\r\n\t\t\t\tconst order = childGroup.options[type];\r\n\t\t\t\tif (order === undefined) continue;\r\n\t\t\t\tlist.push({\r\n\t\t\t\t\torder,\r\n\t\t\t\t\tgroup,\r\n\t\t\t\t\tchildGroup\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (list.length === 0) return undefined;\r\n\t\tlist.sort((a, b) => {\r\n\t\t\tconst cmp = b.order - a.order;\r\n\t\t\tif (cmp !== 0) return cmp;\r\n\t\t\treturn a.group.compareTo(chunkGraph, b.group);\r\n\t\t});\r\n\t\tconst result = [];\r\n\t\tlet lastEntry;\r\n\t\tfor (const { group, childGroup } of list) {\r\n\t\t\tif (lastEntry && lastEntry.onChunks === group.chunks) {\r\n\t\t\t\tfor (const chunk of childGroup.chunks) {\r\n\t\t\t\t\tlastEntry.chunks.add(chunk);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(\r\n\t\t\t\t\t(lastEntry = {\r\n\t\t\t\t\t\tonChunks: group.chunks,\r\n\t\t\t\t\t\tchunks: new Set(childGroup.chunks)\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGraph} chunkGraph the chunk graph\r\n\t * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\r\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\r\n\t * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\r\n\t */\r\n\tgetChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\r\n\t\t/** @type {Record<string|number, Record<string, (string | number)[]>>} */\r\n\t\tconst chunkMaps = Object.create(null);\r\n\r\n\t\t/**\r\n\t\t * @param {Chunk} chunk a chunk\r\n\t\t * @returns {void}\r\n\t\t */\r\n\t\tconst addChildIdsByOrdersToMap = chunk => {\r\n\t\t\tconst data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\r\n\t\t\tfor (const key of Object.keys(data)) {\r\n\t\t\t\tlet chunkMap = chunkMaps[key];\r\n\t\t\t\tif (chunkMap === undefined) {\r\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\r\n\t\t\t\t}\r\n\t\t\t\tchunkMap[chunk.id] = data[key];\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif (includeDirectChildren) {\r\n\t\t\t/** @type {Set<Chunk>} */\r\n\t\t\tconst chunks = new Set();\r\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\r\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\t\t\tchunks.add(chunk);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (const chunk of chunks) {\r\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\r\n\t\t\taddChildIdsByOrdersToMap(chunk);\r\n\t\t}\r\n\r\n\t\treturn chunkMaps;\r\n\t}\r\n}\r\n\r\nmodule.exports = Chunk;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}