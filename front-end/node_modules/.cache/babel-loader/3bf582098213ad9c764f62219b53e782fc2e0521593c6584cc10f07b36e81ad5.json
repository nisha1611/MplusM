{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\r\n * Handles internal casting for query filters.\r\n *\r\n * @param {Schema} schema\r\n * @param {Object} obj Object to cast\r\n * @param {Object} [options] the query options\r\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\r\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\r\n * @param {Boolean} [options.upsert]\r\n * @param {Query} [context] passed to setters\r\n * @api private\r\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n  if (obj == null) {\n    return obj;\n  }\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n  options = options || {};\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        val[k] = cast(schema, val[k], options, context);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            if (discriminatorVal != null) {\n              schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);\n            }\n          }\n        }\n      }\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQueryWrapper({\n                val: val.$maxDistance,\n                context: context\n              });\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQueryWrapper({\n                val: val.$minDistance,\n                context: context\n              });\n            }\n            if (geo === '$within') {\n              const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQueryWrapper({\n                  val: value.$maxDistance,\n                  context: context\n                });\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQueryWrapper({\n                  val: value.$minDistance,\n                  context: context\n                });\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n        if (schema.nested[path]) {\n          continue;\n        }\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        }\n        if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (getConstructorName(val) === 'Object') {\n        any$conditionals = Object.keys(val).some(isOperator);\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQueryWrapper({\n            val: val,\n            context: context\n          });\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQueryWrapper({\n                      $conditional: key,\n                      val: nested[key],\n                      context: context\n                    });\n                  }\n                } else {\n                  val[$cond] = schematype.castForQueryWrapper({\n                    $conditional: $cond,\n                    val: nested,\n                    context: context\n                  });\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQueryWrapper({\n                $conditional: $cond,\n                val: nested,\n                context: context\n              });\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQueryWrapper({\n            val: _val,\n            context: context\n          }));\n        }\n        obj[path] = {\n          $in: casted\n        };\n      } else {\n        obj[path] = schematype.castForQueryWrapper({\n          val: val,\n          context: context\n        });\n      }\n    }\n  }\n  return obj;\n};\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQueryWrapper({\n        val: item,\n        context: context\n      });\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({\n          val: item,\n          context: context\n        });\n      }\n    }\n  }\n}\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strict' in queryOptions) {\n    return queryOptions.strict;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  if ('strict' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strict;\n  }\n  const mongooseOptions = context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n    if ('strict' in mongooseOptions) {\n      return mongooseOptions.strict;\n    }\n  }\n  return schemaOptions.strictQuery;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","Types","cast$expr","castTextSearch","get","getConstructorName","getSchemaDiscriminatorByValue","isOperator","util","isObject","isMongooseObject","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","context","Array","isArray","Error","inspect","discriminators","discriminatorKey","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","toString","split","j","pathFirstHalf","slice","join","pathLastHalf","_schematype","discriminatorVal","remainingConds","caster","ret","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQueryWrapper","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","coordinates","$geometry","toObject","transform","virtuals","geoWithinType","indexOf","_cast","strict","strictQuery","getStrictQuery","_userProvidedOptions","upsert","some","ks","$cond","key","$conditional","instance","casted","valuesArray","_val","push","$in","forEach","item","nearKeys","nearLen","nkey","castForQuery","queryOptions","schemaUserProvidedOptions","schemaOptions","mongooseOptions","mongooseCollection","conn","base"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/cast.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst CastError = require('./error/cast');\r\nconst StrictModeError = require('./error/strict');\r\nconst Types = require('./schema/index');\r\nconst cast$expr = require('./helpers/query/cast$expr');\r\nconst castTextSearch = require('./schema/operators/text');\r\nconst get = require('./helpers/get');\r\nconst getConstructorName = require('./helpers/getConstructorName');\r\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\r\nconst isOperator = require('./helpers/query/isOperator');\r\nconst util = require('util');\r\nconst isObject = require('./helpers/isObject');\r\nconst isMongooseObject = require('./helpers/isMongooseObject');\r\n\r\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\r\n\r\n/**\r\n * Handles internal casting for query filters.\r\n *\r\n * @param {Schema} schema\r\n * @param {Object} obj Object to cast\r\n * @param {Object} [options] the query options\r\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\r\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\r\n * @param {Boolean} [options.upsert]\r\n * @param {Query} [context] passed to setters\r\n * @api private\r\n */\r\nmodule.exports = function cast(schema, obj, options, context) {\r\n  if (Array.isArray(obj)) {\r\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\r\n  }\r\n\r\n  if (obj == null) {\r\n    return obj;\r\n  }\r\n\r\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\r\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\r\n  }\r\n\r\n  const paths = Object.keys(obj);\r\n  let i = paths.length;\r\n  let _keys;\r\n  let any$conditionals;\r\n  let schematype;\r\n  let nested;\r\n  let path;\r\n  let type;\r\n  let val;\r\n\r\n  options = options || {};\r\n\r\n  while (i--) {\r\n    path = paths[i];\r\n    val = obj[path];\r\n\r\n    if (path === '$or' || path === '$nor' || path === '$and') {\r\n      if (!Array.isArray(val)) {\r\n        throw new CastError('Array', val, path);\r\n      }\r\n      for (let k = 0; k < val.length; ++k) {\r\n        if (val[k] == null || typeof val[k] !== 'object') {\r\n          throw new CastError('Object', val[k], path + '.' + k);\r\n        }\r\n        val[k] = cast(schema, val[k], options, context);\r\n      }\r\n    } else if (path === '$where') {\r\n      type = typeof val;\r\n\r\n      if (type !== 'string' && type !== 'function') {\r\n        throw new Error('Must have a string or function for $where');\r\n      }\r\n\r\n      if (type === 'function') {\r\n        obj[path] = val.toString();\r\n      }\r\n\r\n      continue;\r\n    } else if (path === '$expr') {\r\n      val = cast$expr(val, schema);\r\n      continue;\r\n    } else if (path === '$elemMatch') {\r\n      val = cast(schema, val, options, context);\r\n    } else if (path === '$text') {\r\n      val = castTextSearch(val, path);\r\n    } else {\r\n      if (!schema) {\r\n        // no casting for Mixed types\r\n        continue;\r\n      }\r\n\r\n      schematype = schema.path(path);\r\n\r\n      // Check for embedded discriminator paths\r\n      if (!schematype) {\r\n        const split = path.split('.');\r\n        let j = split.length;\r\n        while (j--) {\r\n          const pathFirstHalf = split.slice(0, j).join('.');\r\n          const pathLastHalf = split.slice(j).join('.');\r\n          const _schematype = schema.path(pathFirstHalf);\r\n          const discriminatorKey = _schematype &&\r\n            _schematype.schema &&\r\n            _schematype.schema.options &&\r\n            _schematype.schema.options.discriminatorKey;\r\n\r\n          // gh-6027: if we haven't found the schematype but this path is\r\n          // underneath an embedded discriminator and the embedded discriminator\r\n          // key is in the query, use the embedded discriminator schema\r\n          if (_schematype != null &&\r\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\r\n            discriminatorKey != null &&\r\n            pathLastHalf !== discriminatorKey) {\r\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\r\n            if (discriminatorVal != null) {\r\n              schematype = _schematype.schema.discriminators[discriminatorVal].\r\n                path(pathLastHalf);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!schematype) {\r\n        // Handle potential embedded array queries\r\n        const split = path.split('.');\r\n        let j = split.length;\r\n        let pathFirstHalf;\r\n        let pathLastHalf;\r\n        let remainingConds;\r\n\r\n        // Find the part of the var path that is a path of the Schema\r\n        while (j--) {\r\n          pathFirstHalf = split.slice(0, j).join('.');\r\n          schematype = schema.path(pathFirstHalf);\r\n          if (schematype) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // If a substring of the input path resolves to an actual real path...\r\n        if (schematype) {\r\n          // Apply the casting; similar code for $elemMatch in schema/array.js\r\n          if (schematype.caster && schematype.caster.schema) {\r\n            remainingConds = {};\r\n            pathLastHalf = split.slice(j).join('.');\r\n            remainingConds[pathLastHalf] = val;\r\n\r\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\r\n            if (ret === void 0) {\r\n              delete obj[path];\r\n            } else {\r\n              obj[path] = ret;\r\n            }\r\n          } else {\r\n            obj[path] = val;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        if (isObject(val)) {\r\n          // handle geo schemas that use object notation\r\n          // { loc: { long: Number, lat: Number }\r\n\r\n          let geo = '';\r\n          if (val.$near) {\r\n            geo = '$near';\r\n          } else if (val.$nearSphere) {\r\n            geo = '$nearSphere';\r\n          } else if (val.$within) {\r\n            geo = '$within';\r\n          } else if (val.$geoIntersects) {\r\n            geo = '$geoIntersects';\r\n          } else if (val.$geoWithin) {\r\n            geo = '$geoWithin';\r\n          }\r\n\r\n          if (geo) {\r\n            const numbertype = new Types.Number('__QueryCasting__');\r\n            let value = val[geo];\r\n\r\n            if (val.$maxDistance != null) {\r\n              val.$maxDistance = numbertype.castForQueryWrapper({\r\n                val: val.$maxDistance,\r\n                context: context\r\n              });\r\n            }\r\n            if (val.$minDistance != null) {\r\n              val.$minDistance = numbertype.castForQueryWrapper({\r\n                val: val.$minDistance,\r\n                context: context\r\n              });\r\n            }\r\n\r\n            if (geo === '$within') {\r\n              const withinType = value.$center\r\n                  || value.$centerSphere\r\n                  || value.$box\r\n                  || value.$polygon;\r\n\r\n              if (!withinType) {\r\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\r\n              }\r\n\r\n              value = withinType;\r\n            } else if (geo === '$near' &&\r\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\r\n              // geojson; cast the coordinates\r\n              value = value.coordinates;\r\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\r\n                value.$geometry && typeof value.$geometry.type === 'string' &&\r\n                Array.isArray(value.$geometry.coordinates)) {\r\n              if (value.$maxDistance != null) {\r\n                value.$maxDistance = numbertype.castForQueryWrapper({\r\n                  val: value.$maxDistance,\r\n                  context: context\r\n                });\r\n              }\r\n              if (value.$minDistance != null) {\r\n                value.$minDistance = numbertype.castForQueryWrapper({\r\n                  val: value.$minDistance,\r\n                  context: context\r\n                });\r\n              }\r\n              if (isMongooseObject(value.$geometry)) {\r\n                value.$geometry = value.$geometry.toObject({\r\n                  transform: false,\r\n                  virtuals: false\r\n                });\r\n              }\r\n              value = value.$geometry.coordinates;\r\n            } else if (geo === '$geoWithin') {\r\n              if (value.$geometry) {\r\n                if (isMongooseObject(value.$geometry)) {\r\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\r\n                }\r\n                const geoWithinType = value.$geometry.type;\r\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\r\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\r\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\r\n                }\r\n                value = value.$geometry.coordinates;\r\n              } else {\r\n                value = value.$box || value.$polygon || value.$center ||\r\n                  value.$centerSphere;\r\n                if (isMongooseObject(value)) {\r\n                  value = value.toObject({ virtuals: false });\r\n                }\r\n              }\r\n            }\r\n\r\n            _cast(value, numbertype, context);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        if (schema.nested[path]) {\r\n          continue;\r\n        }\r\n\r\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\r\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\r\n        if (options.upsert && strict) {\r\n          if (strict === 'throw') {\r\n            throw new StrictModeError(path);\r\n          }\r\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\r\n            'schema, strict mode is `true`, and upsert is `true`.');\r\n        } if (strictQuery === 'throw') {\r\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\r\n            'schema and strictQuery is \\'throw\\'.');\r\n        } else if (strictQuery) {\r\n          delete obj[path];\r\n        }\r\n      } else if (val == null) {\r\n        continue;\r\n      } else if (getConstructorName(val) === 'Object') {\r\n        any$conditionals = Object.keys(val).some(isOperator);\r\n\r\n        if (!any$conditionals) {\r\n          obj[path] = schematype.castForQueryWrapper({\r\n            val: val,\r\n            context: context\r\n          });\r\n        } else {\r\n          const ks = Object.keys(val);\r\n          let $cond;\r\n\r\n          let k = ks.length;\r\n\r\n          while (k--) {\r\n            $cond = ks[k];\r\n            nested = val[$cond];\r\n\r\n            if ($cond === '$not') {\r\n              if (nested && schematype) {\r\n                _keys = Object.keys(nested);\r\n                if (_keys.length && isOperator(_keys[0])) {\r\n                  for (const key in nested) {\r\n                    nested[key] = schematype.castForQueryWrapper({\r\n                      $conditional: key,\r\n                      val: nested[key],\r\n                      context: context\r\n                    });\r\n                  }\r\n                } else {\r\n                  val[$cond] = schematype.castForQueryWrapper({\r\n                    $conditional: $cond,\r\n                    val: nested,\r\n                    context: context\r\n                  });\r\n                }\r\n                continue;\r\n              }\r\n            } else {\r\n              val[$cond] = schematype.castForQueryWrapper({\r\n                $conditional: $cond,\r\n                val: nested,\r\n                context: context\r\n              });\r\n            }\r\n          }\r\n        }\r\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\r\n        const casted = [];\r\n        const valuesArray = val;\r\n\r\n        for (const _val of valuesArray) {\r\n          casted.push(schematype.castForQueryWrapper({\r\n            val: _val,\r\n            context: context\r\n          }));\r\n        }\r\n\r\n        obj[path] = { $in: casted };\r\n      } else {\r\n        obj[path] = schematype.castForQueryWrapper({\r\n          val: val,\r\n          context: context\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nfunction _cast(val, numbertype, context) {\r\n  if (Array.isArray(val)) {\r\n    val.forEach(function(item, i) {\r\n      if (Array.isArray(item) || isObject(item)) {\r\n        return _cast(item, numbertype, context);\r\n      }\r\n      val[i] = numbertype.castForQueryWrapper({ val: item, context: context });\r\n    });\r\n  } else {\r\n    const nearKeys = Object.keys(val);\r\n    let nearLen = nearKeys.length;\r\n    while (nearLen--) {\r\n      const nkey = nearKeys[nearLen];\r\n      const item = val[nkey];\r\n      if (Array.isArray(item) || isObject(item)) {\r\n        _cast(item, numbertype, context);\r\n        val[nkey] = item;\r\n      } else {\r\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\r\n  if ('strictQuery' in queryOptions) {\r\n    return queryOptions.strictQuery;\r\n  }\r\n  if ('strict' in queryOptions) {\r\n    return queryOptions.strict;\r\n  }\r\n  if ('strictQuery' in schemaUserProvidedOptions) {\r\n    return schemaUserProvidedOptions.strictQuery;\r\n  }\r\n  if ('strict' in schemaUserProvidedOptions) {\r\n    return schemaUserProvidedOptions.strict;\r\n  }\r\n  const mongooseOptions = context.mongooseCollection &&\r\n    context.mongooseCollection.conn &&\r\n    context.mongooseCollection.conn.base &&\r\n    context.mongooseCollection.conn.base.options;\r\n  if (mongooseOptions) {\r\n    if ('strictQuery' in mongooseOptions) {\r\n      return mongooseOptions.strictQuery;\r\n    }\r\n    if ('strict' in mongooseOptions) {\r\n      return mongooseOptions.strict;\r\n    }\r\n  }\r\n  return schemaOptions.strictQuery;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}