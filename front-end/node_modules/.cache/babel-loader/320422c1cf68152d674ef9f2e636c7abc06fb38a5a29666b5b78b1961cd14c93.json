{"ast":null,"code":"import { GetRoleCredentialsCommand, SSOClient } from \"@aws-sdk/client-sso\";\nimport { CredentialsProviderError } from \"@aws-sdk/property-provider\";\nimport { getSSOTokenFromFile } from \"@aws-sdk/shared-ini-file-loader\";\nimport { fromSso as getSsoTokenProvider } from \"@aws-sdk/token-providers\";\nconst EXPIRE_WINDOW_MS = 15 * 60 * 1000;\nconst SHOULD_FAIL_CREDENTIAL_CHAIN = false;\nexport const resolveSSOCredentials = async _ref => {\n  let {\n    ssoStartUrl,\n    ssoSession,\n    ssoAccountId,\n    ssoRegion,\n    ssoRoleName,\n    ssoClient,\n    profile\n  } = _ref;\n  let token;\n  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;\n  if (ssoSession) {\n    try {\n      const _token = await getSsoTokenProvider({\n        profile\n      })();\n      token = {\n        accessToken: _token.token,\n        expiresAt: new Date(_token.expiration).toISOString()\n      };\n    } catch (e) {\n      throw new CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);\n    }\n  } else {\n    try {\n      token = await getSSOTokenFromFile(ssoStartUrl);\n    } catch (e) {\n      throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);\n    }\n  }\n  if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {\n    throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);\n  }\n  const {\n    accessToken\n  } = token;\n  const sso = ssoClient || new SSOClient({\n    region: ssoRegion\n  });\n  let ssoResp;\n  try {\n    ssoResp = await sso.send(new GetRoleCredentialsCommand({\n      accountId: ssoAccountId,\n      roleName: ssoRoleName,\n      accessToken\n    }));\n  } catch (e) {\n    throw CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);\n  }\n  const {\n    roleCredentials: {\n      accessKeyId,\n      secretAccessKey,\n      sessionToken,\n      expiration\n    } = {}\n  } = ssoResp;\n  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {\n    throw new CredentialsProviderError(\"SSO returns an invalid temporary credential.\", SHOULD_FAIL_CREDENTIAL_CHAIN);\n  }\n  return {\n    accessKeyId,\n    secretAccessKey,\n    sessionToken,\n    expiration: new Date(expiration)\n  };\n};","map":{"version":3,"names":["GetRoleCredentialsCommand","SSOClient","CredentialsProviderError","getSSOTokenFromFile","fromSso","getSsoTokenProvider","EXPIRE_WINDOW_MS","SHOULD_FAIL_CREDENTIAL_CHAIN","resolveSSOCredentials","ssoStartUrl","ssoSession","ssoAccountId","ssoRegion","ssoRoleName","ssoClient","profile","token","refreshMessage","_token","accessToken","expiresAt","Date","expiration","toISOString","e","message","getTime","now","sso","region","ssoResp","send","accountId","roleName","from","roleCredentials","accessKeyId","secretAccessKey","sessionToken"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js"],"sourcesContent":["import { GetRoleCredentialsCommand, SSOClient } from \"@aws-sdk/client-sso\";\r\nimport { CredentialsProviderError } from \"@aws-sdk/property-provider\";\r\nimport { getSSOTokenFromFile } from \"@aws-sdk/shared-ini-file-loader\";\r\nimport { fromSso as getSsoTokenProvider } from \"@aws-sdk/token-providers\";\r\nconst EXPIRE_WINDOW_MS = 15 * 60 * 1000;\r\nconst SHOULD_FAIL_CREDENTIAL_CHAIN = false;\r\nexport const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile, }) => {\r\n    let token;\r\n    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;\r\n    if (ssoSession) {\r\n        try {\r\n            const _token = await getSsoTokenProvider({ profile })();\r\n            token = {\r\n                accessToken: _token.token,\r\n                expiresAt: new Date(_token.expiration).toISOString(),\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw new CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);\r\n        }\r\n    }\r\n    else {\r\n        try {\r\n            token = await getSSOTokenFromFile(ssoStartUrl);\r\n        }\r\n        catch (e) {\r\n            throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);\r\n        }\r\n    }\r\n    if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {\r\n        throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);\r\n    }\r\n    const { accessToken } = token;\r\n    const sso = ssoClient || new SSOClient({ region: ssoRegion });\r\n    let ssoResp;\r\n    try {\r\n        ssoResp = await sso.send(new GetRoleCredentialsCommand({\r\n            accountId: ssoAccountId,\r\n            roleName: ssoRoleName,\r\n            accessToken,\r\n        }));\r\n    }\r\n    catch (e) {\r\n        throw CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);\r\n    }\r\n    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;\r\n    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {\r\n        throw new CredentialsProviderError(\"SSO returns an invalid temporary credential.\", SHOULD_FAIL_CREDENTIAL_CHAIN);\r\n    }\r\n    return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };\r\n};\r\n"],"mappings":"AAAA,SAASA,yBAAyB,EAAEC,SAAS,QAAQ,qBAAqB;AAC1E,SAASC,wBAAwB,QAAQ,4BAA4B;AACrE,SAASC,mBAAmB,QAAQ,iCAAiC;AACrE,SAASC,OAAO,IAAIC,mBAAmB,QAAQ,0BAA0B;AACzE,MAAMC,gBAAgB,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;AACvC,MAAMC,4BAA4B,GAAG,KAAK;AAC1C,OAAO,MAAMC,qBAAqB,GAAG,cAAkG;EAAA,IAA3F;IAAEC,WAAW;IAAEC,UAAU;IAAEC,YAAY;IAAEC,SAAS;IAAEC,WAAW;IAAEC,SAAS;IAAEC;EAAS,CAAC;EAC9H,IAAIC,KAAK;EACT,MAAMC,cAAc,GAAI,+EAA8E;EACtG,IAAIP,UAAU,EAAE;IACZ,IAAI;MACA,MAAMQ,MAAM,GAAG,MAAMb,mBAAmB,CAAC;QAAEU;MAAQ,CAAC,CAAC,EAAE;MACvDC,KAAK,GAAG;QACJG,WAAW,EAAED,MAAM,CAACF,KAAK;QACzBI,SAAS,EAAE,IAAIC,IAAI,CAACH,MAAM,CAACI,UAAU,CAAC,CAACC,WAAW;MACtD,CAAC;IACL,CAAC,CACD,OAAOC,CAAC,EAAE;MACN,MAAM,IAAItB,wBAAwB,CAACsB,CAAC,CAACC,OAAO,EAAElB,4BAA4B,CAAC;IAC/E;EACJ,CAAC,MACI;IACD,IAAI;MACAS,KAAK,GAAG,MAAMb,mBAAmB,CAACM,WAAW,CAAC;IAClD,CAAC,CACD,OAAOe,CAAC,EAAE;MACN,MAAM,IAAItB,wBAAwB,CAAE,4DAA2De,cAAe,EAAC,EAAEV,4BAA4B,CAAC;IAClJ;EACJ;EACA,IAAI,IAAIc,IAAI,CAACL,KAAK,CAACI,SAAS,CAAC,CAACM,OAAO,EAAE,GAAGL,IAAI,CAACM,GAAG,EAAE,IAAIrB,gBAAgB,EAAE;IACtE,MAAM,IAAIJ,wBAAwB,CAAE,6DAA4De,cAAe,EAAC,EAAEV,4BAA4B,CAAC;EACnJ;EACA,MAAM;IAAEY;EAAY,CAAC,GAAGH,KAAK;EAC7B,MAAMY,GAAG,GAAGd,SAAS,IAAI,IAAIb,SAAS,CAAC;IAAE4B,MAAM,EAAEjB;EAAU,CAAC,CAAC;EAC7D,IAAIkB,OAAO;EACX,IAAI;IACAA,OAAO,GAAG,MAAMF,GAAG,CAACG,IAAI,CAAC,IAAI/B,yBAAyB,CAAC;MACnDgC,SAAS,EAAErB,YAAY;MACvBsB,QAAQ,EAAEpB,WAAW;MACrBM;IACJ,CAAC,CAAC,CAAC;EACP,CAAC,CACD,OAAOK,CAAC,EAAE;IACN,MAAMtB,wBAAwB,CAACgC,IAAI,CAACV,CAAC,EAAEjB,4BAA4B,CAAC;EACxE;EACA,MAAM;IAAE4B,eAAe,EAAE;MAAEC,WAAW;MAAEC,eAAe;MAAEC,YAAY;MAAEhB;IAAW,CAAC,GAAG,CAAC;EAAE,CAAC,GAAGQ,OAAO;EACpG,IAAI,CAACM,WAAW,IAAI,CAACC,eAAe,IAAI,CAACC,YAAY,IAAI,CAAChB,UAAU,EAAE;IAClE,MAAM,IAAIpB,wBAAwB,CAAC,8CAA8C,EAAEK,4BAA4B,CAAC;EACpH;EACA,OAAO;IAAE6B,WAAW;IAAEC,eAAe;IAAEC,YAAY;IAAEhB,UAAU,EAAE,IAAID,IAAI,CAACC,UAAU;EAAE,CAAC;AAC3F,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}