{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\nconst {\n  UsageState\n} = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  STAGE_DEFAULT\n} = require(\"./OptimizationStages\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\nconst TupleQueue = require(\"./util/TupleQueue\");\nconst {\n  getEntryRuntime,\n  mergeRuntimeOwned\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst {\n  NO_EXPORTS_REFERENCED,\n  EXPORTS_OBJECT_REFERENCED\n} = Dependency;\nclass FlagDependencyUsagePlugin {\n  /**\r\n   * @param {boolean} global do a global analysis instead of per runtime\r\n   */\n  constructor(global) {\n    this.global = global;\n  }\n\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler the compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.optimizeDependencies.tap({\n        name: \"FlagDependencyUsagePlugin\",\n        stage: STAGE_DEFAULT\n      }, modules => {\n        if (compilation.moduleMemCaches) {\n          throw new Error(\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\");\n        }\n        const logger = compilation.getLogger(\"webpack.FlagDependencyUsagePlugin\");\n        /** @type {Map<ExportsInfo, Module>} */\n        const exportInfoToModuleMap = new Map();\n\n        /** @type {TupleQueue<[Module, RuntimeSpec]>} */\n        const queue = new TupleQueue();\n\n        /**\r\n         * @param {Module} module module to process\r\n         * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\r\n         * @param {RuntimeSpec} runtime part of which runtime\r\n         * @param {boolean} forceSideEffects always apply side effects\r\n         * @returns {void}\r\n         */\n        const processReferencedModule = (module, usedExports, runtime, forceSideEffects) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          if (usedExports.length > 0) {\n            if (!module.buildMeta || !module.buildMeta.exportsType) {\n              if (exportsInfo.setUsedWithoutInfo(runtime)) {\n                queue.enqueue(module, runtime);\n              }\n              return;\n            }\n            for (const usedExportInfo of usedExports) {\n              let usedExport;\n              let canMangle = true;\n              if (Array.isArray(usedExportInfo)) {\n                usedExport = usedExportInfo;\n              } else {\n                usedExport = usedExportInfo.name;\n                canMangle = usedExportInfo.canMangle !== false;\n              }\n              if (usedExport.length === 0) {\n                if (exportsInfo.setUsedInUnknownWay(runtime)) {\n                  queue.enqueue(module, runtime);\n                }\n              } else {\n                let currentExportsInfo = exportsInfo;\n                for (let i = 0; i < usedExport.length; i++) {\n                  const exportInfo = currentExportsInfo.getExportInfo(usedExport[i]);\n                  if (canMangle === false) {\n                    exportInfo.canMangleUse = false;\n                  }\n                  const lastOne = i === usedExport.length - 1;\n                  if (!lastOne) {\n                    const nestedInfo = exportInfo.getNestedExportsInfo();\n                    if (nestedInfo) {\n                      if (exportInfo.setUsedConditionally(used => used === UsageState.Unused, UsageState.OnlyPropertiesUsed, runtime)) {\n                        const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n                        if (currentModule) {\n                          queue.enqueue(currentModule, runtime);\n                        }\n                      }\n                      currentExportsInfo = nestedInfo;\n                      continue;\n                    }\n                  }\n                  if (exportInfo.setUsedConditionally(v => v !== UsageState.Used, UsageState.Used, runtime)) {\n                    const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n                    if (currentModule) {\n                      queue.enqueue(currentModule, runtime);\n                    }\n                  }\n                  break;\n                }\n              }\n            }\n          } else {\n            // for a module without side effects we stop tracking usage here when no export is used\n            // This module won't be evaluated in this case\n            // TODO webpack 6 remove this check\n            if (!forceSideEffects && module.factoryMeta !== undefined && module.factoryMeta.sideEffectFree) {\n              return;\n            }\n            if (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n              queue.enqueue(module, runtime);\n            }\n          }\n        };\n\n        /**\r\n         * @param {DependenciesBlock} module the module\r\n         * @param {RuntimeSpec} runtime part of which runtime\r\n         * @param {boolean} forceSideEffects always apply side effects\r\n         * @returns {void}\r\n         */\n        const processModule = (module, runtime, forceSideEffects) => {\n          /** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n          const map = new Map();\n\n          /** @type {ArrayQueue<DependenciesBlock>} */\n          const queue = new ArrayQueue();\n          queue.enqueue(module);\n          for (;;) {\n            const block = queue.dequeue();\n            if (block === undefined) break;\n            for (const b of block.blocks) {\n              if (!this.global && b.groupOptions && b.groupOptions.entryOptions) {\n                processModule(b, b.groupOptions.entryOptions.runtime || undefined, true);\n              } else {\n                queue.enqueue(b);\n              }\n            }\n            for (const dep of block.dependencies) {\n              const connection = moduleGraph.getConnection(dep);\n              if (!connection || !connection.module) {\n                continue;\n              }\n              const activeState = connection.getActiveState(runtime);\n              if (activeState === false) continue;\n              const {\n                module\n              } = connection;\n              if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                processModule(module, runtime, false);\n                continue;\n              }\n              const oldReferencedExports = map.get(module);\n              if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n                continue;\n              }\n              const referencedExports = compilation.getDependencyReferencedExports(dep, runtime);\n              if (oldReferencedExports === undefined || oldReferencedExports === NO_EXPORTS_REFERENCED || referencedExports === EXPORTS_OBJECT_REFERENCED) {\n                map.set(module, referencedExports);\n              } else if (oldReferencedExports !== undefined && referencedExports === NO_EXPORTS_REFERENCED) {\n                continue;\n              } else {\n                let exportsMap;\n                if (Array.isArray(oldReferencedExports)) {\n                  exportsMap = new Map();\n                  for (const item of oldReferencedExports) {\n                    if (Array.isArray(item)) {\n                      exportsMap.set(item.join(\"\\n\"), item);\n                    } else {\n                      exportsMap.set(item.name.join(\"\\n\"), item);\n                    }\n                  }\n                  map.set(module, exportsMap);\n                } else {\n                  exportsMap = oldReferencedExports;\n                }\n                for (const item of referencedExports) {\n                  if (Array.isArray(item)) {\n                    const key = item.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n                    if (oldItem === undefined) {\n                      exportsMap.set(key, item);\n                    }\n                    // if oldItem is already an array we have to do nothing\n                    // if oldItem is an ReferencedExport object, we don't have to do anything\n                    // as canMangle defaults to true for arrays\n                  } else {\n                    const key = item.name.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n                    if (oldItem === undefined || Array.isArray(oldItem)) {\n                      exportsMap.set(key, item);\n                    } else {\n                      exportsMap.set(key, {\n                        name: item.name,\n                        canMangle: item.canMangle && oldItem.canMangle\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n          for (const [module, referencedExports] of map) {\n            if (Array.isArray(referencedExports)) {\n              processReferencedModule(module, referencedExports, runtime, forceSideEffects);\n            } else {\n              processReferencedModule(module, Array.from(referencedExports.values()), runtime, forceSideEffects);\n            }\n          }\n        };\n        logger.time(\"initialize exports usage\");\n        for (const module of modules) {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          exportInfoToModuleMap.set(exportsInfo, module);\n          exportsInfo.setHasUseInfo();\n        }\n        logger.timeEnd(\"initialize exports usage\");\n        logger.time(\"trace exports usage in graph\");\n\n        /**\r\n         * @param {Dependency} dep dependency\r\n         * @param {RuntimeSpec} runtime runtime\r\n         */\n        const processEntryDependency = (dep, runtime) => {\n          const module = moduleGraph.getModule(dep);\n          if (module) {\n            processReferencedModule(module, NO_EXPORTS_REFERENCED, runtime, true);\n          }\n        };\n        /** @type {RuntimeSpec} */\n        let globalRuntime = undefined;\n        for (const [entryName, {\n          dependencies: deps,\n          includeDependencies: includeDeps,\n          options\n        }] of compilation.entries) {\n          const runtime = this.global ? undefined : getEntryRuntime(compilation, entryName, options);\n          for (const dep of deps) {\n            processEntryDependency(dep, runtime);\n          }\n          for (const dep of includeDeps) {\n            processEntryDependency(dep, runtime);\n          }\n          globalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n        }\n        for (const dep of compilation.globalEntry.dependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n        for (const dep of compilation.globalEntry.includeDependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n        while (queue.length) {\n          const [module, runtime] = queue.dequeue();\n          processModule(module, runtime, false);\n        }\n        logger.timeEnd(\"trace exports usage in graph\");\n      });\n    });\n  }\n}\nmodule.exports = FlagDependencyUsagePlugin;","map":{"version":3,"names":["Dependency","require","UsageState","ModuleGraphConnection","STAGE_DEFAULT","ArrayQueue","TupleQueue","getEntryRuntime","mergeRuntimeOwned","NO_EXPORTS_REFERENCED","EXPORTS_OBJECT_REFERENCED","FlagDependencyUsagePlugin","constructor","global","apply","compiler","hooks","compilation","tap","moduleGraph","optimizeDependencies","name","stage","modules","moduleMemCaches","Error","logger","getLogger","exportInfoToModuleMap","Map","queue","processReferencedModule","module","usedExports","runtime","forceSideEffects","exportsInfo","getExportsInfo","length","buildMeta","exportsType","setUsedWithoutInfo","enqueue","usedExportInfo","usedExport","canMangle","Array","isArray","setUsedInUnknownWay","currentExportsInfo","i","exportInfo","getExportInfo","canMangleUse","lastOne","nestedInfo","getNestedExportsInfo","setUsedConditionally","used","Unused","OnlyPropertiesUsed","currentModule","get","v","Used","factoryMeta","undefined","sideEffectFree","setUsedForSideEffectsOnly","processModule","map","block","dequeue","b","blocks","groupOptions","entryOptions","dep","dependencies","connection","getConnection","activeState","getActiveState","TRANSITIVE_ONLY","oldReferencedExports","referencedExports","getDependencyReferencedExports","set","exportsMap","item","join","key","oldItem","from","values","time","setHasUseInfo","timeEnd","processEntryDependency","getModule","globalRuntime","entryName","deps","includeDependencies","includeDeps","options","entries","globalEntry","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/FlagDependencyUsagePlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst Dependency = require(\"./Dependency\");\r\nconst { UsageState } = require(\"./ExportsInfo\");\r\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\r\nconst { STAGE_DEFAULT } = require(\"./OptimizationStages\");\r\nconst ArrayQueue = require(\"./util/ArrayQueue\");\r\nconst TupleQueue = require(\"./util/TupleQueue\");\r\nconst { getEntryRuntime, mergeRuntimeOwned } = require(\"./util/runtime\");\r\n\r\n/** @typedef {import(\"./Chunk\")} Chunk */\r\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\r\n/** @typedef {import(\"./Compiler\")} Compiler */\r\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\r\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\r\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\r\n\r\nconst { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED } = Dependency;\r\n\r\nclass FlagDependencyUsagePlugin {\r\n\t/**\r\n\t * @param {boolean} global do a global analysis instead of per runtime\r\n\t */\r\n\tconstructor(global) {\r\n\t\tthis.global = global;\r\n\t}\r\n\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler the compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tcompiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\r\n\t\t\tconst moduleGraph = compilation.moduleGraph;\r\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\r\n\t\t\t\t{\r\n\t\t\t\t\tname: \"FlagDependencyUsagePlugin\",\r\n\t\t\t\t\tstage: STAGE_DEFAULT\r\n\t\t\t\t},\r\n\t\t\t\tmodules => {\r\n\t\t\t\t\tif (compilation.moduleMemCaches) {\r\n\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\"\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst logger = compilation.getLogger(\r\n\t\t\t\t\t\t\"webpack.FlagDependencyUsagePlugin\"\r\n\t\t\t\t\t);\r\n\t\t\t\t\t/** @type {Map<ExportsInfo, Module>} */\r\n\t\t\t\t\tconst exportInfoToModuleMap = new Map();\r\n\r\n\t\t\t\t\t/** @type {TupleQueue<[Module, RuntimeSpec]>} */\r\n\t\t\t\t\tconst queue = new TupleQueue();\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {Module} module module to process\r\n\t\t\t\t\t * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\r\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\r\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\r\n\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst processReferencedModule = (\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\tusedExports,\r\n\t\t\t\t\t\truntime,\r\n\t\t\t\t\t\tforceSideEffects\r\n\t\t\t\t\t) => {\r\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\r\n\t\t\t\t\t\tif (usedExports.length > 0) {\r\n\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\r\n\t\t\t\t\t\t\t\tif (exportsInfo.setUsedWithoutInfo(runtime)) {\r\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (const usedExportInfo of usedExports) {\r\n\t\t\t\t\t\t\t\tlet usedExport;\r\n\t\t\t\t\t\t\t\tlet canMangle = true;\r\n\t\t\t\t\t\t\t\tif (Array.isArray(usedExportInfo)) {\r\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo.name;\r\n\t\t\t\t\t\t\t\t\tcanMangle = usedExportInfo.canMangle !== false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (usedExport.length === 0) {\r\n\t\t\t\t\t\t\t\t\tif (exportsInfo.setUsedInUnknownWay(runtime)) {\r\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tlet currentExportsInfo = exportsInfo;\r\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < usedExport.length; i++) {\r\n\t\t\t\t\t\t\t\t\t\tconst exportInfo = currentExportsInfo.getExportInfo(\r\n\t\t\t\t\t\t\t\t\t\t\tusedExport[i]\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\tif (canMangle === false) {\r\n\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleUse = false;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tconst lastOne = i === usedExport.length - 1;\r\n\t\t\t\t\t\t\t\t\t\tif (!lastOne) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\r\n\t\t\t\t\t\t\t\t\t\t\tif (nestedInfo) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tused => used === UsageState.Unused,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsageState.OnlyPropertiesUsed,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\truntime\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? module\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo = nestedInfo;\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\r\n\t\t\t\t\t\t\t\t\t\t\t\tv => v !== UsageState.Used,\r\n\t\t\t\t\t\t\t\t\t\t\t\tUsageState.Used,\r\n\t\t\t\t\t\t\t\t\t\t\t\truntime\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t? module\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// for a module without side effects we stop tracking usage here when no export is used\r\n\t\t\t\t\t\t\t// This module won't be evaluated in this case\r\n\t\t\t\t\t\t\t// TODO webpack 6 remove this check\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t!forceSideEffects &&\r\n\t\t\t\t\t\t\t\tmodule.factoryMeta !== undefined &&\r\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\r\n\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {DependenciesBlock} module the module\r\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\r\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\r\n\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst processModule = (module, runtime, forceSideEffects) => {\r\n\t\t\t\t\t\t/** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\r\n\t\t\t\t\t\tconst map = new Map();\r\n\r\n\t\t\t\t\t\t/** @type {ArrayQueue<DependenciesBlock>} */\r\n\t\t\t\t\t\tconst queue = new ArrayQueue();\r\n\t\t\t\t\t\tqueue.enqueue(module);\r\n\t\t\t\t\t\tfor (;;) {\r\n\t\t\t\t\t\t\tconst block = queue.dequeue();\r\n\t\t\t\t\t\t\tif (block === undefined) break;\r\n\t\t\t\t\t\t\tfor (const b of block.blocks) {\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t!this.global &&\r\n\t\t\t\t\t\t\t\t\tb.groupOptions &&\r\n\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tprocessModule(\r\n\t\t\t\t\t\t\t\t\t\tb,\r\n\t\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions.runtime || undefined,\r\n\t\t\t\t\t\t\t\t\t\ttrue\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tqueue.enqueue(b);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (const dep of block.dependencies) {\r\n\t\t\t\t\t\t\t\tconst connection = moduleGraph.getConnection(dep);\r\n\t\t\t\t\t\t\t\tif (!connection || !connection.module) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst activeState = connection.getActiveState(runtime);\r\n\t\t\t\t\t\t\t\tif (activeState === false) continue;\r\n\t\t\t\t\t\t\t\tconst { module } = connection;\r\n\t\t\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\r\n\t\t\t\t\t\t\t\t\tprocessModule(module, runtime, false);\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst oldReferencedExports = map.get(module);\r\n\t\t\t\t\t\t\t\tif (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst referencedExports =\r\n\t\t\t\t\t\t\t\t\tcompilation.getDependencyReferencedExports(dep, runtime);\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\toldReferencedExports === undefined ||\r\n\t\t\t\t\t\t\t\t\toldReferencedExports === NO_EXPORTS_REFERENCED ||\r\n\t\t\t\t\t\t\t\t\treferencedExports === EXPORTS_OBJECT_REFERENCED\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tmap.set(module, referencedExports);\r\n\t\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\t\toldReferencedExports !== undefined &&\r\n\t\t\t\t\t\t\t\t\treferencedExports === NO_EXPORTS_REFERENCED\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tlet exportsMap;\r\n\t\t\t\t\t\t\t\t\tif (Array.isArray(oldReferencedExports)) {\r\n\t\t\t\t\t\t\t\t\t\texportsMap = new Map();\r\n\t\t\t\t\t\t\t\t\t\tfor (const item of oldReferencedExports) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.join(\"\\n\"), item);\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.name.join(\"\\n\"), item);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tmap.set(module, exportsMap);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\texportsMap = oldReferencedExports;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tfor (const item of referencedExports) {\r\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.join(\"\\n\");\r\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\r\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is already an array we have to do nothing\r\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is an ReferencedExport object, we don't have to do anything\r\n\t\t\t\t\t\t\t\t\t\t\t// as canMangle defaults to true for arrays\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.name.join(\"\\n\");\r\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\r\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined || Array.isArray(oldItem)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: item.name,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle: item.canMangle && oldItem.canMangle\r\n\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (const [module, referencedExports] of map) {\r\n\t\t\t\t\t\t\tif (Array.isArray(referencedExports)) {\r\n\t\t\t\t\t\t\t\tprocessReferencedModule(\r\n\t\t\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\t\t\treferencedExports,\r\n\t\t\t\t\t\t\t\t\truntime,\r\n\t\t\t\t\t\t\t\t\tforceSideEffects\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tprocessReferencedModule(\r\n\t\t\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\t\t\tArray.from(referencedExports.values()),\r\n\t\t\t\t\t\t\t\t\truntime,\r\n\t\t\t\t\t\t\t\t\tforceSideEffects\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tlogger.time(\"initialize exports usage\");\r\n\t\t\t\t\tfor (const module of modules) {\r\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\r\n\t\t\t\t\t\texportInfoToModuleMap.set(exportsInfo, module);\r\n\t\t\t\t\t\texportsInfo.setHasUseInfo();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlogger.timeEnd(\"initialize exports usage\");\r\n\r\n\t\t\t\t\tlogger.time(\"trace exports usage in graph\");\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {Dependency} dep dependency\r\n\t\t\t\t\t * @param {RuntimeSpec} runtime runtime\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst processEntryDependency = (dep, runtime) => {\r\n\t\t\t\t\t\tconst module = moduleGraph.getModule(dep);\r\n\t\t\t\t\t\tif (module) {\r\n\t\t\t\t\t\t\tprocessReferencedModule(\r\n\t\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\t\tNO_EXPORTS_REFERENCED,\r\n\t\t\t\t\t\t\t\truntime,\r\n\t\t\t\t\t\t\t\ttrue\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\t/** @type {RuntimeSpec} */\r\n\t\t\t\t\tlet globalRuntime = undefined;\r\n\t\t\t\t\tfor (const [\r\n\t\t\t\t\t\tentryName,\r\n\t\t\t\t\t\t{ dependencies: deps, includeDependencies: includeDeps, options }\r\n\t\t\t\t\t] of compilation.entries) {\r\n\t\t\t\t\t\tconst runtime = this.global\r\n\t\t\t\t\t\t\t? undefined\r\n\t\t\t\t\t\t\t: getEntryRuntime(compilation, entryName, options);\r\n\t\t\t\t\t\tfor (const dep of deps) {\r\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (const dep of includeDeps) {\r\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tglobalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (const dep of compilation.globalEntry.dependencies) {\r\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (const dep of compilation.globalEntry.includeDependencies) {\r\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile (queue.length) {\r\n\t\t\t\t\t\tconst [module, runtime] = queue.dequeue();\r\n\t\t\t\t\t\tprocessModule(module, runtime, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlogger.timeEnd(\"trace exports usage in graph\");\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = FlagDependencyUsagePlugin;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC1C,MAAM;EAAEC;AAAW,CAAC,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC/C,MAAME,qBAAqB,GAAGF,OAAO,CAAC,yBAAyB,CAAC;AAChE,MAAM;EAAEG;AAAc,CAAC,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AACzD,MAAMI,UAAU,GAAGJ,OAAO,CAAC,mBAAmB,CAAC;AAC/C,MAAMK,UAAU,GAAGL,OAAO,CAAC,mBAAmB,CAAC;AAC/C,MAAM;EAAEM,eAAe;EAAEC;AAAkB,CAAC,GAAGP,OAAO,CAAC,gBAAgB,CAAC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAAEQ,qBAAqB;EAAEC;AAA0B,CAAC,GAAGV,UAAU;AAEvE,MAAMW,yBAAyB,CAAC;EAC/B;AACD;AACA;EACCC,WAAW,CAACC,MAAM,EAAE;IACnB,IAAI,CAACA,MAAM,GAAGA,MAAM;EACrB;;EAEA;AACD;AACA;AACA;AACA;EACCC,KAAK,CAACC,QAAQ,EAAE;IACfA,QAAQ,CAACC,KAAK,CAACC,WAAW,CAACC,GAAG,CAAC,2BAA2B,EAAED,WAAW,IAAI;MAC1E,MAAME,WAAW,GAAGF,WAAW,CAACE,WAAW;MAC3CF,WAAW,CAACD,KAAK,CAACI,oBAAoB,CAACF,GAAG,CACzC;QACCG,IAAI,EAAE,2BAA2B;QACjCC,KAAK,EAAElB;MACR,CAAC,EACDmB,OAAO,IAAI;QACV,IAAIN,WAAW,CAACO,eAAe,EAAE;UAChC,MAAM,IAAIC,KAAK,CACd,gGAAgG,CAChG;QACF;QAEA,MAAMC,MAAM,GAAGT,WAAW,CAACU,SAAS,CACnC,mCAAmC,CACnC;QACD;QACA,MAAMC,qBAAqB,GAAG,IAAIC,GAAG,EAAE;;QAEvC;QACA,MAAMC,KAAK,GAAG,IAAIxB,UAAU,EAAE;;QAE9B;AACL;AACA;AACA;AACA;AACA;AACA;QACK,MAAMyB,uBAAuB,GAAG,CAC/BC,MAAM,EACNC,WAAW,EACXC,OAAO,EACPC,gBAAgB,KACZ;UACJ,MAAMC,WAAW,GAAGjB,WAAW,CAACkB,cAAc,CAACL,MAAM,CAAC;UACtD,IAAIC,WAAW,CAACK,MAAM,GAAG,CAAC,EAAE;YAC3B,IAAI,CAACN,MAAM,CAACO,SAAS,IAAI,CAACP,MAAM,CAACO,SAAS,CAACC,WAAW,EAAE;cACvD,IAAIJ,WAAW,CAACK,kBAAkB,CAACP,OAAO,CAAC,EAAE;gBAC5CJ,KAAK,CAACY,OAAO,CAACV,MAAM,EAAEE,OAAO,CAAC;cAC/B;cACA;YACD;YACA,KAAK,MAAMS,cAAc,IAAIV,WAAW,EAAE;cACzC,IAAIW,UAAU;cACd,IAAIC,SAAS,GAAG,IAAI;cACpB,IAAIC,KAAK,CAACC,OAAO,CAACJ,cAAc,CAAC,EAAE;gBAClCC,UAAU,GAAGD,cAAc;cAC5B,CAAC,MAAM;gBACNC,UAAU,GAAGD,cAAc,CAACtB,IAAI;gBAChCwB,SAAS,GAAGF,cAAc,CAACE,SAAS,KAAK,KAAK;cAC/C;cACA,IAAID,UAAU,CAACN,MAAM,KAAK,CAAC,EAAE;gBAC5B,IAAIF,WAAW,CAACY,mBAAmB,CAACd,OAAO,CAAC,EAAE;kBAC7CJ,KAAK,CAACY,OAAO,CAACV,MAAM,EAAEE,OAAO,CAAC;gBAC/B;cACD,CAAC,MAAM;gBACN,IAAIe,kBAAkB,GAAGb,WAAW;gBACpC,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,UAAU,CAACN,MAAM,EAAEY,CAAC,EAAE,EAAE;kBAC3C,MAAMC,UAAU,GAAGF,kBAAkB,CAACG,aAAa,CAClDR,UAAU,CAACM,CAAC,CAAC,CACb;kBACD,IAAIL,SAAS,KAAK,KAAK,EAAE;oBACxBM,UAAU,CAACE,YAAY,GAAG,KAAK;kBAChC;kBACA,MAAMC,OAAO,GAAGJ,CAAC,KAAKN,UAAU,CAACN,MAAM,GAAG,CAAC;kBAC3C,IAAI,CAACgB,OAAO,EAAE;oBACb,MAAMC,UAAU,GAAGJ,UAAU,CAACK,oBAAoB,EAAE;oBACpD,IAAID,UAAU,EAAE;sBACf,IACCJ,UAAU,CAACM,oBAAoB,CAC9BC,IAAI,IAAIA,IAAI,KAAKxD,UAAU,CAACyD,MAAM,EAClCzD,UAAU,CAAC0D,kBAAkB,EAC7B1B,OAAO,CACP,EACA;wBACD,MAAM2B,aAAa,GAClBZ,kBAAkB,KAAKb,WAAW,GAC/BJ,MAAM,GACNJ,qBAAqB,CAACkC,GAAG,CAACb,kBAAkB,CAAC;wBACjD,IAAIY,aAAa,EAAE;0BAClB/B,KAAK,CAACY,OAAO,CAACmB,aAAa,EAAE3B,OAAO,CAAC;wBACtC;sBACD;sBACAe,kBAAkB,GAAGM,UAAU;sBAC/B;oBACD;kBACD;kBACA,IACCJ,UAAU,CAACM,oBAAoB,CAC9BM,CAAC,IAAIA,CAAC,KAAK7D,UAAU,CAAC8D,IAAI,EAC1B9D,UAAU,CAAC8D,IAAI,EACf9B,OAAO,CACP,EACA;oBACD,MAAM2B,aAAa,GAClBZ,kBAAkB,KAAKb,WAAW,GAC/BJ,MAAM,GACNJ,qBAAqB,CAACkC,GAAG,CAACb,kBAAkB,CAAC;oBACjD,IAAIY,aAAa,EAAE;sBAClB/B,KAAK,CAACY,OAAO,CAACmB,aAAa,EAAE3B,OAAO,CAAC;oBACtC;kBACD;kBACA;gBACD;cACD;YACD;UACD,CAAC,MAAM;YACN;YACA;YACA;YACA,IACC,CAACC,gBAAgB,IACjBH,MAAM,CAACiC,WAAW,KAAKC,SAAS,IAChClC,MAAM,CAACiC,WAAW,CAACE,cAAc,EAChC;cACD;YACD;YACA,IAAI/B,WAAW,CAACgC,yBAAyB,CAAClC,OAAO,CAAC,EAAE;cACnDJ,KAAK,CAACY,OAAO,CAACV,MAAM,EAAEE,OAAO,CAAC;YAC/B;UACD;QACD,CAAC;;QAED;AACL;AACA;AACA;AACA;AACA;QACK,MAAMmC,aAAa,GAAG,CAACrC,MAAM,EAAEE,OAAO,EAAEC,gBAAgB,KAAK;UAC5D;UACA,MAAMmC,GAAG,GAAG,IAAIzC,GAAG,EAAE;;UAErB;UACA,MAAMC,KAAK,GAAG,IAAIzB,UAAU,EAAE;UAC9ByB,KAAK,CAACY,OAAO,CAACV,MAAM,CAAC;UACrB,SAAS;YACR,MAAMuC,KAAK,GAAGzC,KAAK,CAAC0C,OAAO,EAAE;YAC7B,IAAID,KAAK,KAAKL,SAAS,EAAE;YACzB,KAAK,MAAMO,CAAC,IAAIF,KAAK,CAACG,MAAM,EAAE;cAC7B,IACC,CAAC,IAAI,CAAC7D,MAAM,IACZ4D,CAAC,CAACE,YAAY,IACdF,CAAC,CAACE,YAAY,CAACC,YAAY,EAC1B;gBACDP,aAAa,CACZI,CAAC,EACDA,CAAC,CAACE,YAAY,CAACC,YAAY,CAAC1C,OAAO,IAAIgC,SAAS,EAChD,IAAI,CACJ;cACF,CAAC,MAAM;gBACNpC,KAAK,CAACY,OAAO,CAAC+B,CAAC,CAAC;cACjB;YACD;YACA,KAAK,MAAMI,GAAG,IAAIN,KAAK,CAACO,YAAY,EAAE;cACrC,MAAMC,UAAU,GAAG5D,WAAW,CAAC6D,aAAa,CAACH,GAAG,CAAC;cACjD,IAAI,CAACE,UAAU,IAAI,CAACA,UAAU,CAAC/C,MAAM,EAAE;gBACtC;cACD;cACA,MAAMiD,WAAW,GAAGF,UAAU,CAACG,cAAc,CAAChD,OAAO,CAAC;cACtD,IAAI+C,WAAW,KAAK,KAAK,EAAE;cAC3B,MAAM;gBAAEjD;cAAO,CAAC,GAAG+C,UAAU;cAC7B,IAAIE,WAAW,KAAK9E,qBAAqB,CAACgF,eAAe,EAAE;gBAC1Dd,aAAa,CAACrC,MAAM,EAAEE,OAAO,EAAE,KAAK,CAAC;gBACrC;cACD;cACA,MAAMkD,oBAAoB,GAAGd,GAAG,CAACR,GAAG,CAAC9B,MAAM,CAAC;cAC5C,IAAIoD,oBAAoB,KAAK1E,yBAAyB,EAAE;gBACvD;cACD;cACA,MAAM2E,iBAAiB,GACtBpE,WAAW,CAACqE,8BAA8B,CAACT,GAAG,EAAE3C,OAAO,CAAC;cACzD,IACCkD,oBAAoB,KAAKlB,SAAS,IAClCkB,oBAAoB,KAAK3E,qBAAqB,IAC9C4E,iBAAiB,KAAK3E,yBAAyB,EAC9C;gBACD4D,GAAG,CAACiB,GAAG,CAACvD,MAAM,EAAEqD,iBAAiB,CAAC;cACnC,CAAC,MAAM,IACND,oBAAoB,KAAKlB,SAAS,IAClCmB,iBAAiB,KAAK5E,qBAAqB,EAC1C;gBACD;cACD,CAAC,MAAM;gBACN,IAAI+E,UAAU;gBACd,IAAI1C,KAAK,CAACC,OAAO,CAACqC,oBAAoB,CAAC,EAAE;kBACxCI,UAAU,GAAG,IAAI3D,GAAG,EAAE;kBACtB,KAAK,MAAM4D,IAAI,IAAIL,oBAAoB,EAAE;oBACxC,IAAItC,KAAK,CAACC,OAAO,CAAC0C,IAAI,CAAC,EAAE;sBACxBD,UAAU,CAACD,GAAG,CAACE,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC,EAAED,IAAI,CAAC;oBACtC,CAAC,MAAM;sBACND,UAAU,CAACD,GAAG,CAACE,IAAI,CAACpE,IAAI,CAACqE,IAAI,CAAC,IAAI,CAAC,EAAED,IAAI,CAAC;oBAC3C;kBACD;kBACAnB,GAAG,CAACiB,GAAG,CAACvD,MAAM,EAAEwD,UAAU,CAAC;gBAC5B,CAAC,MAAM;kBACNA,UAAU,GAAGJ,oBAAoB;gBAClC;gBACA,KAAK,MAAMK,IAAI,IAAIJ,iBAAiB,EAAE;kBACrC,IAAIvC,KAAK,CAACC,OAAO,CAAC0C,IAAI,CAAC,EAAE;oBACxB,MAAME,GAAG,GAAGF,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC;oBAC3B,MAAME,OAAO,GAAGJ,UAAU,CAAC1B,GAAG,CAAC6B,GAAG,CAAC;oBACnC,IAAIC,OAAO,KAAK1B,SAAS,EAAE;sBAC1BsB,UAAU,CAACD,GAAG,CAACI,GAAG,EAAEF,IAAI,CAAC;oBAC1B;oBACA;oBACA;oBACA;kBACD,CAAC,MAAM;oBACN,MAAME,GAAG,GAAGF,IAAI,CAACpE,IAAI,CAACqE,IAAI,CAAC,IAAI,CAAC;oBAChC,MAAME,OAAO,GAAGJ,UAAU,CAAC1B,GAAG,CAAC6B,GAAG,CAAC;oBACnC,IAAIC,OAAO,KAAK1B,SAAS,IAAIpB,KAAK,CAACC,OAAO,CAAC6C,OAAO,CAAC,EAAE;sBACpDJ,UAAU,CAACD,GAAG,CAACI,GAAG,EAAEF,IAAI,CAAC;oBAC1B,CAAC,MAAM;sBACND,UAAU,CAACD,GAAG,CAACI,GAAG,EAAE;wBACnBtE,IAAI,EAAEoE,IAAI,CAACpE,IAAI;wBACfwB,SAAS,EAAE4C,IAAI,CAAC5C,SAAS,IAAI+C,OAAO,CAAC/C;sBACtC,CAAC,CAAC;oBACH;kBACD;gBACD;cACD;YACD;UACD;UAEA,KAAK,MAAM,CAACb,MAAM,EAAEqD,iBAAiB,CAAC,IAAIf,GAAG,EAAE;YAC9C,IAAIxB,KAAK,CAACC,OAAO,CAACsC,iBAAiB,CAAC,EAAE;cACrCtD,uBAAuB,CACtBC,MAAM,EACNqD,iBAAiB,EACjBnD,OAAO,EACPC,gBAAgB,CAChB;YACF,CAAC,MAAM;cACNJ,uBAAuB,CACtBC,MAAM,EACNc,KAAK,CAAC+C,IAAI,CAACR,iBAAiB,CAACS,MAAM,EAAE,CAAC,EACtC5D,OAAO,EACPC,gBAAgB,CAChB;YACF;UACD;QACD,CAAC;QAEDT,MAAM,CAACqE,IAAI,CAAC,0BAA0B,CAAC;QACvC,KAAK,MAAM/D,MAAM,IAAIT,OAAO,EAAE;UAC7B,MAAMa,WAAW,GAAGjB,WAAW,CAACkB,cAAc,CAACL,MAAM,CAAC;UACtDJ,qBAAqB,CAAC2D,GAAG,CAACnD,WAAW,EAAEJ,MAAM,CAAC;UAC9CI,WAAW,CAAC4D,aAAa,EAAE;QAC5B;QACAtE,MAAM,CAACuE,OAAO,CAAC,0BAA0B,CAAC;QAE1CvE,MAAM,CAACqE,IAAI,CAAC,8BAA8B,CAAC;;QAE3C;AACL;AACA;AACA;QACK,MAAMG,sBAAsB,GAAG,CAACrB,GAAG,EAAE3C,OAAO,KAAK;UAChD,MAAMF,MAAM,GAAGb,WAAW,CAACgF,SAAS,CAACtB,GAAG,CAAC;UACzC,IAAI7C,MAAM,EAAE;YACXD,uBAAuB,CACtBC,MAAM,EACNvB,qBAAqB,EACrByB,OAAO,EACP,IAAI,CACJ;UACF;QACD,CAAC;QACD;QACA,IAAIkE,aAAa,GAAGlC,SAAS;QAC7B,KAAK,MAAM,CACVmC,SAAS,EACT;UAAEvB,YAAY,EAAEwB,IAAI;UAAEC,mBAAmB,EAAEC,WAAW;UAAEC;QAAQ,CAAC,CACjE,IAAIxF,WAAW,CAACyF,OAAO,EAAE;UACzB,MAAMxE,OAAO,GAAG,IAAI,CAACrB,MAAM,GACxBqD,SAAS,GACT3D,eAAe,CAACU,WAAW,EAAEoF,SAAS,EAAEI,OAAO,CAAC;UACnD,KAAK,MAAM5B,GAAG,IAAIyB,IAAI,EAAE;YACvBJ,sBAAsB,CAACrB,GAAG,EAAE3C,OAAO,CAAC;UACrC;UACA,KAAK,MAAM2C,GAAG,IAAI2B,WAAW,EAAE;YAC9BN,sBAAsB,CAACrB,GAAG,EAAE3C,OAAO,CAAC;UACrC;UACAkE,aAAa,GAAG5F,iBAAiB,CAAC4F,aAAa,EAAElE,OAAO,CAAC;QAC1D;QACA,KAAK,MAAM2C,GAAG,IAAI5D,WAAW,CAAC0F,WAAW,CAAC7B,YAAY,EAAE;UACvDoB,sBAAsB,CAACrB,GAAG,EAAEuB,aAAa,CAAC;QAC3C;QACA,KAAK,MAAMvB,GAAG,IAAI5D,WAAW,CAAC0F,WAAW,CAACJ,mBAAmB,EAAE;UAC9DL,sBAAsB,CAACrB,GAAG,EAAEuB,aAAa,CAAC;QAC3C;QAEA,OAAOtE,KAAK,CAACQ,MAAM,EAAE;UACpB,MAAM,CAACN,MAAM,EAAEE,OAAO,CAAC,GAAGJ,KAAK,CAAC0C,OAAO,EAAE;UACzCH,aAAa,CAACrC,MAAM,EAAEE,OAAO,EAAE,KAAK,CAAC;QACtC;QACAR,MAAM,CAACuE,OAAO,CAAC,8BAA8B,CAAC;MAC/C,CAAC,CACD;IACF,CAAC,CAAC;EACH;AACD;AAEAjE,MAAM,CAAC4E,OAAO,GAAGjG,yBAAyB"},"metadata":{},"sourceType":"script","externalDependencies":[]}