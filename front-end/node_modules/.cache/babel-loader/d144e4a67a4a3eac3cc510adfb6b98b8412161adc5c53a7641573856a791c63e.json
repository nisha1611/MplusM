{"ast":null,"code":"/**\r\n * bcrypt namespace.\r\n * @type {Object.<string,*>}\r\n */\nvar bcrypt = {};\n\n/**\r\n * The random implementation to use as a fallback.\r\n * @type {?function(number):!Array.<number>}\r\n * @inner\r\n */\nvar randomFallback = null;\n\n/**\r\n * Generates cryptographically secure random bytes.\r\n * @function\r\n * @param {number} len Bytes length\r\n * @returns {!Array.<number>} Random bytes\r\n * @throws {Error} If no random implementation is available\r\n * @inner\r\n */\nfunction random(len) {\n  /* node */if (typeof module !== 'undefined' && module && module['exports']) try {\n    return require(\"crypto\")['randomBytes'](len);\n  } catch (e) {}\n  /* WCA */\n  try {\n    var a;\n    (self['crypto'] || self['msCrypto'])['getRandomValues'](a = new Uint32Array(len));\n    return Array.prototype.slice.call(a);\n  } catch (e) {}\n  /* fallback */\n  if (!randomFallback) throw Error(\"Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative\");\n  return randomFallback(len);\n}\n\n// Test if any secure randomness source is available\nvar randomAvailable = false;\ntry {\n  random(1);\n  randomAvailable = true;\n} catch (e) {}\n\n// Default fallback, if any\nrandomFallback = /*? if (ISAAC) { */function (len) {\n  for (var a = [], i = 0; i < len; ++i) a[i] = (0.5 + isaac() * 2.3283064365386963e-10) * 256 | 0;\n  return a;\n}; /*? } else { */\nnull; /*? }*/\n\n/**\r\n * Sets the pseudo random number generator to use as a fallback if neither node's `crypto` module nor the Web Crypto\r\n *  API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it\r\n *  is seeded properly!\r\n * @param {?function(number):!Array.<number>} random Function taking the number of bytes to generate as its\r\n *  sole argument, returning the corresponding array of cryptographically secure random byte values.\r\n * @see http://nodejs.org/api/crypto.html\r\n * @see http://www.w3.org/TR/WebCryptoAPI/\r\n */\nbcrypt.setRandomFallback = function (random) {\n  randomFallback = random;\n};\n\n/**\r\n * Synchronously generates a salt.\r\n * @param {number=} rounds Number of rounds to use, defaults to 10 if omitted\r\n * @param {number=} seed_length Not supported.\r\n * @returns {string} Resulting salt\r\n * @throws {Error} If a random fallback is required but not set\r\n * @expose\r\n */\nbcrypt.genSaltSync = function (rounds, seed_length) {\n  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;\n  if (typeof rounds !== 'number') throw Error(\"Illegal arguments: \" + typeof rounds + \", \" + typeof seed_length);\n  if (rounds < 4) rounds = 4;else if (rounds > 31) rounds = 31;\n  var salt = [];\n  salt.push(\"$2a$\");\n  if (rounds < 10) salt.push(\"0\");\n  salt.push(rounds.toString());\n  salt.push('$');\n  salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN)); // May throw\n  return salt.join('');\n};\n\n/**\r\n * Asynchronously generates a salt.\r\n * @param {(number|function(Error, string=))=} rounds Number of rounds to use, defaults to 10 if omitted\r\n * @param {(number|function(Error, string=))=} seed_length Not supported.\r\n * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting salt\r\n * @returns {!Promise} If `callback` has been omitted\r\n * @throws {Error} If `callback` is present but not a function\r\n * @expose\r\n */\nbcrypt.genSalt = function (rounds, seed_length, callback) {\n  if (typeof seed_length === 'function') callback = seed_length, seed_length = undefined; // Not supported.\n  if (typeof rounds === 'function') callback = rounds, rounds = undefined;\n  if (typeof rounds === 'undefined') rounds = GENSALT_DEFAULT_LOG2_ROUNDS;else if (typeof rounds !== 'number') throw Error(\"illegal arguments: \" + typeof rounds);\n  function _async(callback) {\n    nextTick(function () {\n      // Pretty thin, but salting is fast enough\n      try {\n        callback(null, bcrypt.genSaltSync(rounds));\n      } catch (err) {\n        callback(err);\n      }\n    });\n  }\n  if (callback) {\n    if (typeof callback !== 'function') throw Error(\"Illegal callback: \" + typeof callback);\n    _async(callback);\n  } else return new Promise(function (resolve, reject) {\n    _async(function (err, res) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\r\n * Synchronously generates a hash for the given string.\r\n * @param {string} s String to hash\r\n * @param {(number|string)=} salt Salt length to generate or salt to use, default to 10\r\n * @returns {string} Resulting hash\r\n * @expose\r\n */\nbcrypt.hashSync = function (s, salt) {\n  if (typeof salt === 'undefined') salt = GENSALT_DEFAULT_LOG2_ROUNDS;\n  if (typeof salt === 'number') salt = bcrypt.genSaltSync(salt);\n  if (typeof s !== 'string' || typeof salt !== 'string') throw Error(\"Illegal arguments: \" + typeof s + ', ' + typeof salt);\n  return _hash(s, salt);\n};\n\n/**\r\n * Asynchronously generates a hash for the given string.\r\n * @param {string} s String to hash\r\n * @param {number|string} salt Salt length to generate or salt to use\r\n * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash\r\n * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\r\n *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\r\n * @returns {!Promise} If `callback` has been omitted\r\n * @throws {Error} If `callback` is present but not a function\r\n * @expose\r\n */\nbcrypt.hash = function (s, salt, callback, progressCallback) {\n  function _async(callback) {\n    if (typeof s === 'string' && typeof salt === 'number') bcrypt.genSalt(salt, function (err, salt) {\n      _hash(s, salt, callback, progressCallback);\n    });else if (typeof s === 'string' && typeof salt === 'string') _hash(s, salt, callback, progressCallback);else nextTick(callback.bind(this, Error(\"Illegal arguments: \" + typeof s + ', ' + typeof salt)));\n  }\n  if (callback) {\n    if (typeof callback !== 'function') throw Error(\"Illegal callback: \" + typeof callback);\n    _async(callback);\n  } else return new Promise(function (resolve, reject) {\n    _async(function (err, res) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\r\n * Compares two strings of the same length in constant time.\r\n * @param {string} known Must be of the correct length\r\n * @param {string} unknown Must be the same length as `known`\r\n * @returns {boolean}\r\n * @inner\r\n */\nfunction safeStringCompare(known, unknown) {\n  var right = 0,\n    wrong = 0;\n  for (var i = 0, k = known.length; i < k; ++i) {\n    if (known.charCodeAt(i) === unknown.charCodeAt(i)) ++right;else ++wrong;\n  }\n  // Prevent removal of unused variables (never true, actually)\n  if (right < 0) return false;\n  return wrong === 0;\n}\n\n/**\r\n * Synchronously tests a string against a hash.\r\n * @param {string} s String to compare\r\n * @param {string} hash Hash to test against\r\n * @returns {boolean} true if matching, otherwise false\r\n * @throws {Error} If an argument is illegal\r\n * @expose\r\n */\nbcrypt.compareSync = function (s, hash) {\n  if (typeof s !== \"string\" || typeof hash !== \"string\") throw Error(\"Illegal arguments: \" + typeof s + ', ' + typeof hash);\n  if (hash.length !== 60) return false;\n  return safeStringCompare(bcrypt.hashSync(s, hash.substr(0, hash.length - 31)), hash);\n};\n\n/**\r\n * Asynchronously compares the given data against the given hash.\r\n * @param {string} s Data to compare\r\n * @param {string} hash Data to be compared to\r\n * @param {function(Error, boolean)=} callback Callback receiving the error, if any, otherwise the result\r\n * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\r\n *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\r\n * @returns {!Promise} If `callback` has been omitted\r\n * @throws {Error} If `callback` is present but not a function\r\n * @expose\r\n */\nbcrypt.compare = function (s, hash, callback, progressCallback) {\n  function _async(callback) {\n    if (typeof s !== \"string\" || typeof hash !== \"string\") {\n      nextTick(callback.bind(this, Error(\"Illegal arguments: \" + typeof s + ', ' + typeof hash)));\n      return;\n    }\n    if (hash.length !== 60) {\n      nextTick(callback.bind(this, null, false));\n      return;\n    }\n    bcrypt.hash(s, hash.substr(0, 29), function (err, comp) {\n      if (err) callback(err);else callback(null, safeStringCompare(comp, hash));\n    }, progressCallback);\n  }\n  if (callback) {\n    if (typeof callback !== 'function') throw Error(\"Illegal callback: \" + typeof callback);\n    _async(callback);\n  } else return new Promise(function (resolve, reject) {\n    _async(function (err, res) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\r\n * Gets the number of rounds used to encrypt the specified hash.\r\n * @param {string} hash Hash to extract the used number of rounds from\r\n * @returns {number} Number of rounds used\r\n * @throws {Error} If `hash` is not a string\r\n * @expose\r\n */\nbcrypt.getRounds = function (hash) {\n  if (typeof hash !== \"string\") throw Error(\"Illegal arguments: \" + typeof hash);\n  return parseInt(hash.split(\"$\")[2], 10);\n};\n\n/**\r\n * Gets the salt portion from a hash. Does not validate the hash.\r\n * @param {string} hash Hash to extract the salt from\r\n * @returns {string} Extracted salt part\r\n * @throws {Error} If `hash` is not a string or otherwise invalid\r\n * @expose\r\n */\nbcrypt.getSalt = function (hash) {\n  if (typeof hash !== 'string') throw Error(\"Illegal arguments: \" + typeof hash);\n  if (hash.length !== 60) throw Error(\"Illegal hash length: \" + hash.length + \" != 60\");\n  return hash.substring(0, 29);\n};\n\n//? include(\"bcrypt/util.js\");\n\n//? include(\"bcrypt/impl.js\");\n\n/**\r\n * Encodes a byte array to base64 with up to len bytes of input, using the custom bcrypt alphabet.\r\n * @function\r\n * @param {!Array.<number>} b Byte array\r\n * @param {number} len Maximum input length\r\n * @returns {string}\r\n * @expose\r\n */\nbcrypt.encodeBase64 = base64_encode;\n\n/**\r\n * Decodes a base64 encoded string to up to len bytes of output, using the custom bcrypt alphabet.\r\n * @function\r\n * @param {string} s String to decode\r\n * @param {number} len Maximum output length\r\n * @returns {!Array.<number>}\r\n * @expose\r\n */\nbcrypt.decodeBase64 = base64_decode;","map":{"version":3,"names":["bcrypt","randomFallback","random","len","module","require","e","a","self","Uint32Array","Array","prototype","slice","call","Error","randomAvailable","i","isaac","setRandomFallback","genSaltSync","rounds","seed_length","GENSALT_DEFAULT_LOG2_ROUNDS","salt","push","toString","base64_encode","BCRYPT_SALT_LEN","join","genSalt","callback","undefined","_async","nextTick","err","Promise","resolve","reject","res","hashSync","s","_hash","hash","progressCallback","bind","safeStringCompare","known","unknown","right","wrong","k","length","charCodeAt","compareSync","substr","compare","comp","getRounds","parseInt","split","getSalt","substring","encodeBase64","decodeBase64","base64_decode"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/bcryptjs/src/bcrypt.js"],"sourcesContent":["/**\r\n * bcrypt namespace.\r\n * @type {Object.<string,*>}\r\n */\r\nvar bcrypt = {};\r\n\r\n/**\r\n * The random implementation to use as a fallback.\r\n * @type {?function(number):!Array.<number>}\r\n * @inner\r\n */\r\nvar randomFallback = null;\r\n\r\n/**\r\n * Generates cryptographically secure random bytes.\r\n * @function\r\n * @param {number} len Bytes length\r\n * @returns {!Array.<number>} Random bytes\r\n * @throws {Error} If no random implementation is available\r\n * @inner\r\n */\r\nfunction random(len) {\r\n    /* node */ if (typeof module !== 'undefined' && module && module['exports'])\r\n        try {\r\n            return require(\"crypto\")['randomBytes'](len);\r\n        } catch (e) {}\r\n    /* WCA */ try {\r\n        var a; (self['crypto']||self['msCrypto'])['getRandomValues'](a = new Uint32Array(len));\r\n        return Array.prototype.slice.call(a);\r\n    } catch (e) {}\r\n    /* fallback */ if (!randomFallback)\r\n        throw Error(\"Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative\");\r\n    return randomFallback(len);\r\n}\r\n\r\n// Test if any secure randomness source is available\r\nvar randomAvailable = false;\r\ntry {\r\n    random(1);\r\n    randomAvailable = true;\r\n} catch (e) {}\r\n\r\n// Default fallback, if any\r\nrandomFallback = /*? if (ISAAC) { */function(len) {\r\n    for (var a=[], i=0; i<len; ++i)\r\n        a[i] = ((0.5 + isaac() * 2.3283064365386963e-10) * 256) | 0;\r\n    return a;\r\n};/*? } else { */null;/*? }*/\r\n\r\n/**\r\n * Sets the pseudo random number generator to use as a fallback if neither node's `crypto` module nor the Web Crypto\r\n *  API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it\r\n *  is seeded properly!\r\n * @param {?function(number):!Array.<number>} random Function taking the number of bytes to generate as its\r\n *  sole argument, returning the corresponding array of cryptographically secure random byte values.\r\n * @see http://nodejs.org/api/crypto.html\r\n * @see http://www.w3.org/TR/WebCryptoAPI/\r\n */\r\nbcrypt.setRandomFallback = function(random) {\r\n    randomFallback = random;\r\n};\r\n\r\n/**\r\n * Synchronously generates a salt.\r\n * @param {number=} rounds Number of rounds to use, defaults to 10 if omitted\r\n * @param {number=} seed_length Not supported.\r\n * @returns {string} Resulting salt\r\n * @throws {Error} If a random fallback is required but not set\r\n * @expose\r\n */\r\nbcrypt.genSaltSync = function(rounds, seed_length) {\r\n    rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;\r\n    if (typeof rounds !== 'number')\r\n        throw Error(\"Illegal arguments: \"+(typeof rounds)+\", \"+(typeof seed_length));\r\n    if (rounds < 4)\r\n        rounds = 4;\r\n    else if (rounds > 31)\r\n        rounds = 31;\r\n    var salt = [];\r\n    salt.push(\"$2a$\");\r\n    if (rounds < 10)\r\n        salt.push(\"0\");\r\n    salt.push(rounds.toString());\r\n    salt.push('$');\r\n    salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN)); // May throw\r\n    return salt.join('');\r\n};\r\n\r\n/**\r\n * Asynchronously generates a salt.\r\n * @param {(number|function(Error, string=))=} rounds Number of rounds to use, defaults to 10 if omitted\r\n * @param {(number|function(Error, string=))=} seed_length Not supported.\r\n * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting salt\r\n * @returns {!Promise} If `callback` has been omitted\r\n * @throws {Error} If `callback` is present but not a function\r\n * @expose\r\n */\r\nbcrypt.genSalt = function(rounds, seed_length, callback) {\r\n    if (typeof seed_length === 'function')\r\n        callback = seed_length,\r\n        seed_length = undefined; // Not supported.\r\n    if (typeof rounds === 'function')\r\n        callback = rounds,\r\n        rounds = undefined;\r\n    if (typeof rounds === 'undefined')\r\n        rounds = GENSALT_DEFAULT_LOG2_ROUNDS;\r\n    else if (typeof rounds !== 'number')\r\n        throw Error(\"illegal arguments: \"+(typeof rounds));\r\n\r\n    function _async(callback) {\r\n        nextTick(function() { // Pretty thin, but salting is fast enough\r\n            try {\r\n                callback(null, bcrypt.genSaltSync(rounds));\r\n            } catch (err) {\r\n                callback(err);\r\n            }\r\n        });\r\n    }\r\n\r\n    if (callback) {\r\n        if (typeof callback !== 'function')\r\n            throw Error(\"Illegal callback: \"+typeof(callback));\r\n        _async(callback);\r\n    } else\r\n        return new Promise(function(resolve, reject) {\r\n            _async(function(err, res) {\r\n                if (err) {\r\n                    reject(err);\r\n                    return;\r\n                }\r\n                resolve(res);\r\n            });\r\n        });\r\n};\r\n\r\n/**\r\n * Synchronously generates a hash for the given string.\r\n * @param {string} s String to hash\r\n * @param {(number|string)=} salt Salt length to generate or salt to use, default to 10\r\n * @returns {string} Resulting hash\r\n * @expose\r\n */\r\nbcrypt.hashSync = function(s, salt) {\r\n    if (typeof salt === 'undefined')\r\n        salt = GENSALT_DEFAULT_LOG2_ROUNDS;\r\n    if (typeof salt === 'number')\r\n        salt = bcrypt.genSaltSync(salt);\r\n    if (typeof s !== 'string' || typeof salt !== 'string')\r\n        throw Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof salt));\r\n    return _hash(s, salt);\r\n};\r\n\r\n/**\r\n * Asynchronously generates a hash for the given string.\r\n * @param {string} s String to hash\r\n * @param {number|string} salt Salt length to generate or salt to use\r\n * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash\r\n * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\r\n *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\r\n * @returns {!Promise} If `callback` has been omitted\r\n * @throws {Error} If `callback` is present but not a function\r\n * @expose\r\n */\r\nbcrypt.hash = function(s, salt, callback, progressCallback) {\r\n\r\n    function _async(callback) {\r\n        if (typeof s === 'string' && typeof salt === 'number')\r\n            bcrypt.genSalt(salt, function(err, salt) {\r\n                _hash(s, salt, callback, progressCallback);\r\n            });\r\n        else if (typeof s === 'string' && typeof salt === 'string')\r\n            _hash(s, salt, callback, progressCallback);\r\n        else\r\n            nextTick(callback.bind(this, Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof salt))));\r\n    }\r\n\r\n    if (callback) {\r\n        if (typeof callback !== 'function')\r\n            throw Error(\"Illegal callback: \"+typeof(callback));\r\n        _async(callback);\r\n    } else\r\n        return new Promise(function(resolve, reject) {\r\n            _async(function(err, res) {\r\n                if (err) {\r\n                    reject(err);\r\n                    return;\r\n                }\r\n                resolve(res);\r\n            });\r\n        });\r\n};\r\n\r\n/**\r\n * Compares two strings of the same length in constant time.\r\n * @param {string} known Must be of the correct length\r\n * @param {string} unknown Must be the same length as `known`\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction safeStringCompare(known, unknown) {\r\n    var right = 0,\r\n        wrong = 0;\r\n    for (var i=0, k=known.length; i<k; ++i) {\r\n        if (known.charCodeAt(i) === unknown.charCodeAt(i))\r\n            ++right;\r\n        else\r\n            ++wrong;\r\n    }\r\n    // Prevent removal of unused variables (never true, actually)\r\n    if (right < 0)\r\n        return false;\r\n    return wrong === 0;\r\n}\r\n\r\n/**\r\n * Synchronously tests a string against a hash.\r\n * @param {string} s String to compare\r\n * @param {string} hash Hash to test against\r\n * @returns {boolean} true if matching, otherwise false\r\n * @throws {Error} If an argument is illegal\r\n * @expose\r\n */\r\nbcrypt.compareSync = function(s, hash) {\r\n    if (typeof s !== \"string\" || typeof hash !== \"string\")\r\n        throw Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof hash));\r\n    if (hash.length !== 60)\r\n        return false;\r\n    return safeStringCompare(bcrypt.hashSync(s, hash.substr(0, hash.length-31)), hash);\r\n};\r\n\r\n/**\r\n * Asynchronously compares the given data against the given hash.\r\n * @param {string} s Data to compare\r\n * @param {string} hash Data to be compared to\r\n * @param {function(Error, boolean)=} callback Callback receiving the error, if any, otherwise the result\r\n * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\r\n *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\r\n * @returns {!Promise} If `callback` has been omitted\r\n * @throws {Error} If `callback` is present but not a function\r\n * @expose\r\n */\r\nbcrypt.compare = function(s, hash, callback, progressCallback) {\r\n\r\n    function _async(callback) {\r\n        if (typeof s !== \"string\" || typeof hash !== \"string\") {\r\n            nextTick(callback.bind(this, Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof hash))));\r\n            return;\r\n        }\r\n        if (hash.length !== 60) {\r\n            nextTick(callback.bind(this, null, false));\r\n            return;\r\n        }\r\n        bcrypt.hash(s, hash.substr(0, 29), function(err, comp) {\r\n            if (err)\r\n                callback(err);\r\n            else\r\n                callback(null, safeStringCompare(comp, hash));\r\n        }, progressCallback);\r\n    }\r\n\r\n    if (callback) {\r\n        if (typeof callback !== 'function')\r\n            throw Error(\"Illegal callback: \"+typeof(callback));\r\n        _async(callback);\r\n    } else\r\n        return new Promise(function(resolve, reject) {\r\n            _async(function(err, res) {\r\n                if (err) {\r\n                    reject(err);\r\n                    return;\r\n                }\r\n                resolve(res);\r\n            });\r\n        });\r\n};\r\n\r\n/**\r\n * Gets the number of rounds used to encrypt the specified hash.\r\n * @param {string} hash Hash to extract the used number of rounds from\r\n * @returns {number} Number of rounds used\r\n * @throws {Error} If `hash` is not a string\r\n * @expose\r\n */\r\nbcrypt.getRounds = function(hash) {\r\n    if (typeof hash !== \"string\")\r\n        throw Error(\"Illegal arguments: \"+(typeof hash));\r\n    return parseInt(hash.split(\"$\")[2], 10);\r\n};\r\n\r\n/**\r\n * Gets the salt portion from a hash. Does not validate the hash.\r\n * @param {string} hash Hash to extract the salt from\r\n * @returns {string} Extracted salt part\r\n * @throws {Error} If `hash` is not a string or otherwise invalid\r\n * @expose\r\n */\r\nbcrypt.getSalt = function(hash) {\r\n    if (typeof hash !== 'string')\r\n        throw Error(\"Illegal arguments: \"+(typeof hash));\r\n    if (hash.length !== 60)\r\n        throw Error(\"Illegal hash length: \"+hash.length+\" != 60\");\r\n    return hash.substring(0, 29);\r\n};\r\n\r\n//? include(\"bcrypt/util.js\");\r\n\r\n//? include(\"bcrypt/impl.js\");\r\n\r\n/**\r\n * Encodes a byte array to base64 with up to len bytes of input, using the custom bcrypt alphabet.\r\n * @function\r\n * @param {!Array.<number>} b Byte array\r\n * @param {number} len Maximum input length\r\n * @returns {string}\r\n * @expose\r\n */\r\nbcrypt.encodeBase64 = base64_encode;\r\n\r\n/**\r\n * Decodes a base64 encoded string to up to len bytes of output, using the custom bcrypt alphabet.\r\n * @function\r\n * @param {string} s String to decode\r\n * @param {number} len Maximum output length\r\n * @returns {!Array.<number>}\r\n * @expose\r\n */\r\nbcrypt.decodeBase64 = base64_decode;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}