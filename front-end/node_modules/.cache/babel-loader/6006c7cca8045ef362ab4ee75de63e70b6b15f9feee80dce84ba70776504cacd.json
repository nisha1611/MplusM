{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst {\n  promisify\n} = require('util');\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\nconst statMethods = {\n  stat,\n  lstat\n};\n\n/**\r\n * @typedef {String} Path\r\n */\n\n/**\r\n * @typedef {Object} FsEventsWatchContainer\r\n * @property {Set<Function>} listeners\r\n * @property {Function} rawEmitter\r\n * @property {{stop: Function}} watcher\r\n */\n\n// fsevents instance helper functions\n/**\r\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n * @type {Map<Path,FsEventsWatchContainer>}\r\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n\n/**\r\n * Instantiates the fsevents interface\r\n * @param {Path} path path to be watched\r\n * @param {Function} callback called when fsevents is bound and ready\r\n * @returns {{stop: Function}} new fsevents instance\r\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n\n/**\r\n * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n * the same file tree.\r\n * @param {Path} path           - to be watched\r\n * @param {Path} realPath       - real path for symlinks\r\n * @param {Function} listener   - called when fsevents emits events\r\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n * @returns {Function} closer\r\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = path => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n\n/**\r\n * @mixin\r\n */\nclass FsEventsHandler {\n  /**\r\n   * @param {import('../index').FSWatcher} fsw\r\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n      return true;\n    }\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat(path);\n      if (this.fsw.closed) return;\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n    if (event === EV_UNLINK) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n      // suppress unlink events on never before seen files\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        }\n\n        // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\r\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n       */\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n      this.fsw._emit(eventName, path);\n      if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n    }\n  }\n\n  /**\r\n   * Handle symlinks encountered during directory scan\r\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n   * @param {String} realPath   - real path (in case of symlinks)\r\n   * @param {Function} transform  - path transformer\r\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n   * @returns {Function} closer for the watcher instance\r\n  */\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return;\n      // ensure directories are tracked\n      const parent = sysPath.dirname(path);\n      const item = sysPath.basename(path);\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);\n\n      // correct for wrong events emitted\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE) {\n          let stats;\n          try {\n            stats = await stat(path);\n          } catch (error) {}\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n    this.fsw._emitReady();\n    return closer;\n  }\n\n  /**\r\n   * Handle symlinks encountered during directory scan\r\n   * @param {String} linkPath path to symlink\r\n   * @param {String} fullPath absolute path to the symlink\r\n   * @param {Function} transform pre-existing path transformer\r\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n   * @returns {Promise<void>}\r\n   */\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n    this.fsw._symlinkPaths.set(fullPath, true);\n    this.fsw._incrReadyCount();\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n      this.fsw._incrReadyCount();\n\n      // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath.join(linkPath, path);\n        }\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n\n  /**\r\n   *\r\n   * @param {Path} newPath\r\n   * @param {fs.Stats} stats\r\n   */\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n    const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n    const base = sysPath.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n    }\n  }\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n    this.fsw._addPathCloser(path, closer);\n  }\n\n  /**\r\n   * Handle added path with fsevents\r\n   * @param {String} path file/dir path or glob pattern\r\n   * @param {Function|Boolean=} transform converts working path to what the user expects\r\n   * @param {Boolean=} forceAdd ensure add is emitted\r\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n   * @returns {Promise<void>}\r\n   */\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n    const wh = this.fsw._getWatchHelpers(path);\n\n    // evaluate what is at the path we're being asked to watch\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n        // don't recurse further if it would exceed depth setting\n        if (priorDepth && priorDepth > opts.depth) return;\n\n        // scan the contents of the dir\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n        this.fsw._emitReady();\n      }\n    }\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n}\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"names":["fs","require","sysPath","promisify","fsevents","error","process","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","match","maj","Number","parseInt","min","undefined","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_ERROR","STR_DATA","STR_END","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","ROOT_GLOBSTAR","DIR_SUFFIX","DOT_SLASH","FUNCTION_TYPE","EMPTY_FN","IDENTITY_FN","Depth","value","isNaN","depth","stat","lstat","realpath","statMethods","FSEventsWatchers","Map","consolidateThreshhold","wrongEventFlags","Set","createFSEventsInstance","path","callback","stop","watch","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","parentPath","cont","get","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","watchedPath","keys","listeners","add","watcher","size","getInfo","forEach","list","event","set","lst","delete","then","Object","freeze","count","canUse","calcDepth","root","i","sameTypes","stats","type","isDirectory","isSymbolicLink","isFile","FsEventsHandler","constructor","fsw","checkIgnored","ipaths","_ignoredPaths","_isIgnored","addOrChange","parent","watchedDir","item","opts","has","handleEvent","checkExists","closed","code","_remove","_getWatchedDir","followSymlinks","curDepth","_addToFsEvents","eventName","_emit","_watchWithFsEvents","transform","globFilter","options","watchCallback","join","relative","basename","ignored","closer","_emitRaw","_emitReady","_handleFsEventsSymlink","linkPath","_symlinkPaths","_incrReadyCount","linkTarget","aliasedPath","_handleError","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","ignoreInitial","initWatch","wh","_addPathCloser","priorDepth","_getWatchHelpers","statMethod","_readdirp","fileFilter","entry","filterPath","directoryFilter","filterDir","on","joinedPath","persistent","e","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/chokidar/lib/fsevents-handler.js"],"sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\n\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n\r\nif (fsevents) {\r\n  // TODO: real check\r\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\r\n  if (mtch && mtch[1] && mtch[2]) {\r\n    const maj = Number.parseInt(mtch[1], 10);\r\n    const min = Number.parseInt(mtch[2], 10);\r\n    if (maj === 8 && min < 16) {\r\n      fsevents = undefined;\r\n    }\r\n  }\r\n}\r\n\r\nconst {\r\n  EV_ADD,\r\n  EV_CHANGE,\r\n  EV_ADD_DIR,\r\n  EV_UNLINK,\r\n  EV_ERROR,\r\n  STR_DATA,\r\n  STR_END,\r\n  FSEVENT_CREATED,\r\n  FSEVENT_MODIFIED,\r\n  FSEVENT_DELETED,\r\n  FSEVENT_MOVED,\r\n  // FSEVENT_CLONED,\r\n  FSEVENT_UNKNOWN,\r\n  FSEVENT_TYPE_FILE,\r\n  FSEVENT_TYPE_DIRECTORY,\r\n  FSEVENT_TYPE_SYMLINK,\r\n\r\n  ROOT_GLOBSTAR,\r\n  DIR_SUFFIX,\r\n  DOT_SLASH,\r\n  FUNCTION_TYPE,\r\n  EMPTY_FN,\r\n  IDENTITY_FN\r\n} = require('./constants');\r\n\r\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\r\n\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst realpath = promisify(fs.realpath);\r\n\r\nconst statMethods = { stat, lstat };\r\n\r\n/**\r\n * @typedef {String} Path\r\n */\r\n\r\n/**\r\n * @typedef {Object} FsEventsWatchContainer\r\n * @property {Set<Function>} listeners\r\n * @property {Function} rawEmitter\r\n * @property {{stop: Function}} watcher\r\n */\r\n\r\n// fsevents instance helper functions\r\n/**\r\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n * @type {Map<Path,FsEventsWatchContainer>}\r\n */\r\nconst FSEventsWatchers = new Map();\r\n\r\n// Threshold of duplicate path prefixes at which to start\r\n// consolidating going forward\r\nconst consolidateThreshhold = 10;\r\n\r\nconst wrongEventFlags = new Set([\r\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\r\n]);\r\n\r\n/**\r\n * Instantiates the fsevents interface\r\n * @param {Path} path path to be watched\r\n * @param {Function} callback called when fsevents is bound and ready\r\n * @returns {{stop: Function}} new fsevents instance\r\n */\r\nconst createFSEventsInstance = (path, callback) => {\r\n  const stop = fsevents.watch(path, callback);\r\n  return {stop};\r\n};\r\n\r\n/**\r\n * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n * the same file tree.\r\n * @param {Path} path           - to be watched\r\n * @param {Path} realPath       - real path for symlinks\r\n * @param {Function} listener   - called when fsevents emits events\r\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n * @returns {Function} closer\r\n */\r\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\r\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\r\n\r\n  const parentPath = sysPath.dirname(watchPath);\r\n  let cont = FSEventsWatchers.get(watchPath);\r\n\r\n  // If we've accumulated a substantial number of paths that\r\n  // could have been consolidated by watching one directory\r\n  // above the current one, create a watcher on the parent\r\n  // path instead, so that we do consolidate going forward.\r\n  if (couldConsolidate(parentPath)) {\r\n    watchPath = parentPath;\r\n  }\r\n\r\n  const resolvedPath = sysPath.resolve(path);\r\n  const hasSymlink = resolvedPath !== realPath;\r\n\r\n  const filteredListener = (fullPath, flags, info) => {\r\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\r\n    if (\r\n      fullPath === resolvedPath ||\r\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\r\n    ) listener(fullPath, flags, info);\r\n  };\r\n\r\n  // check if there is already a watcher on a parent path\r\n  // modifies `watchPath` to the parent path when it finds a match\r\n  let watchedParent = false;\r\n  for (const watchedPath of FSEventsWatchers.keys()) {\r\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\r\n      watchPath = watchedPath;\r\n      cont = FSEventsWatchers.get(watchPath);\r\n      watchedParent = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (cont || watchedParent) {\r\n    cont.listeners.add(filteredListener);\r\n  } else {\r\n    cont = {\r\n      listeners: new Set([filteredListener]),\r\n      rawEmitter,\r\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\r\n        if (!cont.listeners.size) return;\r\n        const info = fsevents.getInfo(fullPath, flags);\r\n        cont.listeners.forEach(list => {\r\n          list(fullPath, flags, info);\r\n        });\r\n\r\n        cont.rawEmitter(info.event, fullPath, info);\r\n      })\r\n    };\r\n    FSEventsWatchers.set(watchPath, cont);\r\n  }\r\n\r\n  // removes this instance's listeners and closes the underlying fsevents\r\n  // instance if there are no more listeners left\r\n  return () => {\r\n    const lst = cont.listeners;\r\n\r\n    lst.delete(filteredListener);\r\n    if (!lst.size) {\r\n      FSEventsWatchers.delete(watchPath);\r\n      if (cont.watcher) return cont.watcher.stop().then(() => {\r\n        cont.rawEmitter = cont.watcher = undefined;\r\n        Object.freeze(cont);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n// Decide whether or not we should start a new higher-level\r\n// parent watcher\r\nconst couldConsolidate = (path) => {\r\n  let count = 0;\r\n  for (const watchPath of FSEventsWatchers.keys()) {\r\n    if (watchPath.indexOf(path) === 0) {\r\n      count++;\r\n      if (count >= consolidateThreshhold) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// returns boolean indicating whether fsevents can be used\r\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\r\n\r\n// determines subdirectory traversal levels from root to path\r\nconst calcDepth = (path, root) => {\r\n  let i = 0;\r\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\r\n  return i;\r\n};\r\n\r\n// returns boolean indicating whether the fsevents' event info has the same type\r\n// as the one returned by fs.stat\r\nconst sameTypes = (info, stats) => (\r\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\r\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\r\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\r\n)\r\n\r\n/**\r\n * @mixin\r\n */\r\nclass FsEventsHandler {\r\n\r\n/**\r\n * @param {import('../index').FSWatcher} fsw\r\n */\r\nconstructor(fsw) {\r\n  this.fsw = fsw;\r\n}\r\ncheckIgnored(path, stats) {\r\n  const ipaths = this.fsw._ignoredPaths;\r\n  if (this.fsw._isIgnored(path, stats)) {\r\n    ipaths.add(path);\r\n    if (stats && stats.isDirectory()) {\r\n      ipaths.add(path + ROOT_GLOBSTAR);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  ipaths.delete(path);\r\n  ipaths.delete(path + ROOT_GLOBSTAR);\r\n}\r\n\r\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\r\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n}\r\n\r\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  try {\r\n    const stats = await stat(path)\r\n    if (this.fsw.closed) return;\r\n    if (sameTypes(info, stats)) {\r\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    } else {\r\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    }\r\n  } catch (error) {\r\n    if (error.code === 'EACCES') {\r\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    } else {\r\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    }\r\n  }\r\n}\r\n\r\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  if (this.fsw.closed || this.checkIgnored(path)) return;\r\n\r\n  if (event === EV_UNLINK) {\r\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\r\n    // suppress unlink events on never before seen files\r\n    if (isDirectory || watchedDir.has(item)) {\r\n      this.fsw._remove(parent, item, isDirectory);\r\n    }\r\n  } else {\r\n    if (event === EV_ADD) {\r\n      // track new directories\r\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\r\n\r\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\r\n        // push symlinks back to the top of the stack to get handled\r\n        const curDepth = opts.depth === undefined ?\r\n          undefined : calcDepth(fullPath, realPath) + 1;\r\n        return this._addToFsEvents(path, false, true, curDepth);\r\n      }\r\n\r\n      // track new paths\r\n      // (other than symlinks being followed, which will be tracked soon)\r\n      this.fsw._getWatchedDir(parent).add(item);\r\n    }\r\n    /**\r\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n     */\r\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\r\n    this.fsw._emit(eventName, path);\r\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered during directory scan\r\n * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n * @param {String} realPath   - real path (in case of symlinks)\r\n * @param {Function} transform  - path transformer\r\n * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n * @returns {Function} closer for the watcher instance\r\n*/\r\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\r\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\r\n  const opts = this.fsw.options;\r\n  const watchCallback = async (fullPath, flags, info) => {\r\n    if (this.fsw.closed) return;\r\n    if (\r\n      opts.depth !== undefined &&\r\n      calcDepth(fullPath, realPath) > opts.depth\r\n    ) return;\r\n    const path = transform(sysPath.join(\r\n      watchPath, sysPath.relative(watchPath, fullPath)\r\n    ));\r\n    if (globFilter && !globFilter(path)) return;\r\n    // ensure directories are tracked\r\n    const parent = sysPath.dirname(path);\r\n    const item = sysPath.basename(path);\r\n    const watchedDir = this.fsw._getWatchedDir(\r\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\r\n    );\r\n\r\n    // correct for wrong events emitted\r\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\r\n      if (typeof opts.ignored === FUNCTION_TYPE) {\r\n        let stats;\r\n        try {\r\n          stats = await stat(path);\r\n        } catch (error) {}\r\n        if (this.fsw.closed) return;\r\n        if (this.checkIgnored(path, stats)) return;\r\n        if (sameTypes(info, stats)) {\r\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n        } else {\r\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n        }\r\n      } else {\r\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      }\r\n    } else {\r\n      switch (info.event) {\r\n      case FSEVENT_CREATED:\r\n      case FSEVENT_MODIFIED:\r\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      case FSEVENT_DELETED:\r\n      case FSEVENT_MOVED:\r\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      }\r\n    }\r\n  };\r\n\r\n  const closer = setFSEventsListener(\r\n    watchPath,\r\n    realPath,\r\n    watchCallback,\r\n    this.fsw._emitRaw\r\n  );\r\n\r\n  this.fsw._emitReady();\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered during directory scan\r\n * @param {String} linkPath path to symlink\r\n * @param {String} fullPath absolute path to the symlink\r\n * @param {Function} transform pre-existing path transformer\r\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n * @returns {Promise<void>}\r\n */\r\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\r\n  // don't follow the same symlink more than once\r\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\r\n\r\n  this.fsw._symlinkPaths.set(fullPath, true);\r\n  this.fsw._incrReadyCount();\r\n\r\n  try {\r\n    const linkTarget = await realpath(linkPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(linkTarget)) {\r\n      return this.fsw._emitReady();\r\n    }\r\n\r\n    this.fsw._incrReadyCount();\r\n\r\n    // add the linkTarget for watching with a wrapper for transform\r\n    // that causes emitted paths to incorporate the link's path\r\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\r\n      let aliasedPath = linkPath;\r\n      if (linkTarget && linkTarget !== DOT_SLASH) {\r\n        aliasedPath = path.replace(linkTarget, linkPath);\r\n      } else if (path !== DOT_SLASH) {\r\n        aliasedPath = sysPath.join(linkPath, path);\r\n      }\r\n      return transform(aliasedPath);\r\n    }, false, curDepth);\r\n  } catch(error) {\r\n    if (this.fsw._handleError(error)) {\r\n      return this.fsw._emitReady();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Path} newPath\r\n * @param {fs.Stats} stats\r\n */\r\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\r\n  const pp = processPath(newPath);\r\n  const isDir = stats.isDirectory();\r\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\r\n  const base = sysPath.basename(pp);\r\n\r\n  // ensure empty dirs get tracked\r\n  if (isDir) this.fsw._getWatchedDir(pp);\r\n  if (dirObj.has(base)) return;\r\n  dirObj.add(base);\r\n\r\n  if (!opts.ignoreInitial || forceAdd === true) {\r\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\r\n  }\r\n}\r\n\r\ninitWatch(realPath, path, wh, processPath) {\r\n  if (this.fsw.closed) return;\r\n  const closer = this._watchWithFsEvents(\r\n    wh.watchPath,\r\n    sysPath.resolve(realPath || wh.watchPath),\r\n    processPath,\r\n    wh.globFilter\r\n  );\r\n  this.fsw._addPathCloser(path, closer);\r\n}\r\n\r\n/**\r\n * Handle added path with fsevents\r\n * @param {String} path file/dir path or glob pattern\r\n * @param {Function|Boolean=} transform converts working path to what the user expects\r\n * @param {Boolean=} forceAdd ensure add is emitted\r\n * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n * @returns {Promise<void>}\r\n */\r\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const opts = this.fsw.options;\r\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\r\n\r\n  const wh = this.fsw._getWatchHelpers(path);\r\n\r\n  // evaluate what is at the path we're being asked to watch\r\n  try {\r\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n      throw null;\r\n    }\r\n    if (stats.isDirectory()) {\r\n      // emit addDir unless this is a glob parent\r\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\r\n\r\n      // don't recurse further if it would exceed depth setting\r\n      if (priorDepth && priorDepth > opts.depth) return;\r\n\r\n      // scan the contents of the dir\r\n      this.fsw._readdirp(wh.watchPath, {\r\n        fileFilter: entry => wh.filterPath(entry),\r\n        directoryFilter: entry => wh.filterDir(entry),\r\n        ...Depth(opts.depth - (priorDepth || 0))\r\n      }).on(STR_DATA, (entry) => {\r\n        // need to check filterPath on dirs b/c filterDir is less restrictive\r\n        if (this.fsw.closed) {\r\n          return;\r\n        }\r\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\r\n\r\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\r\n        const {fullPath} = entry;\r\n\r\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\r\n          // preserve the current depth here since it can't be derived from\r\n          // real paths past the symlink\r\n          const curDepth = opts.depth === undefined ?\r\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\r\n\r\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\r\n        } else {\r\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\r\n        }\r\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\r\n        this.fsw._emitReady();\r\n      });\r\n    } else {\r\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\r\n      this.fsw._emitReady();\r\n    }\r\n  } catch (error) {\r\n    if (!error || this.fsw._handleError(error)) {\r\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\r\n      this.fsw._emitReady();\r\n      this.fsw._emitReady();\r\n    }\r\n  }\r\n\r\n  if (opts.persistent && forceAdd !== true) {\r\n    if (typeof transform === FUNCTION_TYPE) {\r\n      // realpath has already been resolved\r\n      this.initWatch(undefined, path, wh, processPath);\r\n    } else {\r\n      let realPath;\r\n      try {\r\n        realPath = await realpath(wh.watchPath);\r\n      } catch (e) {}\r\n      this.initWatch(realPath, path, wh, processPath);\r\n    }\r\n  }\r\n}\r\n\r\n}\r\n\r\nmodule.exports = FsEventsHandler;\r\nmodule.exports.canUse = canUse;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}