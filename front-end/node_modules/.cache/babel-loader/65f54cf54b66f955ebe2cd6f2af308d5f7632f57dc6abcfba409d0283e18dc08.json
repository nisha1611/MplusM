{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefaultRetryToken = void 0;\nconst constants_1 = require(\"./constants\");\nconst defaultRetryBackoffStrategy_1 = require(\"./defaultRetryBackoffStrategy\");\nconst getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n  var _a, _b, _c;\n  const MAX_CAPACITY = initialRetryTokens;\n  const retryCost = (_a = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _a !== void 0 ? _a : constants_1.RETRY_COST;\n  const timeoutRetryCost = (_b = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _b !== void 0 ? _b : constants_1.TIMEOUT_RETRY_COST;\n  const retryBackoffStrategy = (_c = options === null || options === void 0 ? void 0 : options.retryBackoffStrategy) !== null && _c !== void 0 ? _c : (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();\n  let availableCapacity = initialRetryTokens;\n  let retryDelay = Math.min(constants_1.MAXIMUM_RETRY_DELAY, initialRetryDelay);\n  let lastRetryCost = undefined;\n  let retryCount = initialRetryCount !== null && initialRetryCount !== void 0 ? initialRetryCount : 0;\n  const getCapacityAmount = errorType => errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost;\n  const getRetryCount = () => retryCount;\n  const getRetryDelay = () => retryDelay;\n  const getLastRetryCost = () => lastRetryCost;\n  const hasRetryTokens = errorType => getCapacityAmount(errorType) <= availableCapacity;\n  const getRetryTokenCount = errorInfo => {\n    const errorType = errorInfo.errorType;\n    if (!hasRetryTokens(errorType)) {\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(errorType);\n    const delayBase = errorType === \"THROTTLING\" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE;\n    retryBackoffStrategy.setDelayBase(delayBase);\n    const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n    if (errorInfo.retryAfterHint) {\n      const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n    } else {\n      retryDelay = delayFromErrorType;\n    }\n    retryCount++;\n    lastRetryCost = capacityAmount;\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  const releaseRetryTokens = releaseAmount => {\n    availableCapacity += releaseAmount !== null && releaseAmount !== void 0 ? releaseAmount : constants_1.NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return {\n    getRetryCount,\n    getRetryDelay,\n    getLastRetryCost,\n    hasRetryTokens,\n    getRetryTokenCount,\n    releaseRetryTokens\n  };\n};\nexports.getDefaultRetryToken = getDefaultRetryToken;","map":{"version":3,"names":["Object","defineProperty","exports","value","getDefaultRetryToken","constants_1","require","defaultRetryBackoffStrategy_1","initialRetryTokens","initialRetryDelay","initialRetryCount","options","_a","_b","_c","MAX_CAPACITY","retryCost","RETRY_COST","timeoutRetryCost","TIMEOUT_RETRY_COST","retryBackoffStrategy","getDefaultRetryBackoffStrategy","availableCapacity","retryDelay","Math","min","MAXIMUM_RETRY_DELAY","lastRetryCost","undefined","retryCount","getCapacityAmount","errorType","getRetryCount","getRetryDelay","getLastRetryCost","hasRetryTokens","getRetryTokenCount","errorInfo","Error","capacityAmount","delayBase","THROTTLING_RETRY_DELAY_BASE","DEFAULT_RETRY_DELAY_BASE","setDelayBase","delayFromErrorType","computeNextBackoffDelay","retryAfterHint","delayFromRetryAfterHint","getTime","Date","now","max","releaseRetryTokens","releaseAmount","NO_RETRY_INCREMENT"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/util-retry/dist-cjs/defaultRetryToken.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getDefaultRetryToken = void 0;\r\nconst constants_1 = require(\"./constants\");\r\nconst defaultRetryBackoffStrategy_1 = require(\"./defaultRetryBackoffStrategy\");\r\nconst getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\r\n    var _a, _b, _c;\r\n    const MAX_CAPACITY = initialRetryTokens;\r\n    const retryCost = (_a = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _a !== void 0 ? _a : constants_1.RETRY_COST;\r\n    const timeoutRetryCost = (_b = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _b !== void 0 ? _b : constants_1.TIMEOUT_RETRY_COST;\r\n    const retryBackoffStrategy = (_c = options === null || options === void 0 ? void 0 : options.retryBackoffStrategy) !== null && _c !== void 0 ? _c : (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();\r\n    let availableCapacity = initialRetryTokens;\r\n    let retryDelay = Math.min(constants_1.MAXIMUM_RETRY_DELAY, initialRetryDelay);\r\n    let lastRetryCost = undefined;\r\n    let retryCount = initialRetryCount !== null && initialRetryCount !== void 0 ? initialRetryCount : 0;\r\n    const getCapacityAmount = (errorType) => (errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost);\r\n    const getRetryCount = () => retryCount;\r\n    const getRetryDelay = () => retryDelay;\r\n    const getLastRetryCost = () => lastRetryCost;\r\n    const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;\r\n    const getRetryTokenCount = (errorInfo) => {\r\n        const errorType = errorInfo.errorType;\r\n        if (!hasRetryTokens(errorType)) {\r\n            throw new Error(\"No retry token available\");\r\n        }\r\n        const capacityAmount = getCapacityAmount(errorType);\r\n        const delayBase = errorType === \"THROTTLING\" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE;\r\n        retryBackoffStrategy.setDelayBase(delayBase);\r\n        const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\r\n        if (errorInfo.retryAfterHint) {\r\n            const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\r\n            retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\r\n        }\r\n        else {\r\n            retryDelay = delayFromErrorType;\r\n        }\r\n        retryCount++;\r\n        lastRetryCost = capacityAmount;\r\n        availableCapacity -= capacityAmount;\r\n        return capacityAmount;\r\n    };\r\n    const releaseRetryTokens = (releaseAmount) => {\r\n        availableCapacity += releaseAmount !== null && releaseAmount !== void 0 ? releaseAmount : constants_1.NO_RETRY_INCREMENT;\r\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\r\n    };\r\n    return {\r\n        getRetryCount,\r\n        getRetryDelay,\r\n        getLastRetryCost,\r\n        hasRetryTokens,\r\n        getRetryTokenCount,\r\n        releaseRetryTokens,\r\n    };\r\n};\r\nexports.getDefaultRetryToken = getDefaultRetryToken;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}