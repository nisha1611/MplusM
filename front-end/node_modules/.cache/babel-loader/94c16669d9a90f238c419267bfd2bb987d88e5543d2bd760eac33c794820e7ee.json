{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst VirtualType = require('./virtualtype');\nconst $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst castNumber = require('./cast/number');\nconst applyDefaults = require('./helpers/document/applyDefaults');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\nconst parentPaths = require('./helpers/path/parentPaths');\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\nconst specialProperties = utils.specialProperties;\n\n/**\r\n * The core Mongoose document constructor. You should not call this directly,\r\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\r\n *\r\n * @param {Object} obj the values to set\r\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\r\n * @param {Object} [options] various configuration options for the document\r\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\r\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\r\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\r\n * @event `save`: Emitted when the document is successfully saved\r\n * @api private\r\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n  const schema = this.$__schema;\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n  const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n    keys.forEach(function (key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({\n          prop: key,\n          subprops: null,\n          prototype: _this\n        });\n      }\n    });\n  }\n  applyQueue(this);\n}\n\n/**\r\n * Boolean flag specifying if the document is new. If you create a document\r\n * using `new`, this document will be considered \"new\". `$isNew` is how\r\n * Mongoose determines whether `save()` should use `insertOne()` to create\r\n * a new document or `updateOne()` to update an existing document.\r\n *\r\n * #### Example:\r\n *\r\n *     const user = new User({ name: 'John Smith' });\r\n *     user.$isNew; // true\r\n *\r\n *     await user.save(); // Sends an `insertOne` to MongoDB\r\n *\r\n * On the other hand, if you load an existing document from the database\r\n * using `findOne()` or another [query operation](/docs/queries.html),\r\n * `$isNew` will be false.\r\n *\r\n * #### Example:\r\n *\r\n *     const user = await User.findOne({ name: 'John Smith' });\r\n *     user.$isNew; // false\r\n *\r\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\r\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\r\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\r\n *\r\n * #### Example:\r\n *\r\n *     userSchema.post('save', function() {\r\n *       this.$isNew; // false\r\n *     });\r\n *     await User.create({ name: 'John Smith' });\r\n *\r\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\r\n * or if you create a new subdocument.\r\n *\r\n * #### Example:\r\n *\r\n *     // Assume `Group` has a document array `users`\r\n *     const group = await Group.findOne();\r\n *     group.users[0].$isNew; // false\r\n *\r\n *     group.users.push({ name: 'John Smith' });\r\n *     group.users[1].$isNew; // true\r\n *\r\n * @api public\r\n * @property $isNew\r\n * @memberOf Document\r\n * @instance\r\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function () {\n    return this.$isNew;\n  },\n  set: function (value) {\n    this.$isNew = value;\n  }\n});\n\n/**\r\n * Hash containing current validation errors.\r\n *\r\n * @api public\r\n * @property errors\r\n * @memberOf Document\r\n * @instance\r\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function () {\n    return this.$errors;\n  },\n  set: function (value) {\n    this.$errors = value;\n  }\n});\n\n/*!\r\n * ignore\r\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\r\n * Document exposes the NodeJS event emitter API, so you can use\r\n * `on`, `once`, etc.\r\n */\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    // Delay creating emitter until necessary because emitters take up a lot of memory,\n    // especially for subdocuments.\n    if (!this.$__.emitter) {\n      if (emitterFn === 'emit') {\n        return;\n      }\n      this.$__.emitter = new EventEmitter();\n      this.$__.emitter.setMaxListeners(0);\n    }\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n  Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n});\nDocument.prototype.constructor = Document;\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\r\n * The document's internal schema.\r\n *\r\n * @api private\r\n * @property schema\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__schema;\n\n/**\r\n * The document's schema.\r\n *\r\n * @api public\r\n * @property schema\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.schema;\n\n/**\r\n * Empty object that you can use for storing properties on the document. This\r\n * is handy for passing data to middleware without conflicting with Mongoose\r\n * internals.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.pre('save', function() {\r\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\r\n *       this.$locals.wasNew = this.isNew;\r\n *     });\r\n *\r\n *     schema.post('save', function() {\r\n *       // Prints true if `isNew` was set before `save()`\r\n *       console.log(this.$locals.wasNew);\r\n *     });\r\n *\r\n * @api public\r\n * @property $locals\r\n * @memberOf Document\r\n * @instance\r\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function () {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function (v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\r\n * Legacy alias for `$isNew`.\r\n *\r\n * @api public\r\n * @property isNew\r\n * @memberOf Document\r\n * @see $isNew #document_Document-$isNew\r\n * @instance\r\n */\n\nDocument.prototype.isNew;\n\n/**\r\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\r\n *\r\n * #### Example:\r\n *\r\n *     // Make sure `save()` never updates a soft deleted document.\r\n *     schema.pre('save', function() {\r\n *       this.$where = { isDeleted: false };\r\n *     });\r\n *\r\n * @api public\r\n * @property $where\r\n * @memberOf Document\r\n * @instance\r\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\r\n * The string version of this documents _id.\r\n *\r\n * #### Note:\r\n *\r\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\r\n *\r\n *     new Schema({ name: String }, { id: false });\r\n *\r\n * @api public\r\n * @see Schema options /docs/guide.html#options\r\n * @property id\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.id;\n\n/**\r\n * Hash containing current validation $errors.\r\n *\r\n * @api public\r\n * @property $errors\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$errors;\n\n/**\r\n * A string containing the current operation that Mongoose is executing\r\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = new Model({ name: 'test' });\r\n *     doc.$op; // null\r\n *\r\n *     const promise = doc.save();\r\n *     doc.$op; // 'save'\r\n *\r\n *     await promise;\r\n *     doc.$op; // null\r\n *\r\n * @api public\r\n * @property $op\r\n * @memberOf Document\r\n * @instance\r\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function () {\n    return this.$__.op || null;\n  },\n  set: function (value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\r\n * ignore\r\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n  flattenObjectWithDottedPaths(val);\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n    let cur = val;\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n      const piece = pieces[j];\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n        break;\n      }\n      curPath += (!curPath.length ? '' : '.') + piece;\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\r\n * Builds the default doc structure\r\n *\r\n * @param {Object} obj\r\n * @param {Object} [fields]\r\n * @param {Boolean} [skipId]\r\n * @param {Boolean} [exclude]\r\n * @param {Object} [hasIncludedChildren]\r\n * @api private\r\n * @method $__buildDoc\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n  const paths = Object.keys(this.$__schema.paths).\n  // Don't build up any paths that are underneath a map, we don't know\n  // what the keys will be\n  filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n  this._doc = doc;\n};\n\n/*!\r\n * Converts to POJO when you use the document for querying\r\n */\n\nDocument.prototype.toBSON = function () {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\r\n * Initializes the document without setters or marking anything modified.\r\n *\r\n * Called internally after a document is returned from mongodb. Normally,\r\n * you do **not** need to call this function on your own.\r\n *\r\n * This function triggers `init` [middleware](/docs/middleware.html).\r\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\r\n *\r\n * @param {Object} doc document returned by mongo\r\n * @param {Object} [opts]\r\n * @param {Function} [fn]\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.init = function (doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n  this.$__init(doc, opts);\n  if (fn) {\n    fn(null, this);\n  }\n  return this;\n};\n\n/**\r\n * Alias for [`.init`](#document_Document-init)\r\n *\r\n * @api public\r\n */\n\nDocument.prototype.$init = function () {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\r\n * Internal \"init\" function\r\n *\r\n * @param {Document} doc\r\n * @param {Object} [opts]\r\n * @returns {Document} this\r\n * @api private\r\n */\n\nDocument.prototype.$__init = function (doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n  init(this, doc, this._doc, opts);\n  markArraySubdocsPopulated(this, opts.populated);\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ? $__hasIncludedChildren(this.$__.selected) : null;\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n  return this;\n};\n\n/**\r\n * Init helper.\r\n *\r\n * @param {Object} self document instance\r\n * @param {Object} obj raw mongodb doc\r\n * @param {Object} doc object we are initializing\r\n * @param {Object} [opts] Optional Options\r\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\r\n * @param {String} [prefix] Prefix to add to each path\r\n * @api private\r\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n  while (index < len) {\n    _init(index++);\n  }\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\r\n * Sends an update command with this document `_id` as the query selector.\r\n *\r\n * #### Example:\r\n *\r\n *     weirdCar.update({ $inc: { wheels:1 } }, { w: 1 }, callback);\r\n *\r\n * #### Valid options:\r\n *\r\n *  - same as in [Model.update](#model_Model-update)\r\n *\r\n * @see Model.update #model_Model-update\r\n * @param {...Object} ops\r\n * @param {Object} [options]\r\n * @param {Function} [callback]\r\n * @return {Query} this\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.update = function update() {\n  const args = [...arguments];\n  args.unshift({\n    _id: this._id\n  });\n  const query = this.constructor.update.apply(this.constructor, args);\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n  return query;\n};\n\n/**\r\n * Sends an updateOne command with this document `_id` as the query selector.\r\n *\r\n * #### Example:\r\n *\r\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\r\n *\r\n * #### Valid options:\r\n *\r\n *  - same as in [Model.updateOne](#model_Model-updateOne)\r\n *\r\n * @see Model.updateOne #model_Model-updateOne\r\n * @param {Object} doc\r\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)\r\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\r\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\r\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\r\n * @param {Function} [callback]\r\n * @return {Query}\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({\n    _id: this._id\n  }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n  if (callback != null) {\n    return query.exec(callback);\n  }\n  return query;\n};\n\n/**\r\n * Sends a replaceOne command with this document `_id` as the query selector.\r\n *\r\n * #### Valid options:\r\n *\r\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model-replaceOne)\r\n *\r\n * @see Model.replaceOne #model_Model-replaceOne\r\n * @param {Object} doc\r\n * @param {Object} [options]\r\n * @param {Function} [callback]\r\n * @return {Query}\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\r\n * Getter/setter around the session associated with this document. Used to\r\n * automatically set `session` if you `save()` a doc that you got from a\r\n * query with an associated session.\r\n *\r\n * #### Example:\r\n *\r\n *     const session = MyModel.startSession();\r\n *     const doc = await MyModel.findOne().session(session);\r\n *     doc.$session() === session; // true\r\n *     doc.$session(null);\r\n *     doc.$session() === null; // true\r\n *\r\n * If this is a top-level document, setting the session propagates to all child\r\n * docs.\r\n *\r\n * @param {ClientSession} [session] overwrite the current session\r\n * @return {ClientSession}\r\n * @method $session\r\n * @api public\r\n * @memberOf Document\r\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' + 'called `endSession()` on the session you are passing to `$session()`.');\n  }\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n  this.$__.session = session;\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n  return session;\n};\n\n/**\r\n * Getter/setter around whether this document will apply timestamps by\r\n * default when using `save()` and `bulkSave()`.\r\n *\r\n * #### Example:\r\n *\r\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\r\n *     const doc = new TestModel({ name: 'John Smith' });\r\n *\r\n *     doc.$timestamps(); // true\r\n *\r\n *     doc.$timestamps(false);\r\n *     await doc.save(); // Does **not** apply timestamps\r\n *\r\n * @param {Boolean} [value] overwrite the current session\r\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\r\n * @method $timestamps\r\n * @api public\r\n * @memberOf Document\r\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n    return undefined;\n  }\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n  return this;\n};\n\n/**\r\n * Overwrite all values in this document with the values of `obj`, except\r\n * for immutable properties. Behaves similarly to `set()`, except for it\r\n * unsets all properties that aren't in `obj`.\r\n *\r\n * @param {Object} obj the object to overwrite this document with\r\n * @method overwrite\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n * @return {Document} this\r\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n  return this;\n};\n\n/**\r\n * Alias for `set()`, used internally to avoid conflicts\r\n *\r\n * @param {String|Object} path path or object of key/vals to set\r\n * @param {Any} val the value to set\r\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\r\n * @param {Object} [options] optionally specify options that modify the behavior of the set\r\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\r\n * @return {Document} this\r\n * @method $set\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n  const strict = options && 'strict' in options ? options.strict : this.$__.strictMode;\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true && !prefix && valForKey != null && pathtype === 'nested' && this._doc[key] != null) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: true\n        });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: false\n        });\n      }\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, {\n          _skipMarkModified: true\n        }));\n        $applyDefaultsToNested(this.$get(prefix + key), prefix + key, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 && this.$get(pathName) !== void 0) {\n          continue;\n        }\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, {\n            typeOnly: true\n          });\n        }\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          const p = path[key];\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key, path[key].toObject({\n            transform: false\n          }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n    return this;\n  }\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, {\n      typeOnly: true\n    });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, {\n        getters: false\n      }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({\n        virtuals: false,\n        transform: false\n      });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n    return this;\n  }\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, {\n        [populateModelSymbol]: val.constructor\n      });\n      val.$__.wasPopulated = {\n        value: unpopulatedValue\n      };\n      didPopulate = true;\n    }\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = {\n        [populateModelSymbol]: val[0].constructor\n      };\n      this.$populated(path, val.map(function (v) {\n        return v._id;\n      }), popOpts);\n      for (const doc of val) {\n        doc.$__.wasPopulated = {\n          value: doc._id\n        };\n      }\n      didPopulate = true;\n    }\n    if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, this, false, priorVal, {\n          overwriteImmutable: true\n        });\n      } else {\n        val = schema.applySetters(val, this, false, priorVal);\n      }\n    }\n    if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath, val.map(v => v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\r\n * Sets the value of a path, or many paths.\r\n * Alias for [`.$set`](#document_Document-$set).\r\n *\r\n * #### Example:\r\n *\r\n *     // path, value\r\n *     doc.set(path, value)\r\n *\r\n *     // object\r\n *     doc.set({\r\n *         path  : value\r\n *       , path2 : {\r\n *            path  : value\r\n *         }\r\n *     })\r\n *\r\n *     // on-the-fly cast to number\r\n *     doc.set(path, value, Number)\r\n *\r\n *     // on-the-fly cast to string\r\n *     doc.set(path, value, String)\r\n *\r\n *     // changing strict mode behavior\r\n *     doc.set(path, value, { strict: false });\r\n *\r\n * @param {String|Object} path path or object of key/vals to set\r\n * @param {Any} val the value to set\r\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\r\n * @param {Object} [options] optionally specify options that modify the behavior of the set\r\n * @return {Document} this\r\n * @api public\r\n * @method set\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\r\n * Determine if we should mark this change as modified.\r\n *\r\n * @param {never} pathToMark UNUSED\r\n * @param {String|Symbol} path\r\n * @param {Object} options\r\n * @param {Any} constructing\r\n * @param {never} parts UNUSED\r\n * @param {Schema} schema\r\n * @param {Any} val\r\n * @param {Any} priorVal\r\n * @return {Boolean}\r\n * @api private\r\n * @method $__shouldModify\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.getStatePaths('default') && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Handles the actual setting of the value and marking the path modified if appropriate.\r\n *\r\n * @param {String} pathToMark\r\n * @param {String|Symbol} path\r\n * @param {Object} options\r\n * @param {Any} constructing\r\n * @param {Array} parts\r\n * @param {Schema} schema\r\n * @param {Any} val\r\n * @param {Any} priorVal\r\n * @api private\r\n * @method $__set\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__set = function (pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function (item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => {\n        doc.isNew = false;\n      });\n    }\n  }\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\r\n * Gets a raw value from a path (no getters)\r\n *\r\n * @param {String} path\r\n * @return {Any} Returns the value from the given `path`.\r\n * @api private\r\n */\n\nDocument.prototype.$__getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\r\n * Increments the numeric value at `path` by the given `val`.\r\n * When you call `save()` on this document, Mongoose will send a\r\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\r\n * as opposed to a `$set`.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ counter: Number });\r\n *     const Test = db.model('Test', schema);\r\n *\r\n *     const doc = await Test.create({ counter: 0 });\r\n *     doc.$inc('counter', 2);\r\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\r\n *     doc.counter; // 2\r\n *\r\n *     doc.counter += 2;\r\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\r\n *\r\n * @param {String|Array} path path or paths to update\r\n * @param {Number} val increment `path` by this value\r\n * @return {Document} this\r\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$inc(p, val));\n    return this;\n  }\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n  try {\n    val = castNumber(val);\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n  const currentValue = this.$__getValue(path) || 0;\n  this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n  this.$__.primitiveAtomics[path] = {\n    $inc: val\n  };\n  this.markModified(path);\n  this.$__setValue(path, currentValue + val);\n  return this;\n};\n\n/**\r\n * Sets a raw value for a path (no casting, setters, transformations)\r\n *\r\n * @param {String} path\r\n * @param {Object} value\r\n * @return {Document} this\r\n * @api private\r\n */\n\nDocument.prototype.$__setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\r\n * Returns the value of a path.\r\n *\r\n * #### Example:\r\n *\r\n *     // path\r\n *     doc.get('age') // 47\r\n *\r\n *     // dynamic casting to a string\r\n *     doc.get('age', String) // \"47\"\r\n *\r\n * @param {String} path\r\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\r\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\r\n * @return {Any}\r\n * @api public\r\n */\n\nDocument.prototype.get = function (path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], {\n        getters: false\n      });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, {\n      path: path\n    });\n  }\n  return obj;\n};\n\n/*!\r\n * ignore\r\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\r\n * Returns the schematype for the given `path`.\r\n *\r\n * @param {String} path\r\n * @return {SchemaPath}\r\n * @api private\r\n * @method $__path\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__path = function (path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\r\n * Marks the path as having pending changes to write to the db.\r\n *\r\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\r\n *\r\n * #### Example:\r\n *\r\n *     doc.mixed.type = 'changed';\r\n *     doc.markModified('mixed.type');\r\n *     doc.save() // changes to mixed.type are now persisted\r\n *\r\n * @param {String} path the path to mark modified\r\n * @param {Document} [scope] the scope to run validators with\r\n * @api public\r\n */\n\nDocument.prototype.markModified = function (path, scope) {\n  this.$__saveInitialState(path);\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\r\n * ignore\r\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = utils.clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\r\n * Clears the modified state on the specified path.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.foo = 'bar';\r\n *     doc.unmarkModified('foo');\r\n *     doc.save(); // changes to foo will not be persisted\r\n *\r\n * @param {String} path the path to unmark modified\r\n * @api public\r\n */\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\r\n * Don't run validation on this path or persist changes to this path.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.foo = null;\r\n *     doc.$ignore('foo');\r\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\r\n *\r\n * @memberOf Document\r\n * @instance\r\n * @method $ignore\r\n * @param {String} path the path to ignore\r\n * @api public\r\n */\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\r\n * Returns the list of paths that have been directly modified. A direct\r\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\r\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\r\n *\r\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\r\n * because a child of `a` was directly modified.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\r\n *     const Model = mongoose.model('Test', schema);\r\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\r\n *\r\n *     const doc = await Model.findOne();\r\n *     doc.nested.bar = 'modified';\r\n *     doc.directModifiedPaths(); // ['nested.bar']\r\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\r\n *\r\n * @return {String[]}\r\n * @api public\r\n */\n\nDocument.prototype.directModifiedPaths = function () {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\r\n * Returns true if the given path is nullish or only contains empty objects.\r\n * Useful for determining whether this subdoc will get stripped out by the\r\n * [minimize option](/docs/guide.html#minimize).\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ nested: { foo: String } });\r\n *     const Model = mongoose.model('Test', schema);\r\n *     const doc = new Model({});\r\n *     doc.$isEmpty('nested'); // true\r\n *     doc.nested.$isEmpty(); // true\r\n *\r\n *     doc.nested.foo = 'bar';\r\n *     doc.$isEmpty('nested'); // false\r\n *     doc.nested.$isEmpty(); // false\r\n *\r\n * @param {String} [path]\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n * @method $isEmpty\r\n * @return {Boolean}\r\n */\n\nDocument.prototype.$isEmpty = function (path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\r\n * Returns the list of paths that have been modified.\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\r\n * @return {String[]}\r\n * @api public\r\n */\n\nDocument.prototype.modifiedPaths = function (options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n    if (!options.includeChildren) {\n      continue;\n    }\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\r\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\r\n * in this document is modified.\r\n *\r\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.set('documents.0.title', 'changed');\r\n *     doc.isModified()                      // true\r\n *     doc.isModified('documents')           // true\r\n *     doc.isModified('documents.0.title')   // true\r\n *     doc.isModified('documents otherProp') // true\r\n *     doc.isDirectModified('documents')     // false\r\n *\r\n * @param {String} [path] optional\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nDocument.prototype.isModified = function (paths, modifiedPaths) {\n  if (paths) {\n    const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n    if (directModifiedPaths.length === 0) {\n      return false;\n    }\n    if (!Array.isArray(paths)) {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n  return this.$__.activePaths.some('modify');\n};\n\n/**\r\n * Alias of [`.isModified`](#document_Document-isModified)\r\n *\r\n * @method $isModified\r\n * @memberOf Document\r\n * @api public\r\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\r\n * Checks if a path is set to its default.\r\n *\r\n * #### Example:\r\n *\r\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\r\n *     const m = new MyModel();\r\n *     m.$isDefault('name'); // true\r\n *\r\n * @memberOf Document\r\n * @instance\r\n * @method $isDefault\r\n * @param {String} [path]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nDocument.prototype.$isDefault = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\r\n * Getter/setter, determines whether the document was removed or not.\r\n *\r\n * #### Example:\r\n *\r\n *     const product = await product.remove();\r\n *     product.$isDeleted(); // true\r\n *     product.remove(); // no-op, doesn't send anything to the db\r\n *\r\n *     product.$isDeleted(false);\r\n *     product.$isDeleted(); // false\r\n *     product.remove(); // will execute a remove against the db\r\n *\r\n *\r\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\r\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\r\n * @method $isDeleted\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n */\n\nDocument.prototype.$isDeleted = function (val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\r\n * Returns true if `path` was directly set and modified, else false.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.set('documents.0.title', 'changed');\r\n *     doc.isDirectModified('documents.0.title') // true\r\n *     doc.isDirectModified('documents') // false\r\n *\r\n * @param {String|String[]} [path]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nDocument.prototype.isDirectModified = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n  }\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\n};\n\n/**\r\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\r\n *\r\n * @param {String} [path]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nDocument.prototype.isInit = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\r\n * Checks if `path` was selected in the source query which initialized this document.\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = await Thing.findOne().select('name');\r\n *     doc.isSelected('name') // true\r\n *     doc.isSelected('age')  // false\r\n *\r\n * @param {String|String[]} path\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n  if (inclusive === null) {\n    return true;\n  }\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n  const pathDot = path + '.';\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n  return !inclusive;\n};\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\r\n * Checks if `path` was explicitly selected. If no projection, always returns\r\n * true.\r\n *\r\n * #### Example:\r\n *\r\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\r\n *        doc.isDirectSelected('nested.name') // true\r\n *        doc.isDirectSelected('nested.otherName') // false\r\n *        doc.isDirectSelected('nested')  // false\r\n *     })\r\n *\r\n * @param {String} path\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n  if (inclusive === null) {\n    return true;\n  }\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n  return !inclusive;\n};\n\n/**\r\n * Executes registered validation rules for this document.\r\n *\r\n * #### Note:\r\n *\r\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.validate(function (err) {\r\n *       if (err) handleError(err);\r\n *       else // validation passed\r\n *     });\r\n *\r\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\r\n * @param {Object} [options] internal options\r\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\r\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\r\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\r\n * @return {Promise} Returns a Promise if no `callback` is given.\r\n * @api public\r\n */\n\nDocument.prototype.validate = function (pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack\n    });\n  }\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n    this.$__validate(pathsToValidate, options, error => {\n      this.$op = null;\n      this.$__.validating = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/**\r\n * Alias of [`.validate`](#document_Document-validate)\r\n *\r\n * @method $validate\r\n * @memberOf Document\r\n * @api public\r\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\r\n * ignore\r\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n    const p = doc.$__schema.path(path);\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function (path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) {\n    paths.add(p);\n  }\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();\n      for (const p of paths) {\n        if (p == null || p.startsWith(fullPathToSubdoc + '.')) {\n          paths.delete(p);\n        }\n      }\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) && !doc.isDirectModified(fullPathToSubdoc) && !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n        skipSchemaValidators[fullPathToSubdoc] = true;\n      }\n    }\n  }\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray &&\n    // Skip document arrays...\n    !_pathType.$embeddedSchemaType.$isMongooseArray &&\n    // and arrays of arrays\n    _pathType.validators.length === 0 &&\n    // and arrays with top-level validators\n    _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n    if (!_pathType.$isMongooseArray ||\n    // To avoid potential performance issues, skip doc arrays whose children\n    // are not required. `getPositionalPathType()` may be slow, so avoid\n    // it unless we have a case of #6364\n    !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray &&\n    // Skip document arrays...\n    !_pathType.$embeddedSchemaType.$isMongooseArray &&\n    // and arrays of arrays\n    _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n  const flattenOptions = {\n    skipArrays: true\n  };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\r\n * ignore\r\n */\n\nDocument.prototype.$__validate = function (pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  const pathsToSkip = options && options.pathsToSkip || null;\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.$isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  if (paths.length === 0) {\n    return immediate(function () {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n          error: error\n        }, function (error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n  const validated = {};\n  let total = 0;\n  for (const path of paths) {\n    validatePath(path);\n  }\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n    validated[path] = true;\n    total++;\n    immediate(function () {\n      const schemaType = _this.$__schema.path(path);\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if (pop = _this.$populated(path)) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n      schemaType.doValidate(val, function (err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n        error: error\n      }, function (error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\r\n * Executes registered validation rules (skipping asynchronous validators) for this document.\r\n *\r\n * #### Note:\r\n *\r\n * This method is useful if you need synchronous validation.\r\n *\r\n * #### Example:\r\n *\r\n *     const err = doc.validateSync();\r\n *     if (err) {\r\n *       handleError(err);\r\n *     } else {\r\n *       // validation passed\r\n *     }\r\n *\r\n * @param {Array|string} [pathsToValidate] only validate the given paths\r\n * @param {Object} [options] options for validation\r\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\r\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\r\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\r\n * @api public\r\n */\n\nDocument.prototype.validateSync = function (pathsToValidate, options) {\n  const _this = this;\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n  let pathsToSkip = options && options.pathsToSkip;\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.$isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n    if (validating[path]) {\n      continue;\n    }\n    validating[path] = true;\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n  return err;\n};\n\n/**\r\n * Marks a path as invalid, causing validation to fail.\r\n *\r\n * The `errorMsg` argument will become the message of the `ValidationError`.\r\n *\r\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\r\n *\r\n *     doc.invalidate('size', 'must be less than 20', 14);\r\n *\r\n *     doc.validate(function (err) {\r\n *       console.log(err)\r\n *       // prints\r\n *       { message: 'Validation failed',\r\n *         name: 'ValidationError',\r\n *         errors:\r\n *          { size:\r\n *             { message: 'must be less than 20',\r\n *               name: 'ValidatorError',\r\n *               path: 'size',\r\n *               type: 'user defined',\r\n *               value: 14 } } }\r\n *     })\r\n *\r\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\r\n * @param {String|Error} err the error which states the reason `path` was invalid\r\n * @param {Object|String|Number|any} val optional invalid value\r\n * @param {String} [kind] optional `kind` property for the error\r\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\r\n * @api public\r\n */\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\r\n * Marks a path as valid, removing existing validation errors.\r\n *\r\n * @param {String} path the field to mark as valid\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n * @method $markValid\r\n */\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\r\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api/document.html#document_Document-isNew) is `true`,\r\n * or sends an [updateOne](/docs/api/document.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\r\n *\r\n * #### Example:\r\n *\r\n *     product.sold = Date.now();\r\n *     product = await product.save();\r\n *\r\n * If save is successful, the returned promise will fulfill with the document\r\n * saved.\r\n *\r\n * #### Example:\r\n *\r\n *     const newProduct = await product.save();\r\n *     newProduct === product; // true\r\n *\r\n * @param {Object} [options] options optional options\r\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api/document.html#document_Document-$session).\r\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\r\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\r\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\r\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\r\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\r\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\r\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\r\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\r\n * @param {Function} [fn] optional callback\r\n * @method save\r\n * @memberOf Document\r\n * @instance\r\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api/document.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\r\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\r\n * @api public\r\n * @see middleware https://mongoosejs.com/docs/middleware.html\r\n */\n\n/**\r\n * Checks if a path is invalid\r\n *\r\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\r\n * @method $isValid\r\n * @memberOf Document\r\n * @instance\r\n * @api private\r\n */\n\nDocument.prototype.$isValid = function (path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\r\n * Resets the internal modified state of this document.\r\n *\r\n * @api private\r\n * @return {Document} this\r\n * @method $__reset\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      subdoc.$__reset();\n      if (subdoc.$isDocumentArrayElement) {\n        if (!resetArrays.has(subdoc.parentArray())) {\n          const array = subdoc.parentArray();\n          this.$__.activePaths.clearPath(fullPathWithIndexes.replace(/\\.\\d+$/, '').slice(-subdoc.$basePath - 1));\n          array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n          array[arrayAtomicsSymbol] = {};\n          resetArrays.add(array);\n        }\n      } else {\n        if (subdoc.$parent() === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          subdoc.$parent().$__reset();\n        }\n      }\n    }\n  }\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function (dirt) {\n    const type = dirt.value;\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\r\n * Returns this documents dirty paths / vals.\r\n *\r\n * @return {Array}\r\n * @api private\r\n * @method $__dirty\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__dirty = function () {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n  const allPaths = new Map(all.filter(el => el != null).map(el => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n    let top = null;\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\r\n * Assigns/compiles `schema` into this documents prototype.\r\n *\r\n * @param {Schema} schema\r\n * @api private\r\n * @method $__setSchema\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__setSchema = function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n/**\r\n * Get active path that were changed and are arrays\r\n *\r\n * @return {Array}\r\n * @api private\r\n * @method $__getArrayPathsToValidate\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.$__getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n\n/**\r\n * Get all subdocs (by bfs)\r\n *\r\n * @return {Array}\r\n * @api public\r\n * @method $getAllSubdocs\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function (seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function (seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function (seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n  return subDocs;\n};\n\n/*!\r\n * Runs queued functions\r\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\r\n * ignore\r\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\r\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\r\n *\r\n * @return {Object}\r\n * @api private\r\n * @method $toObject\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$toObject = function (options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor && this.constructor.base && this.constructor.base.options && get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? {\n    ...options\n  } : {};\n  options._calledWithOptions = options._calledWithOptions || {\n    ...options\n  };\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    _seen: options && options._seen || new Map()\n  });\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n  const depopulate = options.depopulate || options._parentOptions && options._parentOptions.depopulate || false;\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n  let ret = clone(this._doc, cloneOptions) || {};\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n  if (transform === true || schemaOptions.toObject && transform) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n  return ret;\n};\n\n/**\r\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\r\n *\r\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\r\n *\r\n * #### Getters/Virtuals\r\n *\r\n * Example of only applying path getters\r\n *\r\n *     doc.toObject({ getters: true, virtuals: false })\r\n *\r\n * Example of only applying virtual getters\r\n *\r\n *     doc.toObject({ virtuals: true })\r\n *\r\n * Example of applying both path and virtual getters\r\n *\r\n *     doc.toObject({ getters: true })\r\n *\r\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\r\n *\r\n *     schema.set('toObject', { virtuals: true })\r\n *\r\n * #### Transform:\r\n *\r\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\r\n *\r\n * Transform functions receive three arguments\r\n *\r\n *     function (doc, ret, options) {}\r\n *\r\n * - `doc` The mongoose document which is being converted\r\n * - `ret` The plain object representation which has been converted\r\n * - `options` The options in use (either schema options or the options passed inline)\r\n *\r\n * #### Example:\r\n *\r\n *     // specify the transform schema option\r\n *     if (!schema.options.toObject) schema.options.toObject = {};\r\n *     schema.options.toObject.transform = function (doc, ret, options) {\r\n *       // remove the _id of every document before returning the result\r\n *       delete ret._id;\r\n *       return ret;\r\n *     }\r\n *\r\n *     // without the transformation in the schema\r\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\r\n *\r\n *     // with the transformation\r\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\r\n *\r\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\r\n *\r\n *     if (!schema.options.toObject) schema.options.toObject = {};\r\n *     schema.options.toObject.transform = function (doc, ret, options) {\r\n *       return { movie: ret.name }\r\n *     }\r\n *\r\n *     // without the transformation in the schema\r\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\r\n *\r\n *     // with the transformation\r\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\r\n *\r\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\r\n *\r\n * Transformations may also be applied inline, overridding any transform set in the options:\r\n *\r\n *     function xform (doc, ret, options) {\r\n *       return { inline: ret.name, custom: true }\r\n *     }\r\n *\r\n *     // pass the transform as an inline option\r\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\r\n *\r\n * If you want to skip transformations, use `transform: false`:\r\n *\r\n *     schema.options.toObject.hide = '_id';\r\n *     schema.options.toObject.transform = function (doc, ret, options) {\r\n *       if (options.hide) {\r\n *         options.hide.split(' ').forEach(function (prop) {\r\n *           delete ret[prop];\r\n *         });\r\n *       }\r\n *       return ret;\r\n *     }\r\n *\r\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\r\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\r\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\r\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\r\n *\r\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\r\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\r\n * Similarly, `transform: false` skips transforms for all subdocuments.\r\n * Note that this behavior is different for transforms defined in the schema:\r\n * if you define a transform in `schema.options.toObject.transform`, that transform\r\n * will **not** apply to subdocuments.\r\n *\r\n *     const memberSchema = new Schema({ name: String, email: String });\r\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\r\n *     const Group = mongoose.model('Group', groupSchema);\r\n *\r\n *     const doc = new Group({\r\n *       name: 'Engineering',\r\n *       email: 'dev@mongoosejs.io',\r\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\r\n *     });\r\n *\r\n *     // Removes `email` from both top-level document **and** array elements\r\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\r\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\r\n *\r\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\r\n *\r\n * See [schema options](/docs/guide.html#toObject) for some more details.\r\n *\r\n * _During save, no custom options are applied to the document before being sent to the database._\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\r\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\r\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\r\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\r\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\r\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\r\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\r\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\r\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\r\n * @return {Object} js object (not a POJO)\r\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n\n/**\r\n * Minimizes an object, removing undefined values and empty objects\r\n *\r\n * @param {Object} object to minimize\r\n * @return {Object}\r\n * @api private\r\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n    hasKeys = true;\n  }\n  return hasKeys ? obj : undefined;\n}\n\n/*!\r\n * Applies virtuals properties to `json`.\r\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean' ? toObjectOptions.aliases : true;\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n  if (!cur) {\n    return json;\n  }\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n  return json;\n}\n\n/**\r\n * Applies virtuals properties to `json`.\r\n *\r\n * @param {Document} self\r\n * @param {Object} json\r\n * @param {Object} [options]\r\n * @return {Object} `json`\r\n * @api private\r\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n  if (!cur) {\n    return json;\n  }\n  while (i--) {\n    path = paths[i];\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n  return json;\n}\n\n/**\r\n * Applies schema type transforms to `json`.\r\n *\r\n * @param {Document} self\r\n * @param {Object} json\r\n * @return {Object} `json`\r\n * @api private\r\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n  if (!cur) {\n    return json;\n  }\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n      json[path] = vals;\n    }\n  }\n  return json;\n}\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n  if (!cur) {\n    return json;\n  }\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n  return json;\n}\n\n/**\r\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\r\n *\r\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\r\n *\r\n *     schema.set('toJSON', { virtuals: true });\r\n *\r\n * There is one difference between `toJSON()` and `toObject()` options.\r\n * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\r\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\r\n *\r\n * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\r\n *\r\n * @param {Object} options\r\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\r\n * @return {Object}\r\n * @see Document#toObject #document_Document-toObject\r\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\nDocument.prototype.ownerDocument = function () {\n  return this;\n};\n\n/**\r\n * If this document is a subdocument or populated document, returns the document's\r\n * parent. Returns the original document if there is no parent.\r\n *\r\n * @return {Document}\r\n * @api public\r\n * @method parent\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.parent = function () {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\r\n * Alias for [`parent()`](#document_Document-parent). If this document is a subdocument or populated\r\n * document, returns the document's parent. Returns `undefined` otherwise.\r\n *\r\n * @return {Document}\r\n * @api public\r\n * @method $parent\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\r\n * Helper for console.log\r\n *\r\n * @return {String}\r\n * @api public\r\n * @method inspect\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.inspect = function (options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n  return ret;\n};\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\r\n * Helper for console.log\r\n *\r\n * @return {String}\r\n * @api public\r\n * @method toString\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.toString = function () {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\r\n * Returns true if this document is equal to another document.\r\n *\r\n * Documents are considered equal when they have matching `_id`s, unless neither\r\n * document has an `_id`, in which case this function falls back to using\r\n * `deepEqual()`.\r\n *\r\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\r\n * @return {Boolean}\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n\n/**\r\n * Populates paths on an existing document.\r\n *\r\n * #### Example:\r\n *\r\n *     // Given a document, `populate()` lets you pull in referenced docs\r\n *     await doc.populate([\r\n *       'stories',\r\n *       { path: 'fans', sort: { name: -1 } }\r\n *     ]);\r\n *     doc.populated('stories'); // Array of ObjectIds\r\n *     doc.stories[0].title; // 'Casino Royale'\r\n *     doc.populated('fans'); // Array of ObjectIds\r\n *\r\n *     // If the referenced doc has been deleted, `populate()` will\r\n *     // remove that entry from the array.\r\n *     await Story.delete({ title: 'Casino Royale' });\r\n *     await doc.populate('stories'); // Empty array\r\n *\r\n *     // You can also pass additional query options to `populate()`,\r\n *     // like projections:\r\n *     await doc.populate('fans', '-email');\r\n *     doc.fans[0].email // undefined because of 2nd param `select`\r\n *\r\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\r\n * @param {Object|String} [select] Field selection for the population query\r\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\r\n * @param {Object} [match] Conditions for the population query\r\n * @param {Object} [options] Options for the population query (sort, etc)\r\n * @param {String} [options.path=null] The path to populate.\r\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).\r\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\r\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\r\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\r\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.\r\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\r\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\r\n * @param {Function} [callback] Callback\r\n * @see population /docs/populate\r\n * @see Query#select #query_Query-select\r\n * @see Model.populate #model_Model-populate\r\n * @memberOf Document\r\n * @instance\r\n * @return {Promise|null} Returns a Promise if no `callback` is given.\r\n * @api public\r\n */\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = [...arguments];\n  let fn;\n  if (args.length !== 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    }\n\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function (populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n  return topLevelModel.populate(this, paths, fn);\n};\n\n/**\r\n * Gets all populated documents associated with this document.\r\n *\r\n * @api public\r\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\r\n * @memberOf Document\r\n * @method $getPopulatedDocs\r\n * @instance\r\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Gets _id(s) used during population of the given `path`.\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = await Model.findOne().populate('author');\r\n *\r\n *     console.log(doc.author.name); // Dr.Seuss\r\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\r\n *\r\n * If the path was not populated, returns `undefined`.\r\n *\r\n * @param {String} path\r\n * @param {Any} [val]\r\n * @param {Object} [options]\r\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n */\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n  return val;\n};\n\n/**\r\n * Alias of [`.populated`](#document_Document-populated).\r\n *\r\n * @method $populated\r\n * @memberOf Document\r\n * @api public\r\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\r\n * Throws an error if a given path is not populated\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = await Model.findOne().populate('author');\r\n *\r\n *     doc.$assertPopulated('author'); // does not throw\r\n *     doc.$assertPopulated('other path'); // throws an error\r\n *\r\n *     // Manually populate and assert in one call. The following does\r\n *     // `doc.$set({ likes })` before asserting.\r\n *     doc.$assertPopulated('likes', { likes });\r\n *\r\n *\r\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\r\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\r\n * @return {Document} this\r\n * @memberOf Document\r\n * @method $assertPopulated\r\n * @instance\r\n * @api public\r\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n  return this;\n};\n\n/**\r\n * Takes a populated field and returns it to its unpopulated state.\r\n *\r\n * #### Example:\r\n *\r\n *     Model.findOne().populate('author').exec(function (err, doc) {\r\n *       console.log(doc.author.name); // Dr.Seuss\r\n *       console.log(doc.depopulate('author'));\r\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\r\n *     })\r\n *\r\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\r\n *\r\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\r\n * @return {Document} this\r\n * @see Document.populate #document_Document-populate\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.depopulate = function (path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n    const keys = Object.keys(populated);\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n/**\r\n * Returns the full path to this document.\r\n *\r\n * @param {String} [path]\r\n * @return {String}\r\n * @api private\r\n * @method $__fullPath\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\r\n * Returns the changes that happened to the document\r\n * in the format that will be sent to MongoDB.\r\n *\r\n * #### Example:\r\n *\r\n *     const userSchema = new Schema({\r\n *       name: String,\r\n *       age: Number,\r\n *       country: String\r\n *     });\r\n *     const User = mongoose.model('User', userSchema);\r\n *     const user = await User.create({\r\n *       name: 'Hafez',\r\n *       age: 25,\r\n *       country: 'Egypt'\r\n *     });\r\n *\r\n *     // returns an empty object, no changes happened yet\r\n *     user.getChanges(); // { }\r\n *\r\n *     user.country = undefined;\r\n *     user.age = 26;\r\n *\r\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\r\n *\r\n *     await user.save();\r\n *\r\n *     user.getChanges(); // { }\r\n *\r\n * Modifying the object that `getChanges()` returns does not affect the document's\r\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\r\n * will still send a `$set` to the server.\r\n *\r\n * @return {Object}\r\n * @api public\r\n * @method getChanges\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.getChanges = function () {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\r\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\r\n *\r\n * @return {Document} a copy of this document\r\n * @api public\r\n * @method $clone\r\n * @memberOf Document\r\n * @instance\r\n */\n\nDocument.prototype.$clone = function () {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc);\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({\n      ...this.$__.activePaths\n    }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\r\n * Module exports.\r\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"names":["EventEmitter","require","InternalCache","MongooseError","MixedSchema","ObjectExpectedError","ObjectParameterError","ParallelValidateError","Schema","StrictModeError","ValidationError","ValidatorError","VirtualType","$__hasIncludedChildren","promiseOrCallback","castNumber","applyDefaults","cleanModifiedSubpaths","compile","defineKey","flatten","flattenObjectWithDottedPaths","get","getEmbeddedDiscriminatorPath","getKeysInSchemaOrder","handleSpreadDoc","immediate","isDefiningProjection","isExclusive","inspect","internalToObjectOptions","markArraySubdocsPopulated","mpath","queryhelpers","utils","isPromise","clone","deepEqual","isMongooseObject","arrayAtomicsBackupSymbol","arrayAtomicsSymbol","documentArrayParent","documentIsModified","documentModifiedPaths","documentSchemaSymbol","getSymbol","populateModelSymbol","scopeSymbol","schemaMixedSymbol","parentPaths","DocumentArray","MongooseArray","Embedded","specialProperties","Document","obj","fields","skipId","options","Object","assign","$__schema","_schema","isObject","instanceOfSchema","$__setSchema","arguments","$__","isNew","$isNew","priorDoc","defaults","undefined","schema","strictMode","strict","requiredPaths","path","activePaths","exclude","isPOJO","keys","length","selected","hasIncludedChildren","_doc","$__buildDoc","$__original_set","$set","willInit","skipDefaults","_this","forEach","key","tree","methods","virtuals","startsWith","prop","subprops","prototype","applyQueue","defineProperty","set","value","$errors","each","emitterFn","emitter","setMaxListeners","apply","constructor","i","configurable","enumerable","locals","v","writable","id","op","$applyDefaultsToNested","val","doc","paths","plen","pathPieces","indexOf","split","curPath","p","type","pieces","splitPath","slice","len","defaultValue","cur","j","piece","def","getDefault","err","invalidate","filter","includes","ii","last","doc_","included","toBSON","toObject","init","opts","fn","$__init","$init","_id","populated","String","item","isVirtual","$populated","getValue","_docs","_childDocs","child","parent","$emit","emit","self","prefix","schemaType","index","docSchema","_init","$isRootDiscriminator","$__isSelected","hasOwnProperty","_castNullish","wasPopulated","setters","overrideInit","applySetters","cast","e","message","reason","$isModified","update","args","unshift","query","$session","session","updateOne","callback","pre","queryPreUpdateOne","cb","_middleware","execPre","post","queryPostUpdateOne","execPost","exec","replaceOne","hasEnded","$isSubdocument","subdocs","$getAllSubdocs","$timestamps","timestamps","currentValue","overwrite","Array","from","Set","concat","versionKey","discriminatorKey","merge","adhoc","constructing","adhocs","pathtype","adhocPaths","interpretAsType","$__isNested","_skipMinimizeTopLevel","pathName","pathType","valForKey","isNonBuiltinObject","_skipMarkModified","$get","typeOnly","transform","orderedDoc","orderedKeys","priorVal","$__getValue","CastError","hasInitialVal","savedState","initialVal","$__setValue","unmarkModified","markModified","parts","aliases","mixed","subpath","join","virtualpath","$__path","pathToMark","getters","$__set","$isSingleNested","$isMongooseArray","_markValidSubpaths","shouldSet","refMatches","model","ref","modelName","baseModelName","refPath","didPopulate","unpopulatedValue","popOpts","typeKey","isArray","_isManuallyPopulatedArray","map","singleNestedPaths","overwriteImmutable","$isMongooseDocumentArray","populatedPaths","populatedPath","_checkImmutableSubpaths","$markValid","isImmutableError","$originalErrorPath","instance","savedStatePath","ownerDocument","fullPath","$__saveInitialState","isDirectModified","el","$__shouldModify","getStatePaths","shouldModify","primitiveAtomics","isMongooseArray","_registerAtomic","isMongooseDocumentArray","__parentArray","l","next","has","Map","$inc","setValue","virtual","applyGetters","nested","applyVirtuals","adhocType","scope","modify","pathsToScopes","$__pathsToScopes","firstDot","topLevelPath","$ignore","ignore","directModifiedPaths","$isEmpty","isEmptyOptions","minimize","_isEmpty","modifiedPaths","result","pLen","add","includeChildren","subPath","modified","iii","iiiLen","isModified","isModifiedChild","some","mod","$isDefault","$isDeleted","isDeleted","isInit","isSelected","inclusive","pathDot","isDirectSelected","validate","pathsToValidate","parallelValidate","$op","validating","parentStack","conflictStack","stack","pathsToSkip","isOnePathOnly","$__validate","error","events","$validate","_evaluateRequiredFunctions","requiredFields","originalRequiredValue","cachedRequired","call","_getPathsToValidate","skipSchemaValidators","addToPaths","subdoc","$basePath","fullPathToSubdoc","$__fullPathWithIndexes","delete","_pathType","caster","validators","$embeddedSchemaType","schemaOptions","required","_pushNestedArrayPaths","numElements","flattenOptions","skipArrays","pathToCheck","_v","flat","$isSchemaMap","hasValidateModifiedOnlyOption","shouldValidateModifiedOnly","validateModifiedOnly","_complete","validationError","errors","errPath","pathDetails","_handlePathsToValidate","_handlePathsToSkip","s","hooks","validated","total","validatePath","complete","$isValid","pop","doValidateOptions","doValidate","isSubdoc","$isArraySubdocument","_pathsToValidate","ret","push","validateSync","doValidateSync","kind","addError","schematype","$immutableSetter","oldVal","$__reset","reset","$parent","resetArrays","fullPathWithIndexes","isParentInit","$isDocumentArrayElement","parentArray","array","clearPath","replace","$__dirty","dirt","backup","default","clear","$__undoReset","states","all","allPaths","minimal","top","hasAtomics","_applyDefaultGetters","$__getArrayPathsToValidate","bind","reduce","seed","docReducer","isNested","_docReduce","subDocs","q","callQueue","pair","$__handleReject","handleReject","$listeners","listeners","$toObject","json","defaultOptions","flattenDecimals","baseOptions","base","_calledWithOptions","_minimize","flattenMaps","cloneOptions","_isNested","_seen","hasUserDefinedProperty","depopulate","_parentOptions","_skipSingleNestedGetters","gettersOptions","originalTransform","applySchemaTypeTransforms","useProjection","omitDeselectedFields","toJSON","xformed","hasKeys","toObjectOptions","numPaths","assignPath","virtualsToApply","substring","branch","part","transformedValue","throwErrorIfPromise","vals","Error","applyPaths","custom","toString","equals","tid","docid","populate","res","populateOptions","object","topLevelModel","nestedPath","_localModel","$getPopulatedDocs","_path","endsWith","rest","$assertPopulated","values","populatedIds","virtualKeys","$$populatedVirtuals","virtualKey","singlePath","$__fullPath","getChanges","delta","$__delta","changes","$clone","Model","clonedDoc","Cache","clonedCache","getOwnPropertyNames","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/document.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst InternalCache = require('./internal');\r\nconst MongooseError = require('./error/index');\r\nconst MixedSchema = require('./schema/mixed');\r\nconst ObjectExpectedError = require('./error/objectExpected');\r\nconst ObjectParameterError = require('./error/objectParameter');\r\nconst ParallelValidateError = require('./error/parallelValidate');\r\nconst Schema = require('./schema');\r\nconst StrictModeError = require('./error/strict');\r\nconst ValidationError = require('./error/validation');\r\nconst ValidatorError = require('./error/validator');\r\nconst VirtualType = require('./virtualtype');\r\nconst $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');\r\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\r\nconst castNumber = require('./cast/number');\r\nconst applyDefaults = require('./helpers/document/applyDefaults');\r\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\r\nconst compile = require('./helpers/document/compile').compile;\r\nconst defineKey = require('./helpers/document/compile').defineKey;\r\nconst flatten = require('./helpers/common').flatten;\r\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\r\nconst get = require('./helpers/get');\r\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\r\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\r\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\r\nconst immediate = require('./helpers/immediate');\r\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\r\nconst isExclusive = require('./helpers/projection/isExclusive');\r\nconst inspect = require('util').inspect;\r\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\r\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\r\nconst mpath = require('mpath');\r\nconst queryhelpers = require('./queryhelpers');\r\nconst utils = require('./utils');\r\nconst isPromise = require('./helpers/isPromise');\r\n\r\nconst clone = utils.clone;\r\nconst deepEqual = utils.deepEqual;\r\nconst isMongooseObject = utils.isMongooseObject;\r\n\r\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\r\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\r\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\r\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\r\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\r\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\r\nconst getSymbol = require('./helpers/symbols').getSymbol;\r\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\r\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\r\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\r\nconst parentPaths = require('./helpers/path/parentPaths');\r\n\r\nlet DocumentArray;\r\nlet MongooseArray;\r\nlet Embedded;\r\n\r\nconst specialProperties = utils.specialProperties;\r\n\r\n/**\r\n * The core Mongoose document constructor. You should not call this directly,\r\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\r\n *\r\n * @param {Object} obj the values to set\r\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\r\n * @param {Object} [options] various configuration options for the document\r\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\r\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\r\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\r\n * @event `save`: Emitted when the document is successfully saved\r\n * @api private\r\n */\r\n\r\nfunction Document(obj, fields, skipId, options) {\r\n  if (typeof skipId === 'object' && skipId != null) {\r\n    options = skipId;\r\n    skipId = options.skipId;\r\n  }\r\n  options = Object.assign({}, options);\r\n\r\n  // Support `browserDocument.js` syntax\r\n  if (this.$__schema == null) {\r\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\r\n      new Schema(fields) :\r\n      fields;\r\n    this.$__setSchema(_schema);\r\n    fields = skipId;\r\n    skipId = options;\r\n    options = arguments[4] || {};\r\n  }\r\n\r\n  this.$__ = new InternalCache();\r\n\r\n  // Avoid setting `isNew` to `true`, because it is `true` by default\r\n  if (options.isNew != null && options.isNew !== true) {\r\n    this.$isNew = options.isNew;\r\n  }\r\n\r\n  if (options.priorDoc != null) {\r\n    this.$__.priorDoc = options.priorDoc;\r\n  }\r\n\r\n  if (skipId) {\r\n    this.$__.skipId = skipId;\r\n  }\r\n\r\n  if (obj != null && typeof obj !== 'object') {\r\n    throw new ObjectParameterError(obj, 'obj', 'Document');\r\n  }\r\n\r\n  let defaults = true;\r\n  if (options.defaults !== undefined) {\r\n    this.$__.defaults = options.defaults;\r\n    defaults = options.defaults;\r\n  }\r\n\r\n  const schema = this.$__schema;\r\n\r\n  if (typeof fields === 'boolean' || fields === 'throw') {\r\n    if (fields !== true) {\r\n      this.$__.strictMode = fields;\r\n    }\r\n    fields = undefined;\r\n  } else if (schema.options.strict !== true) {\r\n    this.$__.strictMode = schema.options.strict;\r\n  }\r\n\r\n  const requiredPaths = schema.requiredPaths(true);\r\n  for (const path of requiredPaths) {\r\n    this.$__.activePaths.require(path);\r\n  }\r\n\r\n  let exclude = null;\r\n\r\n  // determine if this doc is a result of a query with\r\n  // excluded fields\r\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\r\n    exclude = isExclusive(fields);\r\n    this.$__.selected = fields;\r\n    this.$__.exclude = exclude;\r\n  }\r\n\r\n  const hasIncludedChildren = exclude === false && fields ?\r\n    $__hasIncludedChildren(fields) :\r\n    null;\r\n\r\n  if (this._doc == null) {\r\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\r\n\r\n    // By default, defaults get applied **before** setting initial values\r\n    // Re: gh-6155\r\n    if (defaults) {\r\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\r\n    }\r\n  }\r\n  if (obj) {\r\n    // Skip set hooks\r\n    if (this.$__original_set) {\r\n      this.$__original_set(obj, undefined, true, options);\r\n    } else {\r\n      this.$set(obj, undefined, true, options);\r\n    }\r\n\r\n    if (obj instanceof Document) {\r\n      this.$isNew = obj.$isNew;\r\n    }\r\n  }\r\n\r\n  // Function defaults get applied **after** setting initial values so they\r\n  // see the full doc rather than an empty one, unless they opt out.\r\n  // Re: gh-3781, gh-6155\r\n  if (options.willInit && defaults) {\r\n    if (options.skipDefaults) {\r\n      this.$__.skipDefaults = options.skipDefaults;\r\n    }\r\n  } else if (defaults) {\r\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\r\n  }\r\n\r\n  if (!this.$__.strictMode && obj) {\r\n    const _this = this;\r\n    const keys = Object.keys(this._doc);\r\n\r\n    keys.forEach(function(key) {\r\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\r\n      // Mongoose internals.\r\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\r\n        defineKey({ prop: key, subprops: null, prototype: _this });\r\n      }\r\n    });\r\n  }\r\n\r\n  applyQueue(this);\r\n}\r\n\r\n/**\r\n * Boolean flag specifying if the document is new. If you create a document\r\n * using `new`, this document will be considered \"new\". `$isNew` is how\r\n * Mongoose determines whether `save()` should use `insertOne()` to create\r\n * a new document or `updateOne()` to update an existing document.\r\n *\r\n * #### Example:\r\n *\r\n *     const user = new User({ name: 'John Smith' });\r\n *     user.$isNew; // true\r\n *\r\n *     await user.save(); // Sends an `insertOne` to MongoDB\r\n *\r\n * On the other hand, if you load an existing document from the database\r\n * using `findOne()` or another [query operation](/docs/queries.html),\r\n * `$isNew` will be false.\r\n *\r\n * #### Example:\r\n *\r\n *     const user = await User.findOne({ name: 'John Smith' });\r\n *     user.$isNew; // false\r\n *\r\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\r\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\r\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\r\n *\r\n * #### Example:\r\n *\r\n *     userSchema.post('save', function() {\r\n *       this.$isNew; // false\r\n *     });\r\n *     await User.create({ name: 'John Smith' });\r\n *\r\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\r\n * or if you create a new subdocument.\r\n *\r\n * #### Example:\r\n *\r\n *     // Assume `Group` has a document array `users`\r\n *     const group = await Group.findOne();\r\n *     group.users[0].$isNew; // false\r\n *\r\n *     group.users.push({ name: 'John Smith' });\r\n *     group.users[1].$isNew; // true\r\n *\r\n * @api public\r\n * @property $isNew\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Document.prototype, 'isNew', {\r\n  get: function() {\r\n    return this.$isNew;\r\n  },\r\n  set: function(value) {\r\n    this.$isNew = value;\r\n  }\r\n});\r\n\r\n/**\r\n * Hash containing current validation errors.\r\n *\r\n * @api public\r\n * @property errors\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Document.prototype, 'errors', {\r\n  get: function() {\r\n    return this.$errors;\r\n  },\r\n  set: function(value) {\r\n    this.$errors = value;\r\n  }\r\n});\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nDocument.prototype.$isNew = true;\r\n\r\n/*!\r\n * Document exposes the NodeJS event emitter API, so you can use\r\n * `on`, `once`, etc.\r\n */\r\nutils.each(\r\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\r\n    'removeAllListeners', 'addListener'],\r\n  function(emitterFn) {\r\n    Document.prototype[emitterFn] = function() {\r\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\r\n      // especially for subdocuments.\r\n      if (!this.$__.emitter) {\r\n        if (emitterFn === 'emit') {\r\n          return;\r\n        }\r\n        this.$__.emitter = new EventEmitter();\r\n        this.$__.emitter.setMaxListeners(0);\r\n      }\r\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\r\n    };\r\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\r\n  });\r\n\r\nDocument.prototype.constructor = Document;\r\n\r\nfor (const i in EventEmitter.prototype) {\r\n  Document[i] = EventEmitter.prototype[i];\r\n}\r\n\r\n/**\r\n * The document's internal schema.\r\n *\r\n * @api private\r\n * @property schema\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__schema;\r\n\r\n/**\r\n * The document's schema.\r\n *\r\n * @api public\r\n * @property schema\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.schema;\r\n\r\n/**\r\n * Empty object that you can use for storing properties on the document. This\r\n * is handy for passing data to middleware without conflicting with Mongoose\r\n * internals.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.pre('save', function() {\r\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\r\n *       this.$locals.wasNew = this.isNew;\r\n *     });\r\n *\r\n *     schema.post('save', function() {\r\n *       // Prints true if `isNew` was set before `save()`\r\n *       console.log(this.$locals.wasNew);\r\n *     });\r\n *\r\n * @api public\r\n * @property $locals\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Document.prototype, '$locals', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  get: function() {\r\n    if (this.$__.locals == null) {\r\n      this.$__.locals = {};\r\n    }\r\n    return this.$__.locals;\r\n  },\r\n  set: function(v) {\r\n    this.$__.locals = v;\r\n  }\r\n});\r\n\r\n/**\r\n * Legacy alias for `$isNew`.\r\n *\r\n * @api public\r\n * @property isNew\r\n * @memberOf Document\r\n * @see $isNew #document_Document-$isNew\r\n * @instance\r\n */\r\n\r\nDocument.prototype.isNew;\r\n\r\n/**\r\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\r\n *\r\n * #### Example:\r\n *\r\n *     // Make sure `save()` never updates a soft deleted document.\r\n *     schema.pre('save', function() {\r\n *       this.$where = { isDeleted: false };\r\n *     });\r\n *\r\n * @api public\r\n * @property $where\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Document.prototype, '$where', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  writable: true\r\n});\r\n\r\n/**\r\n * The string version of this documents _id.\r\n *\r\n * #### Note:\r\n *\r\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\r\n *\r\n *     new Schema({ name: String }, { id: false });\r\n *\r\n * @api public\r\n * @see Schema options /docs/guide.html#options\r\n * @property id\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.id;\r\n\r\n/**\r\n * Hash containing current validation $errors.\r\n *\r\n * @api public\r\n * @property $errors\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$errors;\r\n\r\n/**\r\n * A string containing the current operation that Mongoose is executing\r\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = new Model({ name: 'test' });\r\n *     doc.$op; // null\r\n *\r\n *     const promise = doc.save();\r\n *     doc.$op; // 'save'\r\n *\r\n *     await promise;\r\n *     doc.$op; // null\r\n *\r\n * @api public\r\n * @property $op\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Document.prototype, '$op', {\r\n  get: function() {\r\n    return this.$__.op || null;\r\n  },\r\n  set: function(value) {\r\n    this.$__.op = value;\r\n  }\r\n});\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction $applyDefaultsToNested(val, path, doc) {\r\n  if (val == null) {\r\n    return;\r\n  }\r\n\r\n  flattenObjectWithDottedPaths(val);\r\n\r\n  const paths = Object.keys(doc.$__schema.paths);\r\n  const plen = paths.length;\r\n\r\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\r\n\r\n  for (let i = 0; i < plen; ++i) {\r\n    let curPath = '';\r\n    const p = paths[i];\r\n\r\n    if (!p.startsWith(path + '.')) {\r\n      continue;\r\n    }\r\n\r\n    const type = doc.$__schema.paths[p];\r\n    const pieces = type.splitPath().slice(pathPieces.length);\r\n    const len = pieces.length;\r\n\r\n    if (type.defaultValue === void 0) {\r\n      continue;\r\n    }\r\n\r\n    let cur = val;\r\n\r\n    for (let j = 0; j < len; ++j) {\r\n      if (cur == null) {\r\n        break;\r\n      }\r\n\r\n      const piece = pieces[j];\r\n\r\n      if (j === len - 1) {\r\n        if (cur[piece] !== void 0) {\r\n          break;\r\n        }\r\n\r\n        try {\r\n          const def = type.getDefault(doc, false);\r\n          if (def !== void 0) {\r\n            cur[piece] = def;\r\n          }\r\n        } catch (err) {\r\n          doc.invalidate(path + '.' + curPath, err);\r\n          break;\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      curPath += (!curPath.length ? '' : '.') + piece;\r\n\r\n      cur[piece] = cur[piece] || {};\r\n      cur = cur[piece];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Builds the default doc structure\r\n *\r\n * @param {Object} obj\r\n * @param {Object} [fields]\r\n * @param {Boolean} [skipId]\r\n * @param {Boolean} [exclude]\r\n * @param {Object} [hasIncludedChildren]\r\n * @api private\r\n * @method $__buildDoc\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\r\n  const doc = {};\r\n\r\n  const paths = Object.keys(this.$__schema.paths).\r\n    // Don't build up any paths that are underneath a map, we don't know\r\n    // what the keys will be\r\n    filter(p => !p.includes('$*'));\r\n  const plen = paths.length;\r\n  let ii = 0;\r\n\r\n  for (; ii < plen; ++ii) {\r\n    const p = paths[ii];\r\n\r\n    if (p === '_id') {\r\n      if (skipId) {\r\n        continue;\r\n      }\r\n      if (obj && '_id' in obj) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    const path = this.$__schema.paths[p].splitPath();\r\n    const len = path.length;\r\n    const last = len - 1;\r\n    let curPath = '';\r\n    let doc_ = doc;\r\n    let included = false;\r\n\r\n    for (let i = 0; i < len; ++i) {\r\n      const piece = path[i];\r\n\r\n      if (!curPath.length) {\r\n        curPath = piece;\r\n      } else {\r\n        curPath += '.' + piece;\r\n      }\r\n\r\n      // support excluding intermediary levels\r\n      if (exclude === true) {\r\n        if (curPath in fields) {\r\n          break;\r\n        }\r\n      } else if (exclude === false && fields && !included) {\r\n        if (curPath in fields) {\r\n          included = true;\r\n        } else if (!hasIncludedChildren[curPath]) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (i < last) {\r\n        doc_ = doc_[piece] || (doc_[piece] = {});\r\n      }\r\n    }\r\n  }\r\n\r\n  this._doc = doc;\r\n};\r\n\r\n/*!\r\n * Converts to POJO when you use the document for querying\r\n */\r\n\r\nDocument.prototype.toBSON = function() {\r\n  return this.toObject(internalToObjectOptions);\r\n};\r\n\r\n/**\r\n * Initializes the document without setters or marking anything modified.\r\n *\r\n * Called internally after a document is returned from mongodb. Normally,\r\n * you do **not** need to call this function on your own.\r\n *\r\n * This function triggers `init` [middleware](/docs/middleware.html).\r\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\r\n *\r\n * @param {Object} doc document returned by mongo\r\n * @param {Object} [opts]\r\n * @param {Function} [fn]\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.init = function(doc, opts, fn) {\r\n  if (typeof opts === 'function') {\r\n    fn = opts;\r\n    opts = null;\r\n  }\r\n\r\n  this.$__init(doc, opts);\r\n\r\n  if (fn) {\r\n    fn(null, this);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Alias for [`.init`](#document_Document-init)\r\n *\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$init = function() {\r\n  return this.constructor.prototype.init.apply(this, arguments);\r\n};\r\n\r\n/**\r\n * Internal \"init\" function\r\n *\r\n * @param {Document} doc\r\n * @param {Object} [opts]\r\n * @returns {Document} this\r\n * @api private\r\n */\r\n\r\nDocument.prototype.$__init = function(doc, opts) {\r\n  this.$isNew = false;\r\n  opts = opts || {};\r\n\r\n  // handle docs with populated paths\r\n  // If doc._id is not null or undefined\r\n  if (doc._id != null && opts.populated && opts.populated.length) {\r\n    const id = String(doc._id);\r\n    for (const item of opts.populated) {\r\n      if (item.isVirtual) {\r\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\r\n      } else {\r\n        this.$populated(item.path, item._docs[id], item);\r\n      }\r\n\r\n      if (item._childDocs == null) {\r\n        continue;\r\n      }\r\n      for (const child of item._childDocs) {\r\n        if (child == null || child.$__ == null) {\r\n          continue;\r\n        }\r\n        child.$__.parent = this;\r\n      }\r\n      item._childDocs = [];\r\n    }\r\n  }\r\n\r\n  init(this, doc, this._doc, opts);\r\n\r\n  markArraySubdocsPopulated(this, opts.populated);\r\n\r\n  this.$emit('init', this);\r\n  this.constructor.emit('init', this);\r\n\r\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\r\n    $__hasIncludedChildren(this.$__.selected) :\r\n    null;\r\n\r\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Init helper.\r\n *\r\n * @param {Object} self document instance\r\n * @param {Object} obj raw mongodb doc\r\n * @param {Object} doc object we are initializing\r\n * @param {Object} [opts] Optional Options\r\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\r\n * @param {String} [prefix] Prefix to add to each path\r\n * @api private\r\n */\r\n\r\nfunction init(self, obj, doc, opts, prefix) {\r\n  prefix = prefix || '';\r\n\r\n  const keys = Object.keys(obj);\r\n  const len = keys.length;\r\n  let schemaType;\r\n  let path;\r\n  let i;\r\n  let index = 0;\r\n  const strict = self.$__.strictMode;\r\n  const docSchema = self.$__schema;\r\n\r\n  while (index < len) {\r\n    _init(index++);\r\n  }\r\n\r\n  function _init(index) {\r\n    i = keys[index];\r\n    path = prefix + i;\r\n    schemaType = docSchema.path(path);\r\n\r\n    // Should still work if not a model-level discriminator, but should not be\r\n    // necessary. This is *only* to catch the case where we queried using the\r\n    // base model and the discriminated model has a projection\r\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\r\n      return;\r\n    }\r\n\r\n    if (!schemaType && utils.isPOJO(obj[i])) {\r\n      // assume nested object\r\n      if (!doc[i]) {\r\n        doc[i] = {};\r\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\r\n          self[i] = doc[i];\r\n        }\r\n      }\r\n      init(self, obj[i], doc[i], opts, path + '.');\r\n    } else if (!schemaType) {\r\n      doc[i] = obj[i];\r\n      if (!strict && !prefix) {\r\n        self[i] = obj[i];\r\n      }\r\n    } else {\r\n      // Retain order when overwriting defaults\r\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\r\n        delete doc[i];\r\n      }\r\n      if (obj[i] === null) {\r\n        doc[i] = schemaType._castNullish(null);\r\n      } else if (obj[i] !== undefined) {\r\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\r\n\r\n        if (schemaType && !wasPopulated) {\r\n          try {\r\n            if (opts && opts.setters) {\r\n              // Call applySetters with `init = false` because otherwise setters are a noop\r\n              const overrideInit = false;\r\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\r\n            } else {\r\n              doc[i] = schemaType.cast(obj[i], self, true);\r\n            }\r\n          } catch (e) {\r\n            self.invalidate(e.path, new ValidatorError({\r\n              path: e.path,\r\n              message: e.message,\r\n              type: 'cast',\r\n              value: e.value,\r\n              reason: e\r\n            }));\r\n          }\r\n        } else {\r\n          doc[i] = obj[i];\r\n        }\r\n      }\r\n      // mark as hydrated\r\n      if (!self.$isModified(path)) {\r\n        self.$__.activePaths.init(path);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sends an update command with this document `_id` as the query selector.\r\n *\r\n * #### Example:\r\n *\r\n *     weirdCar.update({ $inc: { wheels:1 } }, { w: 1 }, callback);\r\n *\r\n * #### Valid options:\r\n *\r\n *  - same as in [Model.update](#model_Model-update)\r\n *\r\n * @see Model.update #model_Model-update\r\n * @param {...Object} ops\r\n * @param {Object} [options]\r\n * @param {Function} [callback]\r\n * @return {Query} this\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.update = function update() {\r\n  const args = [...arguments];\r\n  args.unshift({ _id: this._id });\r\n  const query = this.constructor.update.apply(this.constructor, args);\r\n\r\n  if (this.$session() != null) {\r\n    if (!('session' in query.options)) {\r\n      query.options.session = this.$session();\r\n    }\r\n  }\r\n\r\n  return query;\r\n};\r\n\r\n/**\r\n * Sends an updateOne command with this document `_id` as the query selector.\r\n *\r\n * #### Example:\r\n *\r\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\r\n *\r\n * #### Valid options:\r\n *\r\n *  - same as in [Model.updateOne](#model_Model-updateOne)\r\n *\r\n * @see Model.updateOne #model_Model-updateOne\r\n * @param {Object} doc\r\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)\r\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\r\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\r\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\r\n * @param {Function} [callback]\r\n * @return {Query}\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\r\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\r\n  const self = this;\r\n  query.pre(function queryPreUpdateOne(cb) {\r\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\r\n  });\r\n  query.post(function queryPostUpdateOne(cb) {\r\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\r\n  });\r\n\r\n  if (this.$session() != null) {\r\n    if (!('session' in query.options)) {\r\n      query.options.session = this.$session();\r\n    }\r\n  }\r\n\r\n  if (callback != null) {\r\n    return query.exec(callback);\r\n  }\r\n\r\n  return query;\r\n};\r\n\r\n/**\r\n * Sends a replaceOne command with this document `_id` as the query selector.\r\n *\r\n * #### Valid options:\r\n *\r\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model-replaceOne)\r\n *\r\n * @see Model.replaceOne #model_Model-replaceOne\r\n * @param {Object} doc\r\n * @param {Object} [options]\r\n * @param {Function} [callback]\r\n * @return {Query}\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.replaceOne = function replaceOne() {\r\n  const args = [...arguments];\r\n  args.unshift({ _id: this._id });\r\n  return this.constructor.replaceOne.apply(this.constructor, args);\r\n};\r\n\r\n/**\r\n * Getter/setter around the session associated with this document. Used to\r\n * automatically set `session` if you `save()` a doc that you got from a\r\n * query with an associated session.\r\n *\r\n * #### Example:\r\n *\r\n *     const session = MyModel.startSession();\r\n *     const doc = await MyModel.findOne().session(session);\r\n *     doc.$session() === session; // true\r\n *     doc.$session(null);\r\n *     doc.$session() === null; // true\r\n *\r\n * If this is a top-level document, setting the session propagates to all child\r\n * docs.\r\n *\r\n * @param {ClientSession} [session] overwrite the current session\r\n * @return {ClientSession}\r\n * @method $session\r\n * @api public\r\n * @memberOf Document\r\n */\r\n\r\nDocument.prototype.$session = function $session(session) {\r\n  if (arguments.length === 0) {\r\n    if (this.$__.session != null && this.$__.session.hasEnded) {\r\n      this.$__.session = null;\r\n      return null;\r\n    }\r\n    return this.$__.session;\r\n  }\r\n\r\n  if (session != null && session.hasEnded) {\r\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\r\n      'called `endSession()` on the session you are passing to `$session()`.');\r\n  }\r\n\r\n  if (session == null && this.$__.session == null) {\r\n    return;\r\n  }\r\n\r\n  this.$__.session = session;\r\n\r\n  if (!this.$isSubdocument) {\r\n    const subdocs = this.$getAllSubdocs();\r\n    for (const child of subdocs) {\r\n      child.$session(session);\r\n    }\r\n  }\r\n\r\n  return session;\r\n};\r\n\r\n/**\r\n * Getter/setter around whether this document will apply timestamps by\r\n * default when using `save()` and `bulkSave()`.\r\n *\r\n * #### Example:\r\n *\r\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\r\n *     const doc = new TestModel({ name: 'John Smith' });\r\n *\r\n *     doc.$timestamps(); // true\r\n *\r\n *     doc.$timestamps(false);\r\n *     await doc.save(); // Does **not** apply timestamps\r\n *\r\n * @param {Boolean} [value] overwrite the current session\r\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\r\n * @method $timestamps\r\n * @api public\r\n * @memberOf Document\r\n */\r\n\r\nDocument.prototype.$timestamps = function $timestamps(value) {\r\n  if (arguments.length === 0) {\r\n    if (this.$__.timestamps != null) {\r\n      return this.$__.timestamps;\r\n    }\r\n\r\n    if (this.$__schema) {\r\n      return this.$__schema.options.timestamps;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  const currentValue = this.$timestamps();\r\n  if (value !== currentValue) {\r\n    this.$__.timestamps = value;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Overwrite all values in this document with the values of `obj`, except\r\n * for immutable properties. Behaves similarly to `set()`, except for it\r\n * unsets all properties that aren't in `obj`.\r\n *\r\n * @param {Object} obj the object to overwrite this document with\r\n * @method overwrite\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n * @return {Document} this\r\n */\r\n\r\nDocument.prototype.overwrite = function overwrite(obj) {\r\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\r\n\r\n  for (const key of keys) {\r\n    if (key === '_id') {\r\n      continue;\r\n    }\r\n    // Explicitly skip version key\r\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\r\n      continue;\r\n    }\r\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\r\n      continue;\r\n    }\r\n    this.$set(key, obj[key]);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Alias for `set()`, used internally to avoid conflicts\r\n *\r\n * @param {String|Object} path path or object of key/vals to set\r\n * @param {Any} val the value to set\r\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\r\n * @param {Object} [options] optionally specify options that modify the behavior of the set\r\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\r\n * @return {Document} this\r\n * @method $set\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$set = function $set(path, val, type, options) {\r\n  if (utils.isPOJO(type)) {\r\n    options = type;\r\n    type = undefined;\r\n  }\r\n\r\n  const merge = options && options.merge;\r\n  const adhoc = type && type !== true;\r\n  const constructing = type === true;\r\n  let adhocs;\r\n  let keys;\r\n  let i = 0;\r\n  let pathtype;\r\n  let key;\r\n  let prefix;\r\n\r\n  const strict = options && 'strict' in options\r\n    ? options.strict\r\n    : this.$__.strictMode;\r\n\r\n  if (adhoc) {\r\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\r\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\r\n  }\r\n\r\n  if (path == null) {\r\n    [path, val] = [val, path];\r\n  } else if (typeof path !== 'string') {\r\n    // new Document({ key: val })\r\n    if (path instanceof Document) {\r\n      if (path.$__isNested) {\r\n        path = path.toObject();\r\n      } else {\r\n        path = path._doc;\r\n      }\r\n    }\r\n    if (path == null) {\r\n      [path, val] = [val, path];\r\n    }\r\n\r\n    prefix = val ? val + '.' : '';\r\n    keys = getKeysInSchemaOrder(this.$__schema, path);\r\n\r\n    const len = keys.length;\r\n\r\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\r\n    // nested key to ensure key order.\r\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\r\n    if (len === 0 && _skipMinimizeTopLevel) {\r\n      delete options._skipMinimizeTopLevel;\r\n      if (val) {\r\n        this.$set(val, {});\r\n      }\r\n      return this;\r\n    }\r\n\r\n    for (let i = 0; i < len; ++i) {\r\n      key = keys[i];\r\n      const pathName = prefix + key;\r\n      pathtype = this.$__schema.pathType(pathName);\r\n      const valForKey = path[key];\r\n\r\n      // On initial set, delete any nested keys if we're going to overwrite\r\n      // them to ensure we keep the user's key order.\r\n      if (type === true &&\r\n          !prefix &&\r\n          valForKey != null &&\r\n          pathtype === 'nested' &&\r\n          this._doc[key] != null) {\r\n        delete this._doc[key];\r\n        // Make sure we set `{}` back even if we minimize re: gh-8565\r\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\r\n      } else {\r\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\r\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\r\n      }\r\n\r\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\r\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, { _skipMarkModified: true }));\r\n        $applyDefaultsToNested(this.$get(prefix + key), prefix + key, this);\r\n        continue;\r\n      } else if (strict) {\r\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\r\n        if (constructing && path[key] === void 0 &&\r\n            this.$get(pathName) !== void 0) {\r\n          continue;\r\n        }\r\n\r\n        if (pathtype === 'adhocOrUndefined') {\r\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\r\n        }\r\n\r\n        if (pathtype === 'real' || pathtype === 'virtual') {\r\n          const p = path[key];\r\n          this.$set(prefix + key, p, constructing, options);\r\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\r\n          this.$set(prefix + key,\r\n            path[key].toObject({ transform: false }), constructing, options);\r\n        } else if (strict === 'throw') {\r\n          if (pathtype === 'nested') {\r\n            throw new ObjectExpectedError(key, path[key]);\r\n          } else {\r\n            throw new StrictModeError(key);\r\n          }\r\n        }\r\n      } else if (path[key] !== void 0) {\r\n        this.$set(prefix + key, path[key], constructing, options);\r\n      }\r\n    }\r\n\r\n    // Ensure all properties are in correct order\r\n    const orderedDoc = {};\r\n    const orderedKeys = Object.keys(this.$__schema.tree);\r\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\r\n      (key = orderedKeys[i]) &&\r\n      (this._doc.hasOwnProperty(key)) &&\r\n      (orderedDoc[key] = undefined);\r\n    }\r\n    this._doc = Object.assign(orderedDoc, this._doc);\r\n\r\n    return this;\r\n  }\r\n\r\n  let pathType = this.$__schema.pathType(path);\r\n  if (pathType === 'adhocOrUndefined') {\r\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\r\n  }\r\n\r\n  // Assume this is a Mongoose document that was copied into a POJO using\r\n  // `Object.assign()` or `{...doc}`\r\n  val = handleSpreadDoc(val);\r\n\r\n  // if this doc is being constructed we should not trigger getters\r\n  const priorVal = (() => {\r\n    if (this.$__.priorDoc != null) {\r\n      return this.$__.priorDoc.$__getValue(path);\r\n    }\r\n    if (constructing) {\r\n      return void 0;\r\n    }\r\n    return this.$__getValue(path);\r\n  })();\r\n\r\n  if (pathType === 'nested' && val) {\r\n    if (typeof val === 'object' && val != null) {\r\n      if (val.$__ != null) {\r\n        val = val.toObject(internalToObjectOptions);\r\n      }\r\n      if (val == null) {\r\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\r\n        return this;\r\n      }\r\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\r\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\r\n        const initialVal = this.$__getValue(path);\r\n        this.$__.savedState[path] = initialVal;\r\n\r\n        const keys = Object.keys(initialVal || {});\r\n        for (const key of keys) {\r\n          this.$__.savedState[path + '.' + key] = initialVal[key];\r\n        }\r\n      }\r\n\r\n      if (!merge) {\r\n        this.$__setValue(path, null);\r\n        cleanModifiedSubpaths(this, path);\r\n      } else {\r\n        return this.$set(val, path, constructing);\r\n      }\r\n\r\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\r\n\r\n      this.$__setValue(path, {});\r\n      for (const key of keys) {\r\n        this.$set(path + '.' + key, val[key], constructing, options);\r\n      }\r\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\r\n        this.unmarkModified(path);\r\n      } else {\r\n        this.markModified(path);\r\n      }\r\n      return this;\r\n    }\r\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\r\n    return this;\r\n  }\r\n\r\n  let schema;\r\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\r\n\r\n  // Might need to change path for top-level alias\r\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\r\n    parts[0] = this.$__schema.aliases[parts[0]];\r\n  }\r\n\r\n  if (pathType === 'adhocOrUndefined' && strict) {\r\n    // check for roots that are Mixed types\r\n    let mixed;\r\n\r\n    for (i = 0; i < parts.length; ++i) {\r\n      const subpath = parts.slice(0, i + 1).join('.');\r\n\r\n      // If path is underneath a virtual, bypass everything and just set it.\r\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\r\n        mpath.set(path, val, this);\r\n        return this;\r\n      }\r\n\r\n      schema = this.$__schema.path(subpath);\r\n      if (schema == null) {\r\n        continue;\r\n      }\r\n\r\n      if (schema instanceof MixedSchema) {\r\n        // allow changes to sub paths of mixed types\r\n        mixed = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (schema == null) {\r\n      // Check for embedded discriminators\r\n      schema = getEmbeddedDiscriminatorPath(this, path);\r\n    }\r\n\r\n    if (!mixed && !schema) {\r\n      if (strict === 'throw') {\r\n        throw new StrictModeError(path);\r\n      }\r\n      return this;\r\n    }\r\n  } else if (pathType === 'virtual') {\r\n    schema = this.$__schema.virtualpath(path);\r\n    schema.applySetters(val, this);\r\n    return this;\r\n  } else {\r\n    schema = this.$__path(path);\r\n  }\r\n\r\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\r\n  let cur = this._doc;\r\n  let curPath = '';\r\n  for (i = 0; i < parts.length - 1; ++i) {\r\n    cur = cur[parts[i]];\r\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\r\n    if (!cur) {\r\n      this.$set(curPath, {});\r\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\r\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\r\n      // traverse the element ({nested: null})` is not likely. If user gets\r\n      // that error, its their fault for now. We should reconsider disallowing\r\n      // modifying not selected paths for 6.x\r\n      if (!this.$__isSelected(curPath)) {\r\n        this.unmarkModified(curPath);\r\n      }\r\n      cur = this.$__getValue(curPath);\r\n    }\r\n  }\r\n\r\n  let pathToMark;\r\n\r\n  // When using the $set operator the path to the field must already exist.\r\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\r\n\r\n  if (parts.length <= 1) {\r\n    pathToMark = path;\r\n  } else {\r\n    const len = parts.length;\r\n    for (i = 0; i < len; ++i) {\r\n      const subpath = parts.slice(0, i + 1).join('.');\r\n      if (this.$get(subpath, null, { getters: false }) === null) {\r\n        pathToMark = subpath;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!pathToMark) {\r\n      pathToMark = path;\r\n    }\r\n  }\r\n\r\n  if (!schema) {\r\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\r\n\r\n    if (pathType === 'nested' && val == null) {\r\n      cleanModifiedSubpaths(this, path);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  // If overwriting a subdocument path, make sure to clear out\r\n  // any errors _before_ setting, so new errors that happen\r\n  // get persisted. Re: #9080\r\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\r\n    _markValidSubpaths(this, path);\r\n  }\r\n\r\n  if (val != null && merge && schema.$isSingleNested) {\r\n    if (val instanceof Document) {\r\n      val = val.toObject({ virtuals: false, transform: false });\r\n    }\r\n    const keys = Object.keys(val);\r\n    for (const key of keys) {\r\n      this.$set(path + '.' + key, val[key], constructing, options);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  let shouldSet = true;\r\n  try {\r\n    // If the user is trying to set a ref path to a document with\r\n    // the correct model name, treat it as populated\r\n    const refMatches = (() => {\r\n      if (schema.options == null) {\r\n        return false;\r\n      }\r\n      if (!(val instanceof Document)) {\r\n        return false;\r\n      }\r\n      const model = val.constructor;\r\n\r\n      // Check ref\r\n      const ref = schema.options.ref;\r\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\r\n        return true;\r\n      }\r\n\r\n      // Check refPath\r\n      const refPath = schema.options.refPath;\r\n      if (refPath == null) {\r\n        return false;\r\n      }\r\n      const modelName = val.get(refPath);\r\n      return modelName === model.modelName || modelName === model.baseModelName;\r\n    })();\r\n\r\n    let didPopulate = false;\r\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\r\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\r\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\r\n      val.$__.wasPopulated = { value: unpopulatedValue };\r\n      didPopulate = true;\r\n    }\r\n\r\n    let popOpts;\r\n    const typeKey = this.$__schema.options.typeKey;\r\n    if (schema.options &&\r\n        Array.isArray(schema.options[typeKey]) &&\r\n        schema.options[typeKey].length &&\r\n        schema.options[typeKey][0].ref &&\r\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\r\n      popOpts = { [populateModelSymbol]: val[0].constructor };\r\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\r\n\r\n      for (const doc of val) {\r\n        doc.$__.wasPopulated = { value: doc._id };\r\n      }\r\n      didPopulate = true;\r\n    }\r\n\r\n    if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {\r\n      // If this path is underneath a single nested schema, we'll call the setter\r\n      // later in `$__set()` because we don't take `_doc` when we iterate through\r\n      // a single nested doc. That's to make sure we get the correct context.\r\n      // Otherwise we would double-call the setter, see gh-7196.\r\n      if (options != null && options.overwriteImmutable) {\r\n        val = schema.applySetters(val, this, false, priorVal, { overwriteImmutable: true });\r\n      } else {\r\n        val = schema.applySetters(val, this, false, priorVal);\r\n      }\r\n    }\r\n\r\n    if (Array.isArray(val) &&\r\n        !Array.isArray(schema) &&\r\n        schema.$isMongooseDocumentArray &&\r\n        val.length !== 0 &&\r\n        val[0] != null &&\r\n        val[0].$__ != null &&\r\n        val[0].$__.populated != null) {\r\n      const populatedPaths = Object.keys(val[0].$__.populated);\r\n      for (const populatedPath of populatedPaths) {\r\n        this.$populated(path + '.' + populatedPath,\r\n          val.map(v => v.$populated(populatedPath)),\r\n          val[0].$__.populated[populatedPath].options);\r\n      }\r\n      didPopulate = true;\r\n    }\r\n\r\n    if (!didPopulate && this.$__.populated) {\r\n      // If this array partially contains populated documents, convert them\r\n      // all to ObjectIds re: #8443\r\n      if (Array.isArray(val) && this.$__.populated[path]) {\r\n        for (let i = 0; i < val.length; ++i) {\r\n          if (val[i] instanceof Document) {\r\n            val.set(i, val[i]._id, true);\r\n          }\r\n        }\r\n      }\r\n      delete this.$__.populated[path];\r\n    }\r\n\r\n    if (val != null && schema.$isSingleNested) {\r\n      _checkImmutableSubpaths(val, schema, priorVal);\r\n    }\r\n\r\n    this.$markValid(path);\r\n  } catch (e) {\r\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\r\n      this.invalidate(path, e);\r\n    } else if (e instanceof MongooseError.CastError) {\r\n      this.invalidate(e.path, e);\r\n      if (e.$originalErrorPath) {\r\n        this.invalidate(path,\r\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\r\n      }\r\n    } else {\r\n      this.invalidate(path,\r\n        new MongooseError.CastError(schema.instance, val, path, e));\r\n    }\r\n    shouldSet = false;\r\n  }\r\n\r\n  if (shouldSet) {\r\n    let savedState = null;\r\n    let savedStatePath = null;\r\n    if (!constructing) {\r\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\r\n      savedState = doc.$__.savedState;\r\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\r\n      doc.$__saveInitialState(savedStatePath);\r\n    }\r\n\r\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\r\n\r\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\r\n      this.unmarkModified(path);\r\n    }\r\n  }\r\n\r\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\r\n    cleanModifiedSubpaths(this, path);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _isManuallyPopulatedArray(val, ref) {\r\n  if (!Array.isArray(val)) {\r\n    return false;\r\n  }\r\n  if (val.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  for (const el of val) {\r\n    if (!(el instanceof Document)) {\r\n      return false;\r\n    }\r\n    const modelName = el.constructor.modelName;\r\n    if (modelName == null) {\r\n      return false;\r\n    }\r\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Sets the value of a path, or many paths.\r\n * Alias for [`.$set`](#document_Document-$set).\r\n *\r\n * #### Example:\r\n *\r\n *     // path, value\r\n *     doc.set(path, value)\r\n *\r\n *     // object\r\n *     doc.set({\r\n *         path  : value\r\n *       , path2 : {\r\n *            path  : value\r\n *         }\r\n *     })\r\n *\r\n *     // on-the-fly cast to number\r\n *     doc.set(path, value, Number)\r\n *\r\n *     // on-the-fly cast to string\r\n *     doc.set(path, value, String)\r\n *\r\n *     // changing strict mode behavior\r\n *     doc.set(path, value, { strict: false });\r\n *\r\n * @param {String|Object} path path or object of key/vals to set\r\n * @param {Any} val the value to set\r\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\r\n * @param {Object} [options] optionally specify options that modify the behavior of the set\r\n * @return {Document} this\r\n * @api public\r\n * @method set\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.set = Document.prototype.$set;\r\n\r\n/**\r\n * Determine if we should mark this change as modified.\r\n *\r\n * @param {never} pathToMark UNUSED\r\n * @param {String|Symbol} path\r\n * @param {Object} options\r\n * @param {Any} constructing\r\n * @param {never} parts UNUSED\r\n * @param {Schema} schema\r\n * @param {Any} val\r\n * @param {Any} priorVal\r\n * @return {Boolean}\r\n * @api private\r\n * @method $__shouldModify\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\r\n  if (options && options._skipMarkModified) {\r\n    return false;\r\n  }\r\n  if (this.$isNew) {\r\n    return true;\r\n  }\r\n  // Is path already modified? If so, always modify. We may unmark modified later.\r\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\r\n    return true;\r\n  }\r\n\r\n  // Re: the note about gh-7196, `val` is the raw value without casting or\r\n  // setters if the full path is under a single nested subdoc because we don't\r\n  // want to double run setters. So don't set it as modified. See gh-7264.\r\n  if (this.$__schema.singleNestedPaths[path] != null) {\r\n    return false;\r\n  }\r\n\r\n  if (val === void 0 && !this.$__isSelected(path)) {\r\n    // when a path is not selected in a query, its initial\r\n    // value will be undefined.\r\n    return true;\r\n  }\r\n\r\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\r\n    // we're just unsetting the default value which was never saved\r\n    return false;\r\n  }\r\n\r\n  // gh-3992: if setting a populated field to a doc, don't mark modified\r\n  // if they have the same _id\r\n  if (this.$populated(path) &&\r\n      val instanceof Document &&\r\n      deepEqual(val._id, priorVal)) {\r\n    return false;\r\n  }\r\n\r\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\r\n    return true;\r\n  }\r\n\r\n  if (!constructing &&\r\n      val !== null &&\r\n      val !== undefined &&\r\n      path in this.$__.activePaths.getStatePaths('default') &&\r\n      deepEqual(val, schema.getDefault(this, constructing))) {\r\n    // a path with a default was $unset on the server\r\n    // and the user is setting it to the same value again\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Handles the actual setting of the value and marking the path modified if appropriate.\r\n *\r\n * @param {String} pathToMark\r\n * @param {String|Symbol} path\r\n * @param {Object} options\r\n * @param {Any} constructing\r\n * @param {Array} parts\r\n * @param {Schema} schema\r\n * @param {Any} val\r\n * @param {Any} priorVal\r\n * @api private\r\n * @method $__set\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\r\n  Embedded = Embedded || require('./types/ArraySubdocument');\r\n\r\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\r\n    schema, val, priorVal);\r\n\r\n  if (shouldModify) {\r\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\r\n      delete this.$__.primitiveAtomics[path];\r\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\r\n        delete this.$__.primitiveAtomics;\r\n      }\r\n    }\r\n    this.markModified(pathToMark);\r\n\r\n    // handle directly setting arrays (gh-1126)\r\n    MongooseArray || (MongooseArray = require('./types/array'));\r\n    if (val && utils.isMongooseArray(val)) {\r\n      val._registerAtomic('$set', val);\r\n\r\n      // Update embedded document parent references (gh-5189)\r\n      if (utils.isMongooseDocumentArray(val)) {\r\n        val.forEach(function(item) {\r\n          item && item.__parentArray && (item.__parentArray = val);\r\n        });\r\n      }\r\n    }\r\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\r\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\r\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\r\n    if (utils.isMongooseDocumentArray(val)) {\r\n      val.forEach(doc => { doc.isNew = false; });\r\n    }\r\n  }\r\n\r\n  let obj = this._doc;\r\n  let i = 0;\r\n  const l = parts.length;\r\n  let cur = '';\r\n\r\n  for (; i < l; i++) {\r\n    const next = i + 1;\r\n    const last = next === l;\r\n    cur += (cur ? '.' + parts[i] : parts[i]);\r\n    if (specialProperties.has(parts[i])) {\r\n      return;\r\n    }\r\n\r\n    if (last) {\r\n      if (obj instanceof Map) {\r\n        obj.set(parts[i], val);\r\n      } else {\r\n        obj[parts[i]] = val;\r\n      }\r\n    } else {\r\n      if (utils.isPOJO(obj[parts[i]])) {\r\n        obj = obj[parts[i]];\r\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\r\n        obj = obj[parts[i]];\r\n      } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {\r\n        obj = obj[parts[i]];\r\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\r\n        obj = obj[parts[i]];\r\n      } else {\r\n        obj[parts[i]] = obj[parts[i]] || {};\r\n        obj = obj[parts[i]];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Gets a raw value from a path (no getters)\r\n *\r\n * @param {String} path\r\n * @return {Any} Returns the value from the given `path`.\r\n * @api private\r\n */\r\n\r\nDocument.prototype.$__getValue = function(path) {\r\n  return utils.getValue(path, this._doc);\r\n};\r\n\r\n/**\r\n * Increments the numeric value at `path` by the given `val`.\r\n * When you call `save()` on this document, Mongoose will send a\r\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\r\n * as opposed to a `$set`.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ counter: Number });\r\n *     const Test = db.model('Test', schema);\r\n *\r\n *     const doc = await Test.create({ counter: 0 });\r\n *     doc.$inc('counter', 2);\r\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\r\n *     doc.counter; // 2\r\n *\r\n *     doc.counter += 2;\r\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\r\n *\r\n * @param {String|Array} path path or paths to update\r\n * @param {Number} val increment `path` by this value\r\n * @return {Document} this\r\n */\r\n\r\nDocument.prototype.$inc = function $inc(path, val) {\r\n  if (val == null) {\r\n    val = 1;\r\n  }\r\n\r\n  if (Array.isArray(path)) {\r\n    path.forEach((p) => this.$inc(p, val));\r\n    return this;\r\n  }\r\n\r\n  const schemaType = this.$__path(path);\r\n  if (schemaType == null) {\r\n    if (this.$__.strictMode === 'throw') {\r\n      throw new StrictModeError(path);\r\n    } else if (this.$__.strictMode === true) {\r\n      return this;\r\n    }\r\n  } else if (schemaType.instance !== 'Number') {\r\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\r\n    return this;\r\n  }\r\n\r\n  try {\r\n    val = castNumber(val);\r\n  } catch (err) {\r\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\r\n  }\r\n\r\n  const currentValue = this.$__getValue(path) || 0;\r\n\r\n  this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\r\n  this.$__.primitiveAtomics[path] = { $inc: val };\r\n  this.markModified(path);\r\n  this.$__setValue(path, currentValue + val);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets a raw value for a path (no casting, setters, transformations)\r\n *\r\n * @param {String} path\r\n * @param {Object} value\r\n * @return {Document} this\r\n * @api private\r\n */\r\n\r\nDocument.prototype.$__setValue = function(path, val) {\r\n  utils.setValue(path, val, this._doc);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the value of a path.\r\n *\r\n * #### Example:\r\n *\r\n *     // path\r\n *     doc.get('age') // 47\r\n *\r\n *     // dynamic casting to a string\r\n *     doc.get('age', String) // \"47\"\r\n *\r\n * @param {String} path\r\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\r\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\r\n * @return {Any}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.get = function(path, type, options) {\r\n  let adhoc;\r\n  options = options || {};\r\n  if (type) {\r\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\r\n  }\r\n\r\n  let schema = this.$__path(path);\r\n  if (schema == null) {\r\n    schema = this.$__schema.virtualpath(path);\r\n  }\r\n  if (schema instanceof MixedSchema) {\r\n    const virtual = this.$__schema.virtualpath(path);\r\n    if (virtual != null) {\r\n      schema = virtual;\r\n    }\r\n  }\r\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\r\n  let obj = this._doc;\r\n\r\n  if (schema instanceof VirtualType) {\r\n    return schema.applyGetters(void 0, this);\r\n  }\r\n\r\n  // Might need to change path for top-level alias\r\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\r\n    pieces[0] = this.$__schema.aliases[pieces[0]];\r\n  }\r\n\r\n  for (let i = 0, l = pieces.length; i < l; i++) {\r\n    if (obj && obj._doc) {\r\n      obj = obj._doc;\r\n    }\r\n\r\n    if (obj == null) {\r\n      obj = void 0;\r\n    } else if (obj instanceof Map) {\r\n      obj = obj.get(pieces[i], { getters: false });\r\n    } else if (i === l - 1) {\r\n      obj = utils.getValue(pieces[i], obj);\r\n    } else {\r\n      obj = obj[pieces[i]];\r\n    }\r\n  }\r\n\r\n  if (adhoc) {\r\n    obj = adhoc.cast(obj);\r\n  }\r\n\r\n  if (schema != null && options.getters !== false) {\r\n    obj = schema.applyGetters(obj, this);\r\n  } else if (this.$__schema.nested[path] && options.virtuals) {\r\n    // Might need to apply virtuals if this is a nested path\r\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nDocument.prototype[getSymbol] = Document.prototype.get;\r\nDocument.prototype.$get = Document.prototype.get;\r\n\r\n/**\r\n * Returns the schematype for the given `path`.\r\n *\r\n * @param {String} path\r\n * @return {SchemaPath}\r\n * @api private\r\n * @method $__path\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__path = function(path) {\r\n  const adhocs = this.$__.adhocPaths;\r\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\r\n\r\n  if (adhocType) {\r\n    return adhocType;\r\n  }\r\n  return this.$__schema.path(path);\r\n};\r\n\r\n/**\r\n * Marks the path as having pending changes to write to the db.\r\n *\r\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\r\n *\r\n * #### Example:\r\n *\r\n *     doc.mixed.type = 'changed';\r\n *     doc.markModified('mixed.type');\r\n *     doc.save() // changes to mixed.type are now persisted\r\n *\r\n * @param {String} path the path to mark modified\r\n * @param {Document} [scope] the scope to run validators with\r\n * @api public\r\n */\r\n\r\nDocument.prototype.markModified = function(path, scope) {\r\n  this.$__saveInitialState(path);\r\n\r\n  this.$__.activePaths.modify(path);\r\n  if (scope != null && !this.$isSubdocument) {\r\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\r\n    this.$__.pathsToScopes[path] = scope;\r\n  }\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\r\n  const savedState = this.$__.savedState;\r\n  const savedStatePath = path;\r\n  if (savedState != null) {\r\n    const firstDot = savedStatePath.indexOf('.');\r\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\r\n    if (!savedState.hasOwnProperty(topLevelPath)) {\r\n      savedState[topLevelPath] = utils.clone(this.$__getValue(topLevelPath));\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Clears the modified state on the specified path.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.foo = 'bar';\r\n *     doc.unmarkModified('foo');\r\n *     doc.save(); // changes to foo will not be persisted\r\n *\r\n * @param {String} path the path to unmark modified\r\n * @api public\r\n */\r\n\r\nDocument.prototype.unmarkModified = function(path) {\r\n  this.$__.activePaths.init(path);\r\n  if (this.$__.pathsToScopes != null) {\r\n    delete this.$__.pathsToScopes[path];\r\n  }\r\n};\r\n\r\n/**\r\n * Don't run validation on this path or persist changes to this path.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.foo = null;\r\n *     doc.$ignore('foo');\r\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\r\n *\r\n * @memberOf Document\r\n * @instance\r\n * @method $ignore\r\n * @param {String} path the path to ignore\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$ignore = function(path) {\r\n  this.$__.activePaths.ignore(path);\r\n};\r\n\r\n/**\r\n * Returns the list of paths that have been directly modified. A direct\r\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\r\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\r\n *\r\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\r\n * because a child of `a` was directly modified.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\r\n *     const Model = mongoose.model('Test', schema);\r\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\r\n *\r\n *     const doc = await Model.findOne();\r\n *     doc.nested.bar = 'modified';\r\n *     doc.directModifiedPaths(); // ['nested.bar']\r\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\r\n *\r\n * @return {String[]}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.directModifiedPaths = function() {\r\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\r\n};\r\n\r\n/**\r\n * Returns true if the given path is nullish or only contains empty objects.\r\n * Useful for determining whether this subdoc will get stripped out by the\r\n * [minimize option](/docs/guide.html#minimize).\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ nested: { foo: String } });\r\n *     const Model = mongoose.model('Test', schema);\r\n *     const doc = new Model({});\r\n *     doc.$isEmpty('nested'); // true\r\n *     doc.nested.$isEmpty(); // true\r\n *\r\n *     doc.nested.foo = 'bar';\r\n *     doc.$isEmpty('nested'); // false\r\n *     doc.nested.$isEmpty(); // false\r\n *\r\n * @param {String} [path]\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n * @method $isEmpty\r\n * @return {Boolean}\r\n */\r\n\r\nDocument.prototype.$isEmpty = function(path) {\r\n  const isEmptyOptions = {\r\n    minimize: true,\r\n    virtuals: false,\r\n    getters: false,\r\n    transform: false\r\n  };\r\n\r\n  if (arguments.length !== 0) {\r\n    const v = this.$get(path);\r\n    if (v == null) {\r\n      return true;\r\n    }\r\n    if (typeof v !== 'object') {\r\n      return false;\r\n    }\r\n    if (utils.isPOJO(v)) {\r\n      return _isEmpty(v);\r\n    }\r\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\r\n  }\r\n\r\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _isEmpty(v) {\r\n  if (v == null) {\r\n    return true;\r\n  }\r\n  if (typeof v !== 'object' || Array.isArray(v)) {\r\n    return false;\r\n  }\r\n  for (const key of Object.keys(v)) {\r\n    if (!_isEmpty(v[key])) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Returns the list of paths that have been modified.\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\r\n * @return {String[]}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.modifiedPaths = function(options) {\r\n  options = options || {};\r\n\r\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\r\n  const result = new Set();\r\n\r\n  let i = 0;\r\n  let j = 0;\r\n  const len = directModifiedPaths.length;\r\n\r\n  for (i = 0; i < len; ++i) {\r\n    const path = directModifiedPaths[i];\r\n    const parts = parentPaths(path);\r\n    const pLen = parts.length;\r\n\r\n    for (j = 0; j < pLen; ++j) {\r\n      result.add(parts[j]);\r\n    }\r\n\r\n    if (!options.includeChildren) {\r\n      continue;\r\n    }\r\n\r\n    let ii = 0;\r\n    let cur = this.$get(path);\r\n    if (typeof cur === 'object' && cur !== null) {\r\n      if (cur._doc) {\r\n        cur = cur._doc;\r\n      }\r\n      const len = cur.length;\r\n      if (Array.isArray(cur)) {\r\n        for (ii = 0; ii < len; ++ii) {\r\n          const subPath = path + '.' + ii;\r\n          if (!result.has(subPath)) {\r\n            result.add(subPath);\r\n            if (cur[ii] != null && cur[ii].$__) {\r\n              const modified = cur[ii].modifiedPaths();\r\n              let iii = 0;\r\n              const iiiLen = modified.length;\r\n              for (iii = 0; iii < iiiLen; ++iii) {\r\n                result.add(subPath + '.' + modified[iii]);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        const keys = Object.keys(cur);\r\n        let ii = 0;\r\n        const len = keys.length;\r\n        for (ii = 0; ii < len; ++ii) {\r\n          result.add(path + '.' + keys[ii]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return Array.from(result);\r\n};\r\n\r\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\r\n\r\n/**\r\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\r\n * in this document is modified.\r\n *\r\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.set('documents.0.title', 'changed');\r\n *     doc.isModified()                      // true\r\n *     doc.isModified('documents')           // true\r\n *     doc.isModified('documents.0.title')   // true\r\n *     doc.isModified('documents otherProp') // true\r\n *     doc.isDirectModified('documents')     // false\r\n *\r\n * @param {String} [path] optional\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.isModified = function(paths, modifiedPaths) {\r\n  if (paths) {\r\n    const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\r\n    if (directModifiedPaths.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (!Array.isArray(paths)) {\r\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\r\n    }\r\n    const modified = modifiedPaths || this[documentModifiedPaths]();\r\n    const isModifiedChild = paths.some(function(path) {\r\n      return !!~modified.indexOf(path);\r\n    });\r\n\r\n    return isModifiedChild || paths.some(function(path) {\r\n      return directModifiedPaths.some(function(mod) {\r\n        return mod === path || path.startsWith(mod + '.');\r\n      });\r\n    });\r\n  }\r\n\r\n  return this.$__.activePaths.some('modify');\r\n};\r\n\r\n/**\r\n * Alias of [`.isModified`](#document_Document-isModified)\r\n *\r\n * @method $isModified\r\n * @memberOf Document\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$isModified = Document.prototype.isModified;\r\n\r\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\r\n\r\n/**\r\n * Checks if a path is set to its default.\r\n *\r\n * #### Example:\r\n *\r\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\r\n *     const m = new MyModel();\r\n *     m.$isDefault('name'); // true\r\n *\r\n * @memberOf Document\r\n * @instance\r\n * @method $isDefault\r\n * @param {String} [path]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$isDefault = function(path) {\r\n  if (path == null) {\r\n    return this.$__.activePaths.some('default');\r\n  }\r\n\r\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\r\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\r\n  }\r\n\r\n  let paths = path;\r\n  if (!Array.isArray(paths)) {\r\n    paths = paths.split(' ');\r\n  }\r\n\r\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\r\n};\r\n\r\n/**\r\n * Getter/setter, determines whether the document was removed or not.\r\n *\r\n * #### Example:\r\n *\r\n *     const product = await product.remove();\r\n *     product.$isDeleted(); // true\r\n *     product.remove(); // no-op, doesn't send anything to the db\r\n *\r\n *     product.$isDeleted(false);\r\n *     product.$isDeleted(); // false\r\n *     product.remove(); // will execute a remove against the db\r\n *\r\n *\r\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\r\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\r\n * @method $isDeleted\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$isDeleted = function(val) {\r\n  if (arguments.length === 0) {\r\n    return !!this.$__.isDeleted;\r\n  }\r\n\r\n  this.$__.isDeleted = !!val;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns true if `path` was directly set and modified, else false.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.set('documents.0.title', 'changed');\r\n *     doc.isDirectModified('documents.0.title') // true\r\n *     doc.isDirectModified('documents') // false\r\n *\r\n * @param {String|String[]} [path]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.isDirectModified = function(path) {\r\n  if (path == null) {\r\n    return this.$__.activePaths.some('modify');\r\n  }\r\n\r\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\r\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\r\n  }\r\n\r\n  let paths = path;\r\n  if (!Array.isArray(paths)) {\r\n    paths = paths.split(' ');\r\n  }\r\n\r\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\r\n};\r\n\r\n/**\r\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\r\n *\r\n * @param {String} [path]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.isInit = function(path) {\r\n  if (path == null) {\r\n    return this.$__.activePaths.some('init');\r\n  }\r\n\r\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\r\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\r\n  }\r\n\r\n  let paths = path;\r\n  if (!Array.isArray(paths)) {\r\n    paths = paths.split(' ');\r\n  }\r\n\r\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\r\n};\r\n\r\n/**\r\n * Checks if `path` was selected in the source query which initialized this document.\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = await Thing.findOne().select('name');\r\n *     doc.isSelected('name') // true\r\n *     doc.isSelected('age')  // false\r\n *\r\n * @param {String|String[]} path\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.isSelected = function isSelected(path) {\r\n  if (this.$__.selected == null) {\r\n    return true;\r\n  }\r\n  if (!path) {\r\n    return false;\r\n  }\r\n  if (path === '_id') {\r\n    return this.$__.selected._id !== 0;\r\n  }\r\n\r\n  if (path.indexOf(' ') !== -1) {\r\n    path = path.split(' ');\r\n  }\r\n  if (Array.isArray(path)) {\r\n    return path.some(p => this.$__isSelected(p));\r\n  }\r\n\r\n  const paths = Object.keys(this.$__.selected);\r\n  let inclusive = null;\r\n\r\n  if (paths.length === 1 && paths[0] === '_id') {\r\n    // only _id was selected.\r\n    return this.$__.selected._id === 0;\r\n  }\r\n\r\n  for (const cur of paths) {\r\n    if (cur === '_id') {\r\n      continue;\r\n    }\r\n    if (!isDefiningProjection(this.$__.selected[cur])) {\r\n      continue;\r\n    }\r\n    inclusive = !!this.$__.selected[cur];\r\n    break;\r\n  }\r\n\r\n  if (inclusive === null) {\r\n    return true;\r\n  }\r\n\r\n  if (path in this.$__.selected) {\r\n    return inclusive;\r\n  }\r\n\r\n  const pathDot = path + '.';\r\n\r\n  for (const cur of paths) {\r\n    if (cur === '_id') {\r\n      continue;\r\n    }\r\n\r\n    if (cur.startsWith(pathDot)) {\r\n      return inclusive || cur !== pathDot;\r\n    }\r\n\r\n    if (pathDot.startsWith(cur + '.')) {\r\n      return inclusive;\r\n    }\r\n  }\r\n\r\n  return !inclusive;\r\n};\r\n\r\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\r\n\r\n/**\r\n * Checks if `path` was explicitly selected. If no projection, always returns\r\n * true.\r\n *\r\n * #### Example:\r\n *\r\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\r\n *        doc.isDirectSelected('nested.name') // true\r\n *        doc.isDirectSelected('nested.otherName') // false\r\n *        doc.isDirectSelected('nested')  // false\r\n *     })\r\n *\r\n * @param {String} path\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\r\n  if (this.$__.selected == null) {\r\n    return true;\r\n  }\r\n\r\n  if (path === '_id') {\r\n    return this.$__.selected._id !== 0;\r\n  }\r\n\r\n  if (path.indexOf(' ') !== -1) {\r\n    path = path.split(' ');\r\n  }\r\n  if (Array.isArray(path)) {\r\n    return path.some(p => this.isDirectSelected(p));\r\n  }\r\n\r\n  const paths = Object.keys(this.$__.selected);\r\n  let inclusive = null;\r\n\r\n  if (paths.length === 1 && paths[0] === '_id') {\r\n    // only _id was selected.\r\n    return this.$__.selected._id === 0;\r\n  }\r\n\r\n  for (const cur of paths) {\r\n    if (cur === '_id') {\r\n      continue;\r\n    }\r\n    if (!isDefiningProjection(this.$__.selected[cur])) {\r\n      continue;\r\n    }\r\n    inclusive = !!this.$__.selected[cur];\r\n    break;\r\n  }\r\n\r\n  if (inclusive === null) {\r\n    return true;\r\n  }\r\n\r\n  if (this.$__.selected.hasOwnProperty(path)) {\r\n    return inclusive;\r\n  }\r\n\r\n  return !inclusive;\r\n};\r\n\r\n/**\r\n * Executes registered validation rules for this document.\r\n *\r\n * #### Note:\r\n *\r\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\r\n *\r\n * #### Example:\r\n *\r\n *     doc.validate(function (err) {\r\n *       if (err) handleError(err);\r\n *       else // validation passed\r\n *     });\r\n *\r\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\r\n * @param {Object} [options] internal options\r\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\r\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\r\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\r\n * @return {Promise} Returns a Promise if no `callback` is given.\r\n * @api public\r\n */\r\n\r\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\r\n  let parallelValidate;\r\n  this.$op = 'validate';\r\n\r\n  if (this.$isSubdocument != null) {\r\n    // Skip parallel validate check for subdocuments\r\n  } else if (this.$__.validating) {\r\n    parallelValidate = new ParallelValidateError(this, {\r\n      parentStack: options && options.parentStack,\r\n      conflictStack: this.$__.validating.stack\r\n    });\r\n  } else {\r\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\r\n  }\r\n\r\n  if (arguments.length === 1) {\r\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\r\n      options = arguments[0];\r\n      callback = null;\r\n      pathsToValidate = null;\r\n    } else if (typeof arguments[0] === 'function') {\r\n      callback = arguments[0];\r\n      options = null;\r\n      pathsToValidate = null;\r\n    }\r\n  } else if (typeof pathsToValidate === 'function') {\r\n    callback = pathsToValidate;\r\n    options = null;\r\n    pathsToValidate = null;\r\n  } else if (typeof options === 'function') {\r\n    callback = options;\r\n    options = pathsToValidate;\r\n    pathsToValidate = null;\r\n  }\r\n  if (options && typeof options.pathsToSkip === 'string') {\r\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\r\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\r\n  }\r\n\r\n  return promiseOrCallback(callback, cb => {\r\n    if (parallelValidate != null) {\r\n      return cb(parallelValidate);\r\n    }\r\n\r\n    this.$__validate(pathsToValidate, options, (error) => {\r\n      this.$op = null;\r\n      this.$__.validating = null;\r\n      cb(error);\r\n    });\r\n  }, this.constructor.events);\r\n};\r\n\r\n/**\r\n * Alias of [`.validate`](#document_Document-validate)\r\n *\r\n * @method $validate\r\n * @memberOf Document\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$validate = Document.prototype.validate;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _evaluateRequiredFunctions(doc) {\r\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\r\n  let i = 0;\r\n  const len = requiredFields.length;\r\n  for (i = 0; i < len; ++i) {\r\n    const path = requiredFields[i];\r\n\r\n    const p = doc.$__schema.path(path);\r\n\r\n    if (p != null && typeof p.originalRequiredValue === 'function') {\r\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\r\n      try {\r\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\r\n      } catch (err) {\r\n        doc.invalidate(path, err);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _getPathsToValidate(doc) {\r\n  const skipSchemaValidators = {};\r\n\r\n  _evaluateRequiredFunctions(doc);\r\n  // only validate required fields when necessary\r\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\r\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\r\n      return false;\r\n    }\r\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\r\n      return doc.$__.cachedRequired[path];\r\n    }\r\n    return true;\r\n  }));\r\n\r\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\r\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\r\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\r\n  function addToPaths(p) { paths.add(p); }\r\n\r\n  const subdocs = doc.$getAllSubdocs();\r\n  const modifiedPaths = doc.modifiedPaths();\r\n  for (const subdoc of subdocs) {\r\n    if (subdoc.$basePath) {\r\n      // Remove child paths for now, because we'll be validating the whole\r\n      // subdoc\r\n      const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();\r\n\r\n      for (const p of paths) {\r\n        if (p == null || p.startsWith(fullPathToSubdoc + '.')) {\r\n          paths.delete(p);\r\n        }\r\n      }\r\n\r\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) &&\r\n            !doc.isDirectModified(fullPathToSubdoc) &&\r\n            !doc.$isDefault(fullPathToSubdoc)) {\r\n        paths.add(fullPathToSubdoc);\r\n\r\n        skipSchemaValidators[fullPathToSubdoc] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const path of paths) {\r\n    const _pathType = doc.$__schema.path(path);\r\n    if (!_pathType) {\r\n      continue;\r\n    }\r\n\r\n    if (_pathType.$isMongooseDocumentArray) {\r\n      for (const p of paths) {\r\n        if (p == null || p.startsWith(_pathType.path + '.')) {\r\n          paths.delete(p);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Optimization: if primitive path with no validators, or array of primitives\r\n    // with no validators, skip validating this path entirely.\r\n    if (!_pathType.caster && _pathType.validators.length === 0) {\r\n      paths.delete(path);\r\n    } else if (_pathType.$isMongooseArray &&\r\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\r\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\r\n      _pathType.validators.length === 0 && // and arrays with top-level validators\r\n      _pathType.$embeddedSchemaType.validators.length === 0) {\r\n      paths.delete(path);\r\n    }\r\n  }\r\n\r\n  // from here on we're not removing items from paths\r\n\r\n  // gh-661: if a whole array is modified, make sure to run validation on all\r\n  // the children as well\r\n  for (const path of paths) {\r\n    const _pathType = doc.$__schema.path(path);\r\n    if (!_pathType) {\r\n      continue;\r\n    }\r\n\r\n    if (!_pathType.$isMongooseArray ||\r\n        // To avoid potential performance issues, skip doc arrays whose children\r\n        // are not required. `getPositionalPathType()` may be slow, so avoid\r\n        // it unless we have a case of #6364\r\n        (!Array.isArray(_pathType) &&\r\n          _pathType.$isMongooseDocumentArray &&\r\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\r\n      continue;\r\n    }\r\n\r\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\r\n    // on the array type, there's no need to run validation on the individual array elements.\r\n    if (_pathType.$isMongooseArray &&\r\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\r\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\r\n        _pathType.$embeddedSchemaType.validators.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    const val = doc.$__getValue(path);\r\n    _pushNestedArrayPaths(val, paths, path);\r\n  }\r\n\r\n  function _pushNestedArrayPaths(val, paths, path) {\r\n    if (val != null) {\r\n      const numElements = val.length;\r\n      for (let j = 0; j < numElements; ++j) {\r\n        if (Array.isArray(val[j])) {\r\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\r\n        } else {\r\n          paths.add(path + '.' + j);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const flattenOptions = { skipArrays: true };\r\n  for (const pathToCheck of paths) {\r\n    if (doc.$__schema.nested[pathToCheck]) {\r\n      let _v = doc.$__getValue(pathToCheck);\r\n      if (isMongooseObject(_v)) {\r\n        _v = _v.toObject({ transform: false });\r\n      }\r\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\r\n      Object.keys(flat).forEach(addToPaths);\r\n    }\r\n  }\r\n\r\n  for (const path of paths) {\r\n    // Single nested paths (paths embedded under single nested subdocs) will\r\n    // be validated on their own when we call `validate()` on the subdoc itself.\r\n    // Re: gh-8468\r\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\r\n      paths.delete(path);\r\n      continue;\r\n    }\r\n    const _pathType = doc.$__schema.path(path);\r\n    if (!_pathType || !_pathType.$isSchemaMap) {\r\n      continue;\r\n    }\r\n\r\n    const val = doc.$__getValue(path);\r\n    if (val == null) {\r\n      continue;\r\n    }\r\n    for (const key of val.keys()) {\r\n      paths.add(path + '.' + key);\r\n    }\r\n  }\r\n\r\n  paths = Array.from(paths);\r\n  return [paths, skipSchemaValidators];\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\r\n  if (typeof pathsToValidate === 'function') {\r\n    callback = pathsToValidate;\r\n    options = null;\r\n    pathsToValidate = null;\r\n  } else if (typeof options === 'function') {\r\n    callback = options;\r\n    options = null;\r\n  }\r\n\r\n  const hasValidateModifiedOnlyOption = options &&\r\n      (typeof options === 'object') &&\r\n      ('validateModifiedOnly' in options);\r\n\r\n  const pathsToSkip = (options && options.pathsToSkip) || null;\r\n\r\n  let shouldValidateModifiedOnly;\r\n  if (hasValidateModifiedOnlyOption) {\r\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\r\n  } else {\r\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\r\n  }\r\n\r\n  const _this = this;\r\n  const _complete = () => {\r\n    let validationError = this.$__.validationError;\r\n    this.$__.validationError = null;\r\n    this.$__.validating = null;\r\n\r\n    if (shouldValidateModifiedOnly && validationError != null) {\r\n      // Remove any validation errors that aren't from modified paths\r\n      const errors = Object.keys(validationError.errors);\r\n      for (const errPath of errors) {\r\n        if (!this.$isModified(errPath)) {\r\n          delete validationError.errors[errPath];\r\n        }\r\n      }\r\n      if (Object.keys(validationError.errors).length === 0) {\r\n        validationError = void 0;\r\n      }\r\n    }\r\n\r\n    this.$__.cachedRequired = {};\r\n    this.$emit('validate', _this);\r\n    this.constructor.emit('validate', _this);\r\n\r\n    if (validationError) {\r\n      for (const key in validationError.errors) {\r\n        // Make sure cast errors persist\r\n        if (!this[documentArrayParent] &&\r\n            validationError.errors[key] instanceof MongooseError.CastError) {\r\n          this.invalidate(key, validationError.errors[key]);\r\n        }\r\n      }\r\n\r\n      return validationError;\r\n    }\r\n  };\r\n\r\n  // only validate required fields when necessary\r\n  const pathDetails = _getPathsToValidate(this);\r\n  let paths = shouldValidateModifiedOnly ?\r\n    pathDetails[0].filter((path) => this.$isModified(path)) :\r\n    pathDetails[0];\r\n  const skipSchemaValidators = pathDetails[1];\r\n  if (typeof pathsToValidate === 'string') {\r\n    pathsToValidate = pathsToValidate.split(' ');\r\n  }\r\n  if (Array.isArray(pathsToValidate)) {\r\n    paths = _handlePathsToValidate(paths, pathsToValidate);\r\n  } else if (pathsToSkip) {\r\n    paths = _handlePathsToSkip(paths, pathsToSkip);\r\n  }\r\n\r\n  if (paths.length === 0) {\r\n    return immediate(function() {\r\n      const error = _complete();\r\n      if (error) {\r\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\r\n          callback(error);\r\n        });\r\n      }\r\n      callback(null, _this);\r\n    });\r\n  }\r\n\r\n  const validated = {};\r\n  let total = 0;\r\n\r\n  for (const path of paths) {\r\n    validatePath(path);\r\n  }\r\n\r\n  function validatePath(path) {\r\n    if (path == null || validated[path]) {\r\n      return;\r\n    }\r\n\r\n    validated[path] = true;\r\n    total++;\r\n\r\n    immediate(function() {\r\n      const schemaType = _this.$__schema.path(path);\r\n\r\n      if (!schemaType) {\r\n        return --total || complete();\r\n      }\r\n\r\n      // If user marked as invalid or there was a cast error, don't validate\r\n      if (!_this.$isValid(path)) {\r\n        --total || complete();\r\n        return;\r\n      }\r\n\r\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\r\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\r\n        return --total || complete();\r\n      }\r\n\r\n      let val = _this.$__getValue(path);\r\n\r\n      // If you `populate()` and get back a null value, required validators\r\n      // shouldn't fail (gh-8018). We should always fall back to the populated\r\n      // value.\r\n      let pop;\r\n      if ((pop = _this.$populated(path))) {\r\n        val = pop;\r\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\r\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\r\n        // so in that case pull out the document's id\r\n        val = val._id;\r\n      }\r\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\r\n        _this.$__.pathsToScopes[path] :\r\n        _this;\r\n\r\n      const doValidateOptions = {\r\n        skipSchemaValidators: skipSchemaValidators[path],\r\n        path: path,\r\n        validateModifiedOnly: shouldValidateModifiedOnly\r\n      };\r\n\r\n      schemaType.doValidate(val, function(err) {\r\n        if (err) {\r\n          const isSubdoc = schemaType.$isSingleNested ||\r\n            schemaType.$isArraySubdocument ||\r\n            schemaType.$isMongooseDocumentArray;\r\n          if (isSubdoc && err instanceof ValidationError) {\r\n            return --total || complete();\r\n          }\r\n          _this.invalidate(path, err, undefined, true);\r\n        }\r\n        --total || complete();\r\n      }, scope, doValidateOptions);\r\n    });\r\n  }\r\n\r\n  function complete() {\r\n    const error = _complete();\r\n    if (error) {\r\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\r\n        callback(error);\r\n      });\r\n    }\r\n    callback(null, _this);\r\n  }\r\n\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _handlePathsToValidate(paths, pathsToValidate) {\r\n  const _pathsToValidate = new Set(pathsToValidate);\r\n  const parentPaths = new Map([]);\r\n  for (const path of pathsToValidate) {\r\n    if (path.indexOf('.') === -1) {\r\n      continue;\r\n    }\r\n    const pieces = path.split('.');\r\n    let cur = pieces[0];\r\n    for (let i = 1; i < pieces.length; ++i) {\r\n      // Since we skip subpaths under single nested subdocs to\r\n      // avoid double validation, we need to add back the\r\n      // single nested subpath if the user asked for it (gh-8626)\r\n      parentPaths.set(cur, path);\r\n      cur = cur + '.' + pieces[i];\r\n    }\r\n  }\r\n\r\n  const ret = [];\r\n  for (const path of paths) {\r\n    if (_pathsToValidate.has(path)) {\r\n      ret.push(path);\r\n    } else if (parentPaths.has(path)) {\r\n      ret.push(parentPaths.get(path));\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _handlePathsToSkip(paths, pathsToSkip) {\r\n  pathsToSkip = new Set(pathsToSkip);\r\n  paths = paths.filter(p => !pathsToSkip.has(p));\r\n  return paths;\r\n}\r\n\r\n/**\r\n * Executes registered validation rules (skipping asynchronous validators) for this document.\r\n *\r\n * #### Note:\r\n *\r\n * This method is useful if you need synchronous validation.\r\n *\r\n * #### Example:\r\n *\r\n *     const err = doc.validateSync();\r\n *     if (err) {\r\n *       handleError(err);\r\n *     } else {\r\n *       // validation passed\r\n *     }\r\n *\r\n * @param {Array|string} [pathsToValidate] only validate the given paths\r\n * @param {Object} [options] options for validation\r\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\r\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\r\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\r\n * @api public\r\n */\r\n\r\nDocument.prototype.validateSync = function(pathsToValidate, options) {\r\n  const _this = this;\r\n\r\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\r\n    options = arguments[0];\r\n    pathsToValidate = null;\r\n  }\r\n\r\n  const hasValidateModifiedOnlyOption = options &&\r\n      (typeof options === 'object') &&\r\n      ('validateModifiedOnly' in options);\r\n\r\n  let shouldValidateModifiedOnly;\r\n  if (hasValidateModifiedOnlyOption) {\r\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\r\n  } else {\r\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\r\n  }\r\n\r\n  let pathsToSkip = options && options.pathsToSkip;\r\n\r\n  if (typeof pathsToValidate === 'string') {\r\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\r\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\r\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\r\n    pathsToSkip = pathsToSkip.split(' ');\r\n  }\r\n\r\n  // only validate required fields when necessary\r\n  const pathDetails = _getPathsToValidate(this);\r\n  let paths = shouldValidateModifiedOnly ?\r\n    pathDetails[0].filter((path) => this.$isModified(path)) :\r\n    pathDetails[0];\r\n  const skipSchemaValidators = pathDetails[1];\r\n\r\n  if (Array.isArray(pathsToValidate)) {\r\n    paths = _handlePathsToValidate(paths, pathsToValidate);\r\n  } else if (Array.isArray(pathsToSkip)) {\r\n    paths = _handlePathsToSkip(paths, pathsToSkip);\r\n  }\r\n  const validating = {};\r\n\r\n  for (let i = 0, len = paths.length; i < len; ++i) {\r\n    const path = paths[i];\r\n\r\n    if (validating[path]) {\r\n      continue;\r\n    }\r\n\r\n    validating[path] = true;\r\n\r\n    const p = _this.$__schema.path(path);\r\n    if (!p) {\r\n      continue;\r\n    }\r\n    if (!_this.$isValid(path)) {\r\n      continue;\r\n    }\r\n\r\n    const val = _this.$__getValue(path);\r\n    const err = p.doValidateSync(val, _this, {\r\n      skipSchemaValidators: skipSchemaValidators[path],\r\n      path: path,\r\n      validateModifiedOnly: shouldValidateModifiedOnly\r\n    });\r\n    if (err) {\r\n      const isSubdoc = p.$isSingleNested ||\r\n        p.$isArraySubdocument ||\r\n        p.$isMongooseDocumentArray;\r\n      if (isSubdoc && err instanceof ValidationError) {\r\n        continue;\r\n      }\r\n      _this.invalidate(path, err, undefined, true);\r\n    }\r\n  }\r\n\r\n  const err = _this.$__.validationError;\r\n  _this.$__.validationError = undefined;\r\n  _this.$emit('validate', _this);\r\n  _this.constructor.emit('validate', _this);\r\n\r\n  if (err) {\r\n    for (const key in err.errors) {\r\n      // Make sure cast errors persist\r\n      if (err.errors[key] instanceof MongooseError.CastError) {\r\n        _this.invalidate(key, err.errors[key]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return err;\r\n};\r\n\r\n/**\r\n * Marks a path as invalid, causing validation to fail.\r\n *\r\n * The `errorMsg` argument will become the message of the `ValidationError`.\r\n *\r\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\r\n *\r\n *     doc.invalidate('size', 'must be less than 20', 14);\r\n *\r\n *     doc.validate(function (err) {\r\n *       console.log(err)\r\n *       // prints\r\n *       { message: 'Validation failed',\r\n *         name: 'ValidationError',\r\n *         errors:\r\n *          { size:\r\n *             { message: 'must be less than 20',\r\n *               name: 'ValidatorError',\r\n *               path: 'size',\r\n *               type: 'user defined',\r\n *               value: 14 } } }\r\n *     })\r\n *\r\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\r\n * @param {String|Error} err the error which states the reason `path` was invalid\r\n * @param {Object|String|Number|any} val optional invalid value\r\n * @param {String} [kind] optional `kind` property for the error\r\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\r\n * @api public\r\n */\r\n\r\nDocument.prototype.invalidate = function(path, err, val, kind) {\r\n  if (!this.$__.validationError) {\r\n    this.$__.validationError = new ValidationError(this);\r\n  }\r\n\r\n  if (this.$__.validationError.errors[path]) {\r\n    return;\r\n  }\r\n\r\n  if (!err || typeof err === 'string') {\r\n    err = new ValidatorError({\r\n      path: path,\r\n      message: err,\r\n      type: kind || 'user defined',\r\n      value: val\r\n    });\r\n  }\r\n\r\n  if (this.$__.validationError === err) {\r\n    return this.$__.validationError;\r\n  }\r\n\r\n  this.$__.validationError.addError(path, err);\r\n  return this.$__.validationError;\r\n};\r\n\r\n/**\r\n * Marks a path as valid, removing existing validation errors.\r\n *\r\n * @param {String} path the field to mark as valid\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n * @method $markValid\r\n */\r\n\r\nDocument.prototype.$markValid = function(path) {\r\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\r\n    return;\r\n  }\r\n\r\n  delete this.$__.validationError.errors[path];\r\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\r\n    this.$__.validationError = null;\r\n  }\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _markValidSubpaths(doc, path) {\r\n  if (!doc.$__.validationError) {\r\n    return;\r\n  }\r\n\r\n  const keys = Object.keys(doc.$__.validationError.errors);\r\n  for (const key of keys) {\r\n    if (key.startsWith(path + '.')) {\r\n      delete doc.$__.validationError.errors[key];\r\n    }\r\n  }\r\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\r\n    doc.$__.validationError = null;\r\n  }\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\r\n  const schema = schematype.schema;\r\n  if (schema == null) {\r\n    return;\r\n  }\r\n\r\n  for (const key of Object.keys(schema.paths)) {\r\n    const path = schema.paths[key];\r\n    if (path.$immutableSetter == null) {\r\n      continue;\r\n    }\r\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\r\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\r\n    // is intentional. That's because `$immutableSetter` compares its param\r\n    // to the current value.\r\n    path.$immutableSetter.call(subdoc, oldVal);\r\n  }\r\n}\r\n\r\n/**\r\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api/document.html#document_Document-isNew) is `true`,\r\n * or sends an [updateOne](/docs/api/document.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\r\n *\r\n * #### Example:\r\n *\r\n *     product.sold = Date.now();\r\n *     product = await product.save();\r\n *\r\n * If save is successful, the returned promise will fulfill with the document\r\n * saved.\r\n *\r\n * #### Example:\r\n *\r\n *     const newProduct = await product.save();\r\n *     newProduct === product; // true\r\n *\r\n * @param {Object} [options] options optional options\r\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api/document.html#document_Document-$session).\r\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\r\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\r\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\r\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\r\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\r\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\r\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\r\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\r\n * @param {Function} [fn] optional callback\r\n * @method save\r\n * @memberOf Document\r\n * @instance\r\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api/document.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\r\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\r\n * @api public\r\n * @see middleware https://mongoosejs.com/docs/middleware.html\r\n */\r\n\r\n/**\r\n * Checks if a path is invalid\r\n *\r\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\r\n * @method $isValid\r\n * @memberOf Document\r\n * @instance\r\n * @api private\r\n */\r\n\r\nDocument.prototype.$isValid = function(path) {\r\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\r\n    return true;\r\n  }\r\n  if (path == null) {\r\n    return false;\r\n  }\r\n\r\n  if (path.indexOf(' ') !== -1) {\r\n    path = path.split(' ');\r\n  }\r\n  if (Array.isArray(path)) {\r\n    return path.some(p => this.$__.validationError.errors[p] == null);\r\n  }\r\n\r\n  return this.$__.validationError.errors[path] == null;\r\n};\r\n\r\n/**\r\n * Resets the internal modified state of this document.\r\n *\r\n * @api private\r\n * @return {Document} this\r\n * @method $__reset\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__reset = function reset() {\r\n  let _this = this;\r\n\r\n  // Skip for subdocuments\r\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\r\n  const resetArrays = new Set();\r\n  for (const subdoc of subdocs) {\r\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\r\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\r\n      subdoc.$__reset();\r\n      if (subdoc.$isDocumentArrayElement) {\r\n        if (!resetArrays.has(subdoc.parentArray())) {\r\n          const array = subdoc.parentArray();\r\n          this.$__.activePaths.clearPath(fullPathWithIndexes.replace(/\\.\\d+$/, '').slice(-subdoc.$basePath - 1));\r\n          array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\r\n          array[arrayAtomicsSymbol] = {};\r\n\r\n          resetArrays.add(array);\r\n        }\r\n      } else {\r\n        if (subdoc.$parent() === this) {\r\n          this.$__.activePaths.clearPath(subdoc.$basePath);\r\n        } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {\r\n          // If map path underneath subdocument, may end up with a case where\r\n          // map path is modified but parent still needs to be reset. See gh-10295\r\n          subdoc.$parent().$__reset();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function isParentInit(path) {\r\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\r\n    let cur = '';\r\n    for (let i = 0; i < path.length; ++i) {\r\n      cur += (cur.length ? '.' : '') + path[i];\r\n      if (_this.$__.activePaths[cur] === 'init') {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // clear atomics\r\n  this.$__dirty().forEach(function(dirt) {\r\n    const type = dirt.value;\r\n\r\n    if (type && type[arrayAtomicsSymbol]) {\r\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\r\n      type[arrayAtomicsSymbol] = {};\r\n    }\r\n  });\r\n\r\n  this.$__.backup = {};\r\n  this.$__.backup.activePaths = {\r\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\r\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\r\n  };\r\n  this.$__.backup.validationError = this.$__.validationError;\r\n  this.$__.backup.errors = this.$errors;\r\n\r\n  // Clear 'dirty' cache\r\n  this.$__.activePaths.clear('modify');\r\n  this.$__.activePaths.clear('default');\r\n  this.$__.validationError = undefined;\r\n  this.$errors = undefined;\r\n  _this = this;\r\n  this.$__schema.requiredPaths().forEach(function(path) {\r\n    _this.$__.activePaths.require(path);\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nDocument.prototype.$__undoReset = function $__undoReset() {\r\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\r\n    return;\r\n  }\r\n\r\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\r\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\r\n\r\n  this.$__.validationError = this.$__.backup.validationError;\r\n  this.$errors = this.$__.backup.errors;\r\n\r\n  for (const dirt of this.$__dirty()) {\r\n    const type = dirt.value;\r\n\r\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\r\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\r\n    }\r\n  }\r\n\r\n  for (const subdoc of this.$getAllSubdocs()) {\r\n    subdoc.$__undoReset();\r\n  }\r\n};\r\n\r\n/**\r\n * Returns this documents dirty paths / vals.\r\n *\r\n * @return {Array}\r\n * @api private\r\n * @method $__dirty\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__dirty = function() {\r\n  const _this = this;\r\n  let all = this.$__.activePaths.map('modify', function(path) {\r\n    return {\r\n      path: path,\r\n      value: _this.$__getValue(path),\r\n      schema: _this.$__path(path)\r\n    };\r\n  });\r\n\r\n  // gh-2558: if we had to set a default and the value is not undefined,\r\n  // we have to save as well\r\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\r\n    if (path === '_id' || _this.$__getValue(path) == null) {\r\n      return;\r\n    }\r\n    return {\r\n      path: path,\r\n      value: _this.$__getValue(path),\r\n      schema: _this.$__path(path)\r\n    };\r\n  }));\r\n\r\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\r\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\r\n  const minimal = [];\r\n\r\n  all.forEach(function(item) {\r\n    if (!item) {\r\n      return;\r\n    }\r\n\r\n    let top = null;\r\n\r\n    const array = parentPaths(item.path);\r\n    for (let i = 0; i < array.length - 1; i++) {\r\n      if (allPaths.has(array[i])) {\r\n        top = allPaths.get(array[i]);\r\n        break;\r\n      }\r\n    }\r\n    if (top == null) {\r\n      minimal.push(item);\r\n    } else if (top != null &&\r\n        top[arrayAtomicsSymbol] != null &&\r\n        top.hasAtomics()) {\r\n      // special case for top level MongooseArrays\r\n      // the `top` array itself and a sub path of `top` are being set.\r\n      // the only way to honor all of both modifications is through a $set\r\n      // of entire array.\r\n      top[arrayAtomicsSymbol] = {};\r\n      top[arrayAtomicsSymbol].$set = top;\r\n    }\r\n  });\r\n  return minimal;\r\n};\r\n\r\n/**\r\n * Assigns/compiles `schema` into this documents prototype.\r\n *\r\n * @param {Schema} schema\r\n * @api private\r\n * @method $__setSchema\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__setSchema = function(schema) {\r\n  compile(schema.tree, this, undefined, schema.options);\r\n\r\n  // Apply default getters if virtual doesn't have any (gh-6262)\r\n  for (const key of Object.keys(schema.virtuals)) {\r\n    schema.virtuals[key]._applyDefaultGetters();\r\n  }\r\n  if (schema.path('schema') == null) {\r\n    this.schema = schema;\r\n  }\r\n  this.$__schema = schema;\r\n  this[documentSchemaSymbol] = schema;\r\n};\r\n\r\n\r\n/**\r\n * Get active path that were changed and are arrays\r\n *\r\n * @return {Array}\r\n * @api private\r\n * @method $__getArrayPathsToValidate\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__getArrayPathsToValidate = function() {\r\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\r\n\r\n  // validate all document arrays.\r\n  return this.$__.activePaths\r\n    .map('init', 'modify', function(i) {\r\n      return this.$__getValue(i);\r\n    }.bind(this))\r\n    .filter(function(val) {\r\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\r\n    }).reduce(function(seed, array) {\r\n      return seed.concat(array);\r\n    }, [])\r\n    .filter(function(doc) {\r\n      return doc;\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * Get all subdocs (by bfs)\r\n *\r\n * @return {Array}\r\n * @api public\r\n * @method $getAllSubdocs\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$getAllSubdocs = function() {\r\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\r\n  Embedded = Embedded || require('./types/ArraySubdocument');\r\n\r\n  function docReducer(doc, seed, path) {\r\n    let val = doc;\r\n    let isNested = false;\r\n    if (path) {\r\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\r\n        val = doc._doc[path];\r\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\r\n        val = doc._doc[path];\r\n        isNested = true;\r\n      } else {\r\n        val = doc[path];\r\n      }\r\n    }\r\n    if (val instanceof Embedded) {\r\n      seed.push(val);\r\n    } else if (val instanceof Map) {\r\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\r\n        return docReducer(val.get(path), seed, null);\r\n      }, seed);\r\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\r\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\r\n        return docReducer(val, seed, path);\r\n      }, seed);\r\n      seed.push(val);\r\n    } else if (val && utils.isMongooseDocumentArray(val)) {\r\n      val.forEach(function _docReduce(doc) {\r\n        if (!doc || !doc._doc) {\r\n          return;\r\n        }\r\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\r\n          return docReducer(doc._doc, seed, path);\r\n        }, seed);\r\n        if (doc instanceof Embedded) {\r\n          seed.push(doc);\r\n        }\r\n      });\r\n    } else if (isNested && val != null) {\r\n      for (const path of Object.keys(val)) {\r\n        docReducer(val, seed, path);\r\n      }\r\n    }\r\n    return seed;\r\n  }\r\n\r\n  const subDocs = [];\r\n  for (const path of Object.keys(this._doc)) {\r\n    docReducer(this, subDocs, path);\r\n  }\r\n\r\n  return subDocs;\r\n};\r\n\r\n/*!\r\n * Runs queued functions\r\n */\r\n\r\nfunction applyQueue(doc) {\r\n  const q = doc.$__schema && doc.$__schema.callQueue;\r\n  if (!q.length) {\r\n    return;\r\n  }\r\n\r\n  for (const pair of q) {\r\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\r\n      doc[pair[0]].apply(doc, pair[1]);\r\n    }\r\n  }\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nDocument.prototype.$__handleReject = function handleReject(err) {\r\n  // emit on the Model if listening\r\n  if (this.$listeners('error').length) {\r\n    this.$emit('error', err);\r\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\r\n    this.constructor.emit('error', err);\r\n  }\r\n};\r\n\r\n/**\r\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\r\n *\r\n * @return {Object}\r\n * @api private\r\n * @method $toObject\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$toObject = function(options, json) {\r\n  let defaultOptions = {\r\n    transform: true,\r\n    flattenDecimals: true\r\n  };\r\n\r\n  const path = json ? 'toJSON' : 'toObject';\r\n  const baseOptions = this.constructor &&\r\n    this.constructor.base &&\r\n    this.constructor.base.options &&\r\n    get(this.constructor.base.options, path) || {};\r\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\r\n  // merge base default options with Schema's set default options if available.\r\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\r\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\r\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\r\n\r\n  // If options do not exist or is not an object, set it to empty object\r\n  options = utils.isPOJO(options) ? { ...options } : {};\r\n  options._calledWithOptions = options._calledWithOptions || { ...options };\r\n\r\n  let _minimize;\r\n  if (options._calledWithOptions.minimize != null) {\r\n    _minimize = options.minimize;\r\n  } else if (defaultOptions.minimize != null) {\r\n    _minimize = defaultOptions.minimize;\r\n  } else {\r\n    _minimize = schemaOptions.minimize;\r\n  }\r\n\r\n  let flattenMaps;\r\n  if (options._calledWithOptions.flattenMaps != null) {\r\n    flattenMaps = options.flattenMaps;\r\n  } else if (defaultOptions.flattenMaps != null) {\r\n    flattenMaps = defaultOptions.flattenMaps;\r\n  } else {\r\n    flattenMaps = schemaOptions.flattenMaps;\r\n  }\r\n\r\n  // The original options that will be passed to `clone()`. Important because\r\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\r\n  // need the original options the user passed in, plus `_isNested` and\r\n  // `_parentOptions` for checking whether we need to depopulate.\r\n  const cloneOptions = Object.assign({}, options, {\r\n    _isNested: true,\r\n    json: json,\r\n    minimize: _minimize,\r\n    flattenMaps: flattenMaps,\r\n    _seen: (options && options._seen) || new Map()\r\n  });\r\n\r\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\r\n    cloneOptions.getters = options.getters;\r\n  }\r\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\r\n    cloneOptions.virtuals = options.virtuals;\r\n  }\r\n\r\n  const depopulate = options.depopulate ||\r\n    (options._parentOptions && options._parentOptions.depopulate || false);\r\n  // _isNested will only be true if this is not the top level document, we\r\n  // should never depopulate the top-level document\r\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\r\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\r\n  }\r\n\r\n  // merge default options with input options.\r\n  options = utils.options(defaultOptions, options);\r\n  options._isNested = true;\r\n  options.json = json;\r\n  options.minimize = _minimize;\r\n\r\n  cloneOptions._parentOptions = options;\r\n  cloneOptions._skipSingleNestedGetters = false;\r\n\r\n  const gettersOptions = Object.assign({}, cloneOptions);\r\n  gettersOptions._skipSingleNestedGetters = true;\r\n\r\n  // remember the root transform function\r\n  // to save it from being overwritten by sub-transform functions\r\n  const originalTransform = options.transform;\r\n\r\n  let ret = clone(this._doc, cloneOptions) || {};\r\n\r\n  if (options.getters) {\r\n    applyGetters(this, ret, gettersOptions);\r\n\r\n    if (options.minimize) {\r\n      ret = minimize(ret) || {};\r\n    }\r\n  }\r\n\r\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\r\n    applyVirtuals(this, ret, gettersOptions, options);\r\n  }\r\n\r\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\r\n    delete ret[this.$__schema.options.versionKey];\r\n  }\r\n\r\n  let transform = options.transform;\r\n\r\n  // In the case where a subdocument has its own transform function, we need to\r\n  // check and see if the parent has a transform (options.transform) and if the\r\n  // child schema has a transform (this.schema.options.toObject) In this case,\r\n  // we need to adjust options.transform to be the child schema's transform and\r\n  // not the parent schema's\r\n  if (transform) {\r\n    applySchemaTypeTransforms(this, ret);\r\n  }\r\n\r\n  if (options.useProjection) {\r\n    omitDeselectedFields(this, ret);\r\n  }\r\n\r\n  if (transform === true || (schemaOptions.toObject && transform)) {\r\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\r\n\r\n    if (opts) {\r\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\r\n    }\r\n  } else {\r\n    options.transform = originalTransform;\r\n  }\r\n\r\n  if (typeof transform === 'function') {\r\n    const xformed = transform(this, ret, options);\r\n    if (typeof xformed !== 'undefined') {\r\n      ret = xformed;\r\n    }\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\r\n *\r\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\r\n *\r\n * #### Getters/Virtuals\r\n *\r\n * Example of only applying path getters\r\n *\r\n *     doc.toObject({ getters: true, virtuals: false })\r\n *\r\n * Example of only applying virtual getters\r\n *\r\n *     doc.toObject({ virtuals: true })\r\n *\r\n * Example of applying both path and virtual getters\r\n *\r\n *     doc.toObject({ getters: true })\r\n *\r\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\r\n *\r\n *     schema.set('toObject', { virtuals: true })\r\n *\r\n * #### Transform:\r\n *\r\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\r\n *\r\n * Transform functions receive three arguments\r\n *\r\n *     function (doc, ret, options) {}\r\n *\r\n * - `doc` The mongoose document which is being converted\r\n * - `ret` The plain object representation which has been converted\r\n * - `options` The options in use (either schema options or the options passed inline)\r\n *\r\n * #### Example:\r\n *\r\n *     // specify the transform schema option\r\n *     if (!schema.options.toObject) schema.options.toObject = {};\r\n *     schema.options.toObject.transform = function (doc, ret, options) {\r\n *       // remove the _id of every document before returning the result\r\n *       delete ret._id;\r\n *       return ret;\r\n *     }\r\n *\r\n *     // without the transformation in the schema\r\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\r\n *\r\n *     // with the transformation\r\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\r\n *\r\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\r\n *\r\n *     if (!schema.options.toObject) schema.options.toObject = {};\r\n *     schema.options.toObject.transform = function (doc, ret, options) {\r\n *       return { movie: ret.name }\r\n *     }\r\n *\r\n *     // without the transformation in the schema\r\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\r\n *\r\n *     // with the transformation\r\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\r\n *\r\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\r\n *\r\n * Transformations may also be applied inline, overridding any transform set in the options:\r\n *\r\n *     function xform (doc, ret, options) {\r\n *       return { inline: ret.name, custom: true }\r\n *     }\r\n *\r\n *     // pass the transform as an inline option\r\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\r\n *\r\n * If you want to skip transformations, use `transform: false`:\r\n *\r\n *     schema.options.toObject.hide = '_id';\r\n *     schema.options.toObject.transform = function (doc, ret, options) {\r\n *       if (options.hide) {\r\n *         options.hide.split(' ').forEach(function (prop) {\r\n *           delete ret[prop];\r\n *         });\r\n *       }\r\n *       return ret;\r\n *     }\r\n *\r\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\r\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\r\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\r\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\r\n *\r\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\r\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\r\n * Similarly, `transform: false` skips transforms for all subdocuments.\r\n * Note that this behavior is different for transforms defined in the schema:\r\n * if you define a transform in `schema.options.toObject.transform`, that transform\r\n * will **not** apply to subdocuments.\r\n *\r\n *     const memberSchema = new Schema({ name: String, email: String });\r\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\r\n *     const Group = mongoose.model('Group', groupSchema);\r\n *\r\n *     const doc = new Group({\r\n *       name: 'Engineering',\r\n *       email: 'dev@mongoosejs.io',\r\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\r\n *     });\r\n *\r\n *     // Removes `email` from both top-level document **and** array elements\r\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\r\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\r\n *\r\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\r\n *\r\n * See [schema options](/docs/guide.html#toObject) for some more details.\r\n *\r\n * _During save, no custom options are applied to the document before being sent to the database._\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\r\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\r\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\r\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\r\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\r\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\r\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\r\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\r\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\r\n * @return {Object} js object (not a POJO)\r\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.toObject = function(options) {\r\n  return this.$toObject(options);\r\n};\r\n\r\n/**\r\n * Minimizes an object, removing undefined values and empty objects\r\n *\r\n * @param {Object} object to minimize\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction minimize(obj) {\r\n  const keys = Object.keys(obj);\r\n  let i = keys.length;\r\n  let hasKeys;\r\n  let key;\r\n  let val;\r\n\r\n  while (i--) {\r\n    key = keys[i];\r\n    val = obj[key];\r\n\r\n    if (utils.isPOJO(val)) {\r\n      obj[key] = minimize(val);\r\n    }\r\n\r\n    if (undefined === obj[key]) {\r\n      delete obj[key];\r\n      continue;\r\n    }\r\n\r\n    hasKeys = true;\r\n  }\r\n\r\n  return hasKeys\r\n    ? obj\r\n    : undefined;\r\n}\r\n\r\n/*!\r\n * Applies virtuals properties to `json`.\r\n */\r\n\r\nfunction applyVirtuals(self, json, options, toObjectOptions) {\r\n  const schema = self.$__schema;\r\n  const paths = Object.keys(schema.virtuals);\r\n  let i = paths.length;\r\n  const numPaths = i;\r\n  let path;\r\n  let assignPath;\r\n  let cur = self._doc;\r\n  let v;\r\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\r\n    ? toObjectOptions.aliases\r\n    : true;\r\n\r\n  let virtualsToApply = null;\r\n  if (Array.isArray(options.virtuals)) {\r\n    virtualsToApply = new Set(options.virtuals);\r\n  }\r\n  else if (options.virtuals && options.virtuals.pathsToSkip) {\r\n    virtualsToApply = new Set(paths);\r\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\r\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\r\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!cur) {\r\n    return json;\r\n  }\r\n\r\n  options = options || {};\r\n  for (i = 0; i < numPaths; ++i) {\r\n    path = paths[i];\r\n\r\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\r\n      continue;\r\n    }\r\n\r\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\r\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\r\n      continue;\r\n    }\r\n\r\n    // We may be applying virtuals to a nested object, for example if calling\r\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\r\n    // will be a trailing substring of the `path`.\r\n    assignPath = path;\r\n    if (options.path != null) {\r\n      if (!path.startsWith(options.path + '.')) {\r\n        continue;\r\n      }\r\n      assignPath = path.substring(options.path.length + 1);\r\n    }\r\n    const parts = assignPath.split('.');\r\n    v = clone(self.get(path), options);\r\n    if (v === void 0) {\r\n      continue;\r\n    }\r\n    const plen = parts.length;\r\n    cur = json;\r\n    for (let j = 0; j < plen - 1; ++j) {\r\n      cur[parts[j]] = cur[parts[j]] || {};\r\n      cur = cur[parts[j]];\r\n    }\r\n    cur[parts[plen - 1]] = v;\r\n  }\r\n\r\n  return json;\r\n}\r\n\r\n\r\n/**\r\n * Applies virtuals properties to `json`.\r\n *\r\n * @param {Document} self\r\n * @param {Object} json\r\n * @param {Object} [options]\r\n * @return {Object} `json`\r\n * @api private\r\n */\r\n\r\nfunction applyGetters(self, json, options) {\r\n  const schema = self.$__schema;\r\n  const paths = Object.keys(schema.paths);\r\n  let i = paths.length;\r\n  let path;\r\n  let cur = self._doc;\r\n  let v;\r\n\r\n  if (!cur) {\r\n    return json;\r\n  }\r\n\r\n  while (i--) {\r\n    path = paths[i];\r\n\r\n    const parts = path.split('.');\r\n    const plen = parts.length;\r\n    const last = plen - 1;\r\n    let branch = json;\r\n    let part;\r\n    cur = self._doc;\r\n\r\n    if (!self.$__isSelected(path)) {\r\n      continue;\r\n    }\r\n\r\n    for (let ii = 0; ii < plen; ++ii) {\r\n      part = parts[ii];\r\n      v = cur[part];\r\n      if (ii === last) {\r\n        const val = self.$get(path);\r\n        branch[part] = clone(val, options);\r\n      } else if (v == null) {\r\n        if (part in cur) {\r\n          branch[part] = v;\r\n        }\r\n        break;\r\n      } else {\r\n        branch = branch[part] || (branch[part] = {});\r\n      }\r\n      cur = v;\r\n    }\r\n  }\r\n\r\n  return json;\r\n}\r\n\r\n/**\r\n * Applies schema type transforms to `json`.\r\n *\r\n * @param {Document} self\r\n * @param {Object} json\r\n * @return {Object} `json`\r\n * @api private\r\n */\r\n\r\nfunction applySchemaTypeTransforms(self, json) {\r\n  const schema = self.$__schema;\r\n  const paths = Object.keys(schema.paths || {});\r\n  const cur = self._doc;\r\n\r\n  if (!cur) {\r\n    return json;\r\n  }\r\n\r\n  for (const path of paths) {\r\n    const schematype = schema.paths[path];\r\n    if (typeof schematype.options.transform === 'function') {\r\n      const val = self.$get(path);\r\n      if (val === undefined) {\r\n        continue;\r\n      }\r\n      const transformedValue = schematype.options.transform.call(self, val);\r\n      throwErrorIfPromise(path, transformedValue);\r\n      utils.setValue(path, transformedValue, json);\r\n    } else if (schematype.$embeddedSchemaType != null &&\r\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\r\n      const val = self.$get(path);\r\n      if (val === undefined) {\r\n        continue;\r\n      }\r\n      const vals = [].concat(val);\r\n      const transform = schematype.$embeddedSchemaType.options.transform;\r\n      for (let i = 0; i < vals.length; ++i) {\r\n        const transformedValue = transform.call(self, vals[i]);\r\n        vals[i] = transformedValue;\r\n        throwErrorIfPromise(path, transformedValue);\r\n      }\r\n\r\n      json[path] = vals;\r\n    }\r\n  }\r\n\r\n  return json;\r\n}\r\n\r\nfunction throwErrorIfPromise(path, transformedValue) {\r\n  if (isPromise(transformedValue)) {\r\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\r\n  }\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction omitDeselectedFields(self, json) {\r\n  const schema = self.$__schema;\r\n  const paths = Object.keys(schema.paths || {});\r\n  const cur = self._doc;\r\n\r\n  if (!cur) {\r\n    return json;\r\n  }\r\n\r\n  let selected = self.$__.selected;\r\n  if (selected === void 0) {\r\n    selected = {};\r\n    queryhelpers.applyPaths(selected, schema);\r\n  }\r\n  if (selected == null || Object.keys(selected).length === 0) {\r\n    return json;\r\n  }\r\n\r\n  for (const path of paths) {\r\n    if (selected[path] != null && !selected[path]) {\r\n      delete json[path];\r\n    }\r\n  }\r\n\r\n  return json;\r\n}\r\n\r\n/**\r\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\r\n *\r\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\r\n *\r\n *     schema.set('toJSON', { virtuals: true });\r\n *\r\n * There is one difference between `toJSON()` and `toObject()` options.\r\n * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\r\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\r\n *\r\n * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\r\n *\r\n * @param {Object} options\r\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\r\n * @return {Object}\r\n * @see Document#toObject #document_Document-toObject\r\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.toJSON = function(options) {\r\n  return this.$toObject(options, true);\r\n};\r\n\r\n\r\nDocument.prototype.ownerDocument = function() {\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * If this document is a subdocument or populated document, returns the document's\r\n * parent. Returns the original document if there is no parent.\r\n *\r\n * @return {Document}\r\n * @api public\r\n * @method parent\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.parent = function() {\r\n  if (this.$isSubdocument || this.$__.wasPopulated) {\r\n    return this.$__.parent;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Alias for [`parent()`](#document_Document-parent). If this document is a subdocument or populated\r\n * document, returns the document's parent. Returns `undefined` otherwise.\r\n *\r\n * @return {Document}\r\n * @api public\r\n * @method $parent\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$parent = Document.prototype.parent;\r\n\r\n/**\r\n * Helper for console.log\r\n *\r\n * @return {String}\r\n * @api public\r\n * @method inspect\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.inspect = function(options) {\r\n  const isPOJO = utils.isPOJO(options);\r\n  let opts;\r\n  if (isPOJO) {\r\n    opts = options;\r\n    opts.minimize = false;\r\n  }\r\n  const ret = this.toObject(opts);\r\n\r\n  if (ret == null) {\r\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\r\n    // prints out null this can cause some serious confusion. See gh-7942.\r\n    return 'MongooseDocument { ' + ret + ' }';\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nif (inspect.custom) {\r\n  // Avoid Node deprecation warning DEP0079\r\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\r\n}\r\n\r\n/**\r\n * Helper for console.log\r\n *\r\n * @return {String}\r\n * @api public\r\n * @method toString\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.toString = function() {\r\n  const ret = this.inspect();\r\n  if (typeof ret === 'string') {\r\n    return ret;\r\n  }\r\n  return inspect(ret);\r\n};\r\n\r\n/**\r\n * Returns true if this document is equal to another document.\r\n *\r\n * Documents are considered equal when they have matching `_id`s, unless neither\r\n * document has an `_id`, in which case this function falls back to using\r\n * `deepEqual()`.\r\n *\r\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\r\n * @return {Boolean}\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.equals = function(doc) {\r\n  if (!doc) {\r\n    return false;\r\n  }\r\n\r\n  const tid = this.$__getValue('_id');\r\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\r\n  if (!tid && !docid) {\r\n    return deepEqual(this, doc);\r\n  }\r\n  return tid && tid.equals\r\n    ? tid.equals(docid)\r\n    : tid === docid;\r\n};\r\n\r\n/**\r\n * Populates paths on an existing document.\r\n *\r\n * #### Example:\r\n *\r\n *     // Given a document, `populate()` lets you pull in referenced docs\r\n *     await doc.populate([\r\n *       'stories',\r\n *       { path: 'fans', sort: { name: -1 } }\r\n *     ]);\r\n *     doc.populated('stories'); // Array of ObjectIds\r\n *     doc.stories[0].title; // 'Casino Royale'\r\n *     doc.populated('fans'); // Array of ObjectIds\r\n *\r\n *     // If the referenced doc has been deleted, `populate()` will\r\n *     // remove that entry from the array.\r\n *     await Story.delete({ title: 'Casino Royale' });\r\n *     await doc.populate('stories'); // Empty array\r\n *\r\n *     // You can also pass additional query options to `populate()`,\r\n *     // like projections:\r\n *     await doc.populate('fans', '-email');\r\n *     doc.fans[0].email // undefined because of 2nd param `select`\r\n *\r\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\r\n * @param {Object|String} [select] Field selection for the population query\r\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\r\n * @param {Object} [match] Conditions for the population query\r\n * @param {Object} [options] Options for the population query (sort, etc)\r\n * @param {String} [options.path=null] The path to populate.\r\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).\r\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\r\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\r\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\r\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.\r\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\r\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\r\n * @param {Function} [callback] Callback\r\n * @see population /docs/populate\r\n * @see Query#select #query_Query-select\r\n * @see Model.populate #model_Model-populate\r\n * @memberOf Document\r\n * @instance\r\n * @return {Promise|null} Returns a Promise if no `callback` is given.\r\n * @api public\r\n */\r\n\r\nDocument.prototype.populate = function populate() {\r\n  const pop = {};\r\n  const args = [...arguments];\r\n  let fn;\r\n\r\n  if (args.length !== 0) {\r\n    if (typeof args[args.length - 1] === 'function') {\r\n      fn = args.pop();\r\n    }\r\n\r\n    // use hash to remove duplicate paths\r\n    const res = utils.populate.apply(null, args);\r\n    for (const populateOptions of res) {\r\n      pop[populateOptions.path] = populateOptions;\r\n    }\r\n  }\r\n\r\n  const paths = utils.object.vals(pop);\r\n  let topLevelModel = this.constructor;\r\n  if (this.$__isNested) {\r\n    topLevelModel = this.$__[scopeSymbol].constructor;\r\n    const nestedPath = this.$__.nestedPath;\r\n    paths.forEach(function(populateOptions) {\r\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\r\n    });\r\n  }\r\n\r\n  // Use `$session()` by default if the document has an associated session\r\n  // See gh-6754\r\n  if (this.$session() != null) {\r\n    const session = this.$session();\r\n    paths.forEach(path => {\r\n      if (path.options == null) {\r\n        path.options = { session: session };\r\n        return;\r\n      }\r\n      if (!('session' in path.options)) {\r\n        path.options.session = session;\r\n      }\r\n    });\r\n  }\r\n\r\n  paths.forEach(p => {\r\n    p._localModel = topLevelModel;\r\n  });\r\n\r\n  return topLevelModel.populate(this, paths, fn);\r\n};\r\n\r\n/**\r\n * Gets all populated documents associated with this document.\r\n *\r\n * @api public\r\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\r\n * @memberOf Document\r\n * @method $getPopulatedDocs\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\r\n  let keys = [];\r\n  if (this.$__.populated != null) {\r\n    keys = keys.concat(Object.keys(this.$__.populated));\r\n  }\r\n  let result = [];\r\n  for (const key of keys) {\r\n    const value = this.$get(key);\r\n    if (Array.isArray(value)) {\r\n      result = result.concat(value);\r\n    } else if (value instanceof Document) {\r\n      result.push(value);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Gets _id(s) used during population of the given `path`.\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = await Model.findOne().populate('author');\r\n *\r\n *     console.log(doc.author.name); // Dr.Seuss\r\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\r\n *\r\n * If the path was not populated, returns `undefined`.\r\n *\r\n * @param {String} path\r\n * @param {Any} [val]\r\n * @param {Object} [options]\r\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\r\n * @memberOf Document\r\n * @instance\r\n * @api public\r\n */\r\n\r\nDocument.prototype.populated = function(path, val, options) {\r\n  // val and options are internal\r\n  if (val == null || val === true) {\r\n    if (!this.$__.populated) {\r\n      return undefined;\r\n    }\r\n    if (typeof path !== 'string') {\r\n      return undefined;\r\n    }\r\n\r\n    // Map paths can be populated with either `path.$*` or just `path`\r\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\r\n\r\n    const v = this.$__.populated[_path];\r\n    if (v) {\r\n      return val === true ? v : v.value;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  this.$__.populated || (this.$__.populated = {});\r\n  this.$__.populated[path] = { value: val, options: options };\r\n\r\n  // If this was a nested populate, make sure each populated doc knows\r\n  // about its populated children (gh-7685)\r\n  const pieces = path.split('.');\r\n  for (let i = 0; i < pieces.length - 1; ++i) {\r\n    const subpath = pieces.slice(0, i + 1).join('.');\r\n    const subdoc = this.$get(subpath);\r\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\r\n      const rest = pieces.slice(i + 1).join('.');\r\n      subdoc.$populated(rest, val, options);\r\n      // No need to continue because the above recursion should take care of\r\n      // marking the rest of the docs as populated\r\n      break;\r\n    }\r\n  }\r\n\r\n  return val;\r\n};\r\n\r\n/**\r\n * Alias of [`.populated`](#document_Document-populated).\r\n *\r\n * @method $populated\r\n * @memberOf Document\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$populated = Document.prototype.populated;\r\n\r\n/**\r\n * Throws an error if a given path is not populated\r\n *\r\n * #### Example:\r\n *\r\n *     const doc = await Model.findOne().populate('author');\r\n *\r\n *     doc.$assertPopulated('author'); // does not throw\r\n *     doc.$assertPopulated('other path'); // throws an error\r\n *\r\n *     // Manually populate and assert in one call. The following does\r\n *     // `doc.$set({ likes })` before asserting.\r\n *     doc.$assertPopulated('likes', { likes });\r\n *\r\n *\r\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\r\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\r\n * @return {Document} this\r\n * @memberOf Document\r\n * @method $assertPopulated\r\n * @instance\r\n * @api public\r\n */\r\n\r\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\r\n  if (Array.isArray(path)) {\r\n    path.forEach(p => this.$assertPopulated(p, values));\r\n    return this;\r\n  }\r\n\r\n  if (arguments.length > 1) {\r\n    this.$set(values);\r\n  }\r\n\r\n  if (!this.$populated(path)) {\r\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Takes a populated field and returns it to its unpopulated state.\r\n *\r\n * #### Example:\r\n *\r\n *     Model.findOne().populate('author').exec(function (err, doc) {\r\n *       console.log(doc.author.name); // Dr.Seuss\r\n *       console.log(doc.depopulate('author'));\r\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\r\n *     })\r\n *\r\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\r\n *\r\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\r\n * @return {Document} this\r\n * @see Document.populate #document_Document-populate\r\n * @api public\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.depopulate = function(path) {\r\n  if (typeof path === 'string') {\r\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\r\n  }\r\n\r\n  let populatedIds;\r\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\r\n  const populated = this.$__ && this.$__.populated || {};\r\n\r\n  if (arguments.length === 0) {\r\n    // Depopulate all\r\n    for (const virtualKey of virtualKeys) {\r\n      delete this.$$populatedVirtuals[virtualKey];\r\n      delete this._doc[virtualKey];\r\n      delete populated[virtualKey];\r\n    }\r\n\r\n    const keys = Object.keys(populated);\r\n\r\n    for (const key of keys) {\r\n      populatedIds = this.$populated(key);\r\n      if (!populatedIds) {\r\n        continue;\r\n      }\r\n      delete populated[key];\r\n      utils.setValue(key, populatedIds, this._doc);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  for (const singlePath of path) {\r\n    populatedIds = this.$populated(singlePath);\r\n    delete populated[singlePath];\r\n\r\n    if (virtualKeys.indexOf(singlePath) !== -1) {\r\n      delete this.$$populatedVirtuals[singlePath];\r\n      delete this._doc[singlePath];\r\n    } else if (populatedIds) {\r\n      utils.setValue(singlePath, populatedIds, this._doc);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * Returns the full path to this document.\r\n *\r\n * @param {String} [path]\r\n * @return {String}\r\n * @api private\r\n * @method $__fullPath\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$__fullPath = function(path) {\r\n  // overridden in SubDocuments\r\n  return path || '';\r\n};\r\n\r\n/**\r\n * Returns the changes that happened to the document\r\n * in the format that will be sent to MongoDB.\r\n *\r\n * #### Example:\r\n *\r\n *     const userSchema = new Schema({\r\n *       name: String,\r\n *       age: Number,\r\n *       country: String\r\n *     });\r\n *     const User = mongoose.model('User', userSchema);\r\n *     const user = await User.create({\r\n *       name: 'Hafez',\r\n *       age: 25,\r\n *       country: 'Egypt'\r\n *     });\r\n *\r\n *     // returns an empty object, no changes happened yet\r\n *     user.getChanges(); // { }\r\n *\r\n *     user.country = undefined;\r\n *     user.age = 26;\r\n *\r\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\r\n *\r\n *     await user.save();\r\n *\r\n *     user.getChanges(); // { }\r\n *\r\n * Modifying the object that `getChanges()` returns does not affect the document's\r\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\r\n * will still send a `$set` to the server.\r\n *\r\n * @return {Object}\r\n * @api public\r\n * @method getChanges\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.getChanges = function() {\r\n  const delta = this.$__delta();\r\n  const changes = delta ? delta[1] : {};\r\n  return changes;\r\n};\r\n\r\n/**\r\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\r\n *\r\n * @return {Document} a copy of this document\r\n * @api public\r\n * @method $clone\r\n * @memberOf Document\r\n * @instance\r\n */\r\n\r\nDocument.prototype.$clone = function() {\r\n  const Model = this.constructor;\r\n  const clonedDoc = new Model();\r\n  clonedDoc.$isNew = this.$isNew;\r\n  if (this._doc) {\r\n    clonedDoc._doc = clone(this._doc);\r\n  }\r\n  if (this.$__) {\r\n    const Cache = this.$__.constructor;\r\n    const clonedCache = new Cache();\r\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\r\n      if (key === 'activePaths') {\r\n        continue;\r\n      }\r\n      clonedCache[key] = clone(this.$__[key]);\r\n    }\r\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\r\n    clonedDoc.$__ = clonedCache;\r\n  }\r\n  return clonedDoc;\r\n};\r\n\r\n/*!\r\n * Module exports.\r\n */\r\n\r\nDocument.ValidationError = ValidationError;\r\nmodule.exports = exports = Document;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}