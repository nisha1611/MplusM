{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schematype');\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\nconst VirtualOptions = require('./options/VirtualOptions');\nconst VirtualType = require('./virtualtype');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst idGetter = require('./helpers/schema/idGetter');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst readPref = require('./driver').get().ReadPreference;\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\nconst util = require('util');\nlet MongooseTypes;\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').middlewareFunctions;\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set());\nconst isPOJO = utils.isPOJO;\nlet id = 0;\n\n/**\r\n * Schema constructor.\r\n *\r\n * #### Example:\r\n *\r\n *     const child = new Schema({ name: String });\r\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\r\n *     const Tree = mongoose.model('Tree', schema);\r\n *\r\n *     // setting schema options\r\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\r\n *\r\n * #### Options:\r\n *\r\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\r\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\r\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\r\n * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\r\n * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false\r\n * - [collection](/docs/guide.html#collection): string - no default\r\n * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`\r\n * - [id](/docs/guide.html#id): bool - defaults to true\r\n * - [_id](/docs/guide.html#_id): bool - defaults to true\r\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\r\n * - [read](/docs/guide.html#read): string\r\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\r\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\r\n * - [strict](/docs/guide.html#strict): bool - defaults to true\r\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\r\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\r\n * - [toObject](/docs/guide.html#toObject) - object - no default\r\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\r\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\r\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\r\n * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\r\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\r\n * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\r\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\r\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\r\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\r\n * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\r\n *\r\n * #### Options for Nested Schemas:\r\n *\r\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\r\n *\r\n * #### Note:\r\n *\r\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\r\n *\r\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\r\n * @param {Object} [options]\r\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\r\n * @event `init`: Emitted after the schema is compiled into a `Model`.\r\n * @api public\r\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = options && options.methods || {};\n  this.methodOptions = {};\n  this.statics = options && options.statics || {};\n  this.tree = {};\n  this.query = options && options.query || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options && options.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] && this.options._id && !_idSubDoc;\n  if (auto_id) {\n    addAutoId(this);\n  }\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\r\n * Create virtual properties with alias field\r\n * @api private\r\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n      alias = options.alias;\n    }\n    if (!alias) {\n      continue;\n    }\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n        schema.aliases[a] = prop;\n        schema.virtual(a).get(function (p) {\n          return function () {\n            if (typeof this.get === 'function') {\n              return this.get(p);\n            }\n            return this[p];\n          };\n        }(prop)).set(function (p) {\n          return function (v) {\n            return this.$set(p, v);\n          };\n        }(prop));\n      }\n      continue;\n    }\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n    schema.aliases[alias] = prop;\n    schema.virtual(alias).get(function (p) {\n      return function () {\n        if (typeof this.get === 'function') {\n          return this.get(p);\n        }\n        return this[p];\n      };\n    }(prop)).set(function (p) {\n      return function (v) {\n        return this.$set(p, v);\n      };\n    }(prop));\n  }\n}\n\n/*!\r\n * Inherit from EventEmitter.\r\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\r\n * ignore\r\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\r\n * Array of child schemas (from document arrays and single nested subdocs)\r\n * and their corresponding compiled models. Each element of the array is\r\n * an object with 2 properties: `schema` and `model`.\r\n *\r\n * This property is typically only useful for plugin authors and advanced users.\r\n * You do not need to interact with this property at all to use mongoose.\r\n *\r\n * @api public\r\n * @property childSchemas\r\n * @memberOf Schema\r\n * @instance\r\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\r\n * Object containing all virtuals defined on this schema.\r\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\r\n *\r\n * This property is typically only useful for plugin authors and advanced users.\r\n * You do not need to interact with this property at all to use mongoose.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({});\r\n *     schema.virtual('answer').get(() => 42);\r\n *\r\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\r\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\r\n *\r\n * @api public\r\n * @property virtuals\r\n * @memberOf Schema\r\n * @instance\r\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\r\n * The original object passed to the schema constructor\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ a: String }).add({ b: String });\r\n *     schema.obj; // { a: String }\r\n *\r\n * @api public\r\n * @property obj\r\n * @memberOf Schema\r\n * @instance\r\n */\n\nSchema.prototype.obj;\n\n/**\r\n * The paths defined on this schema. The keys are the top-level paths\r\n * in this schema, and the values are instances of the SchemaType class.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ name: String }, { _id: false });\r\n *     schema.paths; // { name: SchemaString { ... } }\r\n *\r\n *     schema.add({ age: Number });\r\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\r\n *\r\n * @api public\r\n * @property paths\r\n * @memberOf Schema\r\n * @instance\r\n */\n\nSchema.prototype.paths;\n\n/**\r\n * Schema as a tree\r\n *\r\n * #### Example:\r\n *\r\n *     {\r\n *         '_id'     : ObjectId\r\n *       , 'nested'  : {\r\n *             'key' : String\r\n *         }\r\n *     }\r\n *\r\n * @api private\r\n * @property tree\r\n * @memberOf Schema\r\n * @instance\r\n */\n\nSchema.prototype.tree;\n\n/**\r\n * Returns a deep copy of the schema\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ name: String });\r\n *     const clone = schema.clone();\r\n *     clone === schema; // false\r\n *     clone.path('name'); // SchemaString { ... }\r\n *\r\n * @return {Schema} the cloned schema\r\n * @api public\r\n * @memberOf Schema\r\n * @instance\r\n */\n\nSchema.prototype.clone = function () {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n  return s;\n};\n\n/*!\r\n * ignore\r\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function (f) {\n    return f;\n  });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);\n  }\n  s.aliases = Object.assign({}, this.aliases);\n  return s;\n};\n\n/**\r\n * Returns a new schema that has the picked `paths` from this schema.\r\n *\r\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = Schema({ name: String, age: Number });\r\n *     // Creates a new schema with the same `name` path as `schema`,\r\n *     // but no `age` path.\r\n *     const newSchema = schema.pick(['name']);\r\n *\r\n *     newSchema.path('name'); // SchemaString { ... }\r\n *     newSchema.path('age'); // undefined\r\n *\r\n * @param {String[]} paths List of Paths to pick for the new Schema\r\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\r\n * @return {Schema}\r\n * @api public\r\n */\n\nSchema.prototype.pick = function (paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' + 'got \"' + typeof paths + '\"');\n  }\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({\n        [path]: get(this.tree, path)\n      });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({\n        [path]: schematype\n      });\n    }\n  }\n  return newSchema;\n};\n\n/**\r\n * Returns default options for this schema, merged with `options`.\r\n *\r\n * @param {Object} [options] Options to overwrite the default options\r\n * @return {Object} The merged options of `options` and the default options\r\n * @api private\r\n */\n\nSchema.prototype.defaultOptions = function (options) {\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n  const baseOptions = this.base && this.base.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = utils.options({\n    strict: strict,\n    strictQuery: 'strict' in this._userProvidedOptions ? this._userProvidedOptions.strict : 'strictQuery' in baseOptions ? baseOptions.strictQuery : strict,\n    bufferCommands: true,\n    capped: false,\n    // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type'\n  }, utils.clone(options));\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + typeof options.versionKey + '`');\n  }\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n  return options;\n};\n\n/**\r\n * Inherit a Schema by applying a discriminator on an existing Schema.\r\n *\r\n *\r\n * #### Example:\r\n *\r\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\r\n *\r\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\r\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\r\n *\r\n *     const Event = mongoose.model('Event', eventSchema);\r\n *\r\n *     Event.discriminators['clicked']; // Model { clicked }\r\n *\r\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\r\n *     doc.element; // '#hero'\r\n *     doc instanceof ClickedModel; // true\r\n *\r\n * @param {String} name the name of the discriminator\r\n * @param {Schema} schema the discriminated Schema\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\nSchema.prototype.discriminator = function (name, schema) {\n  this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, {\n    [name]: schema\n  });\n  return this;\n};\n\n/**\r\n * Adds key path / schema type pairs to this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const ToySchema = new Schema();\r\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\r\n *\r\n *     const TurboManSchema = new Schema();\r\n *     // You can also `add()` another schema and copy over all paths, virtuals,\r\n *     // getters, setters, indexes, methods, and statics.\r\n *     TurboManSchema.add(ToySchema).add({ year: Number });\r\n *\r\n * @param {Object|Schema} obj plain object with paths to add, or another schema\r\n * @param {String} [prefix] path to prefix the newly added paths with\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {\n    merge(this, obj);\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n    const fullPath = prefix + key;\n    const val = obj[key];\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath + '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath + '`, got value \"' + val[0] + '\"');\n    }\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {\n        const applyDiscriminators = val[0]._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      } else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {\n        const applyDiscriminators = val._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || typeKey === 'type' && isPOJO(val.type) && val.type.type) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        const _schema = new Schema(_typeDef);\n        const schemaWrappedPath = Object.assign({}, val, {\n          type: _schema\n        });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n  const aliasObj = Object.fromEntries(Object.entries(obj).map(_ref => {\n    let [key] = _ref;\n    return [prefix + key, null];\n  }));\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\r\n * Add an alias for `path`. This means getting or setting the `alias`\r\n * is equivalent to getting or setting the `path`.\r\n *\r\n * #### Example:\r\n *\r\n *     const toySchema = new Schema({ n: String });\r\n *\r\n *     // Make 'name' an alias for 'n'\r\n *     toySchema.alias('n', 'name');\r\n *\r\n *     const Toy = mongoose.model('Toy', toySchema);\r\n *     const turboMan = new Toy({ n: 'Turbo Man' });\r\n *\r\n *     turboMan.name; // 'Turbo Man'\r\n *     turboMan.n; // 'Turbo Man'\r\n *\r\n *     turboMan.name = 'Turbo Man Action Figure';\r\n *     turboMan.n; // 'Turbo Man Action Figure'\r\n *\r\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\r\n *\r\n *\r\n * @param {String} path real path to alias\r\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, {\n    [path]: alias\n  });\n  return this;\n};\n\n/**\r\n * Remove an index by name or index specification.\r\n *\r\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\r\n * in MongoDB.\r\n *\r\n * #### Example:\r\n *\r\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\r\n *\r\n *     // Add a new index on { name, color }\r\n *     ToySchema.index({ name: 1, color: 1 });\r\n *\r\n *     // Remove index on { name, color }\r\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\r\n *     ToySchema.removeIndex({ name: 1, color: 1 });\r\n *\r\n *     // Add an index with a custom name\r\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\r\n *     // Remove index by name\r\n *     ToySchema.removeIndex('my custom index name');\r\n *\r\n * @param {Object|string} index name or index specification\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n  return this;\n};\n\n/**\r\n * Remove all indexes from this schema.\r\n *\r\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\r\n * in MongoDB.\r\n *\r\n * #### Example:\r\n *\r\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\r\n *     ToySchema.index({ name: 1 });\r\n *     ToySchema.index({ color: 1 });\r\n *\r\n *     // Remove all indexes on this schema\r\n *     ToySchema.clearIndexes();\r\n *\r\n *     ToySchema.indexes(); // []\r\n *\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n  return this;\n};\n\n/**\r\n * Reserved document keys.\r\n *\r\n * Keys in this object are names that are warned in schema declarations\r\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\r\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\r\n *\r\n * - _posts\r\n * - _pres\r\n * - collection\r\n  * - emit\r\n * - errors\r\n * - get\r\n * - init\r\n * - isModified\r\n * - isNew\r\n * - listeners\r\n * - modelName\r\n * - on\r\n * - once\r\n * - populated\r\n * - prototype\r\n * - remove\r\n * - removeListener\r\n * - save\r\n * - schema\r\n * - toObject\r\n * - validate\r\n *\r\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\r\n *\r\n *      const schema = new Schema(..);\r\n *      schema.methods.init = function () {} // potentially breaking\r\n *\r\n * @property reserved\r\n * @memberOf Schema\r\n * @static\r\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit = reserved.listeners = reserved.removeListener =\n// document properties and functions\nreserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;\nreserved.collection = 1;\n\n/**\r\n * Gets/sets schema paths.\r\n *\r\n * Sets a path (if arity 2)\r\n * Gets a path (if arity 1)\r\n *\r\n * #### Example:\r\n *\r\n *     schema.path('name') // returns a SchemaType\r\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\r\n *\r\n * @param {String} path The name of the Path to get / set\r\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\r\n * @api public\r\n */\n\nSchema.prototype.path = function (path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path) ? getPositionalPath(this, path) : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` + 'You are allowed to use it, but use at your own risk. ' + 'To disable this warning pass `supressReservedKeysWarning` as a schema option.';\n    utils.warn(errorMessage);\n  }\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. ' + 'Parent path `' + fullPath + '` already set to type ' + branch[sub].name + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n  branch[last] = utils.clone(obj);\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster.clone();\n      }\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n  }\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.schema,\n        model: schematype.caster\n      });\n    }\n  }\n  return childSchemas;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n  return null;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n  return null;\n}\n\n/**\r\n * The Mongoose instance this schema is associated with\r\n *\r\n * @property base\r\n * @api private\r\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\r\n * Converts type arguments into Mongoose Types.\r\n *\r\n * @param {String} path\r\n * @param {Object} obj constructor\r\n * @param {Object} options\r\n * @api private\r\n */\n\nSchema.prototype.interpretAsType = function (path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n  const Types = this.base != null ? this.base.Types : require('./types');\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type) ? obj[options.typeKey] : {};\n  let name;\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = type === Array || type === 'array' ? obj.cast || obj.of : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path + '` is from a different copy of the Mongoose module. ' + 'Please make sure you\\'re using the same version ' + 'of Mongoose everywhere with `npm list mongoose`. If you are still ' + 'getting this error, please add `new Schema()` around the path: ' + `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path + '` is from a different copy of the Mongoose module. ' + 'Please make sure you\\'re using the same version ' + 'of Mongoose everywhere with `npm list mongoose`. If you are still ' + 'getting this error, please add `new Schema()` around the path: ' + `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = {\n          minimize: options.minimize\n        };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n      name = typeof type === 'string' ? type : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' + `Could not determine the embedded type for array \\`${path}\\`. ` + 'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' + `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` + 'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` + 'invalid. See ' + 'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` + `a valid type at path \\`${path}\\`. See ` + 'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n  const schemaType = new MongooseTypes[name](path, obj);\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n  return schemaType;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = {\n    type: {}\n  };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = {\n        [schema.options.typeKey]: new Schema(obj.of)\n      };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = {\n        [schema.options.typeKey]: obj.of\n      };\n    }\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\r\n * Iterates the schemas paths similar to Array#forEach.\r\n *\r\n * The callback is passed the pathname and the schemaType instance.\r\n *\r\n * #### Example:\r\n *\r\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\r\n *     userSchema.eachPath((pathname, schematype) => {\r\n *       // Prints twice:\r\n *       // name SchemaString { ... }\r\n *       // registeredAt SchemaDate { ... }\r\n *       console.log(pathname, schematype);\r\n *     });\r\n *\r\n * @param {Function} fn callback function\r\n * @return {Schema} this\r\n * @api public\r\n */\n\nSchema.prototype.eachPath = function (fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n  return this;\n};\n\n/**\r\n * Returns an Array of path strings that are required by this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const s = new Schema({\r\n *       name: { type: String, required: true },\r\n *       age: { type: String, required: true },\r\n *       notes: String\r\n *     });\r\n *     s.requiredPaths(); // [ 'age', 'name' ]\r\n *\r\n * @api public\r\n * @param {Boolean} invalidate Refresh the cache\r\n * @return {Array}\r\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\r\n * Returns indexes from fields and schema-level indexes (cached).\r\n *\r\n * @api private\r\n * @return {Array}\r\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\r\n * Returns the pathType of `path` for this schema.\r\n *\r\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\r\n *\r\n * #### Example:\r\n *\r\n *     const s = new Schema({ name: String, nested: { foo: String } });\r\n *     s.virtual('foo').get(() => 42);\r\n *     s.pathType('name'); // \"real\"\r\n *     s.pathType('nested'); // \"nested\"\r\n *     s.pathType('foo'); // \"virtual\"\r\n *     s.pathType('fail'); // \"adhocOrUndefined\"\r\n *\r\n * @param {String} path\r\n * @return {String}\r\n * @api public\r\n */\n\nSchema.prototype.pathType = function (path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\r\n * Returns true iff this path is a child of a mixed schema.\r\n *\r\n * @param {String} path\r\n * @return {Boolean}\r\n * @api private\r\n */\n\nSchema.prototype.hasMixedParent = function (path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n  return null;\n};\n\n/**\r\n * Setup updatedAt and createdAt timestamps to documents if enabled\r\n *\r\n * @param {Boolean|Object} timestamps timestamps options\r\n * @api private\r\n */\nSchema.prototype.setupTimestamp = function (timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\r\n * ignore. Deprecated re: #6405\r\n * @param {Any} self\r\n * @param {String} path\r\n * @api private\r\n */\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ? self.paths[subpaths[0]] : 'adhocOrUndefined';\n  }\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n  const last = subpaths.length - 1;\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n    const type = val.schema.pathType(subpath);\n    isNested = type === 'nested';\n    val = val.schema.path(subpath);\n  }\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\r\n * Adds a method call to the queue.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.methods.print = function() { console.log(this); };\r\n *     schema.queue('print', []); // Print the doc every one is instantiated\r\n *\r\n *     const Model = mongoose.model('Test', schema);\r\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\r\n *\r\n * @param {String} name name of the document method to call later\r\n * @param {Array} args arguments to pass to the method\r\n * @api public\r\n */\n\nSchema.prototype.queue = function (name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\r\n * Defines a pre hook for the model.\r\n *\r\n * #### Example:\r\n *\r\n *     const toySchema = new Schema({ name: String, created: Date });\r\n *\r\n *     toySchema.pre('save', function(next) {\r\n *       if (!this.created) this.created = new Date;\r\n *       next();\r\n *     });\r\n *\r\n *     toySchema.pre('validate', function(next) {\r\n *       if (this.name !== 'Woody') this.name = 'Woody';\r\n *       next();\r\n *     });\r\n *\r\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\r\n *     toySchema.pre(/^find/, function(next) {\r\n *       console.log(this.getFilter());\r\n *     });\r\n *\r\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\r\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\r\n *       console.log(this.getFilter());\r\n *     });\r\n *\r\n *     toySchema.pre('deleteOne', function() {\r\n *       // Runs when you call `Toy.deleteOne()`\r\n *     });\r\n *\r\n *     toySchema.pre('deleteOne', { document: true }, function() {\r\n *       // Runs when you call `doc.deleteOne()`\r\n *     });\r\n *\r\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\r\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\r\n * @param {Function} callback\r\n * @api public\r\n */\n\nSchema.prototype.pre = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\r\n * Defines a post hook for the document\r\n *\r\n *     const schema = new Schema(..);\r\n *     schema.post('save', function (doc) {\r\n *       console.log('this fired after a document was saved');\r\n *     });\r\n *\r\n *     schema.post('find', function(docs) {\r\n *       console.log('this fired after you ran a find query');\r\n *     });\r\n *\r\n *     schema.post(/Many$/, function(res) {\r\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\r\n *     });\r\n *\r\n *     const Model = mongoose.model('Model', schema);\r\n *\r\n *     const m = new Model(..);\r\n *     m.save(function(err) {\r\n *       console.log('this fires after the `post` hook');\r\n *     });\r\n *\r\n *     m.find(function(err, docs) {\r\n *       console.log('this fires after the post find hook');\r\n *     });\r\n *\r\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\r\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\r\n * @param {Function} fn callback\r\n * @see middleware https://mongoosejs.com/docs/middleware.html\r\n * @see kareem https://npmjs.org/package/kareem\r\n * @api public\r\n */\n\nSchema.prototype.post = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\r\n * Registers a plugin for this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const s = new Schema({ name: String });\r\n *     s.plugin(schema => console.log(schema.path('name').path));\r\n *     mongoose.model('Test', s); // Prints 'name'\r\n *\r\n * Or with Options:\r\n *\r\n *     const s = new Schema({ name: String });\r\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\r\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\r\n *\r\n * @param {Function} plugin The Plugin's callback\r\n * @param {Object} [opts] Options to pass to the plugin\r\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\r\n * @see plugins /docs/plugins.html\r\n * @api public\r\n */\n\nSchema.prototype.plugin = function (fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' + 'got \"' + typeof fn + '\"');\n  }\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({\n    fn: fn,\n    opts: opts\n  });\n  fn(this, opts);\n  return this;\n};\n\n/**\r\n * Adds an instance method to documents constructed from Models compiled from this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = kittySchema = new Schema(..);\r\n *\r\n *     schema.method('meow', function () {\r\n *       console.log('meeeeeoooooooooooow');\r\n *     })\r\n *\r\n *     const Kitty = mongoose.model('Kitty', schema);\r\n *\r\n *     const fizz = new Kitty;\r\n *     fizz.meow(); // meeeeeooooooooooooow\r\n *\r\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\r\n *\r\n *     schema.method({\r\n *         purr: function () {}\r\n *       , scratch: function () {}\r\n *     });\r\n *\r\n *     // later\r\n *     const fizz = new Kitty;\r\n *     fizz.purr();\r\n *     fizz.scratch();\r\n *\r\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)\r\n *\r\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\r\n * @param {Function} [fn] The Function in a single-function definition.\r\n * @api public\r\n */\n\nSchema.prototype.method = function (name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n  return this;\n};\n\n/**\r\n * Adds static \"class\" methods to Models compiled from this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema(..);\r\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\r\n *     schema.static('findByName', function(name) {\r\n *       return this.find({ name: name });\r\n *     });\r\n *\r\n *     const Drink = mongoose.model('Drink', schema);\r\n *     await Drink.findByName('LaCroix');\r\n *\r\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\r\n *\r\n *     schema.static({\r\n *         findByName: function () {..}\r\n *       , findByCost: function () {..}\r\n *     });\r\n *\r\n *     const Drink = mongoose.model('Drink', schema);\r\n *     await Drink.findByName('LaCroix');\r\n *     await Drink.findByCost(3);\r\n *\r\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\r\n *\r\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\r\n * @param {Function} [fn] The Function in a single-function definition.\r\n * @api public\r\n * @see Statics /docs/guide.html#statics\r\n */\n\nSchema.prototype.static = function (name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\r\n * Defines an index (most likely compound) for this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.index({ first: 1, last: -1 })\r\n *\r\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\r\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\r\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\r\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\r\n * @api public\r\n */\n\nSchema.prototype.index = function (fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n  if (options.expires) {\n    utils.expires(options);\n  }\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\r\n * Sets a schema option.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.set('strict'); // 'true' by default\r\n *     schema.set('strict', false); // Sets 'strict' to false\r\n *     schema.set('strict'); // 'false'\r\n *\r\n * @param {String} key The name of the option to set the value to\r\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\r\n * @see Schema #schema_Schema\r\n * @api public\r\n */\n\nSchema.prototype.set = function (key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n  return this;\n};\n\n/**\r\n * Gets a schema option.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.get('strict'); // true\r\n *     schema.set('strict', false);\r\n *     schema.get('strict'); // false\r\n *\r\n * @param {String} key The name of the Option to get the current value for\r\n * @api public\r\n * @return {Any} the option's value\r\n */\n\nSchema.prototype.get = function (key) {\n  return this.options[key];\n};\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\r\n * The allowed index types\r\n *\r\n * @property {String[]} indexTypes\r\n * @memberOf Schema\r\n * @static\r\n * @api public\r\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function () {\n    return indexTypes;\n  },\n  set: function () {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\r\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\r\n * Indexes are expressed as an array `[spec, options]`.\r\n *\r\n * #### Example:\r\n *\r\n *     const userSchema = new Schema({\r\n *       email: { type: String, required: true, unique: true },\r\n *       registeredAt: { type: Date, index: true }\r\n *     });\r\n *\r\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\r\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\r\n *     userSchema.indexes();\r\n *\r\n * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\r\n * For example, the below plugin makes every index unique by default.\r\n *\r\n *     function myPlugin(schema) {\r\n *       for (const index of schema.indexes()) {\r\n *         if (index[1].unique === undefined) {\r\n *           index[1].unique = true;\r\n *         }\r\n *       }\r\n *     }\r\n *\r\n * @api public\r\n * @return {Array} list of indexes defined in the schema\r\n */\n\nSchema.prototype.indexes = function () {\n  return getIndexes(this);\n};\n\n/**\r\n * Creates a virtual type with the given name.\r\n *\r\n * @param {String} name The name of the Virtual\r\n * @param {Object} [options]\r\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).\r\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\r\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\r\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\r\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\r\n * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\r\n * @return {VirtualType}\r\n */\n\nSchema.prototype.virtual = function (name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n    this.pre('init', function virtualPreInit(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        }\n        mpath.unset(name, obj);\n      }\n    });\n    const virtual = this.virtual(name);\n    virtual.options = options;\n    virtual.set(function (_v) {\n      if (!this.$$populatedVirtuals) {\n        this.$$populatedVirtuals = {};\n      }\n      if (options.justOne || options.count) {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n        if (typeof this.$$populatedVirtuals[name] !== 'object') {\n          this.$$populatedVirtuals[name] = options.count ? _v : null;\n        }\n      } else {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function (doc) {\n          return doc && typeof doc === 'object';\n        });\n      }\n    });\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n      cur += '.' + parts[i + 1];\n    }\n    return virtual;\n  }\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' + ' conflicts with a real path in the schema');\n  }\n  virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});\n    return mem[part];\n  }, this.tree);\n  return virtuals[name];\n};\n\n/**\r\n * Returns the virtual type with the given `name`.\r\n *\r\n * @param {String} name The name of the Virtual to get\r\n * @return {VirtualType|null}\r\n */\n\nSchema.prototype.virtualpath = function (name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\r\n * Removes the given `path` (or [`paths`]).\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ name: String, age: Number });\r\n *     schema.remove('name');\r\n *     schema.path('name'); // Undefined\r\n *     schema.path('age'); // SchemaNumber { ... }\r\n *\r\n * Or as a Array:\r\n *\r\n *     schema.remove(['name', 'age']);\r\n *     schema.path('name'); // Undefined\r\n *     schema.path('age'); // Undefined\r\n *\r\n * @param {String|Array} path The Path(s) to remove\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\nSchema.prototype.remove = function (path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function (name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n  let branch = schema.tree;\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n  delete branch[last];\n}\n\n/**\r\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\r\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\r\n * to schema [virtuals](/docs/guide.html#virtuals),\r\n * [statics](/docs/guide.html#statics), and\r\n * [methods](/docs/guide.html#methods).\r\n *\r\n * #### Example:\r\n *\r\n * ```javascript\r\n * const md5 = require('md5');\r\n * const userSchema = new Schema({ email: String });\r\n * class UserClass {\r\n *   // `gravatarImage` becomes a virtual\r\n *   get gravatarImage() {\r\n *     const hash = md5(this.email.toLowerCase());\r\n *     return `https://www.gravatar.com/avatar/${hash}`;\r\n *   }\r\n *\r\n *   // `getProfileUrl()` becomes a document method\r\n *   getProfileUrl() {\r\n *     return `https://mysite.com/${this.email}`;\r\n *   }\r\n *\r\n *   // `findByEmail()` becomes a static\r\n *   static findByEmail(email) {\r\n *     return this.findOne({ email });\r\n *   }\r\n * }\r\n *\r\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\r\n * // and a `findByEmail()` static\r\n * userSchema.loadClass(UserClass);\r\n * ```\r\n *\r\n * @param {Function} model The Class to load\r\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\r\n */\nSchema.prototype.loadClass = function (model, virtualsOnly) {\n  if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function (name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function (name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nSchema.prototype._getSchema = function (path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n        foundschema.$fullPath = resultPath.join('.');\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\r\n * ignore\r\n */\n\nSchema.prototype._getPathType = function (path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  if (pathschema) {\n    return 'real';\n  }\n  function search(parts, schema) {\n    let p = parts.length + 1,\n      foundschema,\n      trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return {\n              schema: foundschema,\n              pathType: 'mixed'\n            };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return {\n                  schema: foundschema,\n                  pathType: 'nested'\n                };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return {\n          schema: foundschema,\n          pathType: 'real'\n        };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return {\n          schema: schema,\n          pathType: 'nested'\n        };\n      }\n    }\n    return {\n      schema: foundschema || schema,\n      pathType: 'undefined'\n    };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\r\n * Called by `compile()` _right before_ compiling. Good for making any changes to\r\n * the schema that should respect options set by plugins, like `id`\r\n * @method _preCompile\r\n * @memberOf Schema\r\n * @instance\r\n * @api private\r\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n\n/*!\r\n * Module exports.\r\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\r\n * The various built-in Mongoose Schema Types.\r\n *\r\n * #### Example:\r\n *\r\n *     const mongoose = require('mongoose');\r\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\r\n *\r\n * #### Types:\r\n *\r\n * - [String](/docs/schematypes.html#strings)\r\n * - [Number](/docs/schematypes.html#numbers)\r\n * - [Boolean](/docs/schematypes.html#booleans) | Bool\r\n * - [Array](/docs/schematypes.html#arrays)\r\n * - [Buffer](/docs/schematypes.html#buffers)\r\n * - [Date](/docs/schematypes.html#dates)\r\n * - [ObjectId](/docs/schematypes.html#objectids) | Oid\r\n * - [Mixed](/docs/schematypes.html#mixed)\r\n *\r\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\r\n *\r\n *     const Mixed = mongoose.Schema.Types.Mixed;\r\n *     new mongoose.Schema({ _user: Mixed })\r\n *\r\n * @api public\r\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\r\n * ignore\r\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;","map":{"version":3,"names":["EventEmitter","require","Kareem","MongooseError","SchemaType","SchemaTypeOptions","VirtualOptions","VirtualType","addAutoId","get","getConstructorName","getIndexes","idGetter","merge","mpath","readPref","ReadPreference","setupTimestamps","utils","validateRef","util","MongooseTypes","queryHooks","middlewareFunctions","documentHooks","hookNames","concat","reduce","s","hook","add","Set","isPOJO","id","Schema","obj","options","paths","aliases","subpaths","virtuals","singleNestedPaths","nested","inherits","callQueue","_indexes","methods","methodOptions","statics","tree","query","childSchemas","plugins","$id","mapPaths","hooks","defaultOptions","Array","isArray","definition","pathNames","Object","keys","pathName","pathOptions","undefined","virtual","set","_idSubDoc","_id","isObject","auto_id","setupTimestamp","timestamps","aliasFields","schema","path","alias","prop","a","Error","p","v","$set","prototype","create","constructor","instanceOfSchema","defineProperty","configurable","enumerable","writable","clone","_clone","on","emit","Constructor","base","_userProvidedOptions","map","f","slice","call","gatherChildSchemas","$globalPluginsApplied","$isRootDiscriminator","$implicitlyCreated","$originalSchemaId","discriminatorMapping","assign","discriminators","_applyDiscriminators","pick","newSchema","schematype","baseOptions","strict","strictQuery","bufferCommands","capped","versionKey","optimisticConcurrency","minimize","autoIndex","discriminatorKey","shardKey","read","validateBeforeSave","typeKey","discriminator","name","prefix","key","specialProperties","has","fullPath","val","TypeError","length","substring","schemaType","applyDiscriminators","disc","type","_typeDef","_schema","schemaWrappedPath","aliasObj","fromEntries","entries","removeIndex","index","arguments","i","isDeepStrictEqual","splice","clearIndexes","reserved","listeners","removeListener","collection","errors","init","isModified","isNew","populated","remove","save","toObject","validate","cleanPath","_pathToPositionalSyntax","_getPath","mapPath","getMapPath","hasMixedParent","test","getPositionalPath","firstPieceOfPath","split","supressReservedKeysWarning","errorMessage","warn","hasUserDefinedProperty","ref","last","pop","branch","sub","msg","interpretAsType","$isSchemaMap","$__schemaType","push","$isSingleNested","value","caster","model","$isMongooseDocumentArray","casterConstructor","$isMongooseArray","arrayPath","_schemaType","toAdd","$embeddedSchemaType","_arrayPath","_arrayParentPath","$isUnderneathDocArray","hasOwnProperty","replace","_path","re","RegExp","Types","constructorName","getFunctionName","oldObj","Function","Mixed","cast","of","DocumentArray","castFromTypeKey","charAt","toUpperCase","childSchemaOptions","childSchema","schemaName","Subdocument","Buffer","isBuffer","ObjectId","Decimal128","toString","createMapNestedSchemaType","_mapType","isInlineSchema","subdocumentSchema","eachPath","subpath","select","fn","len","requiredPaths","invalidate","_requiredpaths","ret","isRequired","indexedPaths","_indexedpaths","indexes","pathType","singleNestedPath","getPositionalPathType","self","filter","Boolean","isNested","queue","args","pre","remainingArgs","apply","el","post","plugin","opts","deduplicate","method","static","fields","expires","_tags","auto","indexTypes","localField","foreignField","virtualPreInit","_v","$$populatedVirtuals","justOne","count","unset","doc","parts","cur","remnant","join","mem","part","virtualpath","forEach","allKeys","startsWith","_deletePath","pieces","piece","loadClass","virtualsOnly","getPrototypeOf","getOwnPropertyNames","match","getOwnPropertyDescriptor","getters","setters","_getSchema","_this","pathschema","resultPath","$fullPath","search","foundschema","trypath","isArrayFilter","_getPathType","endsWith","_preCompile","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/schema.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst Kareem = require('kareem');\r\nconst MongooseError = require('./error/mongooseError');\r\nconst SchemaType = require('./schematype');\r\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\r\nconst VirtualOptions = require('./options/VirtualOptions');\r\nconst VirtualType = require('./virtualtype');\r\nconst addAutoId = require('./helpers/schema/addAutoId');\r\nconst get = require('./helpers/get');\r\nconst getConstructorName = require('./helpers/getConstructorName');\r\nconst getIndexes = require('./helpers/schema/getIndexes');\r\nconst idGetter = require('./helpers/schema/idGetter');\r\nconst merge = require('./helpers/schema/merge');\r\nconst mpath = require('mpath');\r\nconst readPref = require('./driver').get().ReadPreference;\r\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\r\nconst utils = require('./utils');\r\nconst validateRef = require('./helpers/populate/validateRef');\r\nconst util = require('util');\r\n\r\nlet MongooseTypes;\r\n\r\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').\r\n  middlewareFunctions;\r\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\r\nconst hookNames = queryHooks.concat(documentHooks).\r\n  reduce((s, hook) => s.add(hook), new Set());\r\n\r\nconst isPOJO = utils.isPOJO;\r\n\r\nlet id = 0;\r\n\r\n/**\r\n * Schema constructor.\r\n *\r\n * #### Example:\r\n *\r\n *     const child = new Schema({ name: String });\r\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\r\n *     const Tree = mongoose.model('Tree', schema);\r\n *\r\n *     // setting schema options\r\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\r\n *\r\n * #### Options:\r\n *\r\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\r\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\r\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\r\n * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\r\n * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false\r\n * - [collection](/docs/guide.html#collection): string - no default\r\n * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`\r\n * - [id](/docs/guide.html#id): bool - defaults to true\r\n * - [_id](/docs/guide.html#_id): bool - defaults to true\r\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\r\n * - [read](/docs/guide.html#read): string\r\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\r\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\r\n * - [strict](/docs/guide.html#strict): bool - defaults to true\r\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\r\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\r\n * - [toObject](/docs/guide.html#toObject) - object - no default\r\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\r\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\r\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\r\n * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\r\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\r\n * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\r\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\r\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\r\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\r\n * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\r\n *\r\n * #### Options for Nested Schemas:\r\n *\r\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\r\n *\r\n * #### Note:\r\n *\r\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\r\n *\r\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\r\n * @param {Object} [options]\r\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\r\n * @event `init`: Emitted after the schema is compiled into a `Model`.\r\n * @api public\r\n */\r\n\r\nfunction Schema(obj, options) {\r\n  if (!(this instanceof Schema)) {\r\n    return new Schema(obj, options);\r\n  }\r\n\r\n  this.obj = obj;\r\n  this.paths = {};\r\n  this.aliases = {};\r\n  this.subpaths = {};\r\n  this.virtuals = {};\r\n  this.singleNestedPaths = {};\r\n  this.nested = {};\r\n  this.inherits = {};\r\n  this.callQueue = [];\r\n  this._indexes = [];\r\n  this.methods = (options && options.methods) || {};\r\n  this.methodOptions = {};\r\n  this.statics = (options && options.statics) || {};\r\n  this.tree = {};\r\n  this.query = (options && options.query) || {};\r\n  this.childSchemas = [];\r\n  this.plugins = [];\r\n  // For internal debugging. Do not use this to try to save a schema in MDB.\r\n  this.$id = ++id;\r\n  this.mapPaths = [];\r\n\r\n  this.s = {\r\n    hooks: new Kareem()\r\n  };\r\n  this.options = this.defaultOptions(options);\r\n\r\n  // build paths\r\n  if (Array.isArray(obj)) {\r\n    for (const definition of obj) {\r\n      this.add(definition);\r\n    }\r\n  } else if (obj) {\r\n    this.add(obj);\r\n  }\r\n\r\n  // build virtual paths\r\n  if (options && options.virtuals) {\r\n    const virtuals = options.virtuals;\r\n    const pathNames = Object.keys(virtuals);\r\n    for (const pathName of pathNames) {\r\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\r\n      const virtual = this.virtual(pathName, pathOptions);\r\n\r\n      if (virtuals[pathName].get) {\r\n        virtual.get(virtuals[pathName].get);\r\n      }\r\n\r\n      if (virtuals[pathName].set) {\r\n        virtual.set(virtuals[pathName].set);\r\n      }\r\n    }\r\n  }\r\n\r\n  // check if _id's value is a subdocument (gh-2276)\r\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\r\n\r\n  // ensure the documents get an auto _id unless disabled\r\n  const auto_id = !this.paths['_id'] &&\r\n      (this.options._id) && !_idSubDoc;\r\n\r\n  if (auto_id) {\r\n    addAutoId(this);\r\n  }\r\n\r\n  this.setupTimestamp(this.options.timestamps);\r\n}\r\n\r\n/**\r\n * Create virtual properties with alias field\r\n * @api private\r\n */\r\nfunction aliasFields(schema, paths) {\r\n  for (const path of Object.keys(paths)) {\r\n    let alias = null;\r\n    if (paths[path] != null) {\r\n      alias = paths[path];\r\n    } else {\r\n      const options = get(schema.paths[path], 'options');\r\n      if (options == null) {\r\n        continue;\r\n      }\r\n\r\n      alias = options.alias;\r\n    }\r\n\r\n    if (!alias) {\r\n      continue;\r\n    }\r\n\r\n    const prop = schema.paths[path].path;\r\n    if (Array.isArray(alias)) {\r\n      for (const a of alias) {\r\n        if (typeof a !== 'string') {\r\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\r\n        }\r\n\r\n        schema.aliases[a] = prop;\r\n\r\n        schema.\r\n          virtual(a).\r\n          get((function(p) {\r\n            return function() {\r\n              if (typeof this.get === 'function') {\r\n                return this.get(p);\r\n              }\r\n              return this[p];\r\n            };\r\n          })(prop)).\r\n          set((function(p) {\r\n            return function(v) {\r\n              return this.$set(p, v);\r\n            };\r\n          })(prop));\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (typeof alias !== 'string') {\r\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\r\n    }\r\n\r\n    schema.aliases[alias] = prop;\r\n\r\n    schema.\r\n      virtual(alias).\r\n      get((function(p) {\r\n        return function() {\r\n          if (typeof this.get === 'function') {\r\n            return this.get(p);\r\n          }\r\n          return this[p];\r\n        };\r\n      })(prop)).\r\n      set((function(p) {\r\n        return function(v) {\r\n          return this.$set(p, v);\r\n        };\r\n      })(prop));\r\n  }\r\n}\r\n\r\n/*!\r\n * Inherit from EventEmitter.\r\n */\r\nSchema.prototype = Object.create(EventEmitter.prototype);\r\nSchema.prototype.constructor = Schema;\r\nSchema.prototype.instanceOfSchema = true;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nObject.defineProperty(Schema.prototype, '$schemaType', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  writable: true\r\n});\r\n\r\n/**\r\n * Array of child schemas (from document arrays and single nested subdocs)\r\n * and their corresponding compiled models. Each element of the array is\r\n * an object with 2 properties: `schema` and `model`.\r\n *\r\n * This property is typically only useful for plugin authors and advanced users.\r\n * You do not need to interact with this property at all to use mongoose.\r\n *\r\n * @api public\r\n * @property childSchemas\r\n * @memberOf Schema\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Schema.prototype, 'childSchemas', {\r\n  configurable: false,\r\n  enumerable: true,\r\n  writable: true\r\n});\r\n\r\n/**\r\n * Object containing all virtuals defined on this schema.\r\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\r\n *\r\n * This property is typically only useful for plugin authors and advanced users.\r\n * You do not need to interact with this property at all to use mongoose.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({});\r\n *     schema.virtual('answer').get(() => 42);\r\n *\r\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\r\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\r\n *\r\n * @api public\r\n * @property virtuals\r\n * @memberOf Schema\r\n * @instance\r\n */\r\n\r\nObject.defineProperty(Schema.prototype, 'virtuals', {\r\n  configurable: false,\r\n  enumerable: true,\r\n  writable: true\r\n});\r\n\r\n/**\r\n * The original object passed to the schema constructor\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ a: String }).add({ b: String });\r\n *     schema.obj; // { a: String }\r\n *\r\n * @api public\r\n * @property obj\r\n * @memberOf Schema\r\n * @instance\r\n */\r\n\r\nSchema.prototype.obj;\r\n\r\n/**\r\n * The paths defined on this schema. The keys are the top-level paths\r\n * in this schema, and the values are instances of the SchemaType class.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ name: String }, { _id: false });\r\n *     schema.paths; // { name: SchemaString { ... } }\r\n *\r\n *     schema.add({ age: Number });\r\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\r\n *\r\n * @api public\r\n * @property paths\r\n * @memberOf Schema\r\n * @instance\r\n */\r\n\r\nSchema.prototype.paths;\r\n\r\n/**\r\n * Schema as a tree\r\n *\r\n * #### Example:\r\n *\r\n *     {\r\n *         '_id'     : ObjectId\r\n *       , 'nested'  : {\r\n *             'key' : String\r\n *         }\r\n *     }\r\n *\r\n * @api private\r\n * @property tree\r\n * @memberOf Schema\r\n * @instance\r\n */\r\n\r\nSchema.prototype.tree;\r\n\r\n/**\r\n * Returns a deep copy of the schema\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ name: String });\r\n *     const clone = schema.clone();\r\n *     clone === schema; // false\r\n *     clone.path('name'); // SchemaString { ... }\r\n *\r\n * @return {Schema} the cloned schema\r\n * @api public\r\n * @memberOf Schema\r\n * @instance\r\n */\r\n\r\nSchema.prototype.clone = function() {\r\n  const s = this._clone();\r\n\r\n  // Bubble up `init` for backwards compat\r\n  s.on('init', v => this.emit('init', v));\r\n\r\n  return s;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchema.prototype._clone = function _clone(Constructor) {\r\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\r\n\r\n  const s = new Constructor({}, this._userProvidedOptions);\r\n  s.base = this.base;\r\n  s.obj = this.obj;\r\n  s.options = utils.clone(this.options);\r\n  s.callQueue = this.callQueue.map(function(f) { return f; });\r\n  s.methods = utils.clone(this.methods);\r\n  s.methodOptions = utils.clone(this.methodOptions);\r\n  s.statics = utils.clone(this.statics);\r\n  s.query = utils.clone(this.query);\r\n  s.plugins = Array.prototype.slice.call(this.plugins);\r\n  s._indexes = utils.clone(this._indexes);\r\n  s.s.hooks = this.s.hooks.clone();\r\n\r\n  s.tree = utils.clone(this.tree);\r\n  s.paths = utils.clone(this.paths);\r\n  s.nested = utils.clone(this.nested);\r\n  s.subpaths = utils.clone(this.subpaths);\r\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\r\n  s.childSchemas = gatherChildSchemas(s);\r\n\r\n  s.virtuals = utils.clone(this.virtuals);\r\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\r\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\r\n  s.$implicitlyCreated = this.$implicitlyCreated;\r\n  s.$id = ++id;\r\n  s.$originalSchemaId = this.$id;\r\n  s.mapPaths = [].concat(this.mapPaths);\r\n\r\n  if (this.discriminatorMapping != null) {\r\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\r\n  }\r\n  if (this.discriminators != null) {\r\n    s.discriminators = Object.assign({}, this.discriminators);\r\n  }\r\n  if (this._applyDiscriminators != null) {\r\n    s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);\r\n  }\r\n\r\n  s.aliases = Object.assign({}, this.aliases);\r\n\r\n  return s;\r\n};\r\n\r\n/**\r\n * Returns a new schema that has the picked `paths` from this schema.\r\n *\r\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = Schema({ name: String, age: Number });\r\n *     // Creates a new schema with the same `name` path as `schema`,\r\n *     // but no `age` path.\r\n *     const newSchema = schema.pick(['name']);\r\n *\r\n *     newSchema.path('name'); // SchemaString { ... }\r\n *     newSchema.path('age'); // undefined\r\n *\r\n * @param {String[]} paths List of Paths to pick for the new Schema\r\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\r\n * @return {Schema}\r\n * @api public\r\n */\r\n\r\nSchema.prototype.pick = function(paths, options) {\r\n  const newSchema = new Schema({}, options || this.options);\r\n  if (!Array.isArray(paths)) {\r\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\r\n      'got \"' + typeof paths + '\"');\r\n  }\r\n\r\n  for (const path of paths) {\r\n    if (this.nested[path]) {\r\n      newSchema.add({ [path]: get(this.tree, path) });\r\n    } else {\r\n      const schematype = this.path(path);\r\n      if (schematype == null) {\r\n        throw new MongooseError('Path `' + path + '` is not in the schema');\r\n      }\r\n      newSchema.add({ [path]: schematype });\r\n    }\r\n  }\r\n\r\n  return newSchema;\r\n};\r\n\r\n/**\r\n * Returns default options for this schema, merged with `options`.\r\n *\r\n * @param {Object} [options] Options to overwrite the default options\r\n * @return {Object} The merged options of `options` and the default options\r\n * @api private\r\n */\r\n\r\nSchema.prototype.defaultOptions = function(options) {\r\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\r\n  const baseOptions = this.base && this.base.options || {};\r\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\r\n  const id = 'id' in baseOptions ? baseOptions.id : true;\r\n  options = utils.options({\r\n    strict: strict,\r\n    strictQuery: 'strict' in this._userProvidedOptions ?\r\n      this._userProvidedOptions.strict :\r\n      'strictQuery' in baseOptions ?\r\n        baseOptions.strictQuery : strict,\r\n    bufferCommands: true,\r\n    capped: false, // { size, max, autoIndexId }\r\n    versionKey: '__v',\r\n    optimisticConcurrency: false,\r\n    minimize: true,\r\n    autoIndex: null,\r\n    discriminatorKey: '__t',\r\n    shardKey: null,\r\n    read: null,\r\n    validateBeforeSave: true,\r\n    // the following are only applied at construction time\r\n    _id: true,\r\n    id: id,\r\n    typeKey: 'type'\r\n  }, utils.clone(options));\r\n\r\n  if (options.read) {\r\n    options.read = readPref(options.read);\r\n  }\r\n\r\n  if (options.versionKey && typeof options.versionKey !== 'string') {\r\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\r\n  }\r\n\r\n  if (options.optimisticConcurrency && !options.versionKey) {\r\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\r\n  }\r\n\r\n  return options;\r\n};\r\n\r\n/**\r\n * Inherit a Schema by applying a discriminator on an existing Schema.\r\n *\r\n *\r\n * #### Example:\r\n *\r\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\r\n *\r\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\r\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\r\n *\r\n *     const Event = mongoose.model('Event', eventSchema);\r\n *\r\n *     Event.discriminators['clicked']; // Model { clicked }\r\n *\r\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\r\n *     doc.element; // '#hero'\r\n *     doc instanceof ClickedModel; // true\r\n *\r\n * @param {String} name the name of the discriminator\r\n * @param {Schema} schema the discriminated Schema\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\r\nSchema.prototype.discriminator = function(name, schema) {\r\n  this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, { [name]: schema });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds key path / schema type pairs to this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const ToySchema = new Schema();\r\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\r\n *\r\n *     const TurboManSchema = new Schema();\r\n *     // You can also `add()` another schema and copy over all paths, virtuals,\r\n *     // getters, setters, indexes, methods, and statics.\r\n *     TurboManSchema.add(ToySchema).add({ year: Number });\r\n *\r\n * @param {Object|Schema} obj plain object with paths to add, or another schema\r\n * @param {String} [prefix] path to prefix the newly added paths with\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\r\n\r\nSchema.prototype.add = function add(obj, prefix) {\r\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\r\n    merge(this, obj);\r\n\r\n    return this;\r\n  }\r\n\r\n  // Special case: setting top-level `_id` to false should convert to disabling\r\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\r\n  // codebases use it (see gh-7516, gh-7512).\r\n  if (obj._id === false && prefix == null) {\r\n    this.options._id = false;\r\n  }\r\n\r\n  prefix = prefix || '';\r\n  // avoid prototype pollution\r\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\r\n    return this;\r\n  }\r\n\r\n  const keys = Object.keys(obj);\r\n  const typeKey = this.options.typeKey;\r\n  for (const key of keys) {\r\n    if (utils.specialProperties.has(key)) {\r\n      continue;\r\n    }\r\n\r\n    const fullPath = prefix + key;\r\n    const val = obj[key];\r\n\r\n    if (val == null) {\r\n      throw new TypeError('Invalid value for schema path `' + fullPath +\r\n        '`, got value \"' + val + '\"');\r\n    }\r\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\r\n    if (key === '_id' && val === false) {\r\n      continue;\r\n    }\r\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\r\n      this.virtual(val);\r\n      continue;\r\n    }\r\n\r\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\r\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\r\n        '`, got value \"' + val[0] + '\"');\r\n    }\r\n\r\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\r\n      // Special-case: Non-options definitely a path so leaf at this node\r\n      // Examples: Schema instances, SchemaType instances\r\n      if (prefix) {\r\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\r\n      }\r\n      this.path(prefix + key, val);\r\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\r\n        const schemaType = this.path(prefix + key);\r\n        for (const key in val[0].discriminators) {\r\n          schemaType.discriminator(key, val[0].discriminators[key]);\r\n        }\r\n      } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {\r\n        const applyDiscriminators = val[0]._applyDiscriminators || [];\r\n        const schemaType = this.path(prefix + key);\r\n        for (const disc in applyDiscriminators) {\r\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\r\n        }\r\n      }\r\n      else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {\r\n        const applyDiscriminators = val._applyDiscriminators || [];\r\n        const schemaType = this.path(prefix + key);\r\n        for (const disc in applyDiscriminators) {\r\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\r\n        }\r\n      }\r\n    } else if (Object.keys(val).length < 1) {\r\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\r\n      if (prefix) {\r\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\r\n      }\r\n      this.path(fullPath, val); // mixed type\r\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\r\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\r\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\r\n      // NestJS sometimes adds `Date.type`.\r\n      this.nested[fullPath] = true;\r\n      this.add(val, fullPath + '.');\r\n    } else {\r\n      // There IS a bona-fide type key that may also be a POJO\r\n      const _typeDef = val[typeKey];\r\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\r\n        // If a POJO is the value of a type key, make it a subdocument\r\n        if (prefix) {\r\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\r\n        }\r\n        const _schema = new Schema(_typeDef);\r\n        const schemaWrappedPath = Object.assign({}, val, { type: _schema });\r\n        this.path(prefix + key, schemaWrappedPath);\r\n      } else {\r\n        // Either the type is non-POJO or we interpret it as Mixed anyway\r\n        if (prefix) {\r\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\r\n        }\r\n        this.path(prefix + key, val);\r\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\r\n          const schemaType = this.path(prefix + key);\r\n          for (const key in val.discriminators) {\r\n            schemaType.discriminator(key, val.discriminators[key]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const aliasObj = Object.fromEntries(\r\n    Object.entries(obj).map(([key]) => ([prefix + key, null]))\r\n  );\r\n  aliasFields(this, aliasObj);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add an alias for `path`. This means getting or setting the `alias`\r\n * is equivalent to getting or setting the `path`.\r\n *\r\n * #### Example:\r\n *\r\n *     const toySchema = new Schema({ n: String });\r\n *\r\n *     // Make 'name' an alias for 'n'\r\n *     toySchema.alias('n', 'name');\r\n *\r\n *     const Toy = mongoose.model('Toy', toySchema);\r\n *     const turboMan = new Toy({ n: 'Turbo Man' });\r\n *\r\n *     turboMan.name; // 'Turbo Man'\r\n *     turboMan.n; // 'Turbo Man'\r\n *\r\n *     turboMan.name = 'Turbo Man Action Figure';\r\n *     turboMan.n; // 'Turbo Man Action Figure'\r\n *\r\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\r\n *\r\n *\r\n * @param {String} path real path to alias\r\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\r\n\r\nSchema.prototype.alias = function alias(path, alias) {\r\n  aliasFields(this, { [path]: alias });\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove an index by name or index specification.\r\n *\r\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\r\n * in MongoDB.\r\n *\r\n * #### Example:\r\n *\r\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\r\n *\r\n *     // Add a new index on { name, color }\r\n *     ToySchema.index({ name: 1, color: 1 });\r\n *\r\n *     // Remove index on { name, color }\r\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\r\n *     ToySchema.removeIndex({ name: 1, color: 1 });\r\n *\r\n *     // Add an index with a custom name\r\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\r\n *     // Remove index by name\r\n *     ToySchema.removeIndex('my custom index name');\r\n *\r\n * @param {Object|string} index name or index specification\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\r\n\r\nSchema.prototype.removeIndex = function removeIndex(index) {\r\n  if (arguments.length > 1) {\r\n    throw new Error('removeIndex() takes only 1 argument');\r\n  }\r\n\r\n  if (typeof index !== 'object' && typeof index !== 'string') {\r\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\r\n  }\r\n\r\n  if (typeof index === 'object') {\r\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\r\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\r\n        this._indexes.splice(i, 1);\r\n      }\r\n    }\r\n  } else {\r\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\r\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\r\n        this._indexes.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove all indexes from this schema.\r\n *\r\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\r\n * in MongoDB.\r\n *\r\n * #### Example:\r\n *\r\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\r\n *     ToySchema.index({ name: 1 });\r\n *     ToySchema.index({ color: 1 });\r\n *\r\n *     // Remove all indexes on this schema\r\n *     ToySchema.clearIndexes();\r\n *\r\n *     ToySchema.indexes(); // []\r\n *\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\r\n\r\nSchema.prototype.clearIndexes = function clearIndexes() {\r\n  this._indexes.length = 0;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Reserved document keys.\r\n *\r\n * Keys in this object are names that are warned in schema declarations\r\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\r\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\r\n *\r\n * - _posts\r\n * - _pres\r\n * - collection\r\n  * - emit\r\n * - errors\r\n * - get\r\n * - init\r\n * - isModified\r\n * - isNew\r\n * - listeners\r\n * - modelName\r\n * - on\r\n * - once\r\n * - populated\r\n * - prototype\r\n * - remove\r\n * - removeListener\r\n * - save\r\n * - schema\r\n * - toObject\r\n * - validate\r\n *\r\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\r\n *\r\n *      const schema = new Schema(..);\r\n *      schema.methods.init = function () {} // potentially breaking\r\n *\r\n * @property reserved\r\n * @memberOf Schema\r\n * @static\r\n */\r\n\r\nSchema.reserved = Object.create(null);\r\nSchema.prototype.reserved = Schema.reserved;\r\n\r\nconst reserved = Schema.reserved;\r\n// Core object\r\nreserved['prototype'] =\r\n// EventEmitter\r\nreserved.emit =\r\nreserved.listeners =\r\nreserved.removeListener =\r\n\r\n// document properties and functions\r\nreserved.collection =\r\nreserved.errors =\r\nreserved.get =\r\nreserved.init =\r\nreserved.isModified =\r\nreserved.isNew =\r\nreserved.populated =\r\nreserved.remove =\r\nreserved.save =\r\nreserved.toObject =\r\nreserved.validate = 1;\r\nreserved.collection = 1;\r\n\r\n/**\r\n * Gets/sets schema paths.\r\n *\r\n * Sets a path (if arity 2)\r\n * Gets a path (if arity 1)\r\n *\r\n * #### Example:\r\n *\r\n *     schema.path('name') // returns a SchemaType\r\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\r\n *\r\n * @param {String} path The name of the Path to get / set\r\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\r\n * @api public\r\n */\r\n\r\nSchema.prototype.path = function(path, obj) {\r\n  // Convert to '.$' to check subpaths re: gh-6405\r\n  const cleanPath = _pathToPositionalSyntax(path);\r\n  if (obj === undefined) {\r\n    let schematype = _getPath(this, path, cleanPath);\r\n    if (schematype != null) {\r\n      return schematype;\r\n    }\r\n\r\n    // Look for maps\r\n    const mapPath = getMapPath(this, path);\r\n    if (mapPath != null) {\r\n      return mapPath;\r\n    }\r\n\r\n    // Look if a parent of this path is mixed\r\n    schematype = this.hasMixedParent(cleanPath);\r\n    if (schematype != null) {\r\n      return schematype;\r\n    }\r\n\r\n    // subpaths?\r\n    return /\\.\\d+\\.?.*$/.test(path)\r\n      ? getPositionalPath(this, path)\r\n      : undefined;\r\n  }\r\n\r\n  // some path names conflict with document methods\r\n  const firstPieceOfPath = path.split('.')[0];\r\n  if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {\r\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\r\n      'You are allowed to use it, but use at your own risk. ' +\r\n      'To disable this warning pass `supressReservedKeysWarning` as a schema option.';\r\n\r\n    utils.warn(errorMessage);\r\n  }\r\n\r\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\r\n    validateRef(obj.ref, path);\r\n  }\r\n\r\n  // update the tree\r\n  const subpaths = path.split(/\\./);\r\n  const last = subpaths.pop();\r\n  let branch = this.tree;\r\n  let fullPath = '';\r\n\r\n  for (const sub of subpaths) {\r\n    if (utils.specialProperties.has(sub)) {\r\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\r\n    }\r\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\r\n    if (!branch[sub]) {\r\n      this.nested[fullPath] = true;\r\n      branch[sub] = {};\r\n    }\r\n    if (typeof branch[sub] !== 'object') {\r\n      const msg = 'Cannot set nested path `' + path + '`. '\r\n          + 'Parent path `'\r\n          + fullPath\r\n          + '` already set to type ' + branch[sub].name\r\n          + '.';\r\n      throw new Error(msg);\r\n    }\r\n    branch = branch[sub];\r\n  }\r\n\r\n  branch[last] = utils.clone(obj);\r\n\r\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\r\n  const schemaType = this.paths[path];\r\n\r\n  if (schemaType.$isSchemaMap) {\r\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\r\n    // The '$' is to imply this path should never be stored in MongoDB so we\r\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\r\n    const mapPath = path + '.$*';\r\n\r\n    this.paths[mapPath] = schemaType.$__schemaType;\r\n    this.mapPaths.push(this.paths[mapPath]);\r\n  }\r\n\r\n  if (schemaType.$isSingleNested) {\r\n    for (const key of Object.keys(schemaType.schema.paths)) {\r\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\r\n    }\r\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\r\n      this.singleNestedPaths[path + '.' + key] =\r\n        schemaType.schema.singleNestedPaths[key];\r\n    }\r\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\r\n      this.singleNestedPaths[path + '.' + key] =\r\n        schemaType.schema.subpaths[key];\r\n    }\r\n    for (const key of Object.keys(schemaType.schema.nested)) {\r\n      this.singleNestedPaths[path + '.' + key] = 'nested';\r\n    }\r\n\r\n    Object.defineProperty(schemaType.schema, 'base', {\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: this.base\r\n    });\r\n\r\n    schemaType.caster.base = this.base;\r\n    this.childSchemas.push({\r\n      schema: schemaType.schema,\r\n      model: schemaType.caster\r\n    });\r\n  } else if (schemaType.$isMongooseDocumentArray) {\r\n    Object.defineProperty(schemaType.schema, 'base', {\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: this.base\r\n    });\r\n\r\n    schemaType.casterConstructor.base = this.base;\r\n    this.childSchemas.push({\r\n      schema: schemaType.schema,\r\n      model: schemaType.casterConstructor\r\n    });\r\n  }\r\n\r\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\r\n    let arrayPath = path;\r\n    let _schemaType = schemaType;\r\n\r\n    const toAdd = [];\r\n    while (_schemaType.$isMongooseArray) {\r\n      arrayPath = arrayPath + '.$';\r\n\r\n      // Skip arrays of document arrays\r\n      if (_schemaType.$isMongooseDocumentArray) {\r\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\r\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\r\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\r\n      } else {\r\n        _schemaType.caster._arrayPath = arrayPath;\r\n        _schemaType.caster._arrayParentPath = path;\r\n        _schemaType = _schemaType.caster.clone();\r\n      }\r\n\r\n      _schemaType.path = arrayPath;\r\n      toAdd.push(_schemaType);\r\n    }\r\n\r\n    for (const _schemaType of toAdd) {\r\n      this.subpaths[_schemaType.path] = _schemaType;\r\n    }\r\n  }\r\n\r\n  if (schemaType.$isMongooseDocumentArray) {\r\n    for (const key of Object.keys(schemaType.schema.paths)) {\r\n      const _schemaType = schemaType.schema.paths[key];\r\n      this.subpaths[path + '.' + key] = _schemaType;\r\n      if (typeof _schemaType === 'object' && _schemaType != null) {\r\n        _schemaType.$isUnderneathDocArray = true;\r\n      }\r\n    }\r\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\r\n      const _schemaType = schemaType.schema.subpaths[key];\r\n      this.subpaths[path + '.' + key] = _schemaType;\r\n      if (typeof _schemaType === 'object' && _schemaType != null) {\r\n        _schemaType.$isUnderneathDocArray = true;\r\n      }\r\n    }\r\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\r\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\r\n      this.subpaths[path + '.' + key] = _schemaType;\r\n      if (typeof _schemaType === 'object' && _schemaType != null) {\r\n        _schemaType.$isUnderneathDocArray = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction gatherChildSchemas(schema) {\r\n  const childSchemas = [];\r\n\r\n  for (const path of Object.keys(schema.paths)) {\r\n    const schematype = schema.paths[path];\r\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\r\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\r\n    }\r\n  }\r\n\r\n  return childSchemas;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _getPath(schema, path, cleanPath) {\r\n  if (schema.paths.hasOwnProperty(path)) {\r\n    return schema.paths[path];\r\n  }\r\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\r\n    return schema.subpaths[cleanPath];\r\n  }\r\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\r\n    return schema.singleNestedPaths[cleanPath];\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _pathToPositionalSyntax(path) {\r\n  if (!/\\.\\d+/.test(path)) {\r\n    return path;\r\n  }\r\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction getMapPath(schema, path) {\r\n  if (schema.mapPaths.length === 0) {\r\n    return null;\r\n  }\r\n  for (const val of schema.mapPaths) {\r\n    const _path = val.path;\r\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\r\n    if (re.test(path)) {\r\n      return schema.paths[_path];\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * The Mongoose instance this schema is associated with\r\n *\r\n * @property base\r\n * @api private\r\n */\r\n\r\nObject.defineProperty(Schema.prototype, 'base', {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: true,\r\n  value: null\r\n});\r\n\r\n/**\r\n * Converts type arguments into Mongoose Types.\r\n *\r\n * @param {String} path\r\n * @param {Object} obj constructor\r\n * @param {Object} options\r\n * @api private\r\n */\r\n\r\nSchema.prototype.interpretAsType = function(path, obj, options) {\r\n  if (obj instanceof SchemaType) {\r\n    if (obj.path === path) {\r\n      return obj;\r\n    }\r\n    const clone = obj.clone();\r\n    clone.path = path;\r\n    return clone;\r\n  }\r\n\r\n  // If this schema has an associated Mongoose object, use the Mongoose object's\r\n  // copy of SchemaTypes re: gh-7158 gh-6933\r\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\r\n  const Types = this.base != null ? this.base.Types : require('./types');\r\n\r\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\r\n    const constructorName = utils.getFunctionName(obj.constructor);\r\n    if (constructorName !== 'Object') {\r\n      const oldObj = obj;\r\n      obj = {};\r\n      obj[options.typeKey] = oldObj;\r\n    }\r\n  }\r\n\r\n  // Get the type making sure to allow keys named \"type\"\r\n  // and default to mixed if not specified.\r\n  // { type: { type: String, default: 'freshcut' } }\r\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\r\n    ? obj[options.typeKey]\r\n    : {};\r\n  let name;\r\n\r\n  if (utils.isPOJO(type) || type === 'mixed') {\r\n    return new MongooseTypes.Mixed(path, obj);\r\n  }\r\n\r\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\r\n    // if it was specified through { type } look for `cast`\r\n    let cast = (type === Array || type === 'array')\r\n      ? obj.cast || obj.of\r\n      : type[0];\r\n\r\n    // new Schema({ path: [new Schema({ ... })] })\r\n    if (cast && cast.instanceOfSchema) {\r\n      if (!(cast instanceof Schema)) {\r\n        throw new TypeError('Schema for array path `' + path +\r\n          '` is from a different copy of the Mongoose module. ' +\r\n          'Please make sure you\\'re using the same version ' +\r\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\r\n          'getting this error, please add `new Schema()` around the path: ' +\r\n          `${path}: new Schema(...)`);\r\n      }\r\n      return new MongooseTypes.DocumentArray(path, cast, obj);\r\n    }\r\n    if (cast &&\r\n        cast[options.typeKey] &&\r\n        cast[options.typeKey].instanceOfSchema) {\r\n      if (!(cast[options.typeKey] instanceof Schema)) {\r\n        throw new TypeError('Schema for array path `' + path +\r\n          '` is from a different copy of the Mongoose module. ' +\r\n          'Please make sure you\\'re using the same version ' +\r\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\r\n          'getting this error, please add `new Schema()` around the path: ' +\r\n          `${path}: new Schema(...)`);\r\n      }\r\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\r\n    }\r\n\r\n    if (Array.isArray(cast)) {\r\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\r\n    }\r\n\r\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\r\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\r\n      cast[options.typeKey] :\r\n      cast;\r\n    if (typeof cast === 'string') {\r\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\r\n    } else if (utils.isPOJO(castFromTypeKey)) {\r\n      if (Object.keys(castFromTypeKey).length) {\r\n        // The `minimize` and `typeKey` options propagate to child schemas\r\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\r\n        // See gh-3560\r\n        const childSchemaOptions = { minimize: options.minimize };\r\n        if (options.typeKey) {\r\n          childSchemaOptions.typeKey = options.typeKey;\r\n        }\r\n        // propagate 'strict' option to child schema\r\n        if (options.hasOwnProperty('strict')) {\r\n          childSchemaOptions.strict = options.strict;\r\n        }\r\n\r\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\r\n          childSchemaOptions._id = this._userProvidedOptions._id;\r\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\r\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\r\n        }\r\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\r\n        childSchema.$implicitlyCreated = true;\r\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\r\n      } else {\r\n        // Special case: empty object becomes mixed\r\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\r\n      }\r\n    }\r\n\r\n    if (cast) {\r\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\r\n        ? cast[options.typeKey]\r\n        : cast;\r\n\r\n      if (Array.isArray(type)) {\r\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\r\n      }\r\n\r\n      name = typeof type === 'string'\r\n        ? type\r\n        : type.schemaName || utils.getFunctionName(type);\r\n\r\n      // For Jest 26+, see #10296\r\n      if (name === 'ClockDate') {\r\n        name = 'Date';\r\n      }\r\n\r\n      if (name === void 0) {\r\n        throw new TypeError('Invalid schema configuration: ' +\r\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\r\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\r\n      }\r\n      if (!MongooseTypes.hasOwnProperty(name)) {\r\n        throw new TypeError('Invalid schema configuration: ' +\r\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\r\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\r\n      }\r\n    }\r\n\r\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\r\n  }\r\n\r\n  if (type && type.instanceOfSchema) {\r\n\r\n    return new MongooseTypes.Subdocument(type, path, obj);\r\n  }\r\n\r\n  if (Buffer.isBuffer(type)) {\r\n    name = 'Buffer';\r\n  } else if (typeof type === 'function' || typeof type === 'object') {\r\n    name = type.schemaName || utils.getFunctionName(type);\r\n  } else if (type === Types.ObjectId) {\r\n    name = 'ObjectId';\r\n  } else if (type === Types.Decimal128) {\r\n    name = 'Decimal128';\r\n  } else {\r\n    name = type == null ? '' + type : type.toString();\r\n  }\r\n\r\n  if (name) {\r\n    name = name.charAt(0).toUpperCase() + name.substring(1);\r\n  }\r\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\r\n  // doesn't line up with Mongoose's.\r\n  if (name === 'ObjectID') {\r\n    name = 'ObjectId';\r\n  }\r\n  // For Jest 26+, see #10296\r\n  if (name === 'ClockDate') {\r\n    name = 'Date';\r\n  }\r\n\r\n  if (name === void 0) {\r\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\r\n      'invalid. See ' +\r\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\r\n  }\r\n  if (MongooseTypes[name] == null) {\r\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\r\n      `a valid type at path \\`${path}\\`. See ` +\r\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\r\n  }\r\n\r\n  const schemaType = new MongooseTypes[name](path, obj);\r\n\r\n  if (schemaType.$isSchemaMap) {\r\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\r\n  }\r\n\r\n  return schemaType;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\r\n  const mapPath = path + '.$*';\r\n  let _mapType = { type: {} };\r\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\r\n    const isInlineSchema = utils.isPOJO(obj.of) &&\r\n      Object.keys(obj.of).length > 0 &&\r\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\r\n    if (isInlineSchema) {\r\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\r\n    } else if (utils.isPOJO(obj.of)) {\r\n      _mapType = Object.assign({}, obj.of);\r\n    } else {\r\n      _mapType = { [schema.options.typeKey]: obj.of };\r\n    }\r\n\r\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\r\n      const subdocumentSchema = _mapType[schema.options.typeKey];\r\n      subdocumentSchema.eachPath((subpath, type) => {\r\n        if (type.options.select === true || type.options.select === false) {\r\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\r\n        }\r\n      });\r\n    }\r\n\r\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\r\n      _mapType.ref = obj.ref;\r\n    }\r\n  }\r\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\r\n}\r\n\r\n/**\r\n * Iterates the schemas paths similar to Array#forEach.\r\n *\r\n * The callback is passed the pathname and the schemaType instance.\r\n *\r\n * #### Example:\r\n *\r\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\r\n *     userSchema.eachPath((pathname, schematype) => {\r\n *       // Prints twice:\r\n *       // name SchemaString { ... }\r\n *       // registeredAt SchemaDate { ... }\r\n *       console.log(pathname, schematype);\r\n *     });\r\n *\r\n * @param {Function} fn callback function\r\n * @return {Schema} this\r\n * @api public\r\n */\r\n\r\nSchema.prototype.eachPath = function(fn) {\r\n  const keys = Object.keys(this.paths);\r\n  const len = keys.length;\r\n\r\n  for (let i = 0; i < len; ++i) {\r\n    fn(keys[i], this.paths[keys[i]]);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns an Array of path strings that are required by this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const s = new Schema({\r\n *       name: { type: String, required: true },\r\n *       age: { type: String, required: true },\r\n *       notes: String\r\n *     });\r\n *     s.requiredPaths(); // [ 'age', 'name' ]\r\n *\r\n * @api public\r\n * @param {Boolean} invalidate Refresh the cache\r\n * @return {Array}\r\n */\r\n\r\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\r\n  if (this._requiredpaths && !invalidate) {\r\n    return this._requiredpaths;\r\n  }\r\n\r\n  const paths = Object.keys(this.paths);\r\n  let i = paths.length;\r\n  const ret = [];\r\n\r\n  while (i--) {\r\n    const path = paths[i];\r\n    if (this.paths[path].isRequired) {\r\n      ret.push(path);\r\n    }\r\n  }\r\n  this._requiredpaths = ret;\r\n  return this._requiredpaths;\r\n};\r\n\r\n/**\r\n * Returns indexes from fields and schema-level indexes (cached).\r\n *\r\n * @api private\r\n * @return {Array}\r\n */\r\n\r\nSchema.prototype.indexedPaths = function indexedPaths() {\r\n  if (this._indexedpaths) {\r\n    return this._indexedpaths;\r\n  }\r\n  this._indexedpaths = this.indexes();\r\n  return this._indexedpaths;\r\n};\r\n\r\n/**\r\n * Returns the pathType of `path` for this schema.\r\n *\r\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\r\n *\r\n * #### Example:\r\n *\r\n *     const s = new Schema({ name: String, nested: { foo: String } });\r\n *     s.virtual('foo').get(() => 42);\r\n *     s.pathType('name'); // \"real\"\r\n *     s.pathType('nested'); // \"nested\"\r\n *     s.pathType('foo'); // \"virtual\"\r\n *     s.pathType('fail'); // \"adhocOrUndefined\"\r\n *\r\n * @param {String} path\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nSchema.prototype.pathType = function(path) {\r\n  // Convert to '.$' to check subpaths re: gh-6405\r\n  const cleanPath = _pathToPositionalSyntax(path);\r\n\r\n  if (this.paths.hasOwnProperty(path)) {\r\n    return 'real';\r\n  }\r\n  if (this.virtuals.hasOwnProperty(path)) {\r\n    return 'virtual';\r\n  }\r\n  if (this.nested.hasOwnProperty(path)) {\r\n    return 'nested';\r\n  }\r\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\r\n    return 'real';\r\n  }\r\n\r\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\r\n  if (singleNestedPath) {\r\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\r\n  }\r\n\r\n  // Look for maps\r\n  const mapPath = getMapPath(this, path);\r\n  if (mapPath != null) {\r\n    return 'real';\r\n  }\r\n\r\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\r\n    return getPositionalPathType(this, path);\r\n  }\r\n  return 'adhocOrUndefined';\r\n};\r\n\r\n/**\r\n * Returns true iff this path is a child of a mixed schema.\r\n *\r\n * @param {String} path\r\n * @return {Boolean}\r\n * @api private\r\n */\r\n\r\nSchema.prototype.hasMixedParent = function(path) {\r\n  const subpaths = path.split(/\\./g);\r\n  path = '';\r\n  for (let i = 0; i < subpaths.length; ++i) {\r\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\r\n    if (this.paths.hasOwnProperty(path) &&\r\n        this.paths[path] instanceof MongooseTypes.Mixed) {\r\n      return this.paths[path];\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n/**\r\n * Setup updatedAt and createdAt timestamps to documents if enabled\r\n *\r\n * @param {Boolean|Object} timestamps timestamps options\r\n * @api private\r\n */\r\nSchema.prototype.setupTimestamp = function(timestamps) {\r\n  return setupTimestamps(this, timestamps);\r\n};\r\n\r\n/**\r\n * ignore. Deprecated re: #6405\r\n * @param {Any} self\r\n * @param {String} path\r\n * @api private\r\n */\r\n\r\nfunction getPositionalPathType(self, path) {\r\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\r\n  if (subpaths.length < 2) {\r\n    return self.paths.hasOwnProperty(subpaths[0]) ?\r\n      self.paths[subpaths[0]] :\r\n      'adhocOrUndefined';\r\n  }\r\n\r\n  let val = self.path(subpaths[0]);\r\n  let isNested = false;\r\n  if (!val) {\r\n    return 'adhocOrUndefined';\r\n  }\r\n\r\n  const last = subpaths.length - 1;\r\n\r\n  for (let i = 1; i < subpaths.length; ++i) {\r\n    isNested = false;\r\n    const subpath = subpaths[i];\r\n\r\n    if (i === last && val && !/\\D/.test(subpath)) {\r\n      if (val.$isMongooseDocumentArray) {\r\n        val = val.$embeddedSchemaType;\r\n      } else if (val instanceof MongooseTypes.Array) {\r\n        // StringSchema, NumberSchema, etc\r\n        val = val.caster;\r\n      } else {\r\n        val = undefined;\r\n      }\r\n      break;\r\n    }\r\n\r\n    // ignore if its just a position segment: path.0.subpath\r\n    if (!/\\D/.test(subpath)) {\r\n      // Nested array\r\n      if (val instanceof MongooseTypes.Array && i !== last) {\r\n        val = val.caster;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (!(val && val.schema)) {\r\n      val = undefined;\r\n      break;\r\n    }\r\n\r\n    const type = val.schema.pathType(subpath);\r\n    isNested = (type === 'nested');\r\n    val = val.schema.path(subpath);\r\n  }\r\n\r\n  self.subpaths[path] = val;\r\n  if (val) {\r\n    return 'real';\r\n  }\r\n  if (isNested) {\r\n    return 'nested';\r\n  }\r\n  return 'adhocOrUndefined';\r\n}\r\n\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction getPositionalPath(self, path) {\r\n  getPositionalPathType(self, path);\r\n  return self.subpaths[path];\r\n}\r\n\r\n/**\r\n * Adds a method call to the queue.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.methods.print = function() { console.log(this); };\r\n *     schema.queue('print', []); // Print the doc every one is instantiated\r\n *\r\n *     const Model = mongoose.model('Test', schema);\r\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\r\n *\r\n * @param {String} name name of the document method to call later\r\n * @param {Array} args arguments to pass to the method\r\n * @api public\r\n */\r\n\r\nSchema.prototype.queue = function(name, args) {\r\n  this.callQueue.push([name, args]);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Defines a pre hook for the model.\r\n *\r\n * #### Example:\r\n *\r\n *     const toySchema = new Schema({ name: String, created: Date });\r\n *\r\n *     toySchema.pre('save', function(next) {\r\n *       if (!this.created) this.created = new Date;\r\n *       next();\r\n *     });\r\n *\r\n *     toySchema.pre('validate', function(next) {\r\n *       if (this.name !== 'Woody') this.name = 'Woody';\r\n *       next();\r\n *     });\r\n *\r\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\r\n *     toySchema.pre(/^find/, function(next) {\r\n *       console.log(this.getFilter());\r\n *     });\r\n *\r\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\r\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\r\n *       console.log(this.getFilter());\r\n *     });\r\n *\r\n *     toySchema.pre('deleteOne', function() {\r\n *       // Runs when you call `Toy.deleteOne()`\r\n *     });\r\n *\r\n *     toySchema.pre('deleteOne', { document: true }, function() {\r\n *       // Runs when you call `doc.deleteOne()`\r\n *     });\r\n *\r\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\r\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\r\n * @param {Function} callback\r\n * @api public\r\n */\r\n\r\nSchema.prototype.pre = function(name) {\r\n  if (name instanceof RegExp) {\r\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\r\n    for (const fn of hookNames) {\r\n      if (name.test(fn)) {\r\n        this.pre.apply(this, [fn].concat(remainingArgs));\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  if (Array.isArray(name)) {\r\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\r\n    for (const el of name) {\r\n      this.pre.apply(this, [el].concat(remainingArgs));\r\n    }\r\n    return this;\r\n  }\r\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Defines a post hook for the document\r\n *\r\n *     const schema = new Schema(..);\r\n *     schema.post('save', function (doc) {\r\n *       console.log('this fired after a document was saved');\r\n *     });\r\n *\r\n *     schema.post('find', function(docs) {\r\n *       console.log('this fired after you ran a find query');\r\n *     });\r\n *\r\n *     schema.post(/Many$/, function(res) {\r\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\r\n *     });\r\n *\r\n *     const Model = mongoose.model('Model', schema);\r\n *\r\n *     const m = new Model(..);\r\n *     m.save(function(err) {\r\n *       console.log('this fires after the `post` hook');\r\n *     });\r\n *\r\n *     m.find(function(err, docs) {\r\n *       console.log('this fires after the post find hook');\r\n *     });\r\n *\r\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\r\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\r\n * @param {Function} fn callback\r\n * @see middleware https://mongoosejs.com/docs/middleware.html\r\n * @see kareem https://npmjs.org/package/kareem\r\n * @api public\r\n */\r\n\r\nSchema.prototype.post = function(name) {\r\n  if (name instanceof RegExp) {\r\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\r\n    for (const fn of hookNames) {\r\n      if (name.test(fn)) {\r\n        this.post.apply(this, [fn].concat(remainingArgs));\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n  if (Array.isArray(name)) {\r\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\r\n    for (const el of name) {\r\n      this.post.apply(this, [el].concat(remainingArgs));\r\n    }\r\n    return this;\r\n  }\r\n  this.s.hooks.post.apply(this.s.hooks, arguments);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Registers a plugin for this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const s = new Schema({ name: String });\r\n *     s.plugin(schema => console.log(schema.path('name').path));\r\n *     mongoose.model('Test', s); // Prints 'name'\r\n *\r\n * Or with Options:\r\n *\r\n *     const s = new Schema({ name: String });\r\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\r\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\r\n *\r\n * @param {Function} plugin The Plugin's callback\r\n * @param {Object} [opts] Options to pass to the plugin\r\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\r\n * @see plugins /docs/plugins.html\r\n * @api public\r\n */\r\n\r\nSchema.prototype.plugin = function(fn, opts) {\r\n  if (typeof fn !== 'function') {\r\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\r\n      'got \"' + (typeof fn) + '\"');\r\n  }\r\n\r\n  if (opts && opts.deduplicate) {\r\n    for (const plugin of this.plugins) {\r\n      if (plugin.fn === fn) {\r\n        return this;\r\n      }\r\n    }\r\n  }\r\n  this.plugins.push({ fn: fn, opts: opts });\r\n\r\n  fn(this, opts);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an instance method to documents constructed from Models compiled from this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = kittySchema = new Schema(..);\r\n *\r\n *     schema.method('meow', function () {\r\n *       console.log('meeeeeoooooooooooow');\r\n *     })\r\n *\r\n *     const Kitty = mongoose.model('Kitty', schema);\r\n *\r\n *     const fizz = new Kitty;\r\n *     fizz.meow(); // meeeeeooooooooooooow\r\n *\r\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\r\n *\r\n *     schema.method({\r\n *         purr: function () {}\r\n *       , scratch: function () {}\r\n *     });\r\n *\r\n *     // later\r\n *     const fizz = new Kitty;\r\n *     fizz.purr();\r\n *     fizz.scratch();\r\n *\r\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)\r\n *\r\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\r\n * @param {Function} [fn] The Function in a single-function definition.\r\n * @api public\r\n */\r\n\r\nSchema.prototype.method = function(name, fn, options) {\r\n  if (typeof name !== 'string') {\r\n    for (const i in name) {\r\n      this.methods[i] = name[i];\r\n      this.methodOptions[i] = utils.clone(options);\r\n    }\r\n  } else {\r\n    this.methods[name] = fn;\r\n    this.methodOptions[name] = utils.clone(options);\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds static \"class\" methods to Models compiled from this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema(..);\r\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\r\n *     schema.static('findByName', function(name) {\r\n *       return this.find({ name: name });\r\n *     });\r\n *\r\n *     const Drink = mongoose.model('Drink', schema);\r\n *     await Drink.findByName('LaCroix');\r\n *\r\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\r\n *\r\n *     schema.static({\r\n *         findByName: function () {..}\r\n *       , findByCost: function () {..}\r\n *     });\r\n *\r\n *     const Drink = mongoose.model('Drink', schema);\r\n *     await Drink.findByName('LaCroix');\r\n *     await Drink.findByCost(3);\r\n *\r\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\r\n *\r\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\r\n * @param {Function} [fn] The Function in a single-function definition.\r\n * @api public\r\n * @see Statics /docs/guide.html#statics\r\n */\r\n\r\nSchema.prototype.static = function(name, fn) {\r\n  if (typeof name !== 'string') {\r\n    for (const i in name) {\r\n      this.statics[i] = name[i];\r\n    }\r\n  } else {\r\n    this.statics[name] = fn;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Defines an index (most likely compound) for this schema.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.index({ first: 1, last: -1 })\r\n *\r\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\r\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\r\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\r\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\r\n * @api public\r\n */\r\n\r\nSchema.prototype.index = function(fields, options) {\r\n  fields || (fields = {});\r\n  options || (options = {});\r\n\r\n  if (options.expires) {\r\n    utils.expires(options);\r\n  }\r\n\r\n  this._indexes.push([fields, options]);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets a schema option.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.set('strict'); // 'true' by default\r\n *     schema.set('strict', false); // Sets 'strict' to false\r\n *     schema.set('strict'); // 'false'\r\n *\r\n * @param {String} key The name of the option to set the value to\r\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\r\n * @see Schema #schema_Schema\r\n * @api public\r\n */\r\n\r\nSchema.prototype.set = function(key, value, _tags) {\r\n  if (arguments.length === 1) {\r\n    return this.options[key];\r\n  }\r\n\r\n  switch (key) {\r\n    case 'read':\r\n      this.options[key] = readPref(value, _tags);\r\n      this._userProvidedOptions[key] = this.options[key];\r\n      break;\r\n    case 'timestamps':\r\n      this.setupTimestamp(value);\r\n      this.options[key] = value;\r\n      this._userProvidedOptions[key] = this.options[key];\r\n      break;\r\n    case '_id':\r\n      this.options[key] = value;\r\n      this._userProvidedOptions[key] = this.options[key];\r\n\r\n      if (value && !this.paths['_id']) {\r\n        addAutoId(this);\r\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\r\n        this.remove('_id');\r\n      }\r\n      break;\r\n    default:\r\n      this.options[key] = value;\r\n      this._userProvidedOptions[key] = this.options[key];\r\n      break;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Gets a schema option.\r\n *\r\n * #### Example:\r\n *\r\n *     schema.get('strict'); // true\r\n *     schema.set('strict', false);\r\n *     schema.get('strict'); // false\r\n *\r\n * @param {String} key The name of the Option to get the current value for\r\n * @api public\r\n * @return {Any} the option's value\r\n */\r\n\r\nSchema.prototype.get = function(key) {\r\n  return this.options[key];\r\n};\r\n\r\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\r\n\r\n/**\r\n * The allowed index types\r\n *\r\n * @property {String[]} indexTypes\r\n * @memberOf Schema\r\n * @static\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Schema, 'indexTypes', {\r\n  get: function() {\r\n    return indexTypes;\r\n  },\r\n  set: function() {\r\n    throw new Error('Cannot overwrite Schema.indexTypes');\r\n  }\r\n});\r\n\r\n/**\r\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\r\n * Indexes are expressed as an array `[spec, options]`.\r\n *\r\n * #### Example:\r\n *\r\n *     const userSchema = new Schema({\r\n *       email: { type: String, required: true, unique: true },\r\n *       registeredAt: { type: Date, index: true }\r\n *     });\r\n *\r\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\r\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\r\n *     userSchema.indexes();\r\n *\r\n * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\r\n * For example, the below plugin makes every index unique by default.\r\n *\r\n *     function myPlugin(schema) {\r\n *       for (const index of schema.indexes()) {\r\n *         if (index[1].unique === undefined) {\r\n *           index[1].unique = true;\r\n *         }\r\n *       }\r\n *     }\r\n *\r\n * @api public\r\n * @return {Array} list of indexes defined in the schema\r\n */\r\n\r\nSchema.prototype.indexes = function() {\r\n  return getIndexes(this);\r\n};\r\n\r\n/**\r\n * Creates a virtual type with the given name.\r\n *\r\n * @param {String} name The name of the Virtual\r\n * @param {Object} [options]\r\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).\r\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\r\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\r\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\r\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\r\n * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\r\n * @return {VirtualType}\r\n */\r\n\r\nSchema.prototype.virtual = function(name, options) {\r\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\r\n    return this.virtual(name.path, name.options);\r\n  }\r\n  options = new VirtualOptions(options);\r\n\r\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\r\n    if (options.localField == null) {\r\n      throw new Error('Reference virtuals require `localField` option');\r\n    }\r\n\r\n    if (options.foreignField == null) {\r\n      throw new Error('Reference virtuals require `foreignField` option');\r\n    }\r\n\r\n    this.pre('init', function virtualPreInit(obj) {\r\n      if (mpath.has(name, obj)) {\r\n        const _v = mpath.get(name, obj);\r\n        if (!this.$$populatedVirtuals) {\r\n          this.$$populatedVirtuals = {};\r\n        }\r\n\r\n        if (options.justOne || options.count) {\r\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\r\n            _v[0] :\r\n            _v;\r\n        } else {\r\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\r\n            _v :\r\n            _v == null ? [] : [_v];\r\n        }\r\n\r\n        mpath.unset(name, obj);\r\n      }\r\n    });\r\n\r\n    const virtual = this.virtual(name);\r\n    virtual.options = options;\r\n\r\n    virtual.\r\n      set(function(_v) {\r\n        if (!this.$$populatedVirtuals) {\r\n          this.$$populatedVirtuals = {};\r\n        }\r\n\r\n        if (options.justOne || options.count) {\r\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\r\n            _v[0] :\r\n            _v;\r\n\r\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\r\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\r\n          }\r\n        } else {\r\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\r\n            _v :\r\n            _v == null ? [] : [_v];\r\n\r\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\r\n            return doc && typeof doc === 'object';\r\n          });\r\n        }\r\n      });\r\n\r\n    if (typeof options.get === 'function') {\r\n      virtual.get(options.get);\r\n    }\r\n\r\n    // Workaround for gh-8198: if virtual is under document array, make a fake\r\n    // virtual. See gh-8210\r\n    const parts = name.split('.');\r\n    let cur = parts[0];\r\n    for (let i = 0; i < parts.length - 1; ++i) {\r\n      if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\r\n        const remnant = parts.slice(i + 1).join('.');\r\n        this.paths[cur].schema.virtual(remnant, options);\r\n        break;\r\n      }\r\n\r\n      cur += '.' + parts[i + 1];\r\n    }\r\n\r\n    return virtual;\r\n  }\r\n\r\n  const virtuals = this.virtuals;\r\n  const parts = name.split('.');\r\n\r\n  if (this.pathType(name) === 'real') {\r\n    throw new Error('Virtual path \"' + name + '\"' +\r\n      ' conflicts with a real path in the schema');\r\n  }\r\n\r\n  virtuals[name] = parts.reduce(function(mem, part, i) {\r\n    mem[part] || (mem[part] = (i === parts.length - 1)\r\n      ? new VirtualType(options, name)\r\n      : {});\r\n    return mem[part];\r\n  }, this.tree);\r\n\r\n  return virtuals[name];\r\n};\r\n\r\n/**\r\n * Returns the virtual type with the given `name`.\r\n *\r\n * @param {String} name The name of the Virtual to get\r\n * @return {VirtualType|null}\r\n */\r\n\r\nSchema.prototype.virtualpath = function(name) {\r\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\r\n};\r\n\r\n/**\r\n * Removes the given `path` (or [`paths`]).\r\n *\r\n * #### Example:\r\n *\r\n *     const schema = new Schema({ name: String, age: Number });\r\n *     schema.remove('name');\r\n *     schema.path('name'); // Undefined\r\n *     schema.path('age'); // SchemaNumber { ... }\r\n *\r\n * Or as a Array:\r\n *\r\n *     schema.remove(['name', 'age']);\r\n *     schema.path('name'); // Undefined\r\n *     schema.path('age'); // Undefined\r\n *\r\n * @param {String|Array} path The Path(s) to remove\r\n * @return {Schema} the Schema instance\r\n * @api public\r\n */\r\nSchema.prototype.remove = function(path) {\r\n  if (typeof path === 'string') {\r\n    path = [path];\r\n  }\r\n  if (Array.isArray(path)) {\r\n    path.forEach(function(name) {\r\n      if (this.path(name) == null && !this.nested[name]) {\r\n        return;\r\n      }\r\n      if (this.nested[name]) {\r\n        const allKeys = Object.keys(this.paths).\r\n          concat(Object.keys(this.nested));\r\n        for (const path of allKeys) {\r\n          if (path.startsWith(name + '.')) {\r\n            delete this.paths[path];\r\n            delete this.nested[path];\r\n            _deletePath(this, path);\r\n          }\r\n        }\r\n\r\n        delete this.nested[name];\r\n        _deletePath(this, name);\r\n        return;\r\n      }\r\n\r\n      delete this.paths[name];\r\n      _deletePath(this, name);\r\n    }, this);\r\n  }\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _deletePath(schema, name) {\r\n  const pieces = name.split('.');\r\n  const last = pieces.pop();\r\n\r\n  let branch = schema.tree;\r\n\r\n  for (const piece of pieces) {\r\n    branch = branch[piece];\r\n  }\r\n\r\n  delete branch[last];\r\n}\r\n\r\n/**\r\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\r\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\r\n * to schema [virtuals](/docs/guide.html#virtuals),\r\n * [statics](/docs/guide.html#statics), and\r\n * [methods](/docs/guide.html#methods).\r\n *\r\n * #### Example:\r\n *\r\n * ```javascript\r\n * const md5 = require('md5');\r\n * const userSchema = new Schema({ email: String });\r\n * class UserClass {\r\n *   // `gravatarImage` becomes a virtual\r\n *   get gravatarImage() {\r\n *     const hash = md5(this.email.toLowerCase());\r\n *     return `https://www.gravatar.com/avatar/${hash}`;\r\n *   }\r\n *\r\n *   // `getProfileUrl()` becomes a document method\r\n *   getProfileUrl() {\r\n *     return `https://mysite.com/${this.email}`;\r\n *   }\r\n *\r\n *   // `findByEmail()` becomes a static\r\n *   static findByEmail(email) {\r\n *     return this.findOne({ email });\r\n *   }\r\n * }\r\n *\r\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\r\n * // and a `findByEmail()` static\r\n * userSchema.loadClass(UserClass);\r\n * ```\r\n *\r\n * @param {Function} model The Class to load\r\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\r\n */\r\nSchema.prototype.loadClass = function(model, virtualsOnly) {\r\n  if (model === Object.prototype ||\r\n      model === Function.prototype ||\r\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\r\n    return this;\r\n  }\r\n\r\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\r\n\r\n  // Add static methods\r\n  if (!virtualsOnly) {\r\n    Object.getOwnPropertyNames(model).forEach(function(name) {\r\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\r\n        return;\r\n      }\r\n      const prop = Object.getOwnPropertyDescriptor(model, name);\r\n      if (prop.hasOwnProperty('value')) {\r\n        this.static(name, prop.value);\r\n      }\r\n    }, this);\r\n  }\r\n\r\n  // Add methods and virtuals\r\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\r\n    if (name.match(/^(constructor)$/)) {\r\n      return;\r\n    }\r\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\r\n    if (!virtualsOnly) {\r\n      if (typeof method.value === 'function') {\r\n        this.method(name, method.value);\r\n      }\r\n    }\r\n    if (typeof method.get === 'function') {\r\n      if (this.virtuals[name]) {\r\n        this.virtuals[name].getters = [];\r\n      }\r\n      this.virtual(name).get(method.get);\r\n    }\r\n    if (typeof method.set === 'function') {\r\n      if (this.virtuals[name]) {\r\n        this.virtuals[name].setters = [];\r\n      }\r\n      this.virtual(name).set(method.set);\r\n    }\r\n  }, this);\r\n\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchema.prototype._getSchema = function(path) {\r\n  const _this = this;\r\n  const pathschema = _this.path(path);\r\n  const resultPath = [];\r\n\r\n  if (pathschema) {\r\n    pathschema.$fullPath = path;\r\n    return pathschema;\r\n  }\r\n\r\n  function search(parts, schema) {\r\n    let p = parts.length + 1;\r\n    let foundschema;\r\n    let trypath;\r\n\r\n    while (p--) {\r\n      trypath = parts.slice(0, p).join('.');\r\n      foundschema = schema.path(trypath);\r\n      if (foundschema) {\r\n        resultPath.push(trypath);\r\n\r\n        if (foundschema.caster) {\r\n          // array of Mixed?\r\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\r\n            foundschema.caster.$fullPath = resultPath.join('.');\r\n            return foundschema.caster;\r\n          }\r\n\r\n          // Now that we found the array, we need to check if there\r\n          // are remaining document paths to look up for casting.\r\n          // Also we need to handle array.$.path since schema.path\r\n          // doesn't work for that.\r\n          // If there is no foundschema.schema we are dealing with\r\n          // a path like array.$\r\n          if (p !== parts.length) {\r\n            if (foundschema.schema) {\r\n              let ret;\r\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\r\n                if (p + 1 === parts.length) {\r\n                  // comments.$\r\n                  return foundschema;\r\n                }\r\n                // comments.$.comments.$.title\r\n                ret = search(parts.slice(p + 1), foundschema.schema);\r\n                if (ret) {\r\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\r\n                    !foundschema.schema.$isSingleNested;\r\n                }\r\n                return ret;\r\n              }\r\n              // this is the last path of the selector\r\n              ret = search(parts.slice(p), foundschema.schema);\r\n              if (ret) {\r\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\r\n                  !foundschema.schema.$isSingleNested;\r\n              }\r\n              return ret;\r\n            }\r\n          }\r\n        } else if (foundschema.$isSchemaMap) {\r\n          if (p >= parts.length) {\r\n            return foundschema;\r\n          }\r\n          // Any path in the map will be an instance of the map's embedded schematype\r\n          if (p + 1 >= parts.length) {\r\n            return foundschema.$__schemaType;\r\n          }\r\n\r\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\r\n            return foundschema.$__schemaType;\r\n          }\r\n          if (foundschema.$__schemaType.schema != null) {\r\n            // Map of docs\r\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\r\n            return ret;\r\n          }\r\n        }\r\n\r\n        foundschema.$fullPath = resultPath.join('.');\r\n\r\n        return foundschema;\r\n      }\r\n    }\r\n  }\r\n\r\n  // look for arrays\r\n  const parts = path.split('.');\r\n  for (let i = 0; i < parts.length; ++i) {\r\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\r\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\r\n      parts[i] = '0';\r\n    }\r\n  }\r\n  return search(parts, _this);\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchema.prototype._getPathType = function(path) {\r\n  const _this = this;\r\n  const pathschema = _this.path(path);\r\n\r\n  if (pathschema) {\r\n    return 'real';\r\n  }\r\n\r\n  function search(parts, schema) {\r\n    let p = parts.length + 1,\r\n        foundschema,\r\n        trypath;\r\n\r\n    while (p--) {\r\n      trypath = parts.slice(0, p).join('.');\r\n      foundschema = schema.path(trypath);\r\n      if (foundschema) {\r\n        if (foundschema.caster) {\r\n          // array of Mixed?\r\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\r\n            return { schema: foundschema, pathType: 'mixed' };\r\n          }\r\n\r\n          // Now that we found the array, we need to check if there\r\n          // are remaining document paths to look up for casting.\r\n          // Also we need to handle array.$.path since schema.path\r\n          // doesn't work for that.\r\n          // If there is no foundschema.schema we are dealing with\r\n          // a path like array.$\r\n          if (p !== parts.length && foundschema.schema) {\r\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\r\n              if (p === parts.length - 1) {\r\n                return { schema: foundschema, pathType: 'nested' };\r\n              }\r\n              // comments.$.comments.$.title\r\n              return search(parts.slice(p + 1), foundschema.schema);\r\n            }\r\n            // this is the last path of the selector\r\n            return search(parts.slice(p), foundschema.schema);\r\n          }\r\n          return {\r\n            schema: foundschema,\r\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\r\n          };\r\n        }\r\n        return { schema: foundschema, pathType: 'real' };\r\n      } else if (p === parts.length && schema.nested[trypath]) {\r\n        return { schema: schema, pathType: 'nested' };\r\n      }\r\n    }\r\n    return { schema: foundschema || schema, pathType: 'undefined' };\r\n  }\r\n\r\n  // look for arrays\r\n  return search(path.split('.'), _this);\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction isArrayFilter(piece) {\r\n  return piece.startsWith('$[') && piece.endsWith(']');\r\n}\r\n\r\n/**\r\n * Called by `compile()` _right before_ compiling. Good for making any changes to\r\n * the schema that should respect options set by plugins, like `id`\r\n * @method _preCompile\r\n * @memberOf Schema\r\n * @instance\r\n * @api private\r\n */\r\n\r\nSchema.prototype._preCompile = function _preCompile() {\r\n  idGetter(this);\r\n};\r\n\r\n/*!\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = exports = Schema;\r\n\r\n// require down here because of reference issues\r\n\r\n/**\r\n * The various built-in Mongoose Schema Types.\r\n *\r\n * #### Example:\r\n *\r\n *     const mongoose = require('mongoose');\r\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\r\n *\r\n * #### Types:\r\n *\r\n * - [String](/docs/schematypes.html#strings)\r\n * - [Number](/docs/schematypes.html#numbers)\r\n * - [Boolean](/docs/schematypes.html#booleans) | Bool\r\n * - [Array](/docs/schematypes.html#arrays)\r\n * - [Buffer](/docs/schematypes.html#buffers)\r\n * - [Date](/docs/schematypes.html#dates)\r\n * - [ObjectId](/docs/schematypes.html#objectids) | Oid\r\n * - [Mixed](/docs/schematypes.html#mixed)\r\n *\r\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\r\n *\r\n *     const Mixed = mongoose.Schema.Types.Mixed;\r\n *     new mongoose.Schema({ _user: Mixed })\r\n *\r\n * @api public\r\n */\r\n\r\nSchema.Types = MongooseTypes = require('./schema/index');\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nexports.ObjectId = MongooseTypes.ObjectId;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}