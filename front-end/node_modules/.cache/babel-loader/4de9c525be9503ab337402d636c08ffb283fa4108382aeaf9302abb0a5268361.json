{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\r\n * @typedef {(testString: string) => boolean} AnymatchFn\r\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\r\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\r\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\nconst arrify = item => Array.isArray(item) ? item : [item];\n\n/**\r\n * @param {AnymatchPattern} matcher\r\n * @param {object} options\r\n * @returns {AnymatchFn}\r\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n  return string => false;\n};\n\n/**\r\n * @param {Array<Function>} patterns\r\n * @param {Array<Function>} negPatterns\r\n * @param {String|Array} args\r\n * @param {Boolean} returnIndex\r\n * @returns {boolean|number}\r\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n  const path = normalizePath(_path, false);\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n  return returnIndex ? -1 : false;\n};\n\n/**\r\n * @param {AnymatchMatcher} matchers\r\n * @param {Array|string} testString\r\n * @param {object} options\r\n * @returns {boolean|number|Function}\r\n */\nconst anymatch = function (matchers, testString) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG).map(matcher => createPattern(matcher, opts));\n  if (testString == null) {\n    return function (testString) {\n      let ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\nanymatch.default = anymatch;\nmodule.exports = anymatch;","map":{"version":3,"names":["Object","defineProperty","exports","value","picomatch","require","normalizePath","BANG","DEFAULT_OPTIONS","returnIndex","arrify","item","Array","isArray","createPattern","matcher","options","glob","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","TypeError","prototype","toString","call","path","index","length","nglob","applied","concat","slice","pattern","anymatch","matchers","testString","opts","mtchers","negatedGlobs","filter","charAt","map","ri","default","module"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/anymatch/index.js"],"sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst picomatch = require('picomatch');\r\nconst normalizePath = require('normalize-path');\r\n\r\n/**\r\n * @typedef {(testString: string) => boolean} AnymatchFn\r\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\r\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\r\n */\r\nconst BANG = '!';\r\nconst DEFAULT_OPTIONS = {returnIndex: false};\r\nconst arrify = (item) => Array.isArray(item) ? item : [item];\r\n\r\n/**\r\n * @param {AnymatchPattern} matcher\r\n * @param {object} options\r\n * @returns {AnymatchFn}\r\n */\r\nconst createPattern = (matcher, options) => {\r\n  if (typeof matcher === 'function') {\r\n    return matcher;\r\n  }\r\n  if (typeof matcher === 'string') {\r\n    const glob = picomatch(matcher, options);\r\n    return (string) => matcher === string || glob(string);\r\n  }\r\n  if (matcher instanceof RegExp) {\r\n    return (string) => matcher.test(string);\r\n  }\r\n  return (string) => false;\r\n};\r\n\r\n/**\r\n * @param {Array<Function>} patterns\r\n * @param {Array<Function>} negPatterns\r\n * @param {String|Array} args\r\n * @param {Boolean} returnIndex\r\n * @returns {boolean|number}\r\n */\r\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\r\n  const isList = Array.isArray(args);\r\n  const _path = isList ? args[0] : args;\r\n  if (!isList && typeof _path !== 'string') {\r\n    throw new TypeError('anymatch: second argument must be a string: got ' +\r\n      Object.prototype.toString.call(_path))\r\n  }\r\n  const path = normalizePath(_path, false);\r\n\r\n  for (let index = 0; index < negPatterns.length; index++) {\r\n    const nglob = negPatterns[index];\r\n    if (nglob(path)) {\r\n      return returnIndex ? -1 : false;\r\n    }\r\n  }\r\n\r\n  const applied = isList && [path].concat(args.slice(1));\r\n  for (let index = 0; index < patterns.length; index++) {\r\n    const pattern = patterns[index];\r\n    if (isList ? pattern(...applied) : pattern(path)) {\r\n      return returnIndex ? index : true;\r\n    }\r\n  }\r\n\r\n  return returnIndex ? -1 : false;\r\n};\r\n\r\n/**\r\n * @param {AnymatchMatcher} matchers\r\n * @param {Array|string} testString\r\n * @param {object} options\r\n * @returns {boolean|number|Function}\r\n */\r\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\r\n  if (matchers == null) {\r\n    throw new TypeError('anymatch: specify first argument');\r\n  }\r\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\r\n  const returnIndex = opts.returnIndex || false;\r\n\r\n  // Early cache for matchers.\r\n  const mtchers = arrify(matchers);\r\n  const negatedGlobs = mtchers\r\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\r\n    .map(item => item.slice(1))\r\n    .map(item => picomatch(item, opts));\r\n  const patterns = mtchers\r\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\r\n    .map(matcher => createPattern(matcher, opts));\r\n\r\n  if (testString == null) {\r\n    return (testString, ri = false) => {\r\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\r\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\r\n    }\r\n  }\r\n\r\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\r\n};\r\n\r\nanymatch.default = anymatch;\r\nmodule.exports = anymatch;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}