{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = void 0;\nconst net = require(\"net\");\nconst socks_1 = require(\"socks\");\nconst tls = require(\"tls\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst gssapi_1 = require(\"./auth/gssapi\");\nconst mongocr_1 = require(\"./auth/mongocr\");\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\nconst plain_1 = require(\"./auth/plain\");\nconst providers_1 = require(\"./auth/providers\");\nconst scram_1 = require(\"./auth/scram\");\nconst x509_1 = require(\"./auth/x509\");\nconst connection_1 = require(\"./connection\");\nconst constants_2 = require(\"./wire_protocol/constants\");\nconst AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\nfunction connect(options, callback) {\n  makeConnection({\n    ...options,\n    existingSocket: undefined\n  }, (err, socket) => {\n    var _a;\n    if (err || !socket) {\n      return callback(err);\n    }\n    let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\nexports.connect = connect;\nfunction checkSupportedServer(hello, options) {\n  var _a;\n  const serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy({\n        force: false\n      });\n    }\n    _callback(err, ret);\n  };\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n    const handshakeOptions = Object.assign({}, options);\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n    const start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n      if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n      }\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n      if (options.loadBalanced) {\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      }\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.hello = response;\n      conn.lastHelloMS = new Date().getTime() - start;\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n        provider.auth(authContext, err => {\n          if (err) {\n            if (err instanceof error_1.MongoError) {\n              err.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n              if ((0, error_1.needsRetryableWriteLabel)(err, response.maxWireVersion)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n              }\n            }\n            return callback(err);\n          }\n          callback(undefined, conn);\n        });\n        return;\n      }\n      callback(undefined, conn);\n    });\n  });\n}\n/**\r\n * @internal\r\n *\r\n * This function is only exposed for testing purposes.\r\n */\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n    helloOk: true,\n    client: options.metadata || (0, utils_1.makeClientMetadata)(options),\n    compression: compressors\n  };\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n  callback(undefined, handshakeDoc);\n}\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n  return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  const connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  const existingSocket = options.existingSocket;\n  let socket;\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n    _callback(err, ret);\n  };\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection({\n      ...options,\n      connectTimeoutMS // Should always be present for Socks5\n    }, callback);\n  }\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\nfunction makeSocks5Connection(options, callback) {\n  var _a, _b;\n  const hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '',\n  // proxyHost is guaranteed to set here\n  (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080);\n  // First, connect to the proxy server itself:\n  makeConnection({\n    ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }, (err, rawSocket) => {\n    if (err) {\n      return callback(err);\n    }\n    const destination = parseConnectOptions(options);\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    }\n    // Then, establish the Socks5 proxy connection:\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(_ref => {\n      let {\n        socket\n      } = _ref;\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection({\n        ...options,\n        existingSocket: socket,\n        proxyHost: undefined\n      }, callback);\n    }, error => callback(connectionFailureError('error', error)));\n  });\n}\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"mappings":"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","names":["AUTH_PROVIDERS","Map","providers_1","MONGODB_AWS","mongodb_aws_1","MONGODB_CR","mongocr_1","MONGODB_GSSAPI","gssapi_1","MONGODB_PLAIN","plain_1","MONGODB_SCRAM_SHA1","scram_1","MONGODB_SCRAM_SHA256","MONGODB_X509","x509_1","connect","options","callback","makeConnection","existingSocket","undefined","err","socket","ConnectionType","connectionType","connection_1","autoEncrypter","performInitialHandshake","exports","checkSupportedServer","hello","serverVersionHighEnough","maxWireVersion","bson_1","constants_2","serverVersionLowEnough","minWireVersion","message","hostAddress","JSON","stringify","error_1","conn","_callback","ret","destroy","force","credentials","mechanism","MONGODB_DEFAULT","get","authContext","auth_provider_1","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","command","response","ok","isWritablePrimary","constants_1","helloOk","supportedServerErr","loadBalanced","serviceId","lastHelloMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","addErrorLabel","HandshakeError","RetryableWriteError","compressors","serverApi","connection","version","client","metadata","compression","username","saslSupportedMechs","source","prepare","parseConnectOptions","result","name","socketPath","path","host","port","parseSslOptions","servername","net","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","useTLS","tls","keepAlive","Reflect","noDelay","rejectUnauthorized","keepAliveInitialDelay","Math","round","proxyHost","makeSocks5Connection","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","process","nextTick","utils_1","fromHostPort","proxyPort","rawSocket","destination","socks_1","existing_socket","timeout","proxy","type","userId","proxyUsername","password","proxyPassword","then","error"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\cmap\\connect.ts"],"sourcesContent":["import type { Socket, SocketConnectOpts } from 'net';\r\nimport * as net from 'net';\r\nimport { SocksClient } from 'socks';\r\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\r\nimport * as tls from 'tls';\r\n\r\nimport type { Document } from '../bson';\r\nimport { Int32 } from '../bson';\r\nimport { LEGACY_HELLO_COMMAND } from '../constants';\r\nimport {\r\n  MongoCompatibilityError,\r\n  MongoError,\r\n  MongoErrorLabel,\r\n  MongoInvalidArgumentError,\r\n  MongoNetworkError,\r\n  MongoNetworkTimeoutError,\r\n  MongoRuntimeError,\r\n  MongoServerError,\r\n  needsRetryableWriteLabel\r\n} from '../error';\r\nimport { Callback, ClientMetadata, HostAddress, makeClientMetadata, ns } from '../utils';\r\nimport { AuthContext, AuthProvider } from './auth/auth_provider';\r\nimport { GSSAPI } from './auth/gssapi';\r\nimport { MongoCR } from './auth/mongocr';\r\nimport { MongoDBAWS } from './auth/mongodb_aws';\r\nimport { Plain } from './auth/plain';\r\nimport { AuthMechanism } from './auth/providers';\r\nimport { ScramSHA1, ScramSHA256 } from './auth/scram';\r\nimport { X509 } from './auth/x509';\r\nimport { Connection, ConnectionOptions, CryptoConnection } from './connection';\r\nimport {\r\n  MAX_SUPPORTED_SERVER_VERSION,\r\n  MAX_SUPPORTED_WIRE_VERSION,\r\n  MIN_SUPPORTED_SERVER_VERSION,\r\n  MIN_SUPPORTED_WIRE_VERSION\r\n} from './wire_protocol/constants';\r\n\r\nconst AUTH_PROVIDERS = new Map<AuthMechanism | string, AuthProvider>([\r\n  [AuthMechanism.MONGODB_AWS, new MongoDBAWS()],\r\n  [AuthMechanism.MONGODB_CR, new MongoCR()],\r\n  [AuthMechanism.MONGODB_GSSAPI, new GSSAPI()],\r\n  [AuthMechanism.MONGODB_PLAIN, new Plain()],\r\n  [AuthMechanism.MONGODB_SCRAM_SHA1, new ScramSHA1()],\r\n  [AuthMechanism.MONGODB_SCRAM_SHA256, new ScramSHA256()],\r\n  [AuthMechanism.MONGODB_X509, new X509()]\r\n]);\r\n\r\n/** @public */\r\nexport type Stream = Socket | TLSSocket;\r\n\r\nexport function connect(options: ConnectionOptions, callback: Callback<Connection>): void {\r\n  makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\r\n    if (err || !socket) {\r\n      return callback(err);\r\n    }\r\n\r\n    let ConnectionType = options.connectionType ?? Connection;\r\n    if (options.autoEncrypter) {\r\n      ConnectionType = CryptoConnection;\r\n    }\r\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\r\n  });\r\n}\r\n\r\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\r\n  const serverVersionHighEnough =\r\n    hello &&\r\n    (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof Int32) &&\r\n    hello.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\r\n  const serverVersionLowEnough =\r\n    hello &&\r\n    (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof Int32) &&\r\n    hello.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\r\n\r\n  if (serverVersionHighEnough) {\r\n    if (serverVersionLowEnough) {\r\n      return null;\r\n    }\r\n\r\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\r\n      hello.minWireVersion\r\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\r\n    return new MongoCompatibilityError(message);\r\n  }\r\n\r\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\r\n    JSON.stringify(hello.maxWireVersion) ?? 0\r\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\r\n  return new MongoCompatibilityError(message);\r\n}\r\n\r\nfunction performInitialHandshake(\r\n  conn: Connection,\r\n  options: ConnectionOptions,\r\n  _callback: Callback\r\n) {\r\n  const callback: Callback<Document> = function (err, ret) {\r\n    if (err && conn) {\r\n      conn.destroy({ force: false });\r\n    }\r\n    _callback(err, ret);\r\n  };\r\n\r\n  const credentials = options.credentials;\r\n  if (credentials) {\r\n    if (\r\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\r\n      !AUTH_PROVIDERS.get(credentials.mechanism)\r\n    ) {\r\n      callback(\r\n        new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`)\r\n      );\r\n      return;\r\n    }\r\n  }\r\n\r\n  const authContext = new AuthContext(conn, credentials, options);\r\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\r\n    if (err || !handshakeDoc) {\r\n      return callback(err);\r\n    }\r\n\r\n    const handshakeOptions: Document = Object.assign({}, options);\r\n    if (typeof options.connectTimeoutMS === 'number') {\r\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\r\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\r\n    }\r\n\r\n    const start = new Date().getTime();\r\n    conn.command(ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      if (response?.ok === 0) {\r\n        callback(new MongoServerError(response));\r\n        return;\r\n      }\r\n\r\n      if (!('isWritablePrimary' in response)) {\r\n        // Provide hello-style response document.\r\n        response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\r\n      }\r\n\r\n      if (response.helloOk) {\r\n        conn.helloOk = true;\r\n      }\r\n\r\n      const supportedServerErr = checkSupportedServer(response, options);\r\n      if (supportedServerErr) {\r\n        callback(supportedServerErr);\r\n        return;\r\n      }\r\n\r\n      if (options.loadBalanced) {\r\n        if (!response.serviceId) {\r\n          return callback(\r\n            new MongoCompatibilityError(\r\n              'Driver attempted to initialize in load balancing mode, ' +\r\n                'but the server does not support this mode.'\r\n            )\r\n          );\r\n        }\r\n      }\r\n\r\n      // NOTE: This is metadata attached to the connection while porting away from\r\n      //       handshake being done in the `Server` class. Likely, it should be\r\n      //       relocated, or at very least restructured.\r\n      conn.hello = response;\r\n      conn.lastHelloMS = new Date().getTime() - start;\r\n\r\n      if (!response.arbiterOnly && credentials) {\r\n        // store the response on auth context\r\n        authContext.response = response;\r\n\r\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\r\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\r\n        if (!provider) {\r\n          return callback(\r\n            new MongoInvalidArgumentError(\r\n              `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\r\n            )\r\n          );\r\n        }\r\n        provider.auth(authContext, err => {\r\n          if (err) {\r\n            if (err instanceof MongoError) {\r\n              err.addErrorLabel(MongoErrorLabel.HandshakeError);\r\n              if (needsRetryableWriteLabel(err, response.maxWireVersion)) {\r\n                err.addErrorLabel(MongoErrorLabel.RetryableWriteError);\r\n              }\r\n            }\r\n            return callback(err);\r\n          }\r\n          callback(undefined, conn);\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      callback(undefined, conn);\r\n    });\r\n  });\r\n}\r\n\r\nexport interface HandshakeDocument extends Document {\r\n  /**\r\n   * @deprecated Use hello instead\r\n   */\r\n  ismaster?: boolean;\r\n  hello?: boolean;\r\n  helloOk?: boolean;\r\n  client: ClientMetadata;\r\n  compression: string[];\r\n  saslSupportedMechs?: string;\r\n  loadBalanced?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * This function is only exposed for testing purposes.\r\n */\r\nexport function prepareHandshakeDocument(\r\n  authContext: AuthContext,\r\n  callback: Callback<HandshakeDocument>\r\n) {\r\n  const options = authContext.options;\r\n  const compressors = options.compressors ? options.compressors : [];\r\n  const { serverApi } = authContext.connection;\r\n\r\n  const handshakeDoc: HandshakeDocument = {\r\n    [serverApi?.version ? 'hello' : LEGACY_HELLO_COMMAND]: true,\r\n    helloOk: true,\r\n    client: options.metadata || makeClientMetadata(options),\r\n    compression: compressors\r\n  };\r\n\r\n  if (options.loadBalanced === true) {\r\n    handshakeDoc.loadBalanced = true;\r\n  }\r\n\r\n  const credentials = authContext.credentials;\r\n  if (credentials) {\r\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\r\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\r\n\r\n      const provider = AUTH_PROVIDERS.get(AuthMechanism.MONGODB_SCRAM_SHA256);\r\n      if (!provider) {\r\n        // This auth mechanism is always present.\r\n        return callback(\r\n          new MongoInvalidArgumentError(\r\n            `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\r\n          )\r\n        );\r\n      }\r\n      return provider.prepare(handshakeDoc, authContext, callback);\r\n    }\r\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\r\n    if (!provider) {\r\n      return callback(\r\n        new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`)\r\n      );\r\n    }\r\n    return provider.prepare(handshakeDoc, authContext, callback);\r\n  }\r\n  callback(undefined, handshakeDoc);\r\n}\r\n\r\n/** @public */\r\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\r\n  'ALPNProtocols',\r\n  'ca',\r\n  'cert',\r\n  'checkServerIdentity',\r\n  'ciphers',\r\n  'crl',\r\n  'ecdhCurve',\r\n  'key',\r\n  'minDHSize',\r\n  'passphrase',\r\n  'pfx',\r\n  'rejectUnauthorized',\r\n  'secureContext',\r\n  'secureProtocol',\r\n  'servername',\r\n  'session'\r\n] as const;\r\n\r\n/** @public */\r\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\r\n  'family',\r\n  'hints',\r\n  'localAddress',\r\n  'localPort',\r\n  'lookup'\r\n] as const;\r\n\r\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\r\n  const hostAddress = options.hostAddress;\r\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\r\n\r\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\r\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\r\n    if (options[name] != null) {\r\n      (result as Document)[name] = options[name];\r\n    }\r\n  }\r\n\r\n  if (typeof hostAddress.socketPath === 'string') {\r\n    result.path = hostAddress.socketPath;\r\n    return result as net.IpcNetConnectOpts;\r\n  } else if (typeof hostAddress.host === 'string') {\r\n    result.host = hostAddress.host;\r\n    result.port = hostAddress.port;\r\n    return result as net.TcpNetConnectOpts;\r\n  } else {\r\n    // This should never happen since we set up HostAddresses\r\n    // But if we don't throw here the socket could hang until timeout\r\n    // TODO(NODE-3483)\r\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\r\n  }\r\n}\r\n\r\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\r\n\r\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\r\n  const result: TLSConnectionOpts = parseConnectOptions(options);\r\n  // Merge in valid SSL options\r\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\r\n    if (options[name] != null) {\r\n      (result as Document)[name] = options[name];\r\n    }\r\n  }\r\n\r\n  if (options.existingSocket) {\r\n    result.socket = options.existingSocket;\r\n  }\r\n\r\n  // Set default sni servername to be the same as host\r\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\r\n    result.servername = result.host;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'] as const;\r\ntype ErrorHandlerEventName = typeof SOCKET_ERROR_EVENT_LIST[number] | 'cancel';\r\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\r\n\r\nfunction makeConnection(options: MakeConnectionOptions, _callback: Callback<Stream>) {\r\n  const useTLS = options.tls ?? false;\r\n  const keepAlive = options.keepAlive ?? true;\r\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\r\n  const noDelay = options.noDelay ?? true;\r\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\r\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\r\n  const keepAliveInitialDelay =\r\n    ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS\r\n      ? Math.round(socketTimeoutMS / 2)\r\n      : options.keepAliveInitialDelay) ?? 120000;\r\n  const existingSocket = options.existingSocket;\r\n\r\n  let socket: Stream;\r\n  const callback: Callback<Stream> = function (err, ret) {\r\n    if (err && socket) {\r\n      socket.destroy();\r\n    }\r\n\r\n    _callback(err, ret);\r\n  };\r\n\r\n  if (options.proxyHost != null) {\r\n    // Currently, only Socks5 is supported.\r\n    return makeSocks5Connection(\r\n      {\r\n        ...options,\r\n        connectTimeoutMS // Should always be present for Socks5\r\n      },\r\n      callback\r\n    );\r\n  }\r\n\r\n  if (useTLS) {\r\n    const tlsSocket = tls.connect(parseSslOptions(options));\r\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\r\n      tlsSocket.disableRenegotiation();\r\n    }\r\n    socket = tlsSocket;\r\n  } else if (existingSocket) {\r\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\r\n    // so we only need to handle the non-TLS case here (where existingSocket\r\n    // gives us all we need out of the box).\r\n    socket = existingSocket;\r\n  } else {\r\n    socket = net.createConnection(parseConnectOptions(options));\r\n  }\r\n\r\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\r\n  socket.setTimeout(connectTimeoutMS);\r\n  socket.setNoDelay(noDelay);\r\n\r\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\r\n  let cancellationHandler: (err: Error) => void;\r\n  function errorHandler(eventName: ErrorHandlerEventName) {\r\n    return (err: Error) => {\r\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\r\n      if (cancellationHandler && options.cancellationToken) {\r\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\r\n      }\r\n\r\n      socket.removeListener(connectEvent, connectHandler);\r\n      callback(connectionFailureError(eventName, err));\r\n    };\r\n  }\r\n\r\n  function connectHandler() {\r\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\r\n    if (cancellationHandler && options.cancellationToken) {\r\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\r\n    }\r\n\r\n    if ('authorizationError' in socket) {\r\n      if (socket.authorizationError && rejectUnauthorized) {\r\n        return callback(socket.authorizationError);\r\n      }\r\n    }\r\n\r\n    socket.setTimeout(socketTimeoutMS);\r\n    callback(undefined, socket);\r\n  }\r\n\r\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\r\n  if (options.cancellationToken) {\r\n    cancellationHandler = errorHandler('cancel');\r\n    options.cancellationToken.once('cancel', cancellationHandler);\r\n  }\r\n\r\n  if (existingSocket) {\r\n    process.nextTick(connectHandler);\r\n  } else {\r\n    socket.once(connectEvent, connectHandler);\r\n  }\r\n}\r\n\r\nfunction makeSocks5Connection(options: MakeConnectionOptions, callback: Callback<Stream>) {\r\n  const hostAddress = HostAddress.fromHostPort(\r\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\r\n    options.proxyPort ?? 1080\r\n  );\r\n\r\n  // First, connect to the proxy server itself:\r\n  makeConnection(\r\n    {\r\n      ...options,\r\n      hostAddress,\r\n      tls: false,\r\n      proxyHost: undefined\r\n    },\r\n    (err, rawSocket) => {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n\r\n      const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\r\n      if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\r\n        return callback(\r\n          new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts')\r\n        );\r\n      }\r\n\r\n      // Then, establish the Socks5 proxy connection:\r\n      SocksClient.createConnection({\r\n        existing_socket: rawSocket,\r\n        timeout: options.connectTimeoutMS,\r\n        command: 'connect',\r\n        destination: {\r\n          host: destination.host,\r\n          port: destination.port\r\n        },\r\n        proxy: {\r\n          // host and port are ignored because we pass existing_socket\r\n          host: 'iLoveJavaScript',\r\n          port: 0,\r\n          type: 5,\r\n          userId: options.proxyUsername || undefined,\r\n          password: options.proxyPassword || undefined\r\n        }\r\n      }).then(\r\n        ({ socket }) => {\r\n          // Finally, now treat the resulting duplex stream as the\r\n          // socket over which we send and receive wire protocol messages:\r\n          makeConnection(\r\n            {\r\n              ...options,\r\n              existingSocket: socket,\r\n              proxyHost: undefined\r\n            },\r\n            callback\r\n          );\r\n        },\r\n        error => callback(connectionFailureError('error', error))\r\n      );\r\n    }\r\n  );\r\n}\r\n\r\nfunction connectionFailureError(type: ErrorHandlerEventName, err: Error) {\r\n  switch (type) {\r\n    case 'error':\r\n      return new MongoNetworkError(err);\r\n    case 'timeout':\r\n      return new MongoNetworkTimeoutError('connection timed out');\r\n    case 'close':\r\n      return new MongoNetworkError('connection closed');\r\n    case 'cancel':\r\n      return new MongoNetworkError('connection establishment was cancelled');\r\n    default:\r\n      return new MongoNetworkError('unknown network error');\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}