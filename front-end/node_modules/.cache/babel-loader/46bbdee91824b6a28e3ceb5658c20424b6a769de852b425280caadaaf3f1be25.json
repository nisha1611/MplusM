{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  first\n} = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n  compareModulesById,\n  compareIterables,\n  compareModulesByIdentifier,\n  concatComparators,\n  compareSelect,\n  compareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n  RuntimeSpecMap,\n  RuntimeSpecSet,\n  runtimeToString,\n  mergeRuntime,\n  forEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\nconst ZERO_BIG_INT = BigInt(0);\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\r\n * @typedef {Object} ChunkSizeOptions\r\n * @property {number=} chunkOverhead constant overhead for a chunk\r\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\r\n */\n\nclass ModuleHashInfo {\n  constructor(hash, renderedHash) {\n    this.hash = hash;\n    this.renderedHash = renderedHash;\n  }\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\r\n * @template T\r\n * @param {SortableSet<T>} set the set\r\n * @returns {T[]} set as array\r\n */\nconst getArray = set => {\n  return Array.from(set);\n};\n\n/**\r\n * @param {SortableSet<Chunk>} chunks the chunks\r\n * @returns {RuntimeSpecSet} runtimes\r\n */\nconst getModuleRuntimes = chunks => {\n  const runtimes = new RuntimeSpecSet();\n  for (const chunk of chunks) {\n    runtimes.add(chunk.runtime);\n  }\n  return runtimes;\n};\n\n/**\r\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\r\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\r\n */\nconst modulesBySourceType = sourceTypesByModule => set => {\n  /** @type {Map<string, SortableSet<Module>>} */\n  const map = new Map();\n  for (const module of set) {\n    const sourceTypes = sourceTypesByModule && sourceTypesByModule.get(module) || module.getSourceTypes();\n    for (const sourceType of sourceTypes) {\n      let innerSet = map.get(sourceType);\n      if (innerSet === undefined) {\n        innerSet = new SortableSet();\n        map.set(sourceType, innerSet);\n      }\n      innerSet.add(module);\n    }\n  }\n  for (const [key, innerSet] of map) {\n    // When all modules have the source type, we reuse the original SortableSet\n    // to benefit from the shared cache (especially for sorting)\n    if (innerSet.size === set.size) {\n      map.set(key, set);\n    }\n  }\n  return map;\n};\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\r\n * @template T\r\n * @param {function(T, T): -1|0|1} comparator comparator function\r\n * @returns {SetToArrayFunction<T>} set as ordered array\r\n */\nconst createOrderedArrayFunction = comparator => {\n  /** @type {SetToArrayFunction<T>} */\n  let fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n  fn = set => {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n\n/**\r\n * @param {Iterable<Module>} modules the modules to get the count/size of\r\n * @returns {number} the size of the modules\r\n */\nconst getModulesSize = modules => {\n  let size = 0;\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      size += module.size(type);\n    }\n  }\n  return size;\n};\n\n/**\r\n * @param {Iterable<Module>} modules the sortable Set to get the size of\r\n * @returns {Record<string, number>} the sizes of the modules\r\n */\nconst getModulesSizes = modules => {\n  let sizes = Object.create(null);\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      sizes[type] = (sizes[type] || 0) + module.size(type);\n    }\n  }\n  return sizes;\n};\n\n/**\r\n * @param {Chunk} a chunk\r\n * @param {Chunk} b chunk\r\n * @returns {boolean} true, if a is always a parent of b\r\n */\nconst isAvailableChunk = (a, b) => {\n  const queue = new Set(b.groupsIterable);\n  for (const chunkGroup of queue) {\n    if (a.isInGroup(chunkGroup)) continue;\n    if (chunkGroup.isInitial()) return false;\n    for (const parent of chunkGroup.parentsIterable) {\n      queue.add(parent);\n    }\n  }\n  return true;\n};\nclass ChunkGraphModule {\n  constructor() {\n    /** @type {SortableSet<Chunk>} */\n    this.chunks = new SortableSet();\n    /** @type {Set<Chunk> | undefined} */\n    this.entryInChunks = undefined;\n    /** @type {Set<Chunk> | undefined} */\n    this.runtimeInChunks = undefined;\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n    this.hashes = undefined;\n    /** @type {string | number} */\n    this.id = null;\n    /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n    this.runtimeRequirements = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n    this.graphHashes = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n    this.graphHashesWithConnections = undefined;\n  }\n}\nclass ChunkGraphChunk {\n  constructor() {\n    /** @type {SortableSet<Module>} */\n    this.modules = new SortableSet();\n    /** @type {WeakMap<Module, Set<string>> | undefined} */\n    this.sourceTypesByModule = undefined;\n    /** @type {Map<Module, Entrypoint>} */\n    this.entryModules = new Map();\n    /** @type {SortableSet<RuntimeModule>} */\n    this.runtimeModules = new SortableSet();\n    /** @type {Set<RuntimeModule> | undefined} */\n    this.fullHashModules = undefined;\n    /** @type {Set<RuntimeModule> | undefined} */\n    this.dependentHashModules = undefined;\n    /** @type {Set<string> | undefined} */\n    this.runtimeRequirements = undefined;\n    /** @type {Set<string>} */\n    this.runtimeRequirementsInTree = new Set();\n    this._modulesBySourceType = defaultModulesBySourceType;\n  }\n}\nclass ChunkGraph {\n  /**\r\n   * @param {ModuleGraph} moduleGraph the module graph\r\n   * @param {string | Hash} hashFunction the hash function to use\r\n   */\n  constructor(moduleGraph) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n\n  /**\r\n   * @private\r\n   * @param {Module} module the module\r\n   * @returns {ChunkGraphModule} internal module\r\n   */\n  _getChunkGraphModule(module) {\n    let cgm = this._modules.get(module);\n    if (cgm === undefined) {\n      cgm = new ChunkGraphModule();\n      this._modules.set(module, cgm);\n    }\n    return cgm;\n  }\n\n  /**\r\n   * @private\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {ChunkGraphChunk} internal chunk\r\n   */\n  _getChunkGraphChunk(chunk) {\n    let cgc = this._chunks.get(chunk);\n    if (cgc === undefined) {\n      cgc = new ChunkGraphChunk();\n      this._chunks.set(chunk, cgc);\n    }\n    return cgc;\n  }\n\n  /**\r\n   * @param {SortableSet<Module>} set the sortable Set to get the roots of\r\n   * @returns {Module[]} the graph roots\r\n   */\n  _getGraphRoots(set) {\n    const {\n      moduleGraph\n    } = this;\n    return Array.from(findGraphRoots(set, module => {\n      /** @type {Set<Module>} */\n      const set = new Set();\n      const addDependencies = module => {\n        for (const connection of moduleGraph.getOutgoingConnections(module)) {\n          if (!connection.module) continue;\n          const activeState = connection.getActiveState(undefined);\n          if (activeState === false) continue;\n          if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n            addDependencies(connection.module);\n            continue;\n          }\n          set.add(connection.module);\n        }\n      };\n      addDependencies(module);\n      return set;\n    })).sort(compareModulesByIdentifier);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {Module} module the module\r\n   * @returns {void}\r\n   */\n  connectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgm.chunks.add(chunk);\n    cgc.modules.add(module);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Module} module the module\r\n   * @returns {void}\r\n   */\n  disconnectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgc.modules.delete(module);\n    // No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n    if (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n    cgm.chunks.delete(chunk);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk which will be disconnected\r\n   * @returns {void}\r\n   */\n  disconnectChunk(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of cgc.modules) {\n      const cgm = this._getChunkGraphModule(module);\n      cgm.chunks.delete(chunk);\n    }\n    cgc.modules.clear();\n    chunk.disconnectFromGroups();\n    ChunkGraph.clearChunkGraphForChunk(chunk);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Iterable<Module>} modules the modules\r\n   * @returns {void}\r\n   */\n  attachModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of modules) {\n      cgc.modules.add(module);\n    }\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Iterable<RuntimeModule>} modules the runtime modules\r\n   * @returns {void}\r\n   */\n  attachRuntimeModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of modules) {\n      cgc.runtimeModules.add(module);\n    }\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\r\n   * @returns {void}\r\n   */\n  attachFullHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    for (const module of modules) {\n      cgc.fullHashModules.add(module);\n    }\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\r\n   * @returns {void}\r\n   */\n  attachDependentHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    for (const module of modules) {\n      cgc.dependentHashModules.add(module);\n    }\n  }\n\n  /**\r\n   * @param {Module} oldModule the replaced module\r\n   * @param {Module} newModule the replacing module\r\n   * @returns {void}\r\n   */\n  replaceModule(oldModule, newModule) {\n    const oldCgm = this._getChunkGraphModule(oldModule);\n    const newCgm = this._getChunkGraphModule(newModule);\n    for (const chunk of oldCgm.chunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n      cgc.modules.delete(oldModule);\n      cgc.modules.add(newModule);\n      newCgm.chunks.add(chunk);\n    }\n    oldCgm.chunks.clear();\n    if (oldCgm.entryInChunks !== undefined) {\n      if (newCgm.entryInChunks === undefined) {\n        newCgm.entryInChunks = new Set();\n      }\n      for (const chunk of oldCgm.entryInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n        const old = cgc.entryModules.get(oldModule);\n        /** @type {Map<Module, Entrypoint>} */\n        const newEntryModules = new Map();\n        for (const [m, cg] of cgc.entryModules) {\n          if (m === oldModule) {\n            newEntryModules.set(newModule, old);\n          } else {\n            newEntryModules.set(m, cg);\n          }\n        }\n        cgc.entryModules = newEntryModules;\n        newCgm.entryInChunks.add(chunk);\n      }\n      oldCgm.entryInChunks = undefined;\n    }\n    if (oldCgm.runtimeInChunks !== undefined) {\n      if (newCgm.runtimeInChunks === undefined) {\n        newCgm.runtimeInChunks = new Set();\n      }\n      for (const chunk of oldCgm.runtimeInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n        cgc.runtimeModules.delete( /** @type {RuntimeModule} */oldModule);\n        cgc.runtimeModules.add( /** @type {RuntimeModule} */newModule);\n        newCgm.runtimeInChunks.add(chunk);\n        if (cgc.fullHashModules !== undefined && cgc.fullHashModules.has( /** @type {RuntimeModule} */oldModule)) {\n          cgc.fullHashModules.delete( /** @type {RuntimeModule} */oldModule);\n          cgc.fullHashModules.add( /** @type {RuntimeModule} */newModule);\n        }\n        if (cgc.dependentHashModules !== undefined && cgc.dependentHashModules.has( /** @type {RuntimeModule} */oldModule)) {\n          cgc.dependentHashModules.delete( /** @type {RuntimeModule} */oldModule);\n          cgc.dependentHashModules.add( /** @type {RuntimeModule} */newModule);\n        }\n      }\n      oldCgm.runtimeInChunks = undefined;\n    }\n  }\n\n  /**\r\n   * @param {Module} module the checked module\r\n   * @param {Chunk} chunk the checked chunk\r\n   * @returns {boolean} true, if the chunk contains the module\r\n   */\n  isModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.has(module);\n  }\n\n  /**\r\n   * @param {Module} module the checked module\r\n   * @param {ChunkGroup} chunkGroup the checked chunk group\r\n   * @returns {boolean} true, if the chunk contains the module\r\n   */\n  isModuleInChunkGroup(module, chunkGroup) {\n    for (const chunk of chunkGroup.chunks) {\n      if (this.isModuleInChunk(module, chunk)) return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {Module} module the checked module\r\n   * @returns {boolean} true, if the module is entry of any chunk\r\n   */\n  isEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.entryInChunks !== undefined;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\r\n   */\n  getModuleChunksIterable(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\r\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\r\n   */\n  getOrderedModuleChunksIterable(module, sortFn) {\n    const cgm = this._getChunkGraphModule(module);\n    cgm.chunks.sortWith(sortFn);\n    return cgm.chunks;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {Chunk[]} array of chunks (cached, do not modify)\r\n   */\n  getModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks.getFromCache(getArray);\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {number} the number of chunk which contain the module\r\n   */\n  getNumberOfModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks.size;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {RuntimeSpecSet} runtimes\r\n   */\n  getModuleRuntimes(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {number} the number of modules which are contained in this chunk\r\n   */\n  getNumberOfChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.size;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {number} the number of full hash modules which are contained in this chunk\r\n   */\n  getNumberOfChunkFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<Module>} return the modules for this chunk\r\n   */\n  getChunkModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {string} sourceType source type\r\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\r\n   */\n  getChunkModulesIterableBySourceType(chunk, sourceType) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    return modulesWithSourceType;\n  }\n\n  /**\r\n   * @param {Chunk} chunk chunk\r\n   * @param {Module} module chunk module\r\n   * @param {Set<string>} sourceTypes source types\r\n   */\n  setChunkModuleSourceTypes(chunk, module, sourceTypes) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.sourceTypesByModule === undefined) {\n      cgc.sourceTypesByModule = new WeakMap();\n    }\n    cgc.sourceTypesByModule.set(module, sourceTypes);\n    // Update cgc._modulesBySourceType to invalidate the cache\n    cgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n  }\n\n  /**\r\n   * @param {Chunk} chunk chunk\r\n   * @param {Module} module chunk module\r\n   * @returns {Set<string>} source types\r\n   */\n  getChunkModuleSourceTypes(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.sourceTypesByModule === undefined) {\n      return module.getSourceTypes();\n    }\n    return cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n  }\n\n  /**\r\n   * @param {Module} module module\r\n   * @returns {Set<string>} source types\r\n   */\n  getModuleSourceTypes(module) {\n    return this._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes();\n  }\n\n  /**\r\n   * @param {Module} module module\r\n   * @returns {Set<string> | undefined} source types\r\n   */\n  _getOverwrittenModuleSourceTypes(module) {\n    let newSet = false;\n    let sourceTypes;\n    for (const chunk of this.getModuleChunksIterable(module)) {\n      const cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.sourceTypesByModule === undefined) return;\n      const st = cgc.sourceTypesByModule.get(module);\n      if (st === undefined) return;\n      if (!sourceTypes) {\n        sourceTypes = st;\n        continue;\n      } else if (!newSet) {\n        for (const type of st) {\n          if (!newSet) {\n            if (!sourceTypes.has(type)) {\n              newSet = true;\n              sourceTypes = new Set(sourceTypes);\n              sourceTypes.add(type);\n            }\n          } else {\n            sourceTypes.add(type);\n          }\n        }\n      } else {\n        for (const type of st) sourceTypes.add(type);\n      }\n    }\n    return sourceTypes;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\r\n   * @returns {Iterable<Module>} return the modules for this chunk\r\n   */\n  getOrderedChunkModulesIterable(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgc.modules.sortWith(comparator);\n    return cgc.modules;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {string} sourceType source type\r\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\r\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\r\n   */\n  getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    if (modulesWithSourceType === undefined) return undefined;\n    modulesWithSourceType.sortWith(comparator);\n    return modulesWithSourceType;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\r\n   */\n  getChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(getArray);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\r\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\r\n   */\n  getOrderedChunkModules(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const arrayFunction = createOrderedArrayFunction(comparator);\n    return cgc.modules.getFromUnorderedCache(arrayFunction);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\r\n   * @param {boolean} includeAllChunks all chunks or only async chunks\r\n   * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\r\n   */\n  getChunkModuleIdMap(chunk, filterFn) {\n    let includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n          const moduleId = this.getModuleId(module);\n          array.push(moduleId);\n        }\n      }\n    }\n    return chunkModuleIdMap;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\r\n   * @param {number} hashLength length of the hash\r\n   * @param {boolean} includeAllChunks all chunks or only async chunks\r\n   * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\r\n   */\n  getChunkModuleRenderedHashMap(chunk, filterFn) {\n    let hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /** @type {Record<string|number, Record<string|number, string>>} */\n    const chunkModuleHashMap = Object.create(null);\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {Record<string|number, string>} */\n      let idToHashMap;\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (idToHashMap === undefined) {\n            idToHashMap = Object.create(null);\n            chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n          }\n          const moduleId = this.getModuleId(module);\n          const hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n          idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n        }\n      }\n    }\n    return chunkModuleHashMap;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {ChunkFilterPredicate} filterFn function used to filter chunks\r\n   * @returns {Record<string|number, boolean>} chunk map\r\n   */\n  getChunkConditionMap(chunk, filterFn) {\n    const map = Object.create(null);\n    for (const c of chunk.getAllReferencedChunks()) {\n      map[c.id] = filterFn(c, this);\n    }\n    return map;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\r\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\r\n   * @returns {boolean} return true if module exists in graph\r\n   */\n  hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n    const queue = new Set(chunk.groupsIterable);\n    const chunksProcessed = new Set();\n    for (const chunkGroup of queue) {\n      for (const innerChunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(innerChunk)) {\n          chunksProcessed.add(innerChunk);\n          if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n            for (const module of this.getChunkModulesIterable(innerChunk)) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {Chunk} chunkA first chunk\r\n   * @param {Chunk} chunkB second chunk\r\n   * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\r\n   */\n  compareChunks(chunkA, chunkB) {\n    const cgcA = this._getChunkGraphChunk(chunkA);\n    const cgcB = this._getChunkGraphChunk(chunkB);\n    if (cgcA.modules.size > cgcB.modules.size) return -1;\n    if (cgcA.modules.size < cgcB.modules.size) return 1;\n    cgcA.modules.sortWith(compareModulesByIdentifier);\n    cgcB.modules.sortWith(compareModulesByIdentifier);\n    return compareModuleIterables(cgcA.modules, cgcB.modules);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {number} total size of all modules in the chunk\r\n   */\n  getChunkModulesSize(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(getModulesSize);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\r\n   */\n  getChunkModulesSizes(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(getModulesSizes);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Module[]} root modules of the chunks (ordered by identifier)\r\n   */\n  getChunkRootModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {ChunkSizeOptions} options options object\r\n   * @returns {number} total size of the chunk\r\n   */\n  getChunkSize(chunk) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const cgc = this._getChunkGraphChunk(chunk);\n    const modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n\n  /**\r\n   * @param {Chunk} chunkA chunk\r\n   * @param {Chunk} chunkB chunk\r\n   * @param {ChunkSizeOptions} options options object\r\n   * @returns {number} total size of the chunk or false if chunks can't be integrated\r\n   */\n  getIntegratedChunksSize(chunkA, chunkB) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const cgcA = this._getChunkGraphChunk(chunkA);\n    const cgcB = this._getChunkGraphChunk(chunkB);\n    const allModules = new Set(cgcA.modules);\n    for (const m of cgcB.modules) allModules.add(m);\n    let modulesSize = getModulesSize(allModules);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n\n  /**\r\n   * @param {Chunk} chunkA chunk\r\n   * @param {Chunk} chunkB chunk\r\n   * @returns {boolean} true, if chunks could be integrated\r\n   */\n  canChunksBeIntegrated(chunkA, chunkB) {\n    if (chunkA.preventIntegration || chunkB.preventIntegration) {\n      return false;\n    }\n    const hasRuntimeA = chunkA.hasRuntime();\n    const hasRuntimeB = chunkB.hasRuntime();\n    if (hasRuntimeA !== hasRuntimeB) {\n      if (hasRuntimeA) {\n        return isAvailableChunk(chunkA, chunkB);\n      } else if (hasRuntimeB) {\n        return isAvailableChunk(chunkB, chunkA);\n      } else {\n        return false;\n      }\n    }\n    if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * @param {Chunk} chunkA the target chunk\r\n   * @param {Chunk} chunkB the chunk to integrate\r\n   * @returns {void}\r\n   */\n  integrateChunks(chunkA, chunkB) {\n    // Decide for one name (deterministic)\n    if (chunkA.name && chunkB.name) {\n      if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (chunkA.name.length !== chunkB.name.length) {\n          chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n        } else {\n          chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n        }\n      } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n        // Pick the name of the chunk with the entry module\n        chunkA.name = chunkB.name;\n      }\n    } else if (chunkB.name) {\n      chunkA.name = chunkB.name;\n    }\n\n    // Merge id name hints\n    for (const hint of chunkB.idNameHints) {\n      chunkA.idNameHints.add(hint);\n    }\n\n    // Merge runtime\n    chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n    // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n    for (const module of this.getChunkModules(chunkB)) {\n      this.disconnectChunkAndModule(chunkB, module);\n      this.connectChunkAndModule(chunkA, module);\n    }\n    for (const [module, chunkGroup] of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB))) {\n      this.disconnectChunkAndEntryModule(chunkB, module);\n      this.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n    }\n    for (const chunkGroup of chunkB.groupsIterable) {\n      chunkGroup.replaceChunk(chunkB, chunkA);\n      chunkA.addGroup(chunkGroup);\n      chunkB.removeGroup(chunkGroup);\n    }\n    ChunkGraph.clearChunkGraphForChunk(chunkB);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk to upgrade\r\n   * @returns {void}\r\n   */\n  upgradeDependentToFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.dependentHashModules === undefined) return;\n    if (cgc.fullHashModules === undefined) {\n      cgc.fullHashModules = cgc.dependentHashModules;\n    } else {\n      for (const m of cgc.dependentHashModules) {\n        cgc.fullHashModules.add(m);\n      }\n      cgc.dependentHashModules = undefined;\n    }\n  }\n\n  /**\r\n   * @param {Module} module the checked module\r\n   * @param {Chunk} chunk the checked chunk\r\n   * @returns {boolean} true, if the chunk contains the module as entry\r\n   */\n  isEntryModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules.has(module);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {Module} module the entry module\r\n   * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\r\n   * @returns {void}\r\n   */\n  connectChunkAndEntryModule(chunk, module, entrypoint) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgm.entryInChunks === undefined) {\n      cgm.entryInChunks = new Set();\n    }\n    cgm.entryInChunks.add(chunk);\n    cgc.entryModules.set(module, entrypoint);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {RuntimeModule} module the runtime module\r\n   * @returns {void}\r\n   */\n  connectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgm.runtimeInChunks === undefined) {\n      cgm.runtimeInChunks = new Set();\n    }\n    cgm.runtimeInChunks.add(chunk);\n    cgc.runtimeModules.add(module);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {RuntimeModule} module the module that require a full hash\r\n   * @returns {void}\r\n   */\n  addFullHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    cgc.fullHashModules.add(module);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {RuntimeModule} module the module that require a full hash\r\n   * @returns {void}\r\n   */\n  addDependentHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    cgc.dependentHashModules.add(module);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {Module} module the entry module\r\n   * @returns {void}\r\n   */\n  disconnectChunkAndEntryModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgm.entryInChunks.delete(chunk);\n    if (cgm.entryInChunks.size === 0) {\n      cgm.entryInChunks = undefined;\n    }\n    cgc.entryModules.delete(module);\n  }\n\n  /**\r\n   * @param {Chunk} chunk the new chunk\r\n   * @param {RuntimeModule} module the runtime module\r\n   * @returns {void}\r\n   */\n  disconnectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgm.runtimeInChunks.delete(chunk);\n    if (cgm.runtimeInChunks.size === 0) {\n      cgm.runtimeInChunks = undefined;\n    }\n    cgc.runtimeModules.delete(module);\n  }\n\n  /**\r\n   * @param {Module} module the entry module, it will no longer be entry\r\n   * @returns {void}\r\n   */\n  disconnectEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n    for (const chunk of cgm.entryInChunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n      cgc.entryModules.delete(module);\n    }\n    cgm.entryInChunks = undefined;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk, for which all entries will be removed\r\n   * @returns {void}\r\n   */\n  disconnectEntries(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of cgc.entryModules.keys()) {\n      const cgm = this._getChunkGraphModule(module);\n      cgm.entryInChunks.delete(chunk);\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n    }\n    cgc.entryModules.clear();\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {number} the amount of entry modules in chunk\r\n   */\n  getNumberOfEntryModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules.size;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {number} the amount of entry modules in chunk\r\n   */\n  getNumberOfRuntimeModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.runtimeModules.size;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<Module>} iterable of modules (do not modify)\r\n   */\n  getChunkEntryModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules.keys();\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<Chunk>} iterable of chunks\r\n   */\n  getChunkEntryDependentChunksIterable(chunk) {\n    /** @type {Set<Chunk>} */\n    const set = new Set();\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup instanceof Entrypoint) {\n        const entrypointChunk = chunkGroup.getEntrypointChunk();\n        const cgc = this._getChunkGraphChunk(entrypointChunk);\n        for (const chunkGroup of cgc.entryModules.values()) {\n          for (const c of chunkGroup.chunks) {\n            if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n              set.add(c);\n            }\n          }\n        }\n      }\n    }\n    return set;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {boolean} true, when it has dependent chunks\r\n   */\n  hasChunkEntryDependentChunks(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const chunkGroup of cgc.entryModules.values()) {\n      for (const c of chunkGroup.chunks) {\n        if (c !== chunk) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\r\n   */\n  getChunkRuntimeModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.runtimeModules;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {RuntimeModule[]} array of modules in order of execution\r\n   */\n  getChunkRuntimeModulesInOrder(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const array = Array.from(cgc.runtimeModules);\n    array.sort(concatComparators(compareSelect(\n    /**\r\n     * @param {RuntimeModule} r runtime module\r\n     * @returns {number=} stage\r\n     */\n    r => r.stage, compareIds), compareModulesByIdentifier));\n    return array;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\r\n   */\n  getChunkFullHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.fullHashModules;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\r\n   */\n  getChunkFullHashModulesSet(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.fullHashModules;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\r\n   */\n  getChunkDependentHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.dependentHashModules;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\r\n   */\n  getChunkEntryModulesWithChunkGroupIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules;\n  }\n\n  /**\r\n   * @param {AsyncDependenciesBlock} depBlock the async block\r\n   * @returns {ChunkGroup} the chunk group\r\n   */\n  getBlockChunkGroup(depBlock) {\n    return this._blockChunkGroups.get(depBlock);\n  }\n\n  /**\r\n   * @param {AsyncDependenciesBlock} depBlock the async block\r\n   * @param {ChunkGroup} chunkGroup the chunk group\r\n   * @returns {void}\r\n   */\n  connectBlockAndChunkGroup(depBlock, chunkGroup) {\n    this._blockChunkGroups.set(depBlock, chunkGroup);\n    chunkGroup.addBlock(depBlock);\n  }\n\n  /**\r\n   * @param {ChunkGroup} chunkGroup the chunk group\r\n   * @returns {void}\r\n   */\n  disconnectChunkGroup(chunkGroup) {\n    for (const block of chunkGroup.blocksIterable) {\n      this._blockChunkGroups.delete(block);\n    }\n    // TODO refactor by moving blocks list into ChunkGraph\n    chunkGroup._blocks.clear();\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {string | number} the id of the module\r\n   */\n  getModuleId(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.id;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {string | number} id the id of the module\r\n   * @returns {void}\r\n   */\n  setModuleId(module, id) {\n    const cgm = this._getChunkGraphModule(module);\n    cgm.id = id;\n  }\n\n  /**\r\n   * @param {string} runtime runtime\r\n   * @returns {string | number} the id of the runtime\r\n   */\n  getRuntimeId(runtime) {\n    return this._runtimeIds.get(runtime);\n  }\n\n  /**\r\n   * @param {string} runtime runtime\r\n   * @param {string | number} id the id of the runtime\r\n   * @returns {void}\r\n   */\n  setRuntimeId(runtime, id) {\n    this._runtimeIds.set(runtime, id);\n  }\n\n  /**\r\n   * @template T\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpecMap<T>} hashes hashes data\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {T} hash\r\n   */\n  _getModuleHashInfo(module, hashes, runtime) {\n    if (!hashes) {\n      throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (hashes not set at all)`);\n    } else if (runtime === undefined) {\n      const hashInfoItems = new Set(hashes.values());\n      if (hashInfoItems.size !== 1) {\n        throw new Error(`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(hashes.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n      }\n      return first(hashInfoItems);\n    } else {\n      const hashInfo = hashes.get(runtime);\n      if (!hashInfo) {\n        throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (available runtimes ${Array.from(hashes.keys(), runtimeToString).join(\", \")})`);\n      }\n      return hashInfo;\n    }\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, if the module has hashes for this runtime\r\n   */\n  hasModuleHashes(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const hashes = cgm.hashes;\n    return hashes && hashes.has(runtime);\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {string} hash\r\n   */\n  getModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).hash;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {string} hash\r\n   */\n  getRenderedModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @param {string} hash the full hash\r\n   * @param {string} renderedHash the shortened hash for rendering\r\n   * @returns {void}\r\n   */\n  setModuleHashes(module, runtime, hash, renderedHash) {\n    const cgm = this._getChunkGraphModule(module);\n    if (cgm.hashes === undefined) {\n      cgm.hashes = new RuntimeSpecMap();\n    }\n    cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\r\n   * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\r\n   * @returns {void}\r\n   */\n  addModuleRuntimeRequirements(module, runtime, items) {\n    let transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const cgm = this._getChunkGraphModule(module);\n    const runtimeRequirementsMap = cgm.runtimeRequirements;\n    if (runtimeRequirementsMap === undefined) {\n      const map = new RuntimeSpecMap();\n      // TODO avoid cloning item and track ownership instead\n      map.set(runtime, transferOwnership ? items : new Set(items));\n      cgm.runtimeRequirements = map;\n      return;\n    }\n    runtimeRequirementsMap.update(runtime, runtimeRequirements => {\n      if (runtimeRequirements === undefined) {\n        return transferOwnership ? items : new Set(items);\n      } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n        for (const item of items) runtimeRequirements.add(item);\n        return runtimeRequirements;\n      } else {\n        for (const item of runtimeRequirements) items.add(item);\n        return items;\n      }\n    });\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\r\n   * @returns {void}\r\n   */\n  addChunkRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const runtimeRequirements = cgc.runtimeRequirements;\n    if (runtimeRequirements === undefined) {\n      cgc.runtimeRequirements = items;\n    } else if (runtimeRequirements.size >= items.size) {\n      for (const item of items) runtimeRequirements.add(item);\n    } else {\n      for (const item of runtimeRequirements) items.add(item);\n      cgc.runtimeRequirements = items;\n    }\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {Iterable<string>} items runtime requirements to be added\r\n   * @returns {void}\r\n   */\n  addTreeRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const runtimeRequirements = cgc.runtimeRequirementsInTree;\n    for (const item of items) runtimeRequirements.add(item);\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {ReadonlySet<string>} runtime requirements\r\n   */\n  getModuleRuntimeRequirements(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {ReadonlySet<string>} runtime requirements\r\n   */\n  getChunkRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const runtimeRequirements = cgc.runtimeRequirements;\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @param {boolean} withConnections include connections\r\n   * @returns {string} hash\r\n   */\n  getModuleGraphHash(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const cgm = this._getChunkGraphModule(module);\n    return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n  }\n\n  /**\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @param {boolean} withConnections include connections\r\n   * @returns {bigint} hash\r\n   */\n  getModuleGraphHashBigInt(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const cgm = this._getChunkGraphModule(module);\n    return withConnections ? BigInt(`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n  }\n\n  /**\r\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {bigint} hash as big int\r\n   */\n  _getModuleGraphHashBigInt(cgm, module, runtime) {\n    if (cgm.graphHashes === undefined) {\n      cgm.graphHashes = new RuntimeSpecMap();\n    }\n    const graphHash = cgm.graphHashes.provide(runtime, () => {\n      const hash = createHash(this._hashFunction);\n      hash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n      const sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n      if (sourceTypes !== undefined) {\n        for (const type of sourceTypes) hash.update(type);\n      }\n      this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n      return BigInt(`0x${/** @type {string} */hash.digest(\"hex\")}`);\n    });\n    return graphHash;\n  }\n\n  /**\r\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\r\n   * @param {Module} module the module\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {string} hash\r\n   */\n  _getModuleGraphHashWithConnections(cgm, module, runtime) {\n    if (cgm.graphHashesWithConnections === undefined) {\n      cgm.graphHashesWithConnections = new RuntimeSpecMap();\n    }\n    const activeStateToString = state => {\n      if (state === false) return \"F\";\n      if (state === true) return \"T\";\n      if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n      throw new Error(\"Not implemented active state\");\n    };\n    const strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n    return cgm.graphHashesWithConnections.provide(runtime, () => {\n      const graphHash = this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n      const connections = this.moduleGraph.getOutgoingConnections(module);\n      /** @type {Set<Module>} */\n      const activeNamespaceModules = new Set();\n      /** @type {Map<string, Module | Set<Module>>} */\n      const connectedModules = new Map();\n      const processConnection = (connection, stateInfo) => {\n        const module = connection.module;\n        stateInfo += module.getExportsType(this.moduleGraph, strict);\n        // cspell:word Tnamespace\n        if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n          const oldModule = connectedModules.get(stateInfo);\n          if (oldModule === undefined) {\n            connectedModules.set(stateInfo, module);\n          } else if (oldModule instanceof Set) {\n            oldModule.add(module);\n          } else if (oldModule !== module) {\n            connectedModules.set(stateInfo, new Set([oldModule, module]));\n          }\n        }\n      };\n      if (runtime === undefined || typeof runtime === \"string\") {\n        for (const connection of connections) {\n          const state = connection.getActiveState(runtime);\n          if (state === false) continue;\n          processConnection(connection, state === true ? \"T\" : \"O\");\n        }\n      } else {\n        // cspell:word Tnamespace\n        for (const connection of connections) {\n          const states = new Set();\n          let stateInfo = \"\";\n          forEachRuntime(runtime, runtime => {\n            const state = connection.getActiveState(runtime);\n            states.add(state);\n            stateInfo += activeStateToString(state) + runtime;\n          }, true);\n          if (states.size === 1) {\n            const state = first(states);\n            if (state === false) continue;\n            stateInfo = activeStateToString(state);\n          }\n          processConnection(connection, stateInfo);\n        }\n      }\n      // cspell:word Tnamespace\n      if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n      const connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort((_ref, _ref2) => {\n        let [a] = _ref;\n        let [b] = _ref2;\n        return a < b ? -1 : 1;\n      }) : connectedModules;\n      const hash = createHash(this._hashFunction);\n      const addModuleToHash = module => {\n        hash.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(module), module, runtime).toString(16));\n      };\n      const addModulesToHash = modules => {\n        let xor = ZERO_BIG_INT;\n        for (const m of modules) {\n          xor = xor ^ this._getModuleGraphHashBigInt(this._getChunkGraphModule(m), m, runtime);\n        }\n        hash.update(xor.toString(16));\n      };\n      if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n      for (const [stateInfo, modules] of connectedModulesInOrder) {\n        hash.update(stateInfo);\n        if (modules instanceof Set) {\n          addModulesToHash(modules);\n        } else {\n          addModuleToHash(modules);\n        }\n      }\n      hash.update(graphHash);\n      return (/** @type {string} */hash.digest(\"hex\")\n      );\n    });\n  }\n\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {ReadonlySet<string>} runtime requirements\r\n   */\n  getTreeRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.runtimeRequirementsInTree;\n  }\n\n  // TODO remove in webpack 6\n  /**\r\n   * @param {Module} module the module\r\n   * @param {string} deprecateMessage message for the deprecation message\r\n   * @param {string} deprecationCode code for the deprecation\r\n   * @returns {ChunkGraph} the chunk graph\r\n   */\n  static getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n    if (fn) return fn(module);\n    const newFn = util.deprecate(\n    /**\r\n     * @param {Module} module the module\r\n     * @returns {ChunkGraph} the chunk graph\r\n     */\n    module => {\n      const chunkGraph = chunkGraphForModuleMap.get(module);\n      if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n    return newFn(module);\n  }\n\n  // TODO remove in webpack 6\n  /**\r\n   * @param {Module} module the module\r\n   * @param {ChunkGraph} chunkGraph the chunk graph\r\n   * @returns {void}\r\n   */\n  static setChunkGraphForModule(module, chunkGraph) {\n    chunkGraphForModuleMap.set(module, chunkGraph);\n  }\n\n  // TODO remove in webpack 6\n  /**\r\n   * @param {Module} module the module\r\n   * @returns {void}\r\n   */\n  static clearChunkGraphForModule(module) {\n    chunkGraphForModuleMap.delete(module);\n  }\n\n  // TODO remove in webpack 6\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {string} deprecateMessage message for the deprecation message\r\n   * @param {string} deprecationCode code for the deprecation\r\n   * @returns {ChunkGraph} the chunk graph\r\n   */\n  static getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n    if (fn) return fn(chunk);\n    const newFn = util.deprecate(\n    /**\r\n     * @param {Chunk} chunk the chunk\r\n     * @returns {ChunkGraph} the chunk graph\r\n     */\n    chunk => {\n      const chunkGraph = chunkGraphForChunkMap.get(chunk);\n      if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n    return newFn(chunk);\n  }\n\n  // TODO remove in webpack 6\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @param {ChunkGraph} chunkGraph the chunk graph\r\n   * @returns {void}\r\n   */\n  static setChunkGraphForChunk(chunk, chunkGraph) {\n    chunkGraphForChunkMap.set(chunk, chunkGraph);\n  }\n\n  // TODO remove in webpack 6\n  /**\r\n   * @param {Chunk} chunk the chunk\r\n   * @returns {void}\r\n   */\n  static clearChunkGraphForChunk(chunk) {\n    chunkGraphForChunkMap.delete(chunk);\n  }\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","constructor","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","sourceTypesByModule","map","Map","module","sourceTypes","get","getSourceTypes","sourceType","innerSet","undefined","key","size","defaultModulesBySourceType","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parent","parentsIterable","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","_modulesBySourceType","ChunkGraph","moduleGraph","hashFunction","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","_getChunkGraphModule","cgm","_getChunkGraphChunk","cgc","addDependencies","connection","getOutgoingConnections","activeState","getActiveState","TRANSITIVE_ONLY","sort","connectChunkAndModule","disconnectChunkAndModule","delete","disconnectChunk","clear","disconnectFromGroups","clearChunkGraphForChunk","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","replaceModule","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","isModuleInChunkGroup","isEntryModule","getModuleChunksIterable","getOrderedModuleChunksIterable","sortFn","getModuleChunks","getFromCache","getNumberOfModuleChunks","getFromUnorderedCache","getNumberOfChunkModules","getNumberOfChunkFullHashModules","getChunkModulesIterable","getChunkModulesIterableBySourceType","modulesWithSourceType","setChunkModuleSourceTypes","getChunkModuleSourceTypes","getModuleSourceTypes","_getOverwrittenModuleSourceTypes","newSet","st","getOrderedChunkModulesIterable","getOrderedChunkModulesIterableBySourceType","getChunkModules","getOrderedChunkModules","arrayFunction","getChunkModuleIdMap","filterFn","includeAllChunks","chunkModuleIdMap","asyncChunk","getAllReferencedChunks","getAllAsyncChunks","array","moduleId","getModuleId","push","getChunkModuleRenderedHashMap","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","getChunkConditionMap","c","hasModuleInGraph","filterChunkFn","chunksProcessed","innerChunk","child","childrenIterable","compareChunks","chunkA","chunkB","cgcA","cgcB","getChunkModulesSize","getChunkModulesSizes","getChunkRootModules","getChunkSize","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","getIntegratedChunksSize","allModules","canChunksBeIntegrated","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","integrateChunks","name","length","hint","idNameHints","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","upgradeDependentToFullHashModules","isEntryModuleInChunk","entrypoint","connectChunkAndRuntimeModule","addFullHashModuleToChunk","addDependentHashModuleToChunk","disconnectChunkAndRuntimeModule","disconnectEntryModule","disconnectEntries","keys","getNumberOfRuntimeModules","getChunkEntryModulesIterable","getChunkEntryDependentChunksIterable","entrypointChunk","getEntrypointChunk","values","hasChunkEntryDependentChunks","getChunkRuntimeModulesIterable","getChunkRuntimeModulesInOrder","r","stage","getChunkFullHashModulesIterable","getChunkFullHashModulesSet","getChunkDependentHashModulesIterable","getBlockChunkGroup","depBlock","connectBlockAndChunkGroup","addBlock","disconnectChunkGroup","block","blocksIterable","_blocks","setModuleId","getRuntimeId","setRuntimeId","_getModuleHashInfo","Error","identifier","hashInfoItems","join","hashInfo","hasModuleHashes","getModuleHash","setModuleHashes","addModuleRuntimeRequirements","items","transferOwnership","runtimeRequirementsMap","update","item","addChunkRuntimeRequirements","addTreeRuntimeRequirements","getModuleRuntimeRequirements","getChunkRuntimeRequirements","getModuleGraphHash","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","getModuleGraphHashBigInt","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","addModuleToHash","addModulesToHash","xor","next","value","getTreeRuntimeRequirements","getChunkGraphForModule","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","setChunkGraphForModule","clearChunkGraphForModule","getChunkGraphForChunk","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","setChunkGraphForChunk","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/ChunkGraph.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst util = require(\"util\");\r\nconst Entrypoint = require(\"./Entrypoint\");\r\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\r\nconst { first } = require(\"./util/SetHelpers\");\r\nconst SortableSet = require(\"./util/SortableSet\");\r\nconst {\r\n\tcompareModulesById,\r\n\tcompareIterables,\r\n\tcompareModulesByIdentifier,\r\n\tconcatComparators,\r\n\tcompareSelect,\r\n\tcompareIds\r\n} = require(\"./util/comparators\");\r\nconst createHash = require(\"./util/createHash\");\r\nconst findGraphRoots = require(\"./util/findGraphRoots\");\r\nconst {\r\n\tRuntimeSpecMap,\r\n\tRuntimeSpecSet,\r\n\truntimeToString,\r\n\tmergeRuntime,\r\n\tforEachRuntime\r\n} = require(\"./util/runtime\");\r\n\r\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\r\n/** @typedef {import(\"./Chunk\")} Chunk */\r\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\r\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\r\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\r\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\r\n\r\n/** @type {ReadonlySet<string>} */\r\nconst EMPTY_SET = new Set();\r\n\r\nconst ZERO_BIG_INT = BigInt(0);\r\n\r\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\r\n\r\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\r\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\r\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\r\n\r\n/**\r\n * @typedef {Object} ChunkSizeOptions\r\n * @property {number=} chunkOverhead constant overhead for a chunk\r\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\r\n */\r\n\r\nclass ModuleHashInfo {\r\n\tconstructor(hash, renderedHash) {\r\n\t\tthis.hash = hash;\r\n\t\tthis.renderedHash = renderedHash;\r\n\t}\r\n}\r\n\r\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\r\n\r\n/**\r\n * @template T\r\n * @param {SortableSet<T>} set the set\r\n * @returns {T[]} set as array\r\n */\r\nconst getArray = set => {\r\n\treturn Array.from(set);\r\n};\r\n\r\n/**\r\n * @param {SortableSet<Chunk>} chunks the chunks\r\n * @returns {RuntimeSpecSet} runtimes\r\n */\r\nconst getModuleRuntimes = chunks => {\r\n\tconst runtimes = new RuntimeSpecSet();\r\n\tfor (const chunk of chunks) {\r\n\t\truntimes.add(chunk.runtime);\r\n\t}\r\n\treturn runtimes;\r\n};\r\n\r\n/**\r\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\r\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\r\n */\r\nconst modulesBySourceType = sourceTypesByModule => set => {\r\n\t/** @type {Map<string, SortableSet<Module>>} */\r\n\tconst map = new Map();\r\n\tfor (const module of set) {\r\n\t\tconst sourceTypes =\r\n\t\t\t(sourceTypesByModule && sourceTypesByModule.get(module)) ||\r\n\t\t\tmodule.getSourceTypes();\r\n\t\tfor (const sourceType of sourceTypes) {\r\n\t\t\tlet innerSet = map.get(sourceType);\r\n\t\t\tif (innerSet === undefined) {\r\n\t\t\t\tinnerSet = new SortableSet();\r\n\t\t\t\tmap.set(sourceType, innerSet);\r\n\t\t\t}\r\n\t\t\tinnerSet.add(module);\r\n\t\t}\r\n\t}\r\n\tfor (const [key, innerSet] of map) {\r\n\t\t// When all modules have the source type, we reuse the original SortableSet\r\n\t\t// to benefit from the shared cache (especially for sorting)\r\n\t\tif (innerSet.size === set.size) {\r\n\t\t\tmap.set(key, set);\r\n\t\t}\r\n\t}\r\n\treturn map;\r\n};\r\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\r\n\r\n/** @type {WeakMap<Function, any>} */\r\nconst createOrderedArrayFunctionMap = new WeakMap();\r\n\r\n/**\r\n * @template T\r\n * @param {function(T, T): -1|0|1} comparator comparator function\r\n * @returns {SetToArrayFunction<T>} set as ordered array\r\n */\r\nconst createOrderedArrayFunction = comparator => {\r\n\t/** @type {SetToArrayFunction<T>} */\r\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\r\n\tif (fn !== undefined) return fn;\r\n\tfn = set => {\r\n\t\tset.sortWith(comparator);\r\n\t\treturn Array.from(set);\r\n\t};\r\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\r\n\treturn fn;\r\n};\r\n\r\n/**\r\n * @param {Iterable<Module>} modules the modules to get the count/size of\r\n * @returns {number} the size of the modules\r\n */\r\nconst getModulesSize = modules => {\r\n\tlet size = 0;\r\n\tfor (const module of modules) {\r\n\t\tfor (const type of module.getSourceTypes()) {\r\n\t\t\tsize += module.size(type);\r\n\t\t}\r\n\t}\r\n\treturn size;\r\n};\r\n\r\n/**\r\n * @param {Iterable<Module>} modules the sortable Set to get the size of\r\n * @returns {Record<string, number>} the sizes of the modules\r\n */\r\nconst getModulesSizes = modules => {\r\n\tlet sizes = Object.create(null);\r\n\tfor (const module of modules) {\r\n\t\tfor (const type of module.getSourceTypes()) {\r\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\r\n\t\t}\r\n\t}\r\n\treturn sizes;\r\n};\r\n\r\n/**\r\n * @param {Chunk} a chunk\r\n * @param {Chunk} b chunk\r\n * @returns {boolean} true, if a is always a parent of b\r\n */\r\nconst isAvailableChunk = (a, b) => {\r\n\tconst queue = new Set(b.groupsIterable);\r\n\tfor (const chunkGroup of queue) {\r\n\t\tif (a.isInGroup(chunkGroup)) continue;\r\n\t\tif (chunkGroup.isInitial()) return false;\r\n\t\tfor (const parent of chunkGroup.parentsIterable) {\r\n\t\t\tqueue.add(parent);\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n};\r\n\r\nclass ChunkGraphModule {\r\n\tconstructor() {\r\n\t\t/** @type {SortableSet<Chunk>} */\r\n\t\tthis.chunks = new SortableSet();\r\n\t\t/** @type {Set<Chunk> | undefined} */\r\n\t\tthis.entryInChunks = undefined;\r\n\t\t/** @type {Set<Chunk> | undefined} */\r\n\t\tthis.runtimeInChunks = undefined;\r\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo>} */\r\n\t\tthis.hashes = undefined;\r\n\t\t/** @type {string | number} */\r\n\t\tthis.id = null;\r\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\r\n\t\tthis.runtimeRequirements = undefined;\r\n\t\t/** @type {RuntimeSpecMap<string>} */\r\n\t\tthis.graphHashes = undefined;\r\n\t\t/** @type {RuntimeSpecMap<string>} */\r\n\t\tthis.graphHashesWithConnections = undefined;\r\n\t}\r\n}\r\n\r\nclass ChunkGraphChunk {\r\n\tconstructor() {\r\n\t\t/** @type {SortableSet<Module>} */\r\n\t\tthis.modules = new SortableSet();\r\n\t\t/** @type {WeakMap<Module, Set<string>> | undefined} */\r\n\t\tthis.sourceTypesByModule = undefined;\r\n\t\t/** @type {Map<Module, Entrypoint>} */\r\n\t\tthis.entryModules = new Map();\r\n\t\t/** @type {SortableSet<RuntimeModule>} */\r\n\t\tthis.runtimeModules = new SortableSet();\r\n\t\t/** @type {Set<RuntimeModule> | undefined} */\r\n\t\tthis.fullHashModules = undefined;\r\n\t\t/** @type {Set<RuntimeModule> | undefined} */\r\n\t\tthis.dependentHashModules = undefined;\r\n\t\t/** @type {Set<string> | undefined} */\r\n\t\tthis.runtimeRequirements = undefined;\r\n\t\t/** @type {Set<string>} */\r\n\t\tthis.runtimeRequirementsInTree = new Set();\r\n\r\n\t\tthis._modulesBySourceType = defaultModulesBySourceType;\r\n\t}\r\n}\r\n\r\nclass ChunkGraph {\r\n\t/**\r\n\t * @param {ModuleGraph} moduleGraph the module graph\r\n\t * @param {string | Hash} hashFunction the hash function to use\r\n\t */\r\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\r\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\r\n\t\tthis._modules = new WeakMap();\r\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\r\n\t\tthis._chunks = new WeakMap();\r\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\r\n\t\tthis._blockChunkGroups = new WeakMap();\r\n\t\t/** @private @type {Map<string, string | number>} */\r\n\t\tthis._runtimeIds = new Map();\r\n\t\t/** @type {ModuleGraph} */\r\n\t\tthis.moduleGraph = moduleGraph;\r\n\r\n\t\tthis._hashFunction = hashFunction;\r\n\r\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * @param {Module} module the module\r\n\t * @returns {ChunkGraphModule} internal module\r\n\t */\r\n\t_getChunkGraphModule(module) {\r\n\t\tlet cgm = this._modules.get(module);\r\n\t\tif (cgm === undefined) {\r\n\t\t\tcgm = new ChunkGraphModule();\r\n\t\t\tthis._modules.set(module, cgm);\r\n\t\t}\r\n\t\treturn cgm;\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {ChunkGraphChunk} internal chunk\r\n\t */\r\n\t_getChunkGraphChunk(chunk) {\r\n\t\tlet cgc = this._chunks.get(chunk);\r\n\t\tif (cgc === undefined) {\r\n\t\t\tcgc = new ChunkGraphChunk();\r\n\t\t\tthis._chunks.set(chunk, cgc);\r\n\t\t}\r\n\t\treturn cgc;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\r\n\t * @returns {Module[]} the graph roots\r\n\t */\r\n\t_getGraphRoots(set) {\r\n\t\tconst { moduleGraph } = this;\r\n\t\treturn Array.from(\r\n\t\t\tfindGraphRoots(set, module => {\r\n\t\t\t\t/** @type {Set<Module>} */\r\n\t\t\t\tconst set = new Set();\r\n\t\t\t\tconst addDependencies = module => {\r\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\r\n\t\t\t\t\t\tif (!connection.module) continue;\r\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\r\n\t\t\t\t\t\tif (activeState === false) continue;\r\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\r\n\t\t\t\t\t\t\taddDependencies(connection.module);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tset.add(connection.module);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\taddDependencies(module);\r\n\t\t\t\treturn set;\r\n\t\t\t})\r\n\t\t).sort(compareModulesByIdentifier);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {Module} module the module\r\n\t * @returns {void}\r\n\t */\r\n\tconnectChunkAndModule(chunk, module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tcgm.chunks.add(chunk);\r\n\t\tcgc.modules.add(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Module} module the module\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectChunkAndModule(chunk, module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tcgc.modules.delete(module);\r\n\t\t// No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\r\n\t\tif (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\r\n\t\tcgm.chunks.delete(chunk);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk which will be disconnected\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectChunk(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tfor (const module of cgc.modules) {\r\n\t\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\t\tcgm.chunks.delete(chunk);\r\n\t\t}\r\n\t\tcgc.modules.clear();\r\n\t\tchunk.disconnectFromGroups();\r\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Iterable<Module>} modules the modules\r\n\t * @returns {void}\r\n\t */\r\n\tattachModules(chunk, modules) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tfor (const module of modules) {\r\n\t\t\tcgc.modules.add(module);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\r\n\t * @returns {void}\r\n\t */\r\n\tattachRuntimeModules(chunk, modules) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tfor (const module of modules) {\r\n\t\t\tcgc.runtimeModules.add(module);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\r\n\t * @returns {void}\r\n\t */\r\n\tattachFullHashModules(chunk, modules) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\r\n\t\tfor (const module of modules) {\r\n\t\t\tcgc.fullHashModules.add(module);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\r\n\t * @returns {void}\r\n\t */\r\n\tattachDependentHashModules(chunk, modules) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.dependentHashModules === undefined)\r\n\t\t\tcgc.dependentHashModules = new Set();\r\n\t\tfor (const module of modules) {\r\n\t\t\tcgc.dependentHashModules.add(module);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} oldModule the replaced module\r\n\t * @param {Module} newModule the replacing module\r\n\t * @returns {void}\r\n\t */\r\n\treplaceModule(oldModule, newModule) {\r\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\r\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\r\n\r\n\t\tfor (const chunk of oldCgm.chunks) {\r\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\t\tcgc.modules.delete(oldModule);\r\n\t\t\tcgc.modules.add(newModule);\r\n\t\t\tnewCgm.chunks.add(chunk);\r\n\t\t}\r\n\t\toldCgm.chunks.clear();\r\n\r\n\t\tif (oldCgm.entryInChunks !== undefined) {\r\n\t\t\tif (newCgm.entryInChunks === undefined) {\r\n\t\t\t\tnewCgm.entryInChunks = new Set();\r\n\t\t\t}\r\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\r\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\r\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\r\n\t\t\t\tconst newEntryModules = new Map();\r\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\r\n\t\t\t\t\tif (m === oldModule) {\r\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcgc.entryModules = newEntryModules;\r\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\r\n\t\t\t}\r\n\t\t\toldCgm.entryInChunks = undefined;\r\n\t\t}\r\n\r\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\r\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\r\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\r\n\t\t\t}\r\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\r\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\r\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\r\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\r\n\t\t\t\tif (\r\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\r\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\r\n\t\t\t\t) {\r\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\r\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\r\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\r\n\t\t\t\t) {\r\n\t\t\t\t\tcgc.dependentHashModules.delete(\r\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tcgc.dependentHashModules.add(\r\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toldCgm.runtimeInChunks = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the checked module\r\n\t * @param {Chunk} chunk the checked chunk\r\n\t * @returns {boolean} true, if the chunk contains the module\r\n\t */\r\n\tisModuleInChunk(module, chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules.has(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the checked module\r\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\r\n\t * @returns {boolean} true, if the chunk contains the module\r\n\t */\r\n\tisModuleInChunkGroup(module, chunkGroup) {\r\n\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the checked module\r\n\t * @returns {boolean} true, if the module is entry of any chunk\r\n\t */\r\n\tisEntryModule(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn cgm.entryInChunks !== undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\r\n\t */\r\n\tgetModuleChunksIterable(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn cgm.chunks;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\r\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\r\n\t */\r\n\tgetOrderedModuleChunksIterable(module, sortFn) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tcgm.chunks.sortWith(sortFn);\r\n\t\treturn cgm.chunks;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\r\n\t */\r\n\tgetModuleChunks(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn cgm.chunks.getFromCache(getArray);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {number} the number of chunk which contain the module\r\n\t */\r\n\tgetNumberOfModuleChunks(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn cgm.chunks.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {RuntimeSpecSet} runtimes\r\n\t */\r\n\tgetModuleRuntimes(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {number} the number of modules which are contained in this chunk\r\n\t */\r\n\tgetNumberOfChunkModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {number} the number of full hash modules which are contained in this chunk\r\n\t */\r\n\tgetNumberOfChunkFullHashModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<Module>} return the modules for this chunk\r\n\t */\r\n\tgetChunkModulesIterable(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {string} sourceType source type\r\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\r\n\t */\r\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst modulesWithSourceType = cgc.modules\r\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\r\n\t\t\t.get(sourceType);\r\n\t\treturn modulesWithSourceType;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk chunk\r\n\t * @param {Module} module chunk module\r\n\t * @param {Set<string>} sourceTypes source types\r\n\t */\r\n\tsetChunkModuleSourceTypes(chunk, module, sourceTypes) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.sourceTypesByModule === undefined) {\r\n\t\t\tcgc.sourceTypesByModule = new WeakMap();\r\n\t\t}\r\n\t\tcgc.sourceTypesByModule.set(module, sourceTypes);\r\n\t\t// Update cgc._modulesBySourceType to invalidate the cache\r\n\t\tcgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk chunk\r\n\t * @param {Module} module chunk module\r\n\t * @returns {Set<string>} source types\r\n\t */\r\n\tgetChunkModuleSourceTypes(chunk, module) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.sourceTypesByModule === undefined) {\r\n\t\t\treturn module.getSourceTypes();\r\n\t\t}\r\n\t\treturn cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module module\r\n\t * @returns {Set<string>} source types\r\n\t */\r\n\tgetModuleSourceTypes(module) {\r\n\t\treturn (\r\n\t\t\tthis._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module module\r\n\t * @returns {Set<string> | undefined} source types\r\n\t */\r\n\t_getOverwrittenModuleSourceTypes(module) {\r\n\t\tlet newSet = false;\r\n\t\tlet sourceTypes;\r\n\t\tfor (const chunk of this.getModuleChunksIterable(module)) {\r\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\t\tif (cgc.sourceTypesByModule === undefined) return;\r\n\t\t\tconst st = cgc.sourceTypesByModule.get(module);\r\n\t\t\tif (st === undefined) return;\r\n\t\t\tif (!sourceTypes) {\r\n\t\t\t\tsourceTypes = st;\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (!newSet) {\r\n\t\t\t\tfor (const type of st) {\r\n\t\t\t\t\tif (!newSet) {\r\n\t\t\t\t\t\tif (!sourceTypes.has(type)) {\r\n\t\t\t\t\t\t\tnewSet = true;\r\n\t\t\t\t\t\t\tsourceTypes = new Set(sourceTypes);\r\n\t\t\t\t\t\t\tsourceTypes.add(type);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsourceTypes.add(type);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (const type of st) sourceTypes.add(type);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sourceTypes;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\r\n\t * @returns {Iterable<Module>} return the modules for this chunk\r\n\t */\r\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tcgc.modules.sortWith(comparator);\r\n\t\treturn cgc.modules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {string} sourceType source type\r\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\r\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\r\n\t */\r\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst modulesWithSourceType = cgc.modules\r\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\r\n\t\t\t.get(sourceType);\r\n\t\tif (modulesWithSourceType === undefined) return undefined;\r\n\t\tmodulesWithSourceType.sortWith(comparator);\r\n\t\treturn modulesWithSourceType;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\r\n\t */\r\n\tgetChunkModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\r\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\r\n\t */\r\n\tgetOrderedChunkModules(chunk, comparator) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\r\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\r\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\r\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\r\n\t */\r\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\r\n\t\t/** @type {Record<string|number, (string|number)[]>} */\r\n\t\tconst chunkModuleIdMap = Object.create(null);\r\n\r\n\t\tfor (const asyncChunk of includeAllChunks\r\n\t\t\t? chunk.getAllReferencedChunks()\r\n\t\t\t: chunk.getAllAsyncChunks()) {\r\n\t\t\t/** @type {(string|number)[]} */\r\n\t\t\tlet array;\r\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\r\n\t\t\t\tasyncChunk,\r\n\t\t\t\tcompareModulesById(this)\r\n\t\t\t)) {\r\n\t\t\t\tif (filterFn(module)) {\r\n\t\t\t\t\tif (array === undefined) {\r\n\t\t\t\t\t\tarray = [];\r\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\r\n\t\t\t\t\tarray.push(moduleId);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chunkModuleIdMap;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\r\n\t * @param {number} hashLength length of the hash\r\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\r\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\r\n\t */\r\n\tgetChunkModuleRenderedHashMap(\r\n\t\tchunk,\r\n\t\tfilterFn,\r\n\t\thashLength = 0,\r\n\t\tincludeAllChunks = false\r\n\t) {\r\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\r\n\t\tconst chunkModuleHashMap = Object.create(null);\r\n\r\n\t\tfor (const asyncChunk of includeAllChunks\r\n\t\t\t? chunk.getAllReferencedChunks()\r\n\t\t\t: chunk.getAllAsyncChunks()) {\r\n\t\t\t/** @type {Record<string|number, string>} */\r\n\t\t\tlet idToHashMap;\r\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\r\n\t\t\t\tasyncChunk,\r\n\t\t\t\tcompareModulesById(this)\r\n\t\t\t)) {\r\n\t\t\t\tif (filterFn(module)) {\r\n\t\t\t\t\tif (idToHashMap === undefined) {\r\n\t\t\t\t\t\tidToHashMap = Object.create(null);\r\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\r\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\r\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chunkModuleHashMap;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\r\n\t * @returns {Record<string|number, boolean>} chunk map\r\n\t */\r\n\tgetChunkConditionMap(chunk, filterFn) {\r\n\t\tconst map = Object.create(null);\r\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\r\n\t\t\tmap[c.id] = filterFn(c, this);\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\r\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\r\n\t * @returns {boolean} return true if module exists in graph\r\n\t */\r\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\r\n\t\tconst queue = new Set(chunk.groupsIterable);\r\n\t\tconst chunksProcessed = new Set();\r\n\r\n\t\tfor (const chunkGroup of queue) {\r\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\r\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\r\n\t\t\t\t\tchunksProcessed.add(innerChunk);\r\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\r\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\r\n\t\t\t\t\t\t\tif (filterFn(module)) {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\r\n\t\t\t\tqueue.add(child);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunkA first chunk\r\n\t * @param {Chunk} chunkB second chunk\r\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\r\n\t */\r\n\tcompareChunks(chunkA, chunkB) {\r\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\r\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\r\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\r\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\r\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\r\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\r\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {number} total size of all modules in the chunk\r\n\t */\r\n\tgetChunkModulesSize(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\r\n\t */\r\n\tgetChunkModulesSizes(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\r\n\t */\r\n\tgetChunkRootModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {ChunkSizeOptions} options options object\r\n\t * @returns {number} total size of the chunk\r\n\t */\r\n\tgetChunkSize(chunk, options = {}) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\r\n\t\tconst chunkOverhead =\r\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\r\n\t\tconst entryChunkMultiplicator =\r\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\r\n\t\t\t\t? options.entryChunkMultiplicator\r\n\t\t\t\t: 10;\r\n\t\treturn (\r\n\t\t\tchunkOverhead +\r\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunkA chunk\r\n\t * @param {Chunk} chunkB chunk\r\n\t * @param {ChunkSizeOptions} options options object\r\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\r\n\t */\r\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\r\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\r\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\r\n\t\tconst allModules = new Set(cgcA.modules);\r\n\t\tfor (const m of cgcB.modules) allModules.add(m);\r\n\t\tlet modulesSize = getModulesSize(allModules);\r\n\t\tconst chunkOverhead =\r\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\r\n\t\tconst entryChunkMultiplicator =\r\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\r\n\t\t\t\t? options.entryChunkMultiplicator\r\n\t\t\t\t: 10;\r\n\t\treturn (\r\n\t\t\tchunkOverhead +\r\n\t\t\tmodulesSize *\r\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\r\n\t\t\t\t\t? entryChunkMultiplicator\r\n\t\t\t\t\t: 1)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunkA chunk\r\n\t * @param {Chunk} chunkB chunk\r\n\t * @returns {boolean} true, if chunks could be integrated\r\n\t */\r\n\tcanChunksBeIntegrated(chunkA, chunkB) {\r\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\r\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\r\n\r\n\t\tif (hasRuntimeA !== hasRuntimeB) {\r\n\t\t\tif (hasRuntimeA) {\r\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\r\n\t\t\t} else if (hasRuntimeB) {\r\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\r\n\t\t\t} else {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\r\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunkA the target chunk\r\n\t * @param {Chunk} chunkB the chunk to integrate\r\n\t * @returns {void}\r\n\t */\r\n\tintegrateChunks(chunkA, chunkB) {\r\n\t\t// Decide for one name (deterministic)\r\n\t\tif (chunkA.name && chunkB.name) {\r\n\t\t\tif (\r\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\r\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\r\n\t\t\t) {\r\n\t\t\t\t// When both chunks have entry modules or none have one, use\r\n\t\t\t\t// shortest name\r\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\r\n\t\t\t\t\tchunkA.name =\r\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\r\n\t\t\t\t}\r\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\r\n\t\t\t\t// Pick the name of the chunk with the entry module\r\n\t\t\t\tchunkA.name = chunkB.name;\r\n\t\t\t}\r\n\t\t} else if (chunkB.name) {\r\n\t\t\tchunkA.name = chunkB.name;\r\n\t\t}\r\n\r\n\t\t// Merge id name hints\r\n\t\tfor (const hint of chunkB.idNameHints) {\r\n\t\t\tchunkA.idNameHints.add(hint);\r\n\t\t}\r\n\r\n\t\t// Merge runtime\r\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\r\n\r\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\r\n\t\tfor (const module of this.getChunkModules(chunkB)) {\r\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\r\n\t\t\tthis.connectChunkAndModule(chunkA, module);\r\n\t\t}\r\n\r\n\t\tfor (const [module, chunkGroup] of Array.from(\r\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\r\n\t\t)) {\r\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\r\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\r\n\t\t}\r\n\r\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\r\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\r\n\t\t\tchunkA.addGroup(chunkGroup);\r\n\t\t\tchunkB.removeGroup(chunkGroup);\r\n\t\t}\r\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk to upgrade\r\n\t * @returns {void}\r\n\t */\r\n\tupgradeDependentToFullHashModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.dependentHashModules === undefined) return;\r\n\t\tif (cgc.fullHashModules === undefined) {\r\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\r\n\t\t} else {\r\n\t\t\tfor (const m of cgc.dependentHashModules) {\r\n\t\t\t\tcgc.fullHashModules.add(m);\r\n\t\t\t}\r\n\t\t\tcgc.dependentHashModules = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the checked module\r\n\t * @param {Chunk} chunk the checked chunk\r\n\t * @returns {boolean} true, if the chunk contains the module as entry\r\n\t */\r\n\tisEntryModuleInChunk(module, chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.entryModules.has(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {Module} module the entry module\r\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\r\n\t * @returns {void}\r\n\t */\r\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgm.entryInChunks === undefined) {\r\n\t\t\tcgm.entryInChunks = new Set();\r\n\t\t}\r\n\t\tcgm.entryInChunks.add(chunk);\r\n\t\tcgc.entryModules.set(module, entrypoint);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {RuntimeModule} module the runtime module\r\n\t * @returns {void}\r\n\t */\r\n\tconnectChunkAndRuntimeModule(chunk, module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgm.runtimeInChunks === undefined) {\r\n\t\t\tcgm.runtimeInChunks = new Set();\r\n\t\t}\r\n\t\tcgm.runtimeInChunks.add(chunk);\r\n\t\tcgc.runtimeModules.add(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {RuntimeModule} module the module that require a full hash\r\n\t * @returns {void}\r\n\t */\r\n\taddFullHashModuleToChunk(chunk, module) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\r\n\t\tcgc.fullHashModules.add(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {RuntimeModule} module the module that require a full hash\r\n\t * @returns {void}\r\n\t */\r\n\taddDependentHashModuleToChunk(chunk, module) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tif (cgc.dependentHashModules === undefined)\r\n\t\t\tcgc.dependentHashModules = new Set();\r\n\t\tcgc.dependentHashModules.add(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {Module} module the entry module\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectChunkAndEntryModule(chunk, module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tcgm.entryInChunks.delete(chunk);\r\n\t\tif (cgm.entryInChunks.size === 0) {\r\n\t\t\tcgm.entryInChunks = undefined;\r\n\t\t}\r\n\t\tcgc.entryModules.delete(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the new chunk\r\n\t * @param {RuntimeModule} module the runtime module\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tcgm.runtimeInChunks.delete(chunk);\r\n\t\tif (cgm.runtimeInChunks.size === 0) {\r\n\t\t\tcgm.runtimeInChunks = undefined;\r\n\t\t}\r\n\t\tcgc.runtimeModules.delete(module);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the entry module, it will no longer be entry\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectEntryModule(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tfor (const chunk of cgm.entryInChunks) {\r\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\t\tcgc.entryModules.delete(module);\r\n\t\t}\r\n\t\tcgm.entryInChunks = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectEntries(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tfor (const module of cgc.entryModules.keys()) {\r\n\t\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\t\tcgm.entryInChunks.delete(chunk);\r\n\t\t\tif (cgm.entryInChunks.size === 0) {\r\n\t\t\t\tcgm.entryInChunks = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcgc.entryModules.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {number} the amount of entry modules in chunk\r\n\t */\r\n\tgetNumberOfEntryModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.entryModules.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {number} the amount of entry modules in chunk\r\n\t */\r\n\tgetNumberOfRuntimeModules(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.runtimeModules.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\r\n\t */\r\n\tgetChunkEntryModulesIterable(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.entryModules.keys();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<Chunk>} iterable of chunks\r\n\t */\r\n\tgetChunkEntryDependentChunksIterable(chunk) {\r\n\t\t/** @type {Set<Chunk>} */\r\n\t\tconst set = new Set();\r\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\r\n\t\t\tif (chunkGroup instanceof Entrypoint) {\r\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\r\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\r\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\r\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\r\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\r\n\t\t\t\t\t\t\tset.add(c);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn set;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {boolean} true, when it has dependent chunks\r\n\t */\r\n\thasChunkEntryDependentChunks(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\r\n\t\t\tfor (const c of chunkGroup.chunks) {\r\n\t\t\t\tif (c !== chunk) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\r\n\t */\r\n\tgetChunkRuntimeModulesIterable(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.runtimeModules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {RuntimeModule[]} array of modules in order of execution\r\n\t */\r\n\tgetChunkRuntimeModulesInOrder(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst array = Array.from(cgc.runtimeModules);\r\n\t\tarray.sort(\r\n\t\t\tconcatComparators(\r\n\t\t\t\tcompareSelect(\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\r\n\t\t\t\t\t * @returns {number=} stage\r\n\t\t\t\t\t */\r\n\t\t\t\t\tr => r.stage,\r\n\t\t\t\t\tcompareIds\r\n\t\t\t\t),\r\n\t\t\t\tcompareModulesByIdentifier\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn array;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\r\n\t */\r\n\tgetChunkFullHashModulesIterable(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.fullHashModules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\r\n\t */\r\n\tgetChunkFullHashModulesSet(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.fullHashModules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\r\n\t */\r\n\tgetChunkDependentHashModulesIterable(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.dependentHashModules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\r\n\t */\r\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.entryModules;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {AsyncDependenciesBlock} depBlock the async block\r\n\t * @returns {ChunkGroup} the chunk group\r\n\t */\r\n\tgetBlockChunkGroup(depBlock) {\r\n\t\treturn this._blockChunkGroups.get(depBlock);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {AsyncDependenciesBlock} depBlock the async block\r\n\t * @param {ChunkGroup} chunkGroup the chunk group\r\n\t * @returns {void}\r\n\t */\r\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\r\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\r\n\t\tchunkGroup.addBlock(depBlock);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGroup} chunkGroup the chunk group\r\n\t * @returns {void}\r\n\t */\r\n\tdisconnectChunkGroup(chunkGroup) {\r\n\t\tfor (const block of chunkGroup.blocksIterable) {\r\n\t\t\tthis._blockChunkGroups.delete(block);\r\n\t\t}\r\n\t\t// TODO refactor by moving blocks list into ChunkGraph\r\n\t\tchunkGroup._blocks.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {string | number} the id of the module\r\n\t */\r\n\tgetModuleId(module) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn cgm.id;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {string | number} id the id of the module\r\n\t * @returns {void}\r\n\t */\r\n\tsetModuleId(module, id) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tcgm.id = id;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} runtime runtime\r\n\t * @returns {string | number} the id of the runtime\r\n\t */\r\n\tgetRuntimeId(runtime) {\r\n\t\treturn this._runtimeIds.get(runtime);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} runtime runtime\r\n\t * @param {string | number} id the id of the runtime\r\n\t * @returns {void}\r\n\t */\r\n\tsetRuntimeId(runtime, id) {\r\n\t\tthis._runtimeIds.set(runtime, id);\r\n\t}\r\n\r\n\t/**\r\n\t * @template T\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {T} hash\r\n\t */\r\n\t_getModuleHashInfo(module, hashes, runtime) {\r\n\t\tif (!hashes) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\r\n\t\t\t\t\truntime\r\n\t\t\t\t)} (hashes not set at all)`\r\n\t\t\t);\r\n\t\t} else if (runtime === undefined) {\r\n\t\t\tconst hashInfoItems = new Set(hashes.values());\r\n\t\t\tif (hashInfoItems.size !== 1) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\r\n\t\t\t\t\t\thashes.keys(),\r\n\t\t\t\t\t\tr => runtimeToString(r)\r\n\t\t\t\t\t).join(\", \")}).\r\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn first(hashInfoItems);\r\n\t\t} else {\r\n\t\t\tconst hashInfo = hashes.get(runtime);\r\n\t\t\tif (!hashInfo) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\r\n\t\t\t\t\t\truntime\r\n\t\t\t\t\t)} (available runtimes ${Array.from(\r\n\t\t\t\t\t\thashes.keys(),\r\n\t\t\t\t\t\truntimeToString\r\n\t\t\t\t\t).join(\", \")})`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn hashInfo;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, if the module has hashes for this runtime\r\n\t */\r\n\thasModuleHashes(module, runtime) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst hashes = cgm.hashes;\r\n\t\treturn hashes && hashes.has(runtime);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {string} hash\r\n\t */\r\n\tgetModuleHash(module, runtime) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst hashes = cgm.hashes;\r\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {string} hash\r\n\t */\r\n\tgetRenderedModuleHash(module, runtime) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst hashes = cgm.hashes;\r\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @param {string} hash the full hash\r\n\t * @param {string} renderedHash the shortened hash for rendering\r\n\t * @returns {void}\r\n\t */\r\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tif (cgm.hashes === undefined) {\r\n\t\t\tcgm.hashes = new RuntimeSpecMap();\r\n\t\t}\r\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\r\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\r\n\t * @returns {void}\r\n\t */\r\n\taddModuleRuntimeRequirements(\r\n\t\tmodule,\r\n\t\truntime,\r\n\t\titems,\r\n\t\ttransferOwnership = true\r\n\t) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\r\n\t\tif (runtimeRequirementsMap === undefined) {\r\n\t\t\tconst map = new RuntimeSpecMap();\r\n\t\t\t// TODO avoid cloning item and track ownership instead\r\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\r\n\t\t\tcgm.runtimeRequirements = map;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\r\n\t\t\tif (runtimeRequirements === undefined) {\r\n\t\t\t\treturn transferOwnership ? items : new Set(items);\r\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\r\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\r\n\t\t\t\treturn runtimeRequirements;\r\n\t\t\t} else {\r\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\r\n\t\t\t\treturn items;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\r\n\t * @returns {void}\r\n\t */\r\n\taddChunkRuntimeRequirements(chunk, items) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\r\n\t\tif (runtimeRequirements === undefined) {\r\n\t\t\tcgc.runtimeRequirements = items;\r\n\t\t} else if (runtimeRequirements.size >= items.size) {\r\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\r\n\t\t} else {\r\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\r\n\t\t\tcgc.runtimeRequirements = items;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {Iterable<string>} items runtime requirements to be added\r\n\t * @returns {void}\r\n\t */\r\n\taddTreeRuntimeRequirements(chunk, items) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\r\n\t\tfor (const item of items) runtimeRequirements.add(item);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {ReadonlySet<string>} runtime requirements\r\n\t */\r\n\tgetModuleRuntimeRequirements(module, runtime) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\tconst runtimeRequirements =\r\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\r\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {ReadonlySet<string>} runtime requirements\r\n\t */\r\n\tgetChunkRuntimeRequirements(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\r\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @param {boolean} withConnections include connections\r\n\t * @returns {string} hash\r\n\t */\r\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn withConnections\r\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\r\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @param {boolean} withConnections include connections\r\n\t * @returns {bigint} hash\r\n\t */\r\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\r\n\t\tconst cgm = this._getChunkGraphModule(module);\r\n\t\treturn withConnections\r\n\t\t\t? BigInt(\r\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\r\n\t\t\t  )\r\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {bigint} hash as big int\r\n\t */\r\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\r\n\t\tif (cgm.graphHashes === undefined) {\r\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\r\n\t\t}\r\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\r\n\t\t\tconst hash = createHash(this._hashFunction);\r\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\r\n\t\t\tconst sourceTypes = this._getOverwrittenModuleSourceTypes(module);\r\n\t\t\tif (sourceTypes !== undefined) {\r\n\t\t\t\tfor (const type of sourceTypes) hash.update(type);\r\n\t\t\t}\r\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\r\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\r\n\t\t});\r\n\t\treturn graphHash;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\r\n\t * @param {Module} module the module\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {string} hash\r\n\t */\r\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\r\n\t\tif (cgm.graphHashesWithConnections === undefined) {\r\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\r\n\t\t}\r\n\t\tconst activeStateToString = state => {\r\n\t\t\tif (state === false) return \"F\";\r\n\t\t\tif (state === true) return \"T\";\r\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\r\n\t\t\tthrow new Error(\"Not implemented active state\");\r\n\t\t};\r\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\r\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\r\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\r\n\t\t\t\tcgm,\r\n\t\t\t\tmodule,\r\n\t\t\t\truntime\r\n\t\t\t).toString(16);\r\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\r\n\t\t\t/** @type {Set<Module>} */\r\n\t\t\tconst activeNamespaceModules = new Set();\r\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\r\n\t\t\tconst connectedModules = new Map();\r\n\t\t\tconst processConnection = (connection, stateInfo) => {\r\n\t\t\t\tconst module = connection.module;\r\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\r\n\t\t\t\t// cspell:word Tnamespace\r\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\r\n\t\t\t\telse {\r\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\r\n\t\t\t\t\tif (oldModule === undefined) {\r\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\r\n\t\t\t\t\t} else if (oldModule instanceof Set) {\r\n\t\t\t\t\t\toldModule.add(module);\r\n\t\t\t\t\t} else if (oldModule !== module) {\r\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\r\n\t\t\t\tfor (const connection of connections) {\r\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\r\n\t\t\t\t\tif (state === false) continue;\r\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// cspell:word Tnamespace\r\n\t\t\t\tfor (const connection of connections) {\r\n\t\t\t\t\tconst states = new Set();\r\n\t\t\t\t\tlet stateInfo = \"\";\r\n\t\t\t\t\tforEachRuntime(\r\n\t\t\t\t\t\truntime,\r\n\t\t\t\t\t\truntime => {\r\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\r\n\t\t\t\t\t\t\tstates.add(state);\r\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (states.size === 1) {\r\n\t\t\t\t\t\tconst state = first(states);\r\n\t\t\t\t\t\tif (state === false) continue;\r\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprocessConnection(connection, stateInfo);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// cspell:word Tnamespace\r\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\r\n\t\t\t\treturn graphHash;\r\n\t\t\tconst connectedModulesInOrder =\r\n\t\t\t\tconnectedModules.size > 1\r\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\r\n\t\t\t\t\t: connectedModules;\r\n\t\t\tconst hash = createHash(this._hashFunction);\r\n\t\t\tconst addModuleToHash = module => {\r\n\t\t\t\thash.update(\r\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\r\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\truntime\r\n\t\t\t\t\t).toString(16)\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t\tconst addModulesToHash = modules => {\r\n\t\t\t\tlet xor = ZERO_BIG_INT;\r\n\t\t\t\tfor (const m of modules) {\r\n\t\t\t\t\txor =\r\n\t\t\t\t\t\txor ^\r\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\r\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\r\n\t\t\t\t\t\t\tm,\r\n\t\t\t\t\t\t\truntime\r\n\t\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\thash.update(xor.toString(16));\r\n\t\t\t};\r\n\t\t\tif (activeNamespaceModules.size === 1)\r\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\r\n\t\t\telse if (activeNamespaceModules.size > 1)\r\n\t\t\t\taddModulesToHash(activeNamespaceModules);\r\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\r\n\t\t\t\thash.update(stateInfo);\r\n\t\t\t\tif (modules instanceof Set) {\r\n\t\t\t\t\taddModulesToHash(modules);\r\n\t\t\t\t} else {\r\n\t\t\t\t\taddModuleToHash(modules);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\thash.update(graphHash);\r\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {ReadonlySet<string>} runtime requirements\r\n\t */\r\n\tgetTreeRuntimeRequirements(chunk) {\r\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\r\n\t\treturn cgc.runtimeRequirementsInTree;\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {string} deprecateMessage message for the deprecation message\r\n\t * @param {string} deprecationCode code for the deprecation\r\n\t * @returns {ChunkGraph} the chunk graph\r\n\t */\r\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\r\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\r\n\t\tif (fn) return fn(module);\r\n\t\tconst newFn = util.deprecate(\r\n\t\t\t/**\r\n\t\t\t * @param {Module} module the module\r\n\t\t\t * @returns {ChunkGraph} the chunk graph\r\n\t\t\t */\r\n\t\t\tmodule => {\r\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\r\n\t\t\t\tif (!chunkGraph)\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\tdeprecateMessage +\r\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\r\n\t\t\t\t\t);\r\n\t\t\t\treturn chunkGraph;\r\n\t\t\t},\r\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\r\n\t\t\tdeprecationCode\r\n\t\t);\r\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\r\n\t\treturn newFn(module);\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @param {ChunkGraph} chunkGraph the chunk graph\r\n\t * @returns {void}\r\n\t */\r\n\tstatic setChunkGraphForModule(module, chunkGraph) {\r\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t/**\r\n\t * @param {Module} module the module\r\n\t * @returns {void}\r\n\t */\r\n\tstatic clearChunkGraphForModule(module) {\r\n\t\tchunkGraphForModuleMap.delete(module);\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {string} deprecateMessage message for the deprecation message\r\n\t * @param {string} deprecationCode code for the deprecation\r\n\t * @returns {ChunkGraph} the chunk graph\r\n\t */\r\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\r\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\r\n\t\tif (fn) return fn(chunk);\r\n\t\tconst newFn = util.deprecate(\r\n\t\t\t/**\r\n\t\t\t * @param {Chunk} chunk the chunk\r\n\t\t\t * @returns {ChunkGraph} the chunk graph\r\n\t\t\t */\r\n\t\t\tchunk => {\r\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\r\n\t\t\t\tif (!chunkGraph)\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\tdeprecateMessage +\r\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\r\n\t\t\t\t\t);\r\n\t\t\t\treturn chunkGraph;\r\n\t\t\t},\r\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\r\n\t\t\tdeprecationCode\r\n\t\t);\r\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\r\n\t\treturn newFn(chunk);\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @param {ChunkGraph} chunkGraph the chunk graph\r\n\t * @returns {void}\r\n\t */\r\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\r\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\r\n\t}\r\n\r\n\t// TODO remove in webpack 6\r\n\t/**\r\n\t * @param {Chunk} chunk the chunk\r\n\t * @returns {void}\r\n\t */\r\n\tstatic clearChunkGraphForChunk(chunk) {\r\n\t\tchunkGraphForChunkMap.delete(chunk);\r\n\t}\r\n}\r\n\r\n// TODO remove in webpack 6\r\n/** @type {WeakMap<Module, ChunkGraph>} */\r\nconst chunkGraphForModuleMap = new WeakMap();\r\n\r\n// TODO remove in webpack 6\r\n/** @type {WeakMap<Chunk, ChunkGraph>} */\r\nconst chunkGraphForChunkMap = new WeakMap();\r\n\r\n// TODO remove in webpack 6\r\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\r\nconst deprecateGetChunkGraphForModuleMap = new Map();\r\n\r\n// TODO remove in webpack 6\r\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\r\nconst deprecateGetChunkGraphForChunkMap = new Map();\r\n\r\nmodule.exports = ChunkGraph;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}