{"ast":null,"code":"/*!\r\n * Module dependencies.\r\n */\n\n'use strict';\n\nconst Readable = require('stream').Readable;\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst helpers = require('../queryhelpers');\nconst immediate = require('../helpers/immediate');\nconst util = require('util');\n\n/**\r\n * A QueryCursor is a concurrency primitive for processing query results\r\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\r\n * in addition to several other mechanisms for loading documents from MongoDB\r\n * one at a time.\r\n *\r\n * QueryCursors execute the model's pre `find` hooks before loading any documents\r\n * from MongoDB, and the model's post `find` hooks after loading each document.\r\n *\r\n * Unless you're an advanced user, do **not** instantiate this class directly.\r\n * Use [`Query#cursor()`](/docs/api/query.html#query_Query-cursor) instead.\r\n *\r\n * @param {Query} query\r\n * @param {Object} options query options passed to `.find()`\r\n * @inherits Readable\r\n * @event `cursor`: Emitted when the cursor is created\r\n * @event `error`: Emitted when an error occurred\r\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\r\n * @event `end`: Emitted when the stream is exhausted\r\n * @api public\r\n */\n\nfunction QueryCursor(query, options) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, {\n    autoDestroy: true,\n    objectMode: true\n  });\n  this.cursor = null;\n  this.query = query;\n  const _this = this;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = options || {};\n  model.hooks.execPre('find', query, err => {\n    if (err != null) {\n      _this._markError(err);\n      _this.listeners('error').length > 0 && _this.emit('error', err);\n      return;\n    }\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      this.options.cursor = options.cursor || {};\n      this.options.cursor.batchSize = options.batchSize;\n\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n    model.collection.find(query._conditions, this.options, (err, cursor) => {\n      if (err != null) {\n        _this._markError(err);\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n        return;\n      }\n      if (_this._error) {\n        cursor.close(function () {});\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n      }\n      _this.cursor = cursor;\n      _this.emit('cursor', cursor);\n    });\n  });\n}\nutil.inherits(QueryCursor, Readable);\n\n/**\r\n * Necessary to satisfy the Readable API\r\n * @method _read\r\n * @memberOf QueryCursor\r\n * @instance\r\n * @api private\r\n */\n\nQueryCursor.prototype._read = function () {\n  const _this = this;\n  _next(this, function (error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function (error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\n/**\r\n * Registers a transform function which subsequently maps documents retrieved\r\n * via the streams interface or `.next()`\r\n *\r\n * #### Example:\r\n *\r\n *     // Map documents returned by `data` events\r\n *     Thing.\r\n *       find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *        doc.foo = \"bar\";\r\n *        return doc;\r\n *       })\r\n *       on('data', function(doc) { console.log(doc.foo); });\r\n *\r\n *     // Or map documents returned by `.next()`\r\n *     const cursor = Thing.find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *         doc.foo = \"bar\";\r\n *         return doc;\r\n *       });\r\n *     cursor.next(function(error, doc) {\r\n *       console.log(doc.foo);\r\n *     });\r\n *\r\n * @param {Function} fn\r\n * @return {QueryCursor}\r\n * @memberOf QueryCursor\r\n * @api public\r\n * @method map\r\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function (fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\r\n * Marks this cursor as errored\r\n * @method _markError\r\n * @memberOf QueryCursor\r\n * @instance\r\n * @api private\r\n */\n\nQueryCursor.prototype._markError = function (error) {\n  this._error = error;\n  return this;\n};\n\n/**\r\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\r\n * `next()` will error.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method close\r\n * @emits close\r\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\r\n */\n\nQueryCursor.prototype.close = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n      this.emit('close');\n      cb(null);\n    });\n  }, this.model.events);\n};\n\n/**\r\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\r\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\r\n * if the resultant data has already been retrieved by this cursor.\r\n *\r\n * @return {AggregationCursor} this\r\n * @api public\r\n * @method rewind\r\n */\n\nQueryCursor.prototype.rewind = function () {\n  const _this = this;\n  _waitForCursor(this, function () {\n    _this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\r\n * Get the next document from this cursor. Will return `null` when there are\r\n * no documents left.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method next\r\n */\n\nQueryCursor.prototype.next = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    _next(this, function (error, doc) {\n      if (error) {\n        return cb(error);\n      }\n      cb(null, doc);\n    });\n  }, this.model.events);\n};\n\n/**\r\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\r\n * will wait for the promise to resolve before iterating on to the next one.\r\n * Returns a promise that resolves when done.\r\n *\r\n * #### Example:\r\n *\r\n *     // Iterate over documents asynchronously\r\n *     Thing.\r\n *       find({ name: /^hello/ }).\r\n *       cursor().\r\n *       eachAsync(async function (doc, i) {\r\n *         doc.foo = doc.bar + i;\r\n *         await doc.save();\r\n *       })\r\n *\r\n * @param {Function} fn\r\n * @param {Object} [options]\r\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\r\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\r\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\r\n * @param {Function} [callback] executed when all docs have been processed\r\n * @return {Promise}\r\n * @api public\r\n * @method eachAsync\r\n */\n\nQueryCursor.prototype.eachAsync = function (fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n  return eachAsync(function (cb) {\n    return _next(_this, cb);\n  }, fn, opts, callback);\n};\n\n/**\r\n * The `options` passed in to the `QueryCursor` constructor.\r\n *\r\n * @api public\r\n * @property options\r\n */\n\nQueryCursor.prototype.options;\n\n/**\r\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\r\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\r\n *\r\n * @param {String} flag\r\n * @param {Boolean} value\r\n * @return {AggregationCursor} this\r\n * @api public\r\n * @method addCursorFlag\r\n */\n\nQueryCursor.prototype.addCursorFlag = function (flag, value) {\n  const _this = this;\n  _waitForCursor(this, function () {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nQueryCursor.prototype.transformNull = function (val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nQueryCursor.prototype._transformForAsyncIterator = function () {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/**\r\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\r\n * You do not need to call this function explicitly, the JavaScript runtime\r\n * will call it for you.\r\n *\r\n * #### Example:\r\n *\r\n *     // Works without using `cursor()`\r\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n *     // Can also use `cursor()`\r\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n * Node.js 10.x supports async iterators natively without any flags. You can\r\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\r\n *\r\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\r\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\r\n * support async iterators.\r\n *\r\n * @method Symbol.asyncIterator\r\n * @memberOf QueryCursor\r\n * @instance\r\n * @api public\r\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function () {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? {\n    done: true\n  } : {\n    value: doc,\n    done: false\n  };\n}\n\n/**\r\n * Get the next doc from the underlying cursor and mongooseify it\r\n * (populate, etc.)\r\n * @param {Any} ctx\r\n * @param {Function} cb\r\n * @api private\r\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function (err, doc) {\n      if (err || doc === null && !ctx._mongooseOptions.transformNull) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function (doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n  if (ctx._error) {\n    return immediate(function () {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        return ctx.cursor.next(_onNext.bind({\n          ctx,\n          callback\n        }));\n      }\n    } else {\n      return ctx.cursor.next(function (error, doc) {\n        if (error) {\n          return callback(error);\n        }\n        if (!doc) {\n          return callback(null, null);\n        }\n        if (!ctx.query._mongooseOptions.populate) {\n          return _nextDoc(ctx, doc, null, callback);\n        }\n        ctx.query.model.populate(doc, ctx._pop, function (err, doc) {\n          if (err) {\n            return callback(err);\n          }\n          return _nextDoc(ctx, doc, ctx._pop, callback);\n        });\n      });\n    }\n  } else {\n    ctx.once('error', cb);\n    ctx.once('cursor', function (cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n  this.ctx._batchDocs.push(doc);\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));\n    }\n    this.ctx.cursor.next(_onNext.bind(this));\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  const _this = this;\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function (err) {\n    if (err) {\n      return _this.callback(err);\n    }\n    _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);\n  });\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  }\n  const {\n    model,\n    _fields,\n    _userProvidedFields,\n    options\n  } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  });\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function (cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\nmodule.exports = QueryCursor;","map":{"version":3,"names":["Readable","require","promiseOrCallback","eachAsync","helpers","immediate","util","QueryCursor","query","options","call","autoDestroy","objectMode","cursor","_this","model","_mongooseOptions","_transforms","hooks","execPre","err","_markError","listeners","length","emit","concat","slice","transform","push","batchSize","_populateBatchSize","Math","min","collection","find","_conditions","_error","close","inherits","prototype","_read","_next","error","doc","Object","defineProperty","value","fn","enumerable","configurable","writable","callback","cb","events","rewind","_waitForCursor","next","opts","addCursorFlag","flag","transformNull","val","arguments","_transformForAsyncIterator","indexOf","map","Symbol","asyncIterator","done","ctx","reduce","populate","_pop","preparePopulationOptionsMQ","__noPromise","_batchDocs","_nextDoc","shift","_batchExhausted","_onNext","bind","once","removeListener","_populateBatch","pop","lean","execPost","_fields","_userProvidedFields","createModelAndInit","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/cursor/QueryCursor.js"],"sourcesContent":["/*!\r\n * Module dependencies.\r\n */\r\n\r\n'use strict';\r\n\r\nconst Readable = require('stream').Readable;\r\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\r\nconst eachAsync = require('../helpers/cursor/eachAsync');\r\nconst helpers = require('../queryhelpers');\r\nconst immediate = require('../helpers/immediate');\r\nconst util = require('util');\r\n\r\n/**\r\n * A QueryCursor is a concurrency primitive for processing query results\r\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\r\n * in addition to several other mechanisms for loading documents from MongoDB\r\n * one at a time.\r\n *\r\n * QueryCursors execute the model's pre `find` hooks before loading any documents\r\n * from MongoDB, and the model's post `find` hooks after loading each document.\r\n *\r\n * Unless you're an advanced user, do **not** instantiate this class directly.\r\n * Use [`Query#cursor()`](/docs/api/query.html#query_Query-cursor) instead.\r\n *\r\n * @param {Query} query\r\n * @param {Object} options query options passed to `.find()`\r\n * @inherits Readable\r\n * @event `cursor`: Emitted when the cursor is created\r\n * @event `error`: Emitted when an error occurred\r\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\r\n * @event `end`: Emitted when the stream is exhausted\r\n * @api public\r\n */\r\n\r\nfunction QueryCursor(query, options) {\r\n  // set autoDestroy=true because on node 12 it's by default false\r\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\r\n  Readable.call(this, { autoDestroy: true, objectMode: true });\r\n\r\n  this.cursor = null;\r\n  this.query = query;\r\n  const _this = this;\r\n  const model = query.model;\r\n  this._mongooseOptions = {};\r\n  this._transforms = [];\r\n  this.model = model;\r\n  this.options = options || {};\r\n\r\n  model.hooks.execPre('find', query, (err) => {\r\n    if (err != null) {\r\n      _this._markError(err);\r\n      _this.listeners('error').length > 0 && _this.emit('error', err);\r\n      return;\r\n    }\r\n    this._transforms = this._transforms.concat(query._transforms.slice());\r\n    if (this.options.transform) {\r\n      this._transforms.push(options.transform);\r\n    }\r\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\r\n    // `batchSize` option doesn't work.\r\n    if (this.options.batchSize) {\r\n      this.options.cursor = options.cursor || {};\r\n      this.options.cursor.batchSize = options.batchSize;\r\n\r\n      // Max out the number of documents we'll populate in parallel at 5000.\r\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\r\n    }\r\n    model.collection.find(query._conditions, this.options, (err, cursor) => {\r\n      if (err != null) {\r\n        _this._markError(err);\r\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\r\n        return;\r\n      }\r\n\r\n      if (_this._error) {\r\n        cursor.close(function() {});\r\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\r\n      }\r\n      _this.cursor = cursor;\r\n      _this.emit('cursor', cursor);\r\n    });\r\n  });\r\n}\r\n\r\nutil.inherits(QueryCursor, Readable);\r\n\r\n/**\r\n * Necessary to satisfy the Readable API\r\n * @method _read\r\n * @memberOf QueryCursor\r\n * @instance\r\n * @api private\r\n */\r\n\r\nQueryCursor.prototype._read = function() {\r\n  const _this = this;\r\n  _next(this, function(error, doc) {\r\n    if (error) {\r\n      return _this.emit('error', error);\r\n    }\r\n    if (!doc) {\r\n      _this.push(null);\r\n      _this.cursor.close(function(error) {\r\n        if (error) {\r\n          return _this.emit('error', error);\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    _this.push(doc);\r\n  });\r\n};\r\n\r\n/**\r\n * Registers a transform function which subsequently maps documents retrieved\r\n * via the streams interface or `.next()`\r\n *\r\n * #### Example:\r\n *\r\n *     // Map documents returned by `data` events\r\n *     Thing.\r\n *       find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *        doc.foo = \"bar\";\r\n *        return doc;\r\n *       })\r\n *       on('data', function(doc) { console.log(doc.foo); });\r\n *\r\n *     // Or map documents returned by `.next()`\r\n *     const cursor = Thing.find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *         doc.foo = \"bar\";\r\n *         return doc;\r\n *       });\r\n *     cursor.next(function(error, doc) {\r\n *       console.log(doc.foo);\r\n *     });\r\n *\r\n * @param {Function} fn\r\n * @return {QueryCursor}\r\n * @memberOf QueryCursor\r\n * @api public\r\n * @method map\r\n */\r\n\r\nObject.defineProperty(QueryCursor.prototype, 'map', {\r\n  value: function(fn) {\r\n    this._transforms.push(fn);\r\n    return this;\r\n  },\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true\r\n});\r\n\r\n/**\r\n * Marks this cursor as errored\r\n * @method _markError\r\n * @memberOf QueryCursor\r\n * @instance\r\n * @api private\r\n */\r\n\r\nQueryCursor.prototype._markError = function(error) {\r\n  this._error = error;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\r\n * `next()` will error.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method close\r\n * @emits close\r\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\r\n */\r\n\r\nQueryCursor.prototype.close = function(callback) {\r\n  return promiseOrCallback(callback, cb => {\r\n    this.cursor.close(error => {\r\n      if (error) {\r\n        cb(error);\r\n        return this.listeners('error').length > 0 && this.emit('error', error);\r\n      }\r\n      this.emit('close');\r\n      cb(null);\r\n    });\r\n  }, this.model.events);\r\n};\r\n\r\n/**\r\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\r\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\r\n * if the resultant data has already been retrieved by this cursor.\r\n *\r\n * @return {AggregationCursor} this\r\n * @api public\r\n * @method rewind\r\n */\r\n\r\nQueryCursor.prototype.rewind = function() {\r\n  const _this = this;\r\n  _waitForCursor(this, function() {\r\n    _this.cursor.rewind();\r\n  });\r\n  return this;\r\n};\r\n\r\n/**\r\n * Get the next document from this cursor. Will return `null` when there are\r\n * no documents left.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method next\r\n */\r\n\r\nQueryCursor.prototype.next = function(callback) {\r\n  return promiseOrCallback(callback, cb => {\r\n    _next(this, function(error, doc) {\r\n      if (error) {\r\n        return cb(error);\r\n      }\r\n      cb(null, doc);\r\n    });\r\n  }, this.model.events);\r\n};\r\n\r\n/**\r\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\r\n * will wait for the promise to resolve before iterating on to the next one.\r\n * Returns a promise that resolves when done.\r\n *\r\n * #### Example:\r\n *\r\n *     // Iterate over documents asynchronously\r\n *     Thing.\r\n *       find({ name: /^hello/ }).\r\n *       cursor().\r\n *       eachAsync(async function (doc, i) {\r\n *         doc.foo = doc.bar + i;\r\n *         await doc.save();\r\n *       })\r\n *\r\n * @param {Function} fn\r\n * @param {Object} [options]\r\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\r\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\r\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\r\n * @param {Function} [callback] executed when all docs have been processed\r\n * @return {Promise}\r\n * @api public\r\n * @method eachAsync\r\n */\r\n\r\nQueryCursor.prototype.eachAsync = function(fn, opts, callback) {\r\n  const _this = this;\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = opts || {};\r\n\r\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\r\n};\r\n\r\n/**\r\n * The `options` passed in to the `QueryCursor` constructor.\r\n *\r\n * @api public\r\n * @property options\r\n */\r\n\r\nQueryCursor.prototype.options;\r\n\r\n/**\r\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\r\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\r\n *\r\n * @param {String} flag\r\n * @param {Boolean} value\r\n * @return {AggregationCursor} this\r\n * @api public\r\n * @method addCursorFlag\r\n */\r\n\r\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\r\n  const _this = this;\r\n  _waitForCursor(this, function() {\r\n    _this.cursor.addCursorFlag(flag, value);\r\n  });\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nQueryCursor.prototype.transformNull = function(val) {\r\n  if (arguments.length === 0) {\r\n    val = true;\r\n  }\r\n  this._mongooseOptions.transformNull = val;\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nQueryCursor.prototype._transformForAsyncIterator = function() {\r\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\r\n    this.map(_transformForAsyncIterator);\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\r\n * You do not need to call this function explicitly, the JavaScript runtime\r\n * will call it for you.\r\n *\r\n * #### Example:\r\n *\r\n *     // Works without using `cursor()`\r\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n *     // Can also use `cursor()`\r\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n * Node.js 10.x supports async iterators natively without any flags. You can\r\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\r\n *\r\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\r\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\r\n * support async iterators.\r\n *\r\n * @method Symbol.asyncIterator\r\n * @memberOf QueryCursor\r\n * @instance\r\n * @api public\r\n */\r\n\r\nif (Symbol.asyncIterator != null) {\r\n  QueryCursor.prototype[Symbol.asyncIterator] = function() {\r\n    return this.transformNull()._transformForAsyncIterator();\r\n  };\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _transformForAsyncIterator(doc) {\r\n  return doc == null ? { done: true } : { value: doc, done: false };\r\n}\r\n\r\n/**\r\n * Get the next doc from the underlying cursor and mongooseify it\r\n * (populate, etc.)\r\n * @param {Any} ctx\r\n * @param {Function} cb\r\n * @api private\r\n */\r\n\r\nfunction _next(ctx, cb) {\r\n  let callback = cb;\r\n  if (ctx._transforms.length) {\r\n    callback = function(err, doc) {\r\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\r\n        return cb(err, doc);\r\n      }\r\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\r\n        return fn.call(ctx, doc);\r\n      }, doc));\r\n    };\r\n  }\r\n\r\n  if (ctx._error) {\r\n    return immediate(function() {\r\n      callback(ctx._error);\r\n    });\r\n  }\r\n\r\n  if (ctx.cursor) {\r\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\r\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\r\n        ctx.query._mongooseOptions);\r\n      ctx._pop.__noPromise = true;\r\n    }\r\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\r\n      if (ctx._batchDocs && ctx._batchDocs.length) {\r\n        // Return a cached populated doc\r\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\r\n      } else if (ctx._batchExhausted) {\r\n        // Internal cursor reported no more docs. Act the same here\r\n        return callback(null, null);\r\n      } else {\r\n        // Request as many docs as batchSize, to populate them also in batch\r\n        ctx._batchDocs = [];\r\n        return ctx.cursor.next(_onNext.bind({ ctx, callback }));\r\n      }\r\n    } else {\r\n      return ctx.cursor.next(function(error, doc) {\r\n        if (error) {\r\n          return callback(error);\r\n        }\r\n        if (!doc) {\r\n          return callback(null, null);\r\n        }\r\n\r\n        if (!ctx.query._mongooseOptions.populate) {\r\n          return _nextDoc(ctx, doc, null, callback);\r\n        }\r\n\r\n        ctx.query.model.populate(doc, ctx._pop, function(err, doc) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n          return _nextDoc(ctx, doc, ctx._pop, callback);\r\n        });\r\n      });\r\n    }\r\n  } else {\r\n    ctx.once('error', cb);\r\n\r\n    ctx.once('cursor', function(cursor) {\r\n      ctx.removeListener('error', cb);\r\n      if (cursor == null) {\r\n        return;\r\n      }\r\n      _next(ctx, cb);\r\n    });\r\n  }\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _onNext(error, doc) {\r\n  if (error) {\r\n    return this.callback(error);\r\n  }\r\n  if (!doc) {\r\n    this.ctx._batchExhausted = true;\r\n    return _populateBatch.call(this);\r\n  }\r\n\r\n  this.ctx._batchDocs.push(doc);\r\n\r\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\r\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\r\n    // cause a stack overflow. So make sure we clear the stack regularly.\r\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\r\n      return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));\r\n    }\r\n    this.ctx.cursor.next(_onNext.bind(this));\r\n  } else {\r\n    _populateBatch.call(this);\r\n  }\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _populateBatch() {\r\n  if (!this.ctx._batchDocs.length) {\r\n    return this.callback(null, null);\r\n  }\r\n  const _this = this;\r\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {\r\n    if (err) {\r\n      return _this.callback(err);\r\n    }\r\n\r\n    _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);\r\n  });\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _nextDoc(ctx, doc, pop, callback) {\r\n  if (ctx.query._mongooseOptions.lean) {\r\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\r\n      if (err != null) {\r\n        return callback(err);\r\n      }\r\n      callback(null, doc);\r\n    });\r\n  }\r\n\r\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\r\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\r\n    if (err != null) {\r\n      return callback(err);\r\n    }\r\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\r\n      if (err != null) {\r\n        return callback(err);\r\n      }\r\n      callback(null, doc);\r\n    });\r\n  });\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _waitForCursor(ctx, cb) {\r\n  if (ctx.cursor) {\r\n    return cb();\r\n  }\r\n  ctx.once('cursor', function(cursor) {\r\n    if (cursor == null) {\r\n      return;\r\n    }\r\n    cb();\r\n  });\r\n}\r\n\r\nmodule.exports = QueryCursor;\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAACD,QAAQ;AAC3C,MAAME,iBAAiB,GAAGD,OAAO,CAAC,8BAA8B,CAAC;AACjE,MAAME,SAAS,GAAGF,OAAO,CAAC,6BAA6B,CAAC;AACxD,MAAMG,OAAO,GAAGH,OAAO,CAAC,iBAAiB,CAAC;AAC1C,MAAMI,SAAS,GAAGJ,OAAO,CAAC,sBAAsB,CAAC;AACjD,MAAMK,IAAI,GAAGL,OAAO,CAAC,MAAM,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASM,WAAW,CAACC,KAAK,EAAEC,OAAO,EAAE;EACnC;EACA;EACAT,QAAQ,CAACU,IAAI,CAAC,IAAI,EAAE;IAAEC,WAAW,EAAE,IAAI;IAAEC,UAAU,EAAE;EAAK,CAAC,CAAC;EAE5D,IAAI,CAACC,MAAM,GAAG,IAAI;EAClB,IAAI,CAACL,KAAK,GAAGA,KAAK;EAClB,MAAMM,KAAK,GAAG,IAAI;EAClB,MAAMC,KAAK,GAAGP,KAAK,CAACO,KAAK;EACzB,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAAC;EAC1B,IAAI,CAACC,WAAW,GAAG,EAAE;EACrB,IAAI,CAACF,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACN,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAE5BM,KAAK,CAACG,KAAK,CAACC,OAAO,CAAC,MAAM,EAAEX,KAAK,EAAGY,GAAG,IAAK;IAC1C,IAAIA,GAAG,IAAI,IAAI,EAAE;MACfN,KAAK,CAACO,UAAU,CAACD,GAAG,CAAC;MACrBN,KAAK,CAACQ,SAAS,CAAC,OAAO,CAAC,CAACC,MAAM,GAAG,CAAC,IAAIT,KAAK,CAACU,IAAI,CAAC,OAAO,EAAEJ,GAAG,CAAC;MAC/D;IACF;IACA,IAAI,CAACH,WAAW,GAAG,IAAI,CAACA,WAAW,CAACQ,MAAM,CAACjB,KAAK,CAACS,WAAW,CAACS,KAAK,EAAE,CAAC;IACrE,IAAI,IAAI,CAACjB,OAAO,CAACkB,SAAS,EAAE;MAC1B,IAAI,CAACV,WAAW,CAACW,IAAI,CAACnB,OAAO,CAACkB,SAAS,CAAC;IAC1C;IACA;IACA;IACA,IAAI,IAAI,CAAClB,OAAO,CAACoB,SAAS,EAAE;MAC1B,IAAI,CAACpB,OAAO,CAACI,MAAM,GAAGJ,OAAO,CAACI,MAAM,IAAI,CAAC,CAAC;MAC1C,IAAI,CAACJ,OAAO,CAACI,MAAM,CAACgB,SAAS,GAAGpB,OAAO,CAACoB,SAAS;;MAEjD;MACA,IAAI,CAACpB,OAAO,CAACqB,kBAAkB,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACvB,OAAO,CAACoB,SAAS,EAAE,IAAI,CAAC;IAC1E;IACAd,KAAK,CAACkB,UAAU,CAACC,IAAI,CAAC1B,KAAK,CAAC2B,WAAW,EAAE,IAAI,CAAC1B,OAAO,EAAE,CAACW,GAAG,EAAEP,MAAM,KAAK;MACtE,IAAIO,GAAG,IAAI,IAAI,EAAE;QACfN,KAAK,CAACO,UAAU,CAACD,GAAG,CAAC;QACrBN,KAAK,CAACQ,SAAS,CAAC,OAAO,CAAC,CAACC,MAAM,GAAG,CAAC,IAAIT,KAAK,CAACU,IAAI,CAAC,OAAO,EAAEV,KAAK,CAACsB,MAAM,CAAC;QACxE;MACF;MAEA,IAAItB,KAAK,CAACsB,MAAM,EAAE;QAChBvB,MAAM,CAACwB,KAAK,CAAC,YAAW,CAAC,CAAC,CAAC;QAC3BvB,KAAK,CAACQ,SAAS,CAAC,OAAO,CAAC,CAACC,MAAM,GAAG,CAAC,IAAIT,KAAK,CAACU,IAAI,CAAC,OAAO,EAAEV,KAAK,CAACsB,MAAM,CAAC;MAC1E;MACAtB,KAAK,CAACD,MAAM,GAAGA,MAAM;MACrBC,KAAK,CAACU,IAAI,CAAC,QAAQ,EAAEX,MAAM,CAAC;IAC9B,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEAP,IAAI,CAACgC,QAAQ,CAAC/B,WAAW,EAAEP,QAAQ,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAO,WAAW,CAACgC,SAAS,CAACC,KAAK,GAAG,YAAW;EACvC,MAAM1B,KAAK,GAAG,IAAI;EAClB2B,KAAK,CAAC,IAAI,EAAE,UAASC,KAAK,EAAEC,GAAG,EAAE;IAC/B,IAAID,KAAK,EAAE;MACT,OAAO5B,KAAK,CAACU,IAAI,CAAC,OAAO,EAAEkB,KAAK,CAAC;IACnC;IACA,IAAI,CAACC,GAAG,EAAE;MACR7B,KAAK,CAACc,IAAI,CAAC,IAAI,CAAC;MAChBd,KAAK,CAACD,MAAM,CAACwB,KAAK,CAAC,UAASK,KAAK,EAAE;QACjC,IAAIA,KAAK,EAAE;UACT,OAAO5B,KAAK,CAACU,IAAI,CAAC,OAAO,EAAEkB,KAAK,CAAC;QACnC;MACF,CAAC,CAAC;MACF;IACF;IACA5B,KAAK,CAACc,IAAI,CAACe,GAAG,CAAC;EACjB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,cAAc,CAACtC,WAAW,CAACgC,SAAS,EAAE,KAAK,EAAE;EAClDO,KAAK,EAAE,UAASC,EAAE,EAAE;IAClB,IAAI,CAAC9B,WAAW,CAACW,IAAI,CAACmB,EAAE,CAAC;IACzB,OAAO,IAAI;EACb,CAAC;EACDC,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE,IAAI;EAClBC,QAAQ,EAAE;AACZ,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3C,WAAW,CAACgC,SAAS,CAAClB,UAAU,GAAG,UAASqB,KAAK,EAAE;EACjD,IAAI,CAACN,MAAM,GAAGM,KAAK;EACnB,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAnC,WAAW,CAACgC,SAAS,CAACF,KAAK,GAAG,UAASc,QAAQ,EAAE;EAC/C,OAAOjD,iBAAiB,CAACiD,QAAQ,EAAEC,EAAE,IAAI;IACvC,IAAI,CAACvC,MAAM,CAACwB,KAAK,CAACK,KAAK,IAAI;MACzB,IAAIA,KAAK,EAAE;QACTU,EAAE,CAACV,KAAK,CAAC;QACT,OAAO,IAAI,CAACpB,SAAS,CAAC,OAAO,CAAC,CAACC,MAAM,GAAG,CAAC,IAAI,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEkB,KAAK,CAAC;MACxE;MACA,IAAI,CAAClB,IAAI,CAAC,OAAO,CAAC;MAClB4B,EAAE,CAAC,IAAI,CAAC;IACV,CAAC,CAAC;EACJ,CAAC,EAAE,IAAI,CAACrC,KAAK,CAACsC,MAAM,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9C,WAAW,CAACgC,SAAS,CAACe,MAAM,GAAG,YAAW;EACxC,MAAMxC,KAAK,GAAG,IAAI;EAClByC,cAAc,CAAC,IAAI,EAAE,YAAW;IAC9BzC,KAAK,CAACD,MAAM,CAACyC,MAAM,EAAE;EACvB,CAAC,CAAC;EACF,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/C,WAAW,CAACgC,SAAS,CAACiB,IAAI,GAAG,UAASL,QAAQ,EAAE;EAC9C,OAAOjD,iBAAiB,CAACiD,QAAQ,EAAEC,EAAE,IAAI;IACvCX,KAAK,CAAC,IAAI,EAAE,UAASC,KAAK,EAAEC,GAAG,EAAE;MAC/B,IAAID,KAAK,EAAE;QACT,OAAOU,EAAE,CAACV,KAAK,CAAC;MAClB;MACAU,EAAE,CAAC,IAAI,EAAET,GAAG,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,EAAE,IAAI,CAAC5B,KAAK,CAACsC,MAAM,CAAC;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9C,WAAW,CAACgC,SAAS,CAACpC,SAAS,GAAG,UAAS4C,EAAE,EAAEU,IAAI,EAAEN,QAAQ,EAAE;EAC7D,MAAMrC,KAAK,GAAG,IAAI;EAClB,IAAI,OAAO2C,IAAI,KAAK,UAAU,EAAE;IAC9BN,QAAQ,GAAGM,IAAI;IACfA,IAAI,GAAG,CAAC,CAAC;EACX;EACAA,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,OAAOtD,SAAS,CAAC,UAASiD,EAAE,EAAE;IAAE,OAAOX,KAAK,CAAC3B,KAAK,EAAEsC,EAAE,CAAC;EAAE,CAAC,EAAEL,EAAE,EAAEU,IAAI,EAAEN,QAAQ,CAAC;AACjF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA5C,WAAW,CAACgC,SAAS,CAAC9B,OAAO;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAF,WAAW,CAACgC,SAAS,CAACmB,aAAa,GAAG,UAASC,IAAI,EAAEb,KAAK,EAAE;EAC1D,MAAMhC,KAAK,GAAG,IAAI;EAClByC,cAAc,CAAC,IAAI,EAAE,YAAW;IAC9BzC,KAAK,CAACD,MAAM,CAAC6C,aAAa,CAACC,IAAI,EAAEb,KAAK,CAAC;EACzC,CAAC,CAAC;EACF,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;;AAEAvC,WAAW,CAACgC,SAAS,CAACqB,aAAa,GAAG,UAASC,GAAG,EAAE;EAClD,IAAIC,SAAS,CAACvC,MAAM,KAAK,CAAC,EAAE;IAC1BsC,GAAG,GAAG,IAAI;EACZ;EACA,IAAI,CAAC7C,gBAAgB,CAAC4C,aAAa,GAAGC,GAAG;EACzC,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;;AAEAtD,WAAW,CAACgC,SAAS,CAACwB,0BAA0B,GAAG,YAAW;EAC5D,IAAI,IAAI,CAAC9C,WAAW,CAAC+C,OAAO,CAACD,0BAA0B,CAAC,KAAK,CAAC,CAAC,EAAE;IAC/D,IAAI,CAACE,GAAG,CAACF,0BAA0B,CAAC;EACtC;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIG,MAAM,CAACC,aAAa,IAAI,IAAI,EAAE;EAChC5D,WAAW,CAACgC,SAAS,CAAC2B,MAAM,CAACC,aAAa,CAAC,GAAG,YAAW;IACvD,OAAO,IAAI,CAACP,aAAa,EAAE,CAACG,0BAA0B,EAAE;EAC1D,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,SAASA,0BAA0B,CAACpB,GAAG,EAAE;EACvC,OAAOA,GAAG,IAAI,IAAI,GAAG;IAAEyB,IAAI,EAAE;EAAK,CAAC,GAAG;IAAEtB,KAAK,EAAEH,GAAG;IAAEyB,IAAI,EAAE;EAAM,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS3B,KAAK,CAAC4B,GAAG,EAAEjB,EAAE,EAAE;EACtB,IAAID,QAAQ,GAAGC,EAAE;EACjB,IAAIiB,GAAG,CAACpD,WAAW,CAACM,MAAM,EAAE;IAC1B4B,QAAQ,GAAG,UAAS/B,GAAG,EAAEuB,GAAG,EAAE;MAC5B,IAAIvB,GAAG,IAAKuB,GAAG,KAAK,IAAI,IAAI,CAAC0B,GAAG,CAACrD,gBAAgB,CAAC4C,aAAc,EAAE;QAChE,OAAOR,EAAE,CAAChC,GAAG,EAAEuB,GAAG,CAAC;MACrB;MACAS,EAAE,CAAChC,GAAG,EAAEiD,GAAG,CAACpD,WAAW,CAACqD,MAAM,CAAC,UAAS3B,GAAG,EAAEI,EAAE,EAAE;QAC/C,OAAOA,EAAE,CAACrC,IAAI,CAAC2D,GAAG,EAAE1B,GAAG,CAAC;MAC1B,CAAC,EAAEA,GAAG,CAAC,CAAC;IACV,CAAC;EACH;EAEA,IAAI0B,GAAG,CAACjC,MAAM,EAAE;IACd,OAAO/B,SAAS,CAAC,YAAW;MAC1B8C,QAAQ,CAACkB,GAAG,CAACjC,MAAM,CAAC;IACtB,CAAC,CAAC;EACJ;EAEA,IAAIiC,GAAG,CAACxD,MAAM,EAAE;IACd,IAAIwD,GAAG,CAAC7D,KAAK,CAACQ,gBAAgB,CAACuD,QAAQ,IAAI,CAACF,GAAG,CAACG,IAAI,EAAE;MACpDH,GAAG,CAACG,IAAI,GAAGpE,OAAO,CAACqE,0BAA0B,CAACJ,GAAG,CAAC7D,KAAK,EACrD6D,GAAG,CAAC7D,KAAK,CAACQ,gBAAgB,CAAC;MAC7BqD,GAAG,CAACG,IAAI,CAACE,WAAW,GAAG,IAAI;IAC7B;IACA,IAAIL,GAAG,CAAC7D,KAAK,CAACQ,gBAAgB,CAACuD,QAAQ,IAAIF,GAAG,CAAC5D,OAAO,CAACqB,kBAAkB,GAAG,CAAC,EAAE;MAC7E,IAAIuC,GAAG,CAACM,UAAU,IAAIN,GAAG,CAACM,UAAU,CAACpD,MAAM,EAAE;QAC3C;QACA,OAAOqD,QAAQ,CAACP,GAAG,EAAEA,GAAG,CAACM,UAAU,CAACE,KAAK,EAAE,EAAER,GAAG,CAACG,IAAI,EAAErB,QAAQ,CAAC;MAClE,CAAC,MAAM,IAAIkB,GAAG,CAACS,eAAe,EAAE;QAC9B;QACA,OAAO3B,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;MAC7B,CAAC,MAAM;QACL;QACAkB,GAAG,CAACM,UAAU,GAAG,EAAE;QACnB,OAAON,GAAG,CAACxD,MAAM,CAAC2C,IAAI,CAACuB,OAAO,CAACC,IAAI,CAAC;UAAEX,GAAG;UAAElB;QAAS,CAAC,CAAC,CAAC;MACzD;IACF,CAAC,MAAM;MACL,OAAOkB,GAAG,CAACxD,MAAM,CAAC2C,IAAI,CAAC,UAASd,KAAK,EAAEC,GAAG,EAAE;QAC1C,IAAID,KAAK,EAAE;UACT,OAAOS,QAAQ,CAACT,KAAK,CAAC;QACxB;QACA,IAAI,CAACC,GAAG,EAAE;UACR,OAAOQ,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;QAC7B;QAEA,IAAI,CAACkB,GAAG,CAAC7D,KAAK,CAACQ,gBAAgB,CAACuD,QAAQ,EAAE;UACxC,OAAOK,QAAQ,CAACP,GAAG,EAAE1B,GAAG,EAAE,IAAI,EAAEQ,QAAQ,CAAC;QAC3C;QAEAkB,GAAG,CAAC7D,KAAK,CAACO,KAAK,CAACwD,QAAQ,CAAC5B,GAAG,EAAE0B,GAAG,CAACG,IAAI,EAAE,UAASpD,GAAG,EAAEuB,GAAG,EAAE;UACzD,IAAIvB,GAAG,EAAE;YACP,OAAO+B,QAAQ,CAAC/B,GAAG,CAAC;UACtB;UACA,OAAOwD,QAAQ,CAACP,GAAG,EAAE1B,GAAG,EAAE0B,GAAG,CAACG,IAAI,EAAErB,QAAQ,CAAC;QAC/C,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;EACF,CAAC,MAAM;IACLkB,GAAG,CAACY,IAAI,CAAC,OAAO,EAAE7B,EAAE,CAAC;IAErBiB,GAAG,CAACY,IAAI,CAAC,QAAQ,EAAE,UAASpE,MAAM,EAAE;MAClCwD,GAAG,CAACa,cAAc,CAAC,OAAO,EAAE9B,EAAE,CAAC;MAC/B,IAAIvC,MAAM,IAAI,IAAI,EAAE;QAClB;MACF;MACA4B,KAAK,CAAC4B,GAAG,EAAEjB,EAAE,CAAC;IAChB,CAAC,CAAC;EACJ;AACF;;AAEA;AACA;AACA;;AAEA,SAAS2B,OAAO,CAACrC,KAAK,EAAEC,GAAG,EAAE;EAC3B,IAAID,KAAK,EAAE;IACT,OAAO,IAAI,CAACS,QAAQ,CAACT,KAAK,CAAC;EAC7B;EACA,IAAI,CAACC,GAAG,EAAE;IACR,IAAI,CAAC0B,GAAG,CAACS,eAAe,GAAG,IAAI;IAC/B,OAAOK,cAAc,CAACzE,IAAI,CAAC,IAAI,CAAC;EAClC;EAEA,IAAI,CAAC2D,GAAG,CAACM,UAAU,CAAC/C,IAAI,CAACe,GAAG,CAAC;EAE7B,IAAI,IAAI,CAAC0B,GAAG,CAACM,UAAU,CAACpD,MAAM,GAAG,IAAI,CAAC8C,GAAG,CAAC5D,OAAO,CAACqB,kBAAkB,EAAE;IACpE;IACA;IACA,IAAI,IAAI,CAACuC,GAAG,CAACM,UAAU,CAACpD,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC8C,GAAG,CAACM,UAAU,CAACpD,MAAM,GAAG,IAAI,KAAK,CAAC,EAAE;MAC7E,OAAOlB,SAAS,CAAC,MAAM,IAAI,CAACgE,GAAG,CAACxD,MAAM,CAAC2C,IAAI,CAACuB,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE;IACA,IAAI,CAACX,GAAG,CAACxD,MAAM,CAAC2C,IAAI,CAACuB,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EAC1C,CAAC,MAAM;IACLG,cAAc,CAACzE,IAAI,CAAC,IAAI,CAAC;EAC3B;AACF;;AAEA;AACA;AACA;;AAEA,SAASyE,cAAc,GAAG;EACxB,IAAI,CAAC,IAAI,CAACd,GAAG,CAACM,UAAU,CAACpD,MAAM,EAAE;IAC/B,OAAO,IAAI,CAAC4B,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;EAClC;EACA,MAAMrC,KAAK,GAAG,IAAI;EAClB,IAAI,CAACuD,GAAG,CAAC7D,KAAK,CAACO,KAAK,CAACwD,QAAQ,CAAC,IAAI,CAACF,GAAG,CAACM,UAAU,EAAE,IAAI,CAACN,GAAG,CAACG,IAAI,EAAE,UAASpD,GAAG,EAAE;IAC9E,IAAIA,GAAG,EAAE;MACP,OAAON,KAAK,CAACqC,QAAQ,CAAC/B,GAAG,CAAC;IAC5B;IAEAwD,QAAQ,CAAC9D,KAAK,CAACuD,GAAG,EAAEvD,KAAK,CAACuD,GAAG,CAACM,UAAU,CAACE,KAAK,EAAE,EAAE/D,KAAK,CAACuD,GAAG,CAACG,IAAI,EAAE1D,KAAK,CAACqC,QAAQ,CAAC;EACnF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;;AAEA,SAASyB,QAAQ,CAACP,GAAG,EAAE1B,GAAG,EAAEyC,GAAG,EAAEjC,QAAQ,EAAE;EACzC,IAAIkB,GAAG,CAAC7D,KAAK,CAACQ,gBAAgB,CAACqE,IAAI,EAAE;IACnC,OAAOhB,GAAG,CAACtD,KAAK,CAACG,KAAK,CAACoE,QAAQ,CAAC,MAAM,EAAEjB,GAAG,CAAC7D,KAAK,EAAE,CAAC,CAACmC,GAAG,CAAC,CAAC,EAAEvB,GAAG,IAAI;MACjE,IAAIA,GAAG,IAAI,IAAI,EAAE;QACf,OAAO+B,QAAQ,CAAC/B,GAAG,CAAC;MACtB;MACA+B,QAAQ,CAAC,IAAI,EAAER,GAAG,CAAC;IACrB,CAAC,CAAC;EACJ;EAEA,MAAM;IAAE5B,KAAK;IAAEwE,OAAO;IAAEC,mBAAmB;IAAE/E;EAAQ,CAAC,GAAG4D,GAAG,CAAC7D,KAAK;EAClEJ,OAAO,CAACqF,kBAAkB,CAAC1E,KAAK,EAAE4B,GAAG,EAAE4C,OAAO,EAAEC,mBAAmB,EAAE/E,OAAO,EAAE2E,GAAG,EAAE,CAAChE,GAAG,EAAEuB,GAAG,KAAK;IAC/F,IAAIvB,GAAG,IAAI,IAAI,EAAE;MACf,OAAO+B,QAAQ,CAAC/B,GAAG,CAAC;IACtB;IACAiD,GAAG,CAACtD,KAAK,CAACG,KAAK,CAACoE,QAAQ,CAAC,MAAM,EAAEjB,GAAG,CAAC7D,KAAK,EAAE,CAAC,CAACmC,GAAG,CAAC,CAAC,EAAEvB,GAAG,IAAI;MAC1D,IAAIA,GAAG,IAAI,IAAI,EAAE;QACf,OAAO+B,QAAQ,CAAC/B,GAAG,CAAC;MACtB;MACA+B,QAAQ,CAAC,IAAI,EAAER,GAAG,CAAC;IACrB,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;;AAEA,SAASY,cAAc,CAACc,GAAG,EAAEjB,EAAE,EAAE;EAC/B,IAAIiB,GAAG,CAACxD,MAAM,EAAE;IACd,OAAOuC,EAAE,EAAE;EACb;EACAiB,GAAG,CAACY,IAAI,CAAC,QAAQ,EAAE,UAASpE,MAAM,EAAE;IAClC,IAAIA,MAAM,IAAI,IAAI,EAAE;MAClB;IACF;IACAuC,EAAE,EAAE;EACN,CAAC,CAAC;AACJ;AAEAsC,MAAM,CAACC,OAAO,GAAGpF,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}