{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSubdocumentOptions = require('../options/SchemaSubdocumentOptions');\nconst SchemaType = require('../schematype');\nconst applyDefaults = require('../helpers/document/applyDefaults');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst utils = require('../utils');\nlet Subdocument;\nmodule.exports = SubdocumentPath;\n\n/**\r\n * Single nested subdocument SchemaType constructor.\r\n *\r\n * @param {Schema} schema\r\n * @param {String} path\r\n * @param {Object} options\r\n * @inherits SchemaType\r\n * @api public\r\n */\n\nfunction SubdocumentPath(schema, path, options) {\n  const schemaTypeIdOption = SubdocumentPath.defaultOptions && SubdocumentPath.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n  schema = handleIdOption(schema, options);\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\r\n * ignore\r\n */\n\nSubdocumentPath.prototype = Object.create(SchemaType.prototype);\nSubdocumentPath.prototype.constructor = SubdocumentPath;\nSubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\r\n * ignore\r\n */\n\nfunction _createConstructor(schema, baseClass) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    Subdocument.apply(this, arguments);\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n  schema._preCompile();\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function () {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n  return _embedded;\n}\n\n/**\r\n * Special case for when users use a common location schema to represent\r\n * locations for use with $geoWithin.\r\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\r\n *\r\n * @param {Object} val\r\n * @api private\r\n */\n\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return {\n    $geometry: this.castForQuery(val.$geometry)\n  };\n};\n\n/*!\r\n * ignore\r\n */\n\nSubdocumentPath.prototype.$conditionalHandlers.$near = SubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\nSubdocumentPath.prototype.$conditionalHandlers.$within = SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\nSubdocumentPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;\nSubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\nSubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\r\n * Casts contents\r\n *\r\n * @param {Object} value\r\n * @api private\r\n */\n\nSubdocumentPath.prototype.cast = function (val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n  const Constructor = getConstructor(this.caster, val);\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc && doc.$__ && doc.$__.selected || {};\n  const path = this.path;\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  options = Object.assign({}, options, {\n    priorDoc: priorVal\n  });\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, false, {\n      defaults: false\n    });\n    delete subdoc.$__.defaults;\n    subdoc.$init(val);\n    applyDefaults(subdoc, selected);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n  return subdoc;\n};\n\n/**\r\n * Casts contents for query\r\n *\r\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\r\n * @param {any} value\r\n * @api private\r\n */\n\nSubdocumentPath.prototype.castForQuery = function ($conditional, val, options) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n  const Constructor = getConstructor(this.caster, val);\n  const overrideStrict = options != null && options.strict != null ? options.strict : void 0;\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\r\n * Async validation on this single nested doc.\r\n *\r\n * @api private\r\n */\n\nSubdocumentPath.prototype.doValidate = function (value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, scope != null && scope.$__ != null ? scope : null);\n  }\n  if (options && options.skipSchemaValidators) {\n    if (!value) {\n      return fn(null);\n    }\n    return value.validate(fn);\n  }\n  SchemaType.prototype.doValidate.call(this, value, function (error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n    value.validate(fn);\n  }, scope, options);\n};\n\n/**\r\n * Synchronously validate this single nested doc\r\n *\r\n * @api private\r\n */\n\nSubdocumentPath.prototype.doValidateSync = function (value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\r\n * Adds a discriminator to this single nested subdocument.\r\n *\r\n * #### Example:\r\n *\r\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\r\n *     const schema = Schema({ shape: shapeSchema });\r\n *\r\n *     const singleNestedPath = parentSchema.path('shape');\r\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\r\n *\r\n * @param {String} name\r\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\r\n * @param {Object|string} [options] If string, same as `options.value`.\r\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\r\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\r\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\r\n * @see discriminators /docs/discriminators.html\r\n * @api public\r\n */\n\nSubdocumentPath.prototype.discriminator = function (name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this.caster, name, schema, value);\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n  return this.caster.discriminators[name];\n};\n\n/*!\r\n * ignore\r\n */\n\nSubdocumentPath.defaultOptions = {};\n\n/**\r\n * Sets a default option for all SubdocumentPath instances.\r\n *\r\n * #### Example:\r\n *\r\n *     // Make all numbers have option `min` equal to 0.\r\n *     mongoose.Schema.SubdocumentPath.set('required', true);\r\n *\r\n * @param {String} option The option you'd like to set the value for\r\n * @param {Any} value value for option\r\n * @return {void}\r\n * @function set\r\n * @static\r\n * @api public\r\n */\n\nSubdocumentPath.set = SchemaType.set;\n\n/*!\r\n * ignore\r\n */\n\nSubdocumentPath.prototype.toJSON = function toJSON() {\n  return {\n    path: this.path,\n    options: this.options\n  };\n};\n\n/*!\r\n * ignore\r\n */\n\nSubdocumentPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.schema, this.path, options);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};","map":{"version":3,"names":["CastError","require","EventEmitter","ObjectExpectedError","SchemaSubdocumentOptions","SchemaType","applyDefaults","$exists","castToNumber","discriminator","geospatial","getConstructor","handleIdOption","internalToObjectOptions","utils","Subdocument","module","exports","SubdocumentPath","schema","path","options","schemaTypeIdOption","defaultOptions","_id","caster","_createConstructor","prototype","$basePath","$isSingleNested","base","call","Object","create","constructor","OptionsConstructor","baseClass","_embedded","SingleNested","value","parent","$__parent","apply","arguments","$session","_preCompile","proto","$__setSchema","events","toBSON","toObject","i","methods","statics","$conditionalHandlers","$geoWithin","handle$geoWithin","val","$geometry","castForQuery","$near","$nearSphere","cast$near","$within","cast$within","$geoIntersects","cast$geoIntersects","$minDistance","$maxDistance","cast","doc","init","priorVal","Array","isArray","Constructor","subdoc","parentSelected","$__","selected","keys","reduce","obj","key","startsWith","substring","length","assign","priorDoc","defaults","$init","undefined","$conditional","handler","Error","runSetters","_applySetters","overrideStrict","strict","error","doValidate","fn","scope","skipSchemaValidators","validate","doValidateSync","schemaTypeError","validateSync","name","isPOJO","clone","instanceOfSchema","discriminators","set","toJSON","schematype","validators","slice","requiredValidator"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/schema/SubdocumentPath.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst CastError = require('../error/cast');\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst ObjectExpectedError = require('../error/objectExpected');\r\nconst SchemaSubdocumentOptions = require('../options/SchemaSubdocumentOptions');\r\nconst SchemaType = require('../schematype');\r\nconst applyDefaults = require('../helpers/document/applyDefaults');\r\nconst $exists = require('./operators/exists');\r\nconst castToNumber = require('./operators/helpers').castToNumber;\r\nconst discriminator = require('../helpers/model/discriminator');\r\nconst geospatial = require('./operators/geospatial');\r\nconst getConstructor = require('../helpers/discriminator/getConstructor');\r\nconst handleIdOption = require('../helpers/schema/handleIdOption');\r\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\r\nconst utils = require('../utils');\r\n\r\nlet Subdocument;\r\n\r\nmodule.exports = SubdocumentPath;\r\n\r\n/**\r\n * Single nested subdocument SchemaType constructor.\r\n *\r\n * @param {Schema} schema\r\n * @param {String} path\r\n * @param {Object} options\r\n * @inherits SchemaType\r\n * @api public\r\n */\r\n\r\nfunction SubdocumentPath(schema, path, options) {\r\n  const schemaTypeIdOption = SubdocumentPath.defaultOptions &&\r\n    SubdocumentPath.defaultOptions._id;\r\n  if (schemaTypeIdOption != null) {\r\n    options = options || {};\r\n    options._id = schemaTypeIdOption;\r\n  }\r\n\r\n  schema = handleIdOption(schema, options);\r\n\r\n  this.caster = _createConstructor(schema);\r\n  this.caster.path = path;\r\n  this.caster.prototype.$basePath = path;\r\n  this.schema = schema;\r\n  this.$isSingleNested = true;\r\n  this.base = schema.base;\r\n  SchemaType.call(this, path, options, 'Embedded');\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSubdocumentPath.prototype = Object.create(SchemaType.prototype);\r\nSubdocumentPath.prototype.constructor = SubdocumentPath;\r\nSubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _createConstructor(schema, baseClass) {\r\n  // lazy load\r\n  Subdocument || (Subdocument = require('../types/subdocument'));\r\n\r\n  const _embedded = function SingleNested(value, path, parent) {\r\n    this.$__parent = parent;\r\n    Subdocument.apply(this, arguments);\r\n\r\n    if (parent == null) {\r\n      return;\r\n    }\r\n    this.$session(parent.$session());\r\n  };\r\n\r\n  schema._preCompile();\r\n\r\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\r\n  _embedded.prototype = Object.create(proto);\r\n  _embedded.prototype.$__setSchema(schema);\r\n  _embedded.prototype.constructor = _embedded;\r\n  _embedded.schema = schema;\r\n  _embedded.$isSingleNested = true;\r\n  _embedded.events = new EventEmitter();\r\n  _embedded.prototype.toBSON = function() {\r\n    return this.toObject(internalToObjectOptions);\r\n  };\r\n\r\n  // apply methods\r\n  for (const i in schema.methods) {\r\n    _embedded.prototype[i] = schema.methods[i];\r\n  }\r\n\r\n  // apply statics\r\n  for (const i in schema.statics) {\r\n    _embedded[i] = schema.statics[i];\r\n  }\r\n\r\n  for (const i in EventEmitter.prototype) {\r\n    _embedded[i] = EventEmitter.prototype[i];\r\n  }\r\n\r\n  return _embedded;\r\n}\r\n\r\n/**\r\n * Special case for when users use a common location schema to represent\r\n * locations for use with $geoWithin.\r\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\r\n *\r\n * @param {Object} val\r\n * @api private\r\n */\r\n\r\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\r\n  return { $geometry: this.castForQuery(val.$geometry) };\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSubdocumentPath.prototype.$conditionalHandlers.$near =\r\nSubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\r\n\r\nSubdocumentPath.prototype.$conditionalHandlers.$within =\r\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\r\n\r\nSubdocumentPath.prototype.$conditionalHandlers.$geoIntersects =\r\n  geospatial.cast$geoIntersects;\r\n\r\nSubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\r\nSubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\r\n\r\nSubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;\r\n\r\n/**\r\n * Casts contents\r\n *\r\n * @param {Object} value\r\n * @api private\r\n */\r\n\r\nSubdocumentPath.prototype.cast = function(val, doc, init, priorVal, options) {\r\n  if (val && val.$isSingleNested && val.parent === doc) {\r\n    return val;\r\n  }\r\n\r\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\r\n    throw new ObjectExpectedError(this.path, val);\r\n  }\r\n\r\n  const Constructor = getConstructor(this.caster, val);\r\n\r\n  let subdoc;\r\n\r\n  // Only pull relevant selected paths and pull out the base path\r\n  const parentSelected = doc && doc.$__ && doc.$__.selected || {};\r\n  const path = this.path;\r\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\r\n    if (key.startsWith(path + '.')) {\r\n      obj = obj || {};\r\n      obj[key.substring(path.length + 1)] = parentSelected[key];\r\n    }\r\n    return obj;\r\n  }, null);\r\n  options = Object.assign({}, options, { priorDoc: priorVal });\r\n  if (init) {\r\n    subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });\r\n    delete subdoc.$__.defaults;\r\n    subdoc.$init(val);\r\n    applyDefaults(subdoc, selected);\r\n  } else {\r\n    if (Object.keys(val).length === 0) {\r\n      return new Constructor({}, selected, doc, undefined, options);\r\n    }\r\n\r\n    return new Constructor(val, selected, doc, undefined, options);\r\n  }\r\n\r\n  return subdoc;\r\n};\r\n\r\n/**\r\n * Casts contents for query\r\n *\r\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\r\n * @param {any} value\r\n * @api private\r\n */\r\n\r\nSubdocumentPath.prototype.castForQuery = function($conditional, val, options) {\r\n  let handler;\r\n  if (arguments.length === 2) {\r\n    handler = this.$conditionalHandlers[$conditional];\r\n    if (!handler) {\r\n      throw new Error('Can\\'t use ' + $conditional);\r\n    }\r\n    return handler.call(this, val);\r\n  }\r\n  val = $conditional;\r\n  if (val == null) {\r\n    return val;\r\n  }\r\n\r\n  if (this.options.runSetters) {\r\n    val = this._applySetters(val);\r\n  }\r\n\r\n  const Constructor = getConstructor(this.caster, val);\r\n  const overrideStrict = options != null && options.strict != null ?\r\n    options.strict :\r\n    void 0;\r\n\r\n  try {\r\n    val = new Constructor(val, overrideStrict);\r\n  } catch (error) {\r\n    // Make sure we always wrap in a CastError (gh-6803)\r\n    if (!(error instanceof CastError)) {\r\n      throw new CastError('Embedded', val, this.path, error, this);\r\n    }\r\n    throw error;\r\n  }\r\n  return val;\r\n};\r\n\r\n/**\r\n * Async validation on this single nested doc.\r\n *\r\n * @api private\r\n */\r\n\r\nSubdocumentPath.prototype.doValidate = function(value, fn, scope, options) {\r\n  const Constructor = getConstructor(this.caster, value);\r\n\r\n  if (value && !(value instanceof Constructor)) {\r\n    value = new Constructor(value, null, (scope != null && scope.$__ != null) ? scope : null);\r\n  }\r\n\r\n  if (options && options.skipSchemaValidators) {\r\n    if (!value) {\r\n      return fn(null);\r\n    }\r\n    return value.validate(fn);\r\n  }\r\n\r\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\r\n    if (error) {\r\n      return fn(error);\r\n    }\r\n    if (!value) {\r\n      return fn(null);\r\n    }\r\n\r\n    value.validate(fn);\r\n  }, scope, options);\r\n};\r\n\r\n/**\r\n * Synchronously validate this single nested doc\r\n *\r\n * @api private\r\n */\r\n\r\nSubdocumentPath.prototype.doValidateSync = function(value, scope, options) {\r\n  if (!options || !options.skipSchemaValidators) {\r\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\r\n    if (schemaTypeError) {\r\n      return schemaTypeError;\r\n    }\r\n  }\r\n  if (!value) {\r\n    return;\r\n  }\r\n  return value.validateSync();\r\n};\r\n\r\n/**\r\n * Adds a discriminator to this single nested subdocument.\r\n *\r\n * #### Example:\r\n *\r\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\r\n *     const schema = Schema({ shape: shapeSchema });\r\n *\r\n *     const singleNestedPath = parentSchema.path('shape');\r\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\r\n *\r\n * @param {String} name\r\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\r\n * @param {Object|string} [options] If string, same as `options.value`.\r\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\r\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\r\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\r\n * @see discriminators /docs/discriminators.html\r\n * @api public\r\n */\r\n\r\nSubdocumentPath.prototype.discriminator = function(name, schema, options) {\r\n  options = options || {};\r\n  const value = utils.isPOJO(options) ? options.value : options;\r\n  const clone = typeof options.clone === 'boolean'\r\n    ? options.clone\r\n    : true;\r\n\r\n  if (schema.instanceOfSchema && clone) {\r\n    schema = schema.clone();\r\n  }\r\n\r\n  schema = discriminator(this.caster, name, schema, value);\r\n\r\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\r\n\r\n  return this.caster.discriminators[name];\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSubdocumentPath.defaultOptions = {};\r\n\r\n/**\r\n * Sets a default option for all SubdocumentPath instances.\r\n *\r\n * #### Example:\r\n *\r\n *     // Make all numbers have option `min` equal to 0.\r\n *     mongoose.Schema.SubdocumentPath.set('required', true);\r\n *\r\n * @param {String} option The option you'd like to set the value for\r\n * @param {Any} value value for option\r\n * @return {void}\r\n * @function set\r\n * @static\r\n * @api public\r\n */\r\n\r\nSubdocumentPath.set = SchemaType.set;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSubdocumentPath.prototype.toJSON = function toJSON() {\r\n  return { path: this.path, options: this.options };\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSubdocumentPath.prototype.clone = function() {\r\n  const options = Object.assign({}, this.options);\r\n  const schematype = new this.constructor(this.schema, this.path, options);\r\n  schematype.validators = this.validators.slice();\r\n  if (this.requiredValidator !== undefined) {\r\n    schematype.requiredValidator = this.requiredValidator;\r\n  }\r\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\r\n  return schematype;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}