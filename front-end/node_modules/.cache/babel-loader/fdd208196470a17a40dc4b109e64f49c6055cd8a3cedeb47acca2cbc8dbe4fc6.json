{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EJSON = exports.isBSONType = void 0;\nvar binary_1 = require(\"./binary\");\nvar code_1 = require(\"./code\");\nvar db_ref_1 = require(\"./db_ref\");\nvar decimal128_1 = require(\"./decimal128\");\nvar double_1 = require(\"./double\");\nvar error_1 = require(\"./error\");\nvar int_32_1 = require(\"./int_32\");\nvar long_1 = require(\"./long\");\nvar max_key_1 = require(\"./max_key\");\nvar min_key_1 = require(\"./min_key\");\nvar objectid_1 = require(\"./objectid\");\nvar utils_1 = require(\"./parser/utils\");\nvar regexp_1 = require(\"./regexp\");\nvar symbol_1 = require(\"./symbol\");\nvar timestamp_1 = require(\"./timestamp\");\nfunction isBSONType(value) {\n  return (0, utils_1.isObjectLike)(value) && Reflect.has(value, '_bsontype') && typeof value._bsontype === 'string';\n}\nexports.isBSONType = isBSONType;\n// INT32 boundaries\nvar BSON_INT32_MAX = 0x7fffffff;\nvar BSON_INT32_MIN = -0x80000000;\n// INT64 boundaries\n// const BSON_INT64_MAX = 0x7fffffffffffffff; // TODO(NODE-4377): This number cannot be precisely represented in JS\nvar BSON_INT64_MAX = 0x8000000000000000;\nvar BSON_INT64_MIN = -0x8000000000000000;\n// all the types where we don't need to do any special processing and can just pass the EJSON\n//straight to type.fromExtendedJSON\nvar keysToCodecs = {\n  $oid: objectid_1.ObjectId,\n  $binary: binary_1.Binary,\n  $uuid: binary_1.Binary,\n  $symbol: symbol_1.BSONSymbol,\n  $numberInt: int_32_1.Int32,\n  $numberDecimal: decimal128_1.Decimal128,\n  $numberDouble: double_1.Double,\n  $numberLong: long_1.Long,\n  $minKey: min_key_1.MinKey,\n  $maxKey: max_key_1.MaxKey,\n  $regex: regexp_1.BSONRegExp,\n  $regularExpression: regexp_1.BSONRegExp,\n  $timestamp: timestamp_1.Timestamp\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction deserializeValue(value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (typeof value === 'number') {\n    if (options.relaxed || options.legacy) {\n      return value;\n    }\n    // if it's an integer, should interpret as smallest BSON integer\n    // that can represent it exactly. (if out of range, interpret as double.)\n    if (Math.floor(value) === value) {\n      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) return new int_32_1.Int32(value);\n      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) return long_1.Long.fromNumber(value);\n    }\n    // If the number is a non-integer or out of integer range, should interpret as BSON Double.\n    return new double_1.Double(value);\n  }\n  // from here on out we're looking for bson types, so bail if its not an object\n  if (value == null || typeof value !== 'object') return value;\n  // upgrade deprecated undefined to null\n  if (value.$undefined) return null;\n  var keys = Object.keys(value).filter(function (k) {\n    return k.startsWith('$') && value[k] != null;\n  });\n  for (var i = 0; i < keys.length; i++) {\n    var c = keysToCodecs[keys[i]];\n    if (c) return c.fromExtendedJSON(value, options);\n  }\n  if (value.$date != null) {\n    var d = value.$date;\n    var date = new Date();\n    if (options.legacy) {\n      if (typeof d === 'number') date.setTime(d);else if (typeof d === 'string') date.setTime(Date.parse(d));\n    } else {\n      if (typeof d === 'string') date.setTime(Date.parse(d));else if (long_1.Long.isLong(d)) date.setTime(d.toNumber());else if (typeof d === 'number' && options.relaxed) date.setTime(d);\n    }\n    return date;\n  }\n  if (value.$code != null) {\n    var copy = Object.assign({}, value);\n    if (value.$scope) {\n      copy.$scope = deserializeValue(value.$scope);\n    }\n    return code_1.Code.fromExtendedJSON(value);\n  }\n  if ((0, db_ref_1.isDBRefLike)(value) || value.$dbPointer) {\n    var v = value.$ref ? value : value.$dbPointer;\n    // we run into this in a \"degenerate EJSON\" case (with $id and $ref order flipped)\n    // because of the order JSON.parse goes through the document\n    if (v instanceof db_ref_1.DBRef) return v;\n    var dollarKeys = Object.keys(v).filter(function (k) {\n      return k.startsWith('$');\n    });\n    var valid_1 = true;\n    dollarKeys.forEach(function (k) {\n      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid_1 = false;\n    });\n    // only make DBRef if $ keys are all valid\n    if (valid_1) return db_ref_1.DBRef.fromExtendedJSON(v);\n  }\n  return value;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction serializeArray(array, options) {\n  return array.map(function (v, index) {\n    options.seenObjects.push({\n      propertyName: \"index \".concat(index),\n      obj: null\n    });\n    try {\n      return serializeValue(v, options);\n    } finally {\n      options.seenObjects.pop();\n    }\n  });\n}\nfunction getISOString(date) {\n  var isoStr = date.toISOString();\n  // we should only show milliseconds in timestamp if they're non-zero\n  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction serializeValue(value, options) {\n  if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\n    var index = options.seenObjects.findIndex(function (entry) {\n      return entry.obj === value;\n    });\n    if (index !== -1) {\n      var props = options.seenObjects.map(function (entry) {\n        return entry.propertyName;\n      });\n      var leadingPart = props.slice(0, index).map(function (prop) {\n        return \"\".concat(prop, \" -> \");\n      }).join('');\n      var alreadySeen = props[index];\n      var circularPart = ' -> ' + props.slice(index + 1, props.length - 1).map(function (prop) {\n        return \"\".concat(prop, \" -> \");\n      }).join('');\n      var current = props[props.length - 1];\n      var leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\n      var dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n      throw new error_1.BSONTypeError('Converting circular structure to EJSON:\\n' + \"    \".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, \"\\n\") + \"    \".concat(leadingSpace, \"\\\\\").concat(dashes, \"/\"));\n    }\n    options.seenObjects[options.seenObjects.length - 1].obj = value;\n  }\n  if (Array.isArray(value)) return serializeArray(value, options);\n  if (value === undefined) return null;\n  if (value instanceof Date || (0, utils_1.isDate)(value)) {\n    var dateNum = value.getTime(),\n      // is it in year range 1970-9999?\n      inRange = dateNum > -1 && dateNum < 253402318800000;\n    if (options.legacy) {\n      return options.relaxed && inRange ? {\n        $date: value.getTime()\n      } : {\n        $date: getISOString(value)\n      };\n    }\n    return options.relaxed && inRange ? {\n      $date: getISOString(value)\n    } : {\n      $date: {\n        $numberLong: value.getTime().toString()\n      }\n    };\n  }\n  if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\n    // it's an integer\n    if (Math.floor(value) === value) {\n      var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX,\n        int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;\n      // interpret as being of the smallest BSON integer type that can represent the number exactly\n      if (int32Range) return {\n        $numberInt: value.toString()\n      };\n      if (int64Range) return {\n        $numberLong: value.toString()\n      };\n    }\n    return {\n      $numberDouble: value.toString()\n    };\n  }\n  if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {\n    var flags = value.flags;\n    if (flags === undefined) {\n      var match = value.toString().match(/[gimuy]*$/);\n      if (match) {\n        flags = match[0];\n      }\n    }\n    var rx = new regexp_1.BSONRegExp(value.source, flags);\n    return rx.toExtendedJSON(options);\n  }\n  if (value != null && typeof value === 'object') return serializeDocument(value, options);\n  return value;\n}\nvar BSON_TYPE_MAPPINGS = {\n  Binary: function (o) {\n    return new binary_1.Binary(o.value(), o.sub_type);\n  },\n  Code: function (o) {\n    return new code_1.Code(o.code, o.scope);\n  },\n  DBRef: function (o) {\n    return new db_ref_1.DBRef(o.collection || o.namespace, o.oid, o.db, o.fields);\n  },\n  Decimal128: function (o) {\n    return new decimal128_1.Decimal128(o.bytes);\n  },\n  Double: function (o) {\n    return new double_1.Double(o.value);\n  },\n  Int32: function (o) {\n    return new int_32_1.Int32(o.value);\n  },\n  Long: function (o) {\n    return long_1.Long.fromBits(\n    // underscore variants for 1.x backwards compatibility\n    o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_);\n  },\n  MaxKey: function () {\n    return new max_key_1.MaxKey();\n  },\n  MinKey: function () {\n    return new min_key_1.MinKey();\n  },\n  ObjectID: function (o) {\n    return new objectid_1.ObjectId(o);\n  },\n  ObjectId: function (o) {\n    return new objectid_1.ObjectId(o);\n  },\n  BSONRegExp: function (o) {\n    return new regexp_1.BSONRegExp(o.pattern, o.options);\n  },\n  Symbol: function (o) {\n    return new symbol_1.BSONSymbol(o.value);\n  },\n  Timestamp: function (o) {\n    return timestamp_1.Timestamp.fromBits(o.low, o.high);\n  }\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction serializeDocument(doc, options) {\n  if (doc == null || typeof doc !== 'object') throw new error_1.BSONError('not an object instance');\n  var bsontype = doc._bsontype;\n  if (typeof bsontype === 'undefined') {\n    // It's a regular object. Recursively serialize its property values.\n    var _doc = {};\n    for (var name in doc) {\n      options.seenObjects.push({\n        propertyName: name,\n        obj: null\n      });\n      try {\n        var value = serializeValue(doc[name], options);\n        if (name === '__proto__') {\n          Object.defineProperty(_doc, name, {\n            value: value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        } else {\n          _doc[name] = value;\n        }\n      } finally {\n        options.seenObjects.pop();\n      }\n    }\n    return _doc;\n  } else if (isBSONType(doc)) {\n    // the \"document\" is really just a BSON type object\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var outDoc = doc;\n    if (typeof outDoc.toExtendedJSON !== 'function') {\n      // There's no EJSON serialization function on the object. It's probably an\n      // object created by a previous version of this library (or another library)\n      // that's duck-typing objects to look like they were generated by this library).\n      // Copy the object into this library's version of that type.\n      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n      if (!mapper) {\n        throw new error_1.BSONTypeError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\n      }\n      outDoc = mapper(outDoc);\n    }\n    // Two BSON types may have nested objects that may need to be serialized too\n    if (bsontype === 'Code' && outDoc.scope) {\n      outDoc = new code_1.Code(outDoc.code, serializeValue(outDoc.scope, options));\n    } else if (bsontype === 'DBRef' && outDoc.oid) {\n      outDoc = new db_ref_1.DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n    }\n    return outDoc.toExtendedJSON(options);\n  } else {\n    throw new error_1.BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\n  }\n}\n/**\r\n * EJSON parse / stringify API\r\n * @public\r\n */\n// the namespace here is used to emulate `export * as EJSON from '...'`\n// which as of now (sept 2020) api-extractor does not support\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar EJSON;\n(function (EJSON) {\n  /**\r\n   * Parse an Extended JSON string, constructing the JavaScript value or object described by that\r\n   * string.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const { EJSON } = require('bson');\r\n   * const text = '{ \"int32\": { \"$numberInt\": \"10\" } }';\r\n   *\r\n   * // prints { int32: { [String: '10'] _bsontype: 'Int32', value: '10' } }\r\n   * console.log(EJSON.parse(text, { relaxed: false }));\r\n   *\r\n   * // prints { int32: 10 }\r\n   * console.log(EJSON.parse(text));\r\n   * ```\r\n   */\n  function parse(text, options) {\n    var finalOptions = Object.assign({}, {\n      relaxed: true,\n      legacy: false\n    }, options);\n    // relaxed implies not strict\n    if (typeof finalOptions.relaxed === 'boolean') finalOptions.strict = !finalOptions.relaxed;\n    if (typeof finalOptions.strict === 'boolean') finalOptions.relaxed = !finalOptions.strict;\n    return JSON.parse(text, function (key, value) {\n      if (key.indexOf('\\x00') !== -1) {\n        throw new error_1.BSONError(\"BSON Document field names cannot contain null bytes, found: \".concat(JSON.stringify(key)));\n      }\n      return deserializeValue(value, finalOptions);\n    });\n  }\n  EJSON.parse = parse;\n  /**\r\n   * Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer\r\n   * function is specified or optionally including only the specified properties if a replacer array\r\n   * is specified.\r\n   *\r\n   * @param value - The value to convert to extended JSON\r\n   * @param replacer - A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string\r\n   * @param space - A String or Number object that's used to insert white space into the output JSON string for readability purposes.\r\n   * @param options - Optional settings\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const { EJSON } = require('bson');\r\n   * const Int32 = require('mongodb').Int32;\r\n   * const doc = { int32: new Int32(10) };\r\n   *\r\n   * // prints '{\"int32\":{\"$numberInt\":\"10\"}}'\r\n   * console.log(EJSON.stringify(doc, { relaxed: false }));\r\n   *\r\n   * // prints '{\"int32\":10}'\r\n   * console.log(EJSON.stringify(doc));\r\n   * ```\r\n   */\n  function stringify(value,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  replacer, space, options) {\n    if (space != null && typeof space === 'object') {\n      options = space;\n      space = 0;\n    }\n    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\n      options = replacer;\n      replacer = undefined;\n      space = 0;\n    }\n    var serializeOptions = Object.assign({\n      relaxed: true,\n      legacy: false\n    }, options, {\n      seenObjects: [{\n        propertyName: '(root)',\n        obj: null\n      }]\n    });\n    var doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n  }\n  EJSON.stringify = stringify;\n  /**\r\n   * Serializes an object to an Extended JSON string, and reparse it as a JavaScript object.\r\n   *\r\n   * @param value - The object to serialize\r\n   * @param options - Optional settings passed to the `stringify` function\r\n   */\n  function serialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n  }\n  EJSON.serialize = serialize;\n  /**\r\n   * Deserializes an Extended JSON object into a plain JavaScript object with native/BSON types\r\n   *\r\n   * @param ejson - The Extended JSON object to deserialize\r\n   * @param options - Optional settings passed to the parse method\r\n   */\n  function deserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n  }\n  EJSON.deserialize = deserialize;\n})(EJSON = exports.EJSON || (exports.EJSON = {}));","map":{"version":3,"mappings":"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","names":["isBSONType","value","Reflect","has","_bsontype","exports","BSON_INT32_MAX","BSON_INT32_MIN","BSON_INT64_MAX","BSON_INT64_MIN","keysToCodecs","$oid","objectid_1","$binary","binary_1","$uuid","$symbol","symbol_1","$numberInt","int_32_1","$numberDecimal","decimal128_1","$numberDouble","double_1","$numberLong","long_1","$minKey","min_key_1","$maxKey","max_key_1","$regex","regexp_1","$regularExpression","$timestamp","timestamp_1","deserializeValue","options","relaxed","legacy","Math","floor","fromNumber","$undefined","keys","Object","filter","startsWith","k","i","length","c","fromExtendedJSON","$date","d","date","Date","setTime","parse","isLong","toNumber","$code","copy","assign","$scope","code_1","$dbPointer","v","$ref","db_ref_1","dollarKeys","valid_1","forEach","indexOf","serializeArray","array","map","index","seenObjects","push","propertyName","obj","serializeValue","pop","getISOString","isoStr","toISOString","getUTCMilliseconds","slice","findIndex","props","leadingPart","prop","join","alreadySeen","circularPart","current","leadingSpace","repeat","dashes","error_1","Array","isArray","undefined","dateNum","getTime","inRange","toString","isFinite","int32Range","int64Range","RegExp","flags","match","rx","source","toExtendedJSON","serializeDocument","BSON_TYPE_MAPPINGS","Binary","o","sub_type","Code","code","scope","DBRef","collection","namespace","oid","db","fields","Decimal128","bytes","Double","Int32","Long","fromBits","low","low_","high","high_","unsigned","unsigned_","MaxKey","MinKey","ObjectID","ObjectId","BSONRegExp","pattern","Symbol","Timestamp","doc","bsontype","_doc","name","defineProperty","writable","enumerable","configurable","outDoc","mapper","EJSON","text","finalOptions","strict","JSON","key","stringify","replacer","space","serializeOptions","serialize","deserialize","ejson"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\extended_json.ts"],"sourcesContent":["import { Binary } from './binary';\r\nimport type { Document } from './bson';\r\nimport { Code } from './code';\r\nimport { DBRef, isDBRefLike } from './db_ref';\r\nimport { Decimal128 } from './decimal128';\r\nimport { Double } from './double';\r\nimport { BSONError, BSONTypeError } from './error';\r\nimport { Int32 } from './int_32';\r\nimport { Long } from './long';\r\nimport { MaxKey } from './max_key';\r\nimport { MinKey } from './min_key';\r\nimport { ObjectId } from './objectid';\r\nimport { isDate, isObjectLike, isRegExp } from './parser/utils';\r\nimport { BSONRegExp } from './regexp';\r\nimport { BSONSymbol } from './symbol';\r\nimport { Timestamp } from './timestamp';\r\n\r\n/** @public */\r\nexport type EJSONOptions = EJSON.Options;\r\n\r\n/** @internal */\r\ntype BSONType =\r\n  | Binary\r\n  | Code\r\n  | DBRef\r\n  | Decimal128\r\n  | Double\r\n  | Int32\r\n  | Long\r\n  | MaxKey\r\n  | MinKey\r\n  | ObjectId\r\n  | BSONRegExp\r\n  | BSONSymbol\r\n  | Timestamp;\r\n\r\nexport function isBSONType(value: unknown): value is BSONType {\r\n  return (\r\n    isObjectLike(value) && Reflect.has(value, '_bsontype') && typeof value._bsontype === 'string'\r\n  );\r\n}\r\n\r\n// INT32 boundaries\r\nconst BSON_INT32_MAX = 0x7fffffff;\r\nconst BSON_INT32_MIN = -0x80000000;\r\n// INT64 boundaries\r\n// const BSON_INT64_MAX = 0x7fffffffffffffff; // TODO(NODE-4377): This number cannot be precisely represented in JS\r\nconst BSON_INT64_MAX = 0x8000000000000000;\r\nconst BSON_INT64_MIN = -0x8000000000000000;\r\n\r\n// all the types where we don't need to do any special processing and can just pass the EJSON\r\n//straight to type.fromExtendedJSON\r\nconst keysToCodecs = {\r\n  $oid: ObjectId,\r\n  $binary: Binary,\r\n  $uuid: Binary,\r\n  $symbol: BSONSymbol,\r\n  $numberInt: Int32,\r\n  $numberDecimal: Decimal128,\r\n  $numberDouble: Double,\r\n  $numberLong: Long,\r\n  $minKey: MinKey,\r\n  $maxKey: MaxKey,\r\n  $regex: BSONRegExp,\r\n  $regularExpression: BSONRegExp,\r\n  $timestamp: Timestamp\r\n} as const;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction deserializeValue(value: any, options: EJSON.Options = {}) {\r\n  if (typeof value === 'number') {\r\n    if (options.relaxed || options.legacy) {\r\n      return value;\r\n    }\r\n\r\n    // if it's an integer, should interpret as smallest BSON integer\r\n    // that can represent it exactly. (if out of range, interpret as double.)\r\n    if (Math.floor(value) === value) {\r\n      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) return new Int32(value);\r\n      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) return Long.fromNumber(value);\r\n    }\r\n\r\n    // If the number is a non-integer or out of integer range, should interpret as BSON Double.\r\n    return new Double(value);\r\n  }\r\n\r\n  // from here on out we're looking for bson types, so bail if its not an object\r\n  if (value == null || typeof value !== 'object') return value;\r\n\r\n  // upgrade deprecated undefined to null\r\n  if (value.$undefined) return null;\r\n\r\n  const keys = Object.keys(value).filter(\r\n    k => k.startsWith('$') && value[k] != null\r\n  ) as (keyof typeof keysToCodecs)[];\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const c = keysToCodecs[keys[i]];\r\n    if (c) return c.fromExtendedJSON(value, options);\r\n  }\r\n\r\n  if (value.$date != null) {\r\n    const d = value.$date;\r\n    const date = new Date();\r\n\r\n    if (options.legacy) {\r\n      if (typeof d === 'number') date.setTime(d);\r\n      else if (typeof d === 'string') date.setTime(Date.parse(d));\r\n    } else {\r\n      if (typeof d === 'string') date.setTime(Date.parse(d));\r\n      else if (Long.isLong(d)) date.setTime(d.toNumber());\r\n      else if (typeof d === 'number' && options.relaxed) date.setTime(d);\r\n    }\r\n    return date;\r\n  }\r\n\r\n  if (value.$code != null) {\r\n    const copy = Object.assign({}, value);\r\n    if (value.$scope) {\r\n      copy.$scope = deserializeValue(value.$scope);\r\n    }\r\n\r\n    return Code.fromExtendedJSON(value);\r\n  }\r\n\r\n  if (isDBRefLike(value) || value.$dbPointer) {\r\n    const v = value.$ref ? value : value.$dbPointer;\r\n\r\n    // we run into this in a \"degenerate EJSON\" case (with $id and $ref order flipped)\r\n    // because of the order JSON.parse goes through the document\r\n    if (v instanceof DBRef) return v;\r\n\r\n    const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));\r\n    let valid = true;\r\n    dollarKeys.forEach(k => {\r\n      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;\r\n    });\r\n\r\n    // only make DBRef if $ keys are all valid\r\n    if (valid) return DBRef.fromExtendedJSON(v);\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\ntype EJSONSerializeOptions = EJSON.Options & {\r\n  seenObjects: { obj: unknown; propertyName: string }[];\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction serializeArray(array: any[], options: EJSONSerializeOptions): any[] {\r\n  return array.map((v: unknown, index: number) => {\r\n    options.seenObjects.push({ propertyName: `index ${index}`, obj: null });\r\n    try {\r\n      return serializeValue(v, options);\r\n    } finally {\r\n      options.seenObjects.pop();\r\n    }\r\n  });\r\n}\r\n\r\nfunction getISOString(date: Date) {\r\n  const isoStr = date.toISOString();\r\n  // we should only show milliseconds in timestamp if they're non-zero\r\n  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction serializeValue(value: any, options: EJSONSerializeOptions): any {\r\n  if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\r\n    const index = options.seenObjects.findIndex(entry => entry.obj === value);\r\n    if (index !== -1) {\r\n      const props = options.seenObjects.map(entry => entry.propertyName);\r\n      const leadingPart = props\r\n        .slice(0, index)\r\n        .map(prop => `${prop} -> `)\r\n        .join('');\r\n      const alreadySeen = props[index];\r\n      const circularPart =\r\n        ' -> ' +\r\n        props\r\n          .slice(index + 1, props.length - 1)\r\n          .map(prop => `${prop} -> `)\r\n          .join('');\r\n      const current = props[props.length - 1];\r\n      const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\r\n      const dashes = '-'.repeat(\r\n        circularPart.length + (alreadySeen.length + current.length) / 2 - 1\r\n      );\r\n\r\n      throw new BSONTypeError(\r\n        'Converting circular structure to EJSON:\\n' +\r\n          `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` +\r\n          `    ${leadingSpace}\\\\${dashes}/`\r\n      );\r\n    }\r\n    options.seenObjects[options.seenObjects.length - 1].obj = value;\r\n  }\r\n\r\n  if (Array.isArray(value)) return serializeArray(value, options);\r\n\r\n  if (value === undefined) return null;\r\n\r\n  if (value instanceof Date || isDate(value)) {\r\n    const dateNum = value.getTime(),\r\n      // is it in year range 1970-9999?\r\n      inRange = dateNum > -1 && dateNum < 253402318800000;\r\n\r\n    if (options.legacy) {\r\n      return options.relaxed && inRange\r\n        ? { $date: value.getTime() }\r\n        : { $date: getISOString(value) };\r\n    }\r\n    return options.relaxed && inRange\r\n      ? { $date: getISOString(value) }\r\n      : { $date: { $numberLong: value.getTime().toString() } };\r\n  }\r\n\r\n  if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\r\n    // it's an integer\r\n    if (Math.floor(value) === value) {\r\n      const int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX,\r\n        int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;\r\n\r\n      // interpret as being of the smallest BSON integer type that can represent the number exactly\r\n      if (int32Range) return { $numberInt: value.toString() };\r\n      if (int64Range) return { $numberLong: value.toString() };\r\n    }\r\n    return { $numberDouble: value.toString() };\r\n  }\r\n\r\n  if (value instanceof RegExp || isRegExp(value)) {\r\n    let flags = value.flags;\r\n    if (flags === undefined) {\r\n      const match = value.toString().match(/[gimuy]*$/);\r\n      if (match) {\r\n        flags = match[0];\r\n      }\r\n    }\r\n\r\n    const rx = new BSONRegExp(value.source, flags);\r\n    return rx.toExtendedJSON(options);\r\n  }\r\n\r\n  if (value != null && typeof value === 'object') return serializeDocument(value, options);\r\n  return value;\r\n}\r\n\r\nconst BSON_TYPE_MAPPINGS = {\r\n  Binary: (o: Binary) => new Binary(o.value(), o.sub_type),\r\n  Code: (o: Code) => new Code(o.code, o.scope),\r\n  DBRef: (o: DBRef) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields), // \"namespace\" for 1.x library backwards compat\r\n  Decimal128: (o: Decimal128) => new Decimal128(o.bytes),\r\n  Double: (o: Double) => new Double(o.value),\r\n  Int32: (o: Int32) => new Int32(o.value),\r\n  Long: (\r\n    o: Long & {\r\n      low_: number;\r\n      high_: number;\r\n      unsigned_: boolean | undefined;\r\n    }\r\n  ) =>\r\n    Long.fromBits(\r\n      // underscore variants for 1.x backwards compatibility\r\n      o.low != null ? o.low : o.low_,\r\n      o.low != null ? o.high : o.high_,\r\n      o.low != null ? o.unsigned : o.unsigned_\r\n    ),\r\n  MaxKey: () => new MaxKey(),\r\n  MinKey: () => new MinKey(),\r\n  ObjectID: (o: ObjectId) => new ObjectId(o),\r\n  ObjectId: (o: ObjectId) => new ObjectId(o), // support 4.0.0/4.0.1 before _bsontype was reverted back to ObjectID\r\n  BSONRegExp: (o: BSONRegExp) => new BSONRegExp(o.pattern, o.options),\r\n  Symbol: (o: BSONSymbol) => new BSONSymbol(o.value),\r\n  Timestamp: (o: Timestamp) => Timestamp.fromBits(o.low, o.high)\r\n} as const;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction serializeDocument(doc: any, options: EJSONSerializeOptions) {\r\n  if (doc == null || typeof doc !== 'object') throw new BSONError('not an object instance');\r\n\r\n  const bsontype: BSONType['_bsontype'] = doc._bsontype;\r\n  if (typeof bsontype === 'undefined') {\r\n    // It's a regular object. Recursively serialize its property values.\r\n    const _doc: Document = {};\r\n    for (const name in doc) {\r\n      options.seenObjects.push({ propertyName: name, obj: null });\r\n      try {\r\n        const value = serializeValue(doc[name], options);\r\n        if (name === '__proto__') {\r\n          Object.defineProperty(_doc, name, {\r\n            value,\r\n            writable: true,\r\n            enumerable: true,\r\n            configurable: true\r\n          });\r\n        } else {\r\n          _doc[name] = value;\r\n        }\r\n      } finally {\r\n        options.seenObjects.pop();\r\n      }\r\n    }\r\n    return _doc;\r\n  } else if (isBSONType(doc)) {\r\n    // the \"document\" is really just a BSON type object\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let outDoc: any = doc;\r\n    if (typeof outDoc.toExtendedJSON !== 'function') {\r\n      // There's no EJSON serialization function on the object. It's probably an\r\n      // object created by a previous version of this library (or another library)\r\n      // that's duck-typing objects to look like they were generated by this library).\r\n      // Copy the object into this library's version of that type.\r\n      const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\r\n      if (!mapper) {\r\n        throw new BSONTypeError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\r\n      }\r\n      outDoc = mapper(outDoc);\r\n    }\r\n\r\n    // Two BSON types may have nested objects that may need to be serialized too\r\n    if (bsontype === 'Code' && outDoc.scope) {\r\n      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\r\n    } else if (bsontype === 'DBRef' && outDoc.oid) {\r\n      outDoc = new DBRef(\r\n        serializeValue(outDoc.collection, options),\r\n        serializeValue(outDoc.oid, options),\r\n        serializeValue(outDoc.db, options),\r\n        serializeValue(outDoc.fields, options)\r\n      );\r\n    }\r\n\r\n    return outDoc.toExtendedJSON(options);\r\n  } else {\r\n    throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\r\n  }\r\n}\r\n\r\n/**\r\n * EJSON parse / stringify API\r\n * @public\r\n */\r\n// the namespace here is used to emulate `export * as EJSON from '...'`\r\n// which as of now (sept 2020) api-extractor does not support\r\n// eslint-disable-next-line @typescript-eslint/no-namespace\r\nexport namespace EJSON {\r\n  export interface Options {\r\n    /** Output using the Extended JSON v1 spec */\r\n    legacy?: boolean;\r\n    /** Enable Extended JSON's `relaxed` mode, which attempts to return native JS types where possible, rather than BSON types */\r\n    relaxed?: boolean;\r\n    /**\r\n     * Disable Extended JSON's `relaxed` mode, which attempts to return BSON types where possible, rather than native JS types\r\n     * @deprecated Please use the relaxed property instead\r\n     */\r\n    strict?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Parse an Extended JSON string, constructing the JavaScript value or object described by that\r\n   * string.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const { EJSON } = require('bson');\r\n   * const text = '{ \"int32\": { \"$numberInt\": \"10\" } }';\r\n   *\r\n   * // prints { int32: { [String: '10'] _bsontype: 'Int32', value: '10' } }\r\n   * console.log(EJSON.parse(text, { relaxed: false }));\r\n   *\r\n   * // prints { int32: 10 }\r\n   * console.log(EJSON.parse(text));\r\n   * ```\r\n   */\r\n  export function parse(text: string, options?: EJSON.Options): SerializableTypes {\r\n    const finalOptions = Object.assign({}, { relaxed: true, legacy: false }, options);\r\n\r\n    // relaxed implies not strict\r\n    if (typeof finalOptions.relaxed === 'boolean') finalOptions.strict = !finalOptions.relaxed;\r\n    if (typeof finalOptions.strict === 'boolean') finalOptions.relaxed = !finalOptions.strict;\r\n\r\n    return JSON.parse(text, (key, value) => {\r\n      if (key.indexOf('\\x00') !== -1) {\r\n        throw new BSONError(\r\n          `BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`\r\n        );\r\n      }\r\n      return deserializeValue(value, finalOptions);\r\n    });\r\n  }\r\n\r\n  export type JSONPrimitive = string | number | boolean | null;\r\n  export type SerializableTypes = Document | Array<JSONPrimitive | Document> | JSONPrimitive;\r\n\r\n  /**\r\n   * Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer\r\n   * function is specified or optionally including only the specified properties if a replacer array\r\n   * is specified.\r\n   *\r\n   * @param value - The value to convert to extended JSON\r\n   * @param replacer - A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string\r\n   * @param space - A String or Number object that's used to insert white space into the output JSON string for readability purposes.\r\n   * @param options - Optional settings\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const { EJSON } = require('bson');\r\n   * const Int32 = require('mongodb').Int32;\r\n   * const doc = { int32: new Int32(10) };\r\n   *\r\n   * // prints '{\"int32\":{\"$numberInt\":\"10\"}}'\r\n   * console.log(EJSON.stringify(doc, { relaxed: false }));\r\n   *\r\n   * // prints '{\"int32\":10}'\r\n   * console.log(EJSON.stringify(doc));\r\n   * ```\r\n   */\r\n  export function stringify(\r\n    value: SerializableTypes,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    replacer?: (number | string)[] | ((this: any, key: string, value: any) => any) | EJSON.Options,\r\n    space?: string | number,\r\n    options?: EJSON.Options\r\n  ): string {\r\n    if (space != null && typeof space === 'object') {\r\n      options = space;\r\n      space = 0;\r\n    }\r\n    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\r\n      options = replacer;\r\n      replacer = undefined;\r\n      space = 0;\r\n    }\r\n    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\r\n      seenObjects: [{ propertyName: '(root)', obj: null }]\r\n    });\r\n\r\n    const doc = serializeValue(value, serializeOptions);\r\n    return JSON.stringify(doc, replacer as Parameters<JSON['stringify']>[1], space);\r\n  }\r\n\r\n  /**\r\n   * Serializes an object to an Extended JSON string, and reparse it as a JavaScript object.\r\n   *\r\n   * @param value - The object to serialize\r\n   * @param options - Optional settings passed to the `stringify` function\r\n   */\r\n  export function serialize(value: SerializableTypes, options?: EJSON.Options): Document {\r\n    options = options || {};\r\n    return JSON.parse(stringify(value, options));\r\n  }\r\n\r\n  /**\r\n   * Deserializes an Extended JSON object into a plain JavaScript object with native/BSON types\r\n   *\r\n   * @param ejson - The Extended JSON object to deserialize\r\n   * @param options - Optional settings passed to the parse method\r\n   */\r\n  export function deserialize(ejson: Document, options?: EJSON.Options): SerializableTypes {\r\n    options = options || {};\r\n    return parse(JSON.stringify(ejson), options);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}