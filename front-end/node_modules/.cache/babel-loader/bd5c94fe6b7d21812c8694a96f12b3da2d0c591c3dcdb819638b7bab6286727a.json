{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\nconst immediate = require('../immediate');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/**\r\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\r\n * will wait for the promise to resolve before iterating on to the next one.\r\n * Returns a promise that resolves when done.\r\n *\r\n * @param {Function} next the thunk to call to get the next document\r\n * @param {Function} fn\r\n * @param {Object} options\r\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\r\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\r\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\r\n * @param {Function} [callback] executed when all docs have been processed\r\n * @return {Promise}\r\n * @api public\r\n * @method eachAsync\r\n */\n\nmodule.exports = function eachAsync(next, fn, options, callback) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n  let aborted = false;\n  return promiseOrCallback(callback, cb => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return cb(null);\n      }\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return cb(null);\n      }, {\n        once: true\n      });\n    }\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n    iterate(cb);\n  });\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n      return fetch;\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n        next(function (err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n          const docsToProcess = batchSize ? documentsBatch : doc;\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;\n              return finalCallback(finalErr);\n            }\n            immediate(() => enqueue(fetch));\n          }\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(function () {\n        callback(null);\n      }, function (error) {\n        callback(error || new Error('`eachAsync()` promise rejected without error'));\n      });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n  return function enqueue(fn) {\n    if (inProgress === null && _queue.length === 0) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n  return new EachAsyncMultiError(aggregatedErrors);\n}","map":{"version":3,"names":["EachAsyncMultiError","require","immediate","promiseOrCallback","module","exports","eachAsync","next","fn","options","callback","parallel","batchSize","signal","continueOnError","aggregatedErrors","enqueue","asyncQueue","aborted","cb","addEventListener","once","TypeError","Number","isInteger","iterate","finalCallback","handleResultsInProgress","currentDocumentIndex","error","i","createFetch","documentsBatch","drained","fetch","done","err","doc","name","push","finalErr","createEachAsyncMultiError","length","handleNextResult","handleNextResultCallBack","docsToProcess","maybePromise","then","Error","_queue","inProgress","id","_step","shift"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\r\nconst immediate = require('../immediate');\r\nconst promiseOrCallback = require('../promiseOrCallback');\r\n\r\n/**\r\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\r\n * will wait for the promise to resolve before iterating on to the next one.\r\n * Returns a promise that resolves when done.\r\n *\r\n * @param {Function} next the thunk to call to get the next document\r\n * @param {Function} fn\r\n * @param {Object} options\r\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\r\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\r\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\r\n * @param {Function} [callback] executed when all docs have been processed\r\n * @return {Promise}\r\n * @api public\r\n * @method eachAsync\r\n */\r\n\r\nmodule.exports = function eachAsync(next, fn, options, callback) {\r\n  const parallel = options.parallel || 1;\r\n  const batchSize = options.batchSize;\r\n  const signal = options.signal;\r\n  const continueOnError = options.continueOnError;\r\n  const aggregatedErrors = [];\r\n  const enqueue = asyncQueue();\r\n\r\n  let aborted = false;\r\n\r\n  return promiseOrCallback(callback, cb => {\r\n    if (signal != null) {\r\n      if (signal.aborted) {\r\n        return cb(null);\r\n      }\r\n\r\n      signal.addEventListener('abort', () => {\r\n        aborted = true;\r\n        return cb(null);\r\n      }, { once: true });\r\n    }\r\n\r\n    if (batchSize != null) {\r\n      if (typeof batchSize !== 'number') {\r\n        throw new TypeError('batchSize must be a number');\r\n      } else if (!Number.isInteger(batchSize)) {\r\n        throw new TypeError('batchSize must be an integer');\r\n      } else if (batchSize < 1) {\r\n        throw new TypeError('batchSize must be at least 1');\r\n      }\r\n    }\r\n\r\n    iterate(cb);\r\n  });\r\n\r\n  function iterate(finalCallback) {\r\n    let handleResultsInProgress = 0;\r\n    let currentDocumentIndex = 0;\r\n\r\n    let error = null;\r\n    for (let i = 0; i < parallel; ++i) {\r\n      enqueue(createFetch());\r\n    }\r\n\r\n    function createFetch() {\r\n      let documentsBatch = [];\r\n      let drained = false;\r\n\r\n      return fetch;\r\n\r\n      function fetch(done) {\r\n        if (drained || aborted) {\r\n          return done();\r\n        } else if (error) {\r\n          return done();\r\n        }\r\n\r\n        next(function(err, doc) {\r\n          if (error != null) {\r\n            return done();\r\n          }\r\n          if (err != null) {\r\n            if (err.name === 'MongoCursorExhaustedError') {\r\n              // We may end up calling `next()` multiple times on an exhausted\r\n              // cursor, which leads to an error. In case cursor is exhausted,\r\n              // just treat it as if the cursor returned no document, which is\r\n              // how a cursor indicates it is exhausted.\r\n              doc = null;\r\n            } else if (continueOnError) {\r\n              aggregatedErrors.push(err);\r\n            } else {\r\n              error = err;\r\n              finalCallback(err);\r\n              return done();\r\n            }\r\n          }\r\n          if (doc == null) {\r\n            drained = true;\r\n            if (handleResultsInProgress <= 0) {\r\n              const finalErr = continueOnError ?\r\n                createEachAsyncMultiError(aggregatedErrors) :\r\n                error;\r\n\r\n              finalCallback(finalErr);\r\n            } else if (batchSize && documentsBatch.length) {\r\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\r\n            }\r\n            return done();\r\n          }\r\n\r\n          ++handleResultsInProgress;\r\n\r\n          // Kick off the subsequent `next()` before handling the result, but\r\n          // make sure we know that we still have a result to handle re: #8422\r\n          immediate(() => done());\r\n\r\n          if (batchSize) {\r\n            documentsBatch.push(doc);\r\n          }\r\n\r\n          // If the current documents size is less than the provided batch size don't process the documents yet\r\n          if (batchSize && documentsBatch.length !== batchSize) {\r\n            immediate(() => enqueue(fetch));\r\n            return;\r\n          }\r\n\r\n          const docsToProcess = batchSize ? documentsBatch : doc;\r\n\r\n          function handleNextResultCallBack(err) {\r\n            if (batchSize) {\r\n              handleResultsInProgress -= documentsBatch.length;\r\n              documentsBatch = [];\r\n            } else {\r\n              --handleResultsInProgress;\r\n            }\r\n            if (err != null) {\r\n              if (continueOnError) {\r\n                aggregatedErrors.push(err);\r\n              } else {\r\n                error = err;\r\n                return finalCallback(err);\r\n              }\r\n            }\r\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\r\n              const finalErr = continueOnError ?\r\n                createEachAsyncMultiError(aggregatedErrors) :\r\n                error;\r\n              return finalCallback(finalErr);\r\n            }\r\n\r\n            immediate(() => enqueue(fetch));\r\n          }\r\n\r\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleNextResult(doc, i, callback) {\r\n    let maybePromise;\r\n    try {\r\n      maybePromise = fn(doc, i);\r\n    } catch (err) {\r\n      return callback(err);\r\n    }\r\n    if (maybePromise && typeof maybePromise.then === 'function') {\r\n      maybePromise.then(\r\n        function() { callback(null); },\r\n        function(error) {\r\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\r\n        });\r\n    } else {\r\n      callback(null);\r\n    }\r\n  }\r\n};\r\n\r\n// `next()` can only execute one at a time, so make sure we always execute\r\n// `next()` in series, while still allowing multiple `fn()` instances to run\r\n// in parallel.\r\nfunction asyncQueue() {\r\n  const _queue = [];\r\n  let inProgress = null;\r\n  let id = 0;\r\n\r\n  return function enqueue(fn) {\r\n    if (\r\n      inProgress === null &&\r\n      _queue.length === 0\r\n    ) {\r\n      inProgress = id++;\r\n      return fn(_step);\r\n    }\r\n    _queue.push(fn);\r\n  };\r\n\r\n  function _step() {\r\n    if (_queue.length !== 0) {\r\n      inProgress = id++;\r\n      const fn = _queue.shift();\r\n      fn(_step);\r\n    } else {\r\n      inProgress = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction createEachAsyncMultiError(aggregatedErrors) {\r\n  if (aggregatedErrors.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return new EachAsyncMultiError(aggregatedErrors);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}