{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$where = exports.$options = exports.$size = exports.$all = exports.$and = exports.$type = exports.$not = exports.$regex = exports.$exists = exports.$mod = exports.$gte = exports.$gt = exports.$lte = exports.$lt = exports.$in = exports.$nin = exports.$elemMatch = exports.$nor = exports.$or = exports.$ne = exports.$eq = exports.$Size = void 0;\nconst core_1 = require(\"./core\");\nconst utils_1 = require(\"./utils\");\nclass $Ne extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._test = (0, core_1.createTester)(this.params, this.options.compare);\n  }\n  reset() {\n    super.reset();\n    this.keep = true;\n  }\n  next(item) {\n    if (this._test(item)) {\n      this.done = true;\n      this.keep = false;\n    }\n  }\n}\n// https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\nclass $ElemMatch extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    if (!this.params || typeof this.params !== \"object\") {\n      throw new Error(`Malformed query. $elemMatch must by an object.`);\n    }\n    this._queryOperation = (0, core_1.createQueryOperation)(this.params, this.owneryQuery, this.options);\n  }\n  reset() {\n    super.reset();\n    this._queryOperation.reset();\n  }\n  next(item) {\n    if ((0, utils_1.isArray)(item)) {\n      for (let i = 0, {\n          length\n        } = item; i < length; i++) {\n        // reset query operation since item being tested needs to pass _all_ query\n        // operations for it to be a success\n        this._queryOperation.reset();\n        const child = item[i];\n        this._queryOperation.next(child, i, item, false);\n        this.keep = this.keep || this._queryOperation.keep;\n      }\n      this.done = true;\n    } else {\n      this.done = false;\n      this.keep = false;\n    }\n  }\n}\nclass $Not extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._queryOperation = (0, core_1.createQueryOperation)(this.params, this.owneryQuery, this.options);\n  }\n  reset() {\n    super.reset();\n    this._queryOperation.reset();\n  }\n  next(item, key, owner, root) {\n    this._queryOperation.next(item, key, owner, root);\n    this.done = this._queryOperation.done;\n    this.keep = !this._queryOperation.keep;\n  }\n}\nclass $Size extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {}\n  next(item) {\n    if ((0, utils_1.isArray)(item) && item.length === this.params) {\n      this.done = true;\n      this.keep = true;\n    }\n    // if (parent && parent.length === this.params) {\n    //   this.done = true;\n    //   this.keep = true;\n    // }\n  }\n}\n\nexports.$Size = $Size;\nconst assertGroupNotEmpty = values => {\n  if (values.length === 0) {\n    throw new Error(`$and/$or/$nor must be a nonempty array`);\n  }\n};\nclass $Or extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = false;\n  }\n  init() {\n    assertGroupNotEmpty(this.params);\n    this._ops = this.params.map(op => (0, core_1.createQueryOperation)(op, null, this.options));\n  }\n  reset() {\n    this.done = false;\n    this.keep = false;\n    for (let i = 0, {\n        length\n      } = this._ops; i < length; i++) {\n      this._ops[i].reset();\n    }\n  }\n  next(item, key, owner) {\n    let done = false;\n    let success = false;\n    for (let i = 0, {\n        length\n      } = this._ops; i < length; i++) {\n      const op = this._ops[i];\n      op.next(item, key, owner);\n      if (op.keep) {\n        done = true;\n        success = op.keep;\n        break;\n      }\n    }\n    this.keep = success;\n    this.done = done;\n  }\n}\nclass $Nor extends $Or {\n  constructor() {\n    super(...arguments);\n    this.propop = false;\n  }\n  next(item, key, owner) {\n    super.next(item, key, owner);\n    this.keep = !this.keep;\n  }\n}\nclass $In extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._testers = this.params.map(value => {\n      if ((0, core_1.containsOperation)(value, this.options)) {\n        throw new Error(`cannot nest $ under ${this.name.toLowerCase()}`);\n      }\n      return (0, core_1.createTester)(value, this.options.compare);\n    });\n  }\n  next(item, key, owner) {\n    let done = false;\n    let success = false;\n    for (let i = 0, {\n        length\n      } = this._testers; i < length; i++) {\n      const test = this._testers[i];\n      if (test(item)) {\n        done = true;\n        success = true;\n        break;\n      }\n    }\n    this.keep = success;\n    this.done = done;\n  }\n}\nclass $Nin extends core_1.BaseOperation {\n  constructor(params, ownerQuery, options, name) {\n    super(params, ownerQuery, options, name);\n    this.propop = true;\n    this._in = new $In(params, ownerQuery, options, name);\n  }\n  next(item, key, owner, root) {\n    this._in.next(item, key, owner);\n    if ((0, utils_1.isArray)(owner) && !root) {\n      if (this._in.keep) {\n        this.keep = false;\n        this.done = true;\n      } else if (key == owner.length - 1) {\n        this.keep = true;\n        this.done = true;\n      }\n    } else {\n      this.keep = !this._in.keep;\n      this.done = true;\n    }\n  }\n  reset() {\n    super.reset();\n    this._in.reset();\n  }\n}\nclass $Exists extends core_1.BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  next(item, key, owner) {\n    if (owner.hasOwnProperty(key) === this.params) {\n      this.done = true;\n      this.keep = true;\n    }\n  }\n}\nclass $And extends core_1.NamedGroupOperation {\n  constructor(params, owneryQuery, options, name) {\n    super(params, owneryQuery, options, params.map(query => (0, core_1.createQueryOperation)(query, owneryQuery, options)), name);\n    this.propop = false;\n    assertGroupNotEmpty(params);\n  }\n  next(item, key, owner, root) {\n    this.childrenNext(item, key, owner, root);\n  }\n}\nclass $All extends core_1.NamedGroupOperation {\n  constructor(params, owneryQuery, options, name) {\n    super(params, owneryQuery, options, params.map(query => (0, core_1.createQueryOperation)(query, owneryQuery, options)), name);\n    this.propop = true;\n  }\n  next(item, key, owner, root) {\n    this.childrenNext(item, key, owner, root);\n  }\n}\nconst $eq = (params, owneryQuery, options) => new core_1.EqualsOperation(params, owneryQuery, options);\nexports.$eq = $eq;\nconst $ne = (params, owneryQuery, options, name) => new $Ne(params, owneryQuery, options, name);\nexports.$ne = $ne;\nconst $or = (params, owneryQuery, options, name) => new $Or(params, owneryQuery, options, name);\nexports.$or = $or;\nconst $nor = (params, owneryQuery, options, name) => new $Nor(params, owneryQuery, options, name);\nexports.$nor = $nor;\nconst $elemMatch = (params, owneryQuery, options, name) => new $ElemMatch(params, owneryQuery, options, name);\nexports.$elemMatch = $elemMatch;\nconst $nin = (params, owneryQuery, options, name) => new $Nin(params, owneryQuery, options, name);\nexports.$nin = $nin;\nconst $in = (params, owneryQuery, options, name) => {\n  return new $In(params, owneryQuery, options, name);\n};\nexports.$in = $in;\nexports.$lt = (0, core_1.numericalOperation)(params => b => b < params);\nexports.$lte = (0, core_1.numericalOperation)(params => b => b <= params);\nexports.$gt = (0, core_1.numericalOperation)(params => b => b > params);\nexports.$gte = (0, core_1.numericalOperation)(params => b => b >= params);\nconst $mod = (_ref, owneryQuery, options) => {\n  let [mod, equalsValue] = _ref;\n  return new core_1.EqualsOperation(b => (0, utils_1.comparable)(b) % mod === equalsValue, owneryQuery, options);\n};\nexports.$mod = $mod;\nconst $exists = (params, owneryQuery, options, name) => new $Exists(params, owneryQuery, options, name);\nexports.$exists = $exists;\nconst $regex = (pattern, owneryQuery, options) => new core_1.EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);\nexports.$regex = $regex;\nconst $not = (params, owneryQuery, options, name) => new $Not(params, owneryQuery, options, name);\nexports.$not = $not;\nconst typeAliases = {\n  number: v => typeof v === \"number\",\n  string: v => typeof v === \"string\",\n  bool: v => typeof v === \"boolean\",\n  array: v => Array.isArray(v),\n  null: v => v === null,\n  timestamp: v => v instanceof Date\n};\nconst $type = (clazz, owneryQuery, options) => new core_1.EqualsOperation(b => {\n  if (typeof clazz === \"string\") {\n    if (!typeAliases[clazz]) {\n      throw new Error(`Type alias does not exist`);\n    }\n    return typeAliases[clazz](b);\n  }\n  return b != null ? b instanceof clazz || b.constructor === clazz : false;\n}, owneryQuery, options);\nexports.$type = $type;\nconst $and = (params, ownerQuery, options, name) => new $And(params, ownerQuery, options, name);\nexports.$and = $and;\nconst $all = (params, ownerQuery, options, name) => new $All(params, ownerQuery, options, name);\nexports.$all = $all;\nconst $size = (params, ownerQuery, options) => new $Size(params, ownerQuery, options, \"$size\");\nexports.$size = $size;\nconst $options = () => null;\nexports.$options = $options;\nconst $where = (params, ownerQuery, options) => {\n  let test;\n  if ((0, utils_1.isFunction)(params)) {\n    test = params;\n  } else if (!process.env.CSP_ENABLED) {\n    test = new Function(\"obj\", \"return \" + params);\n  } else {\n    throw new Error(`In CSP mode, sift does not support strings in \"$where\" condition`);\n  }\n  return new core_1.EqualsOperation(b => test.bind(b)(b), ownerQuery, options);\n};\nexports.$where = $where;","map":{"version":3,"mappings":"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","names":["$Ne","core_1","constructor","init","_test","params","options","compare","reset","keep","next","item","done","$ElemMatch","Error","_queryOperation","owneryQuery","i","length","child","$Not","key","owner","root","$Size","exports","assertGroupNotEmpty","values","$Or","_ops","map","op","success","$Nor","$In","_testers","value","name","toLowerCase","test","$Nin","ownerQuery","_in","$Exists","hasOwnProperty","$And","query","childrenNext","$All","$eq","$ne","$or","$nor","$elemMatch","$nin","$in","b","$mod","mod","equalsValue","$exists","$regex","pattern","RegExp","$options","$not","typeAliases","number","v","string","bool","array","Array","isArray","null","timestamp","Date","$type","clazz","$and","$all","$size","$where","process","env","CSP_ENABLED","Function","bind"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\sift\\src\\operations.ts"],"sourcesContent":["import {\r\n  BaseOperation,\r\n  EqualsOperation,\r\n  Options,\r\n  createTester,\r\n  Tester,\r\n  createQueryOperation,\r\n  QueryOperation,\r\n  Operation,\r\n  Query,\r\n  NamedGroupOperation,\r\n  numericalOperation,\r\n  containsOperation,\r\n  NamedOperation\r\n} from \"./core\";\r\nimport { Key, comparable, isFunction, isArray } from \"./utils\";\r\n\r\nclass $Ne extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  private _test: Tester;\r\n  init() {\r\n    this._test = createTester(this.params, this.options.compare);\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this.keep = true;\r\n  }\r\n  next(item: any) {\r\n    if (this._test(item)) {\r\n      this.done = true;\r\n      this.keep = false;\r\n    }\r\n  }\r\n}\r\n// https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\r\nclass $ElemMatch extends BaseOperation<Query<any>> {\r\n  readonly propop = true;\r\n  private _queryOperation: QueryOperation<any>;\r\n  init() {\r\n    if (!this.params || typeof this.params !== \"object\") {\r\n      throw new Error(`Malformed query. $elemMatch must by an object.`);\r\n    }\r\n    this._queryOperation = createQueryOperation(\r\n      this.params,\r\n      this.owneryQuery,\r\n      this.options\r\n    );\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this._queryOperation.reset();\r\n  }\r\n  next(item: any) {\r\n    if (isArray(item)) {\r\n      for (let i = 0, { length } = item; i < length; i++) {\r\n        // reset query operation since item being tested needs to pass _all_ query\r\n        // operations for it to be a success\r\n        this._queryOperation.reset();\r\n\r\n        const child = item[i];\r\n        this._queryOperation.next(child, i, item, false);\r\n        this.keep = this.keep || this._queryOperation.keep;\r\n      }\r\n      this.done = true;\r\n    } else {\r\n      this.done = false;\r\n      this.keep = false;\r\n    }\r\n  }\r\n}\r\n\r\nclass $Not extends BaseOperation<Query<any>> {\r\n  readonly propop = true;\r\n  private _queryOperation: QueryOperation<any>;\r\n  init() {\r\n    this._queryOperation = createQueryOperation(\r\n      this.params,\r\n      this.owneryQuery,\r\n      this.options\r\n    );\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this._queryOperation.reset();\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this._queryOperation.next(item, key, owner, root);\r\n    this.done = this._queryOperation.done;\r\n    this.keep = !this._queryOperation.keep;\r\n  }\r\n}\r\n\r\nexport class $Size extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  init() {}\r\n  next(item) {\r\n    if (isArray(item) && item.length === this.params) {\r\n      this.done = true;\r\n      this.keep = true;\r\n    }\r\n    // if (parent && parent.length === this.params) {\r\n    //   this.done = true;\r\n    //   this.keep = true;\r\n    // }\r\n  }\r\n}\r\n\r\nconst assertGroupNotEmpty = (values: any[]) => {\r\n  if (values.length === 0) {\r\n    throw new Error(`$and/$or/$nor must be a nonempty array`);\r\n  }\r\n};\r\n\r\nclass $Or extends BaseOperation<any> {\r\n  readonly propop = false;\r\n  private _ops: Operation<any>[];\r\n  init() {\r\n    assertGroupNotEmpty(this.params);\r\n    this._ops = this.params.map(op =>\r\n      createQueryOperation(op, null, this.options)\r\n    );\r\n  }\r\n  reset() {\r\n    this.done = false;\r\n    this.keep = false;\r\n    for (let i = 0, { length } = this._ops; i < length; i++) {\r\n      this._ops[i].reset();\r\n    }\r\n  }\r\n  next(item: any, key: Key, owner: any) {\r\n    let done = false;\r\n    let success = false;\r\n    for (let i = 0, { length } = this._ops; i < length; i++) {\r\n      const op = this._ops[i];\r\n      op.next(item, key, owner);\r\n      if (op.keep) {\r\n        done = true;\r\n        success = op.keep;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.keep = success;\r\n    this.done = done;\r\n  }\r\n}\r\n\r\nclass $Nor extends $Or {\r\n  readonly propop = false;\r\n  next(item: any, key: Key, owner: any) {\r\n    super.next(item, key, owner);\r\n    this.keep = !this.keep;\r\n  }\r\n}\r\n\r\nclass $In extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  private _testers: Tester[];\r\n  init() {\r\n    this._testers = this.params.map(value => {\r\n      if (containsOperation(value, this.options)) {\r\n        throw new Error(`cannot nest $ under ${this.name.toLowerCase()}`);\r\n      }\r\n      return createTester(value, this.options.compare);\r\n    });\r\n  }\r\n  next(item: any, key: Key, owner: any) {\r\n    let done = false;\r\n    let success = false;\r\n    for (let i = 0, { length } = this._testers; i < length; i++) {\r\n      const test = this._testers[i];\r\n      if (test(item)) {\r\n        done = true;\r\n        success = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.keep = success;\r\n    this.done = done;\r\n  }\r\n}\r\n\r\nclass $Nin extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  private _in: $In;\r\n  constructor(params: any, ownerQuery: any, options: Options, name: string) {\r\n    super(params, ownerQuery, options, name);\r\n    this._in = new $In(params, ownerQuery, options, name);\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this._in.next(item, key, owner);\r\n\r\n    if (isArray(owner) && !root) {\r\n      if (this._in.keep) {\r\n        this.keep = false;\r\n        this.done = true;\r\n      } else if (key == owner.length - 1) {\r\n        this.keep = true;\r\n        this.done = true;\r\n      }\r\n    } else {\r\n      this.keep = !this._in.keep;\r\n      this.done = true;\r\n    }\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this._in.reset();\r\n  }\r\n}\r\n\r\nclass $Exists extends BaseOperation<boolean> {\r\n  readonly propop = true;\r\n  next(item: any, key: Key, owner: any) {\r\n    if (owner.hasOwnProperty(key) === this.params) {\r\n      this.done = true;\r\n      this.keep = true;\r\n    }\r\n  }\r\n}\r\n\r\nclass $And extends NamedGroupOperation {\r\n  readonly propop = false;\r\n  constructor(\r\n    params: Query<any>[],\r\n    owneryQuery: Query<any>,\r\n    options: Options,\r\n    name: string\r\n  ) {\r\n    super(\r\n      params,\r\n      owneryQuery,\r\n      options,\r\n      params.map(query => createQueryOperation(query, owneryQuery, options)),\r\n      name\r\n    );\r\n\r\n    assertGroupNotEmpty(params);\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this.childrenNext(item, key, owner, root);\r\n  }\r\n}\r\n\r\nclass $All extends NamedGroupOperation {\r\n  readonly propop = true;\r\n  constructor(\r\n    params: Query<any>[],\r\n    owneryQuery: Query<any>,\r\n    options: Options,\r\n    name: string\r\n  ) {\r\n    super(\r\n      params,\r\n      owneryQuery,\r\n      options,\r\n      params.map(query => createQueryOperation(query, owneryQuery, options)),\r\n      name\r\n    );\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this.childrenNext(item, key, owner, root);\r\n  }\r\n}\r\n\r\nexport const $eq = (params: any, owneryQuery: Query<any>, options: Options) =>\r\n  new EqualsOperation(params, owneryQuery, options);\r\nexport const $ne = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Ne(params, owneryQuery, options, name);\r\nexport const $or = (\r\n  params: Query<any>[],\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Or(params, owneryQuery, options, name);\r\nexport const $nor = (\r\n  params: Query<any>[],\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Nor(params, owneryQuery, options, name);\r\nexport const $elemMatch = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $ElemMatch(params, owneryQuery, options, name);\r\nexport const $nin = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Nin(params, owneryQuery, options, name);\r\nexport const $in = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => {\r\n  return new $In(params, owneryQuery, options, name);\r\n};\r\n\r\nexport const $lt = numericalOperation(params => b => b < params);\r\nexport const $lte = numericalOperation(params => b => b <= params);\r\nexport const $gt = numericalOperation(params => b => b > params);\r\nexport const $gte = numericalOperation(params => b => b >= params);\r\nexport const $mod = (\r\n  [mod, equalsValue]: number[],\r\n  owneryQuery: Query<any>,\r\n  options: Options\r\n) =>\r\n  new EqualsOperation(\r\n    b => comparable(b) % mod === equalsValue,\r\n    owneryQuery,\r\n    options\r\n  );\r\nexport const $exists = (\r\n  params: boolean,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Exists(params, owneryQuery, options, name);\r\nexport const $regex = (\r\n  pattern: string,\r\n  owneryQuery: Query<any>,\r\n  options: Options\r\n) =>\r\n  new EqualsOperation(\r\n    new RegExp(pattern, owneryQuery.$options),\r\n    owneryQuery,\r\n    options\r\n  );\r\nexport const $not = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Not(params, owneryQuery, options, name);\r\n\r\nconst typeAliases = {\r\n  number: v => typeof v === \"number\",\r\n  string: v => typeof v === \"string\",\r\n  bool: v => typeof v === \"boolean\",\r\n  array: v => Array.isArray(v),\r\n  null: v => v === null,\r\n  timestamp: v => v instanceof Date\r\n};\r\n\r\nexport const $type = (\r\n  clazz: Function | string,\r\n  owneryQuery: Query<any>,\r\n  options: Options\r\n) =>\r\n  new EqualsOperation(\r\n    b => {\r\n      if (typeof clazz === \"string\") {\r\n        if (!typeAliases[clazz]) {\r\n          throw new Error(`Type alias does not exist`);\r\n        }\r\n\r\n        return typeAliases[clazz](b);\r\n      }\r\n\r\n      return b != null ? b instanceof clazz || b.constructor === clazz : false;\r\n    },\r\n    owneryQuery,\r\n    options\r\n  );\r\nexport const $and = (\r\n  params: Query<any>[],\r\n  ownerQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $And(params, ownerQuery, options, name);\r\n\r\nexport const $all = (\r\n  params: Query<any>[],\r\n  ownerQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $All(params, ownerQuery, options, name);\r\nexport const $size = (\r\n  params: number,\r\n  ownerQuery: Query<any>,\r\n  options: Options\r\n) => new $Size(params, ownerQuery, options, \"$size\");\r\nexport const $options = () => null;\r\nexport const $where = (\r\n  params: string | Function,\r\n  ownerQuery: Query<any>,\r\n  options: Options\r\n) => {\r\n  let test;\r\n\r\n  if (isFunction(params)) {\r\n    test = params;\r\n  } else if (!process.env.CSP_ENABLED) {\r\n    test = new Function(\"obj\", \"return \" + params);\r\n  } else {\r\n    throw new Error(\r\n      `In CSP mode, sift does not support strings in \"$where\" condition`\r\n    );\r\n  }\r\n\r\n  return new EqualsOperation(b => test.bind(b)(b), ownerQuery, options);\r\n};\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}