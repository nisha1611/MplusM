{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  ConcatSource,\n  RawSource\n} = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst {\n  relative,\n  dirname\n} = require(\"./util/fs\");\nconst {\n  makePathsAbsolute\n} = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\nconst validate = createSchemaValidation(require(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"), () => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"), {\n  name: \"SourceMap DevTool Plugin\",\n  baseDataPath: \"options\"\n});\n/**\r\n * @typedef {object} SourceMapTask\r\n * @property {Source} asset\r\n * @property {AssetInfo} assetInfo\r\n * @property {(string | Module)[]} modules\r\n * @property {string} source\r\n * @property {string} file\r\n * @property {SourceMap} sourceMap\r\n * @property {ItemCacheFacade} cacheItem cache item\r\n */\n\n/**\r\n * Escapes regular expression metacharacters\r\n * @param {string} str String to quote\r\n * @returns {string} Escaped string\r\n */\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\r\n * Creating {@link SourceMapTask} for given file\r\n * @param {string} file current compiled file\r\n * @param {Source} asset the asset\r\n * @param {AssetInfo} assetInfo the asset info\r\n * @param {MapOptions} options source map options\r\n * @param {Compilation} compilation compilation instance\r\n * @param {ItemCacheFacade} cacheItem cache item\r\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\r\n */\nconst getTaskForFile = (file, asset, assetInfo, options, compilation, cacheItem) => {\n  let source;\n  /** @type {SourceMap} */\n  let sourceMap;\n  /**\r\n   * Check if asset can build source map\r\n   */\n  if (asset.sourceAndMap) {\n    const sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = /** @type {SourceMap} */sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = /** @type {SourceMap} */asset.map(options);\n    source = asset.source();\n  }\n  if (!sourceMap || typeof source !== \"string\") return;\n  const context = compilation.options.context;\n  const root = compilation.compiler.root;\n  const cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n  const modules = sourceMap.sources.map(source => {\n    if (!source.startsWith(\"webpack://\")) return source;\n    source = cachedAbsolutify(source.slice(10));\n    const module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    file,\n    asset,\n    source,\n    assetInfo,\n    sourceMap,\n    modules,\n    cacheItem\n  };\n};\nclass SourceMapDevToolPlugin {\n  /**\r\n   * @param {SourceMapDevToolPluginOptions} [options] options object\r\n   * @throws {Error} throws error, if got more than 1 arguments\r\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n\n    /** @type {string | false} */\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n    /** @type {string | Function} */\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n    this.options = options;\n  }\n\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    const outputFs = compiler.outputFileSystem;\n    const sourceMapFilename = this.sourceMapFilename;\n    const sourceMappingURLComment = this.sourceMappingURLComment;\n    const moduleFilenameTemplate = this.moduleFilenameTemplate;\n    const namespace = this.namespace;\n    const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n    const requestShortener = compiler.requestShortener;\n    const options = this.options;\n    options.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n      new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n      compilation.hooks.processAssets.tapAsync({\n        name: \"SourceMapDevToolPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n        additionalAssets: true\n      }, (assets, callback) => {\n        const chunkGraph = compilation.chunkGraph;\n        const cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n        /** @type {Map<string | Module, string>} */\n        const moduleToSourceNameMapping = new Map();\n        /**\r\n         * @type {Function}\r\n         * @returns {void}\r\n         */\n        const reportProgress = ProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n        /** @type {Map<string, Chunk>} */\n        const fileToChunk = new Map();\n        for (const chunk of compilation.chunks) {\n          for (const file of chunk.files) {\n            fileToChunk.set(file, chunk);\n          }\n          for (const file of chunk.auxiliaryFiles) {\n            fileToChunk.set(file, chunk);\n          }\n        }\n\n        /** @type {string[]} */\n        const files = [];\n        for (const file of Object.keys(assets)) {\n          if (matchObject(file)) {\n            files.push(file);\n          }\n        }\n        reportProgress(0.0);\n        /** @type {SourceMapTask[]} */\n        const tasks = [];\n        let fileIndex = 0;\n        asyncLib.each(files, (file, callback) => {\n          const asset = compilation.getAsset(file);\n          if (asset.info.related && asset.info.related.sourceMap) {\n            fileIndex++;\n            return callback();\n          }\n          const cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));\n          cacheItem.get((err, cacheEntry) => {\n            if (err) {\n              return callback(err);\n            }\n            /**\r\n             * If presented in cache, reassigns assets. Cache assets already have source maps.\r\n             */\n            if (cacheEntry) {\n              const {\n                assets,\n                assetsInfo\n              } = cacheEntry;\n              for (const cachedFile of Object.keys(assets)) {\n                if (cachedFile === file) {\n                  compilation.updateAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                } else {\n                  compilation.emitAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                }\n                /**\r\n                 * Add file to chunk, if not presented there\r\n                 */\n                if (cachedFile !== file) {\n                  const chunk = fileToChunk.get(file);\n                  if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);\n                }\n              }\n              reportProgress(0.5 * ++fileIndex / files.length, file, \"restored cached SourceMap\");\n              return callback();\n            }\n            reportProgress(0.5 * fileIndex / files.length, file, \"generate SourceMap\");\n\n            /** @type {SourceMapTask | undefined} */\n            const task = getTaskForFile(file, asset.source, asset.info, {\n              module: options.module,\n              columns: options.columns\n            }, compilation, cacheItem);\n            if (task) {\n              const modules = task.modules;\n              for (let idx = 0; idx < modules.length; idx++) {\n                const module = modules[idx];\n                if (!moduleToSourceNameMapping.get(module)) {\n                  moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, {\n                    requestShortener,\n                    chunkGraph,\n                    hashFunction: compilation.outputOptions.hashFunction\n                  }));\n                }\n              }\n              tasks.push(task);\n            }\n            reportProgress(0.5 * ++fileIndex / files.length, file, \"generated SourceMap\");\n            callback();\n          });\n        }, err => {\n          if (err) {\n            return callback(err);\n          }\n          reportProgress(0.5, \"resolve sources\");\n          /** @type {Set<string>} */\n          const usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          /** @type {Set<string>} */\n          const conflictDetectionSet = new Set();\n\n          /**\r\n           * all modules in defined order (longest identifier first)\r\n           * @type {Array<string | Module>}\r\n           */\n          const allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {\n            const ai = typeof a === \"string\" ? a : a.identifier();\n            const bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          });\n\n          // find modules with conflicting source names\n          for (let idx = 0; idx < allModules.length; idx++) {\n            const module = allModules[idx];\n            let sourceName = moduleToSourceNameMapping.get(module);\n            let hasName = conflictDetectionSet.has(sourceName);\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            }\n\n            // try the fallback name first\n            sourceName = ModuleFilenameHelpers.createFilename(module, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, {\n              requestShortener,\n              chunkGraph,\n              hashFunction: compilation.outputOptions.hashFunction\n            });\n            hasName = usedNamesSet.has(sourceName);\n            if (!hasName) {\n              moduleToSourceNameMapping.set(module, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            }\n\n            // otherwise just append stars until we have a valid name\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n            moduleToSourceNameMapping.set(module, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n          let taskIndex = 0;\n          asyncLib.each(tasks, (task, callback) => {\n            const assets = Object.create(null);\n            const assetsInfo = Object.create(null);\n            const file = task.file;\n            const chunk = fileToChunk.get(file);\n            const sourceMap = task.sourceMap;\n            const source = task.source;\n            const modules = task.modules;\n            reportProgress(0.5 + 0.5 * taskIndex / tasks.length, file, \"attach SourceMap\");\n            const moduleFilenames = modules.map(m => moduleToSourceNameMapping.get(m));\n            sourceMap.sources = moduleFilenames;\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            const usesContentHash = sourceMapFilename && /\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\n\n            // If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n            if (usesContentHash && task.assetInfo.contenthash) {\n              const contenthash = task.assetInfo.contenthash;\n              let pattern;\n              if (Array.isArray(contenthash)) {\n                pattern = contenthash.map(quoteMeta).join(\"|\");\n              } else {\n                pattern = quoteMeta(contenthash);\n              }\n              sourceMap.file = sourceMap.file.replace(new RegExp(pattern, \"g\"), m => \"x\".repeat(m.length));\n            }\n\n            /** @type {string | false} */\n            let currentSourceMappingURLComment = sourceMappingURLComment;\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n            const sourceMapString = JSON.stringify(sourceMap);\n            if (sourceMapFilename) {\n              let filename = file;\n              const sourceMapContentHash = usesContentHash && /** @type {string} */\n              createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest(\"hex\");\n              const pathParams = {\n                chunk,\n                filename: options.fileContext ? relative(outputFs, `/${options.fileContext}`, `/${filename}`) : filename,\n                contentHash: sourceMapContentHash\n              };\n              const {\n                path: sourceMapFile,\n                info: sourceMapInfo\n              } = compilation.getPathWithInfo(sourceMapFilename, pathParams);\n              const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, `/${file}`), `/${sourceMapFile}`);\n              /** @type {Source} */\n              let asset = new RawSource(source);\n              if (currentSourceMappingURLComment !== false) {\n                // Add source map url to compilation asset, if currentSourceMappingURLComment is set\n                asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                  url: sourceMapUrl\n                }, pathParams)));\n              }\n              const assetInfo = {\n                related: {\n                  sourceMap: sourceMapFile\n                }\n              };\n              assets[file] = asset;\n              assetsInfo[file] = assetInfo;\n              compilation.updateAsset(file, asset, assetInfo);\n              // Add source map file to compilation assets and chunk files\n              const sourceMapAsset = new RawSource(sourceMapString);\n              const sourceMapAssetInfo = {\n                ...sourceMapInfo,\n                development: true\n              };\n              assets[sourceMapFile] = sourceMapAsset;\n              assetsInfo[sourceMapFile] = sourceMapAssetInfo;\n              compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo);\n              if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n              /**\r\n               * Add source map as data url to asset\r\n               */\n              const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, () => sourceMapString).replace(/\\[url\\]/g, () => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\")}`));\n              assets[file] = asset;\n              assetsInfo[file] = undefined;\n              compilation.updateAsset(file, asset);\n            }\n            task.cacheItem.store({\n              assets,\n              assetsInfo\n            }, err => {\n              reportProgress(0.5 + 0.5 * ++taskIndex / tasks.length, task.file, \"attached SourceMap\");\n              if (err) {\n                return callback(err);\n              }\n              callback();\n            });\n          }, err => {\n            reportProgress(1.0);\n            callback(err);\n          });\n        });\n      });\n    });\n  }\n}\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"names":["asyncLib","require","ConcatSource","RawSource","Compilation","ModuleFilenameHelpers","ProgressPlugin","SourceMapDevToolModuleOptionsPlugin","createSchemaValidation","createHash","relative","dirname","makePathsAbsolute","validate","name","baseDataPath","quoteMeta","str","replace","getTaskForFile","file","asset","assetInfo","options","compilation","cacheItem","source","sourceMap","sourceAndMap","map","context","root","compiler","cachedAbsolutify","bindContextCache","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","constructor","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","apply","outputFs","outputFileSystem","requestShortener","test","matchObject","bind","undefined","hooks","tap","processAssets","tapAsync","stage","PROCESS_ASSETS_STAGE_DEV_TOOLING","additionalAssets","assets","callback","chunkGraph","cache","getCache","moduleToSourceNameMapping","Map","reportProgress","getReporter","fileToChunk","chunk","chunks","files","set","auxiliaryFiles","Object","keys","push","tasks","fileIndex","each","getAsset","info","related","getItemCache","mergeEtags","getLazyHashedEtag","get","err","cacheEntry","assetsInfo","cachedFile","updateAsset","emitAsset","add","length","task","columns","idx","createFilename","hashFunction","outputOptions","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","sort","a","b","ai","identifier","bi","sourceName","hasName","has","taskIndex","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","usesContentHash","contenthash","pattern","isArray","join","RegExp","repeat","currentSourceMappingURLComment","sourceMapString","JSON","stringify","sourceMapContentHash","update","digest","pathParams","fileContext","contentHash","path","sourceMapFile","sourceMapInfo","getPathWithInfo","sourceMapUrl","publicPath","getPath","assign","url","sourceMapAsset","sourceMapAssetInfo","development","Error","Buffer","toString","store","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst asyncLib = require(\"neo-async\");\r\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\r\nconst Compilation = require(\"./Compilation\");\r\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\r\nconst ProgressPlugin = require(\"./ProgressPlugin\");\r\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\r\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\r\nconst createHash = require(\"./util/createHash\");\r\nconst { relative, dirname } = require(\"./util/fs\");\r\nconst { makePathsAbsolute } = require(\"./util/identifier\");\r\n\r\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\r\n/** @typedef {import(\"webpack-sources\").Source} Source */\r\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\r\n/** @typedef {import(\"./Cache\").Etag} Etag */\r\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\r\n/** @typedef {import(\"./Chunk\")} Chunk */\r\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\r\n/** @typedef {import(\"./Compiler\")} Compiler */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\r\n/** @typedef {import(\"./util/Hash\")} Hash */\r\n\r\nconst validate = createSchemaValidation(\r\n\trequire(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"),\r\n\t() => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"),\r\n\t{\r\n\t\tname: \"SourceMap DevTool Plugin\",\r\n\t\tbaseDataPath: \"options\"\r\n\t}\r\n);\r\n/**\r\n * @typedef {object} SourceMapTask\r\n * @property {Source} asset\r\n * @property {AssetInfo} assetInfo\r\n * @property {(string | Module)[]} modules\r\n * @property {string} source\r\n * @property {string} file\r\n * @property {SourceMap} sourceMap\r\n * @property {ItemCacheFacade} cacheItem cache item\r\n */\r\n\r\n/**\r\n * Escapes regular expression metacharacters\r\n * @param {string} str String to quote\r\n * @returns {string} Escaped string\r\n */\r\nconst quoteMeta = str => {\r\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\r\n};\r\n\r\n/**\r\n * Creating {@link SourceMapTask} for given file\r\n * @param {string} file current compiled file\r\n * @param {Source} asset the asset\r\n * @param {AssetInfo} assetInfo the asset info\r\n * @param {MapOptions} options source map options\r\n * @param {Compilation} compilation compilation instance\r\n * @param {ItemCacheFacade} cacheItem cache item\r\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\r\n */\r\nconst getTaskForFile = (\r\n\tfile,\r\n\tasset,\r\n\tassetInfo,\r\n\toptions,\r\n\tcompilation,\r\n\tcacheItem\r\n) => {\r\n\tlet source;\r\n\t/** @type {SourceMap} */\r\n\tlet sourceMap;\r\n\t/**\r\n\t * Check if asset can build source map\r\n\t */\r\n\tif (asset.sourceAndMap) {\r\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\r\n\t\tsourceMap = /** @type {SourceMap} */ (sourceAndMap.map);\r\n\t\tsource = sourceAndMap.source;\r\n\t} else {\r\n\t\tsourceMap = /** @type {SourceMap} */ (asset.map(options));\r\n\t\tsource = asset.source();\r\n\t}\r\n\tif (!sourceMap || typeof source !== \"string\") return;\r\n\tconst context = compilation.options.context;\r\n\tconst root = compilation.compiler.root;\r\n\tconst cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\r\n\tconst modules = sourceMap.sources.map(source => {\r\n\t\tif (!source.startsWith(\"webpack://\")) return source;\r\n\t\tsource = cachedAbsolutify(source.slice(10));\r\n\t\tconst module = compilation.findModule(source);\r\n\t\treturn module || source;\r\n\t});\r\n\r\n\treturn {\r\n\t\tfile,\r\n\t\tasset,\r\n\t\tsource,\r\n\t\tassetInfo,\r\n\t\tsourceMap,\r\n\t\tmodules,\r\n\t\tcacheItem\r\n\t};\r\n};\r\n\r\nclass SourceMapDevToolPlugin {\r\n\t/**\r\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\r\n\t * @throws {Error} throws error, if got more than 1 arguments\r\n\t */\r\n\tconstructor(options = {}) {\r\n\t\tvalidate(options);\r\n\r\n\t\t/** @type {string | false} */\r\n\t\tthis.sourceMapFilename = options.filename;\r\n\t\t/** @type {string | false} */\r\n\t\tthis.sourceMappingURLComment =\r\n\t\t\toptions.append === false\r\n\t\t\t\t? false\r\n\t\t\t\t: options.append || \"\\n//# source\" + \"MappingURL=[url]\";\r\n\t\t/** @type {string | Function} */\r\n\t\tthis.moduleFilenameTemplate =\r\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\r\n\t\t/** @type {string | Function} */\r\n\t\tthis.fallbackModuleFilenameTemplate =\r\n\t\t\toptions.fallbackModuleFilenameTemplate ||\r\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\r\n\t\t/** @type {string} */\r\n\t\tthis.namespace = options.namespace || \"\";\r\n\t\t/** @type {SourceMapDevToolPluginOptions} */\r\n\t\tthis.options = options;\r\n\t}\r\n\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tconst outputFs = compiler.outputFileSystem;\r\n\t\tconst sourceMapFilename = this.sourceMapFilename;\r\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\r\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\r\n\t\tconst namespace = this.namespace;\r\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\r\n\t\tconst requestShortener = compiler.requestShortener;\r\n\t\tconst options = this.options;\r\n\t\toptions.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\r\n\r\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\r\n\t\t\tundefined,\r\n\t\t\toptions\r\n\t\t);\r\n\r\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\r\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\r\n\r\n\t\t\tcompilation.hooks.processAssets.tapAsync(\r\n\t\t\t\t{\r\n\t\t\t\t\tname: \"SourceMapDevToolPlugin\",\r\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\r\n\t\t\t\t\tadditionalAssets: true\r\n\t\t\t\t},\r\n\t\t\t\t(assets, callback) => {\r\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\r\n\t\t\t\t\tconst cache = compilation.getCache(\"SourceMapDevToolPlugin\");\r\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\r\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @type {Function}\r\n\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst reportProgress =\r\n\t\t\t\t\t\tProgressPlugin.getReporter(compilation.compiler) || (() => {});\r\n\r\n\t\t\t\t\t/** @type {Map<string, Chunk>} */\r\n\t\t\t\t\tconst fileToChunk = new Map();\r\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\r\n\t\t\t\t\t\tfor (const file of chunk.files) {\r\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\r\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/** @type {string[]} */\r\n\t\t\t\t\tconst files = [];\r\n\t\t\t\t\tfor (const file of Object.keys(assets)) {\r\n\t\t\t\t\t\tif (matchObject(file)) {\r\n\t\t\t\t\t\t\tfiles.push(file);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treportProgress(0.0);\r\n\t\t\t\t\t/** @type {SourceMapTask[]} */\r\n\t\t\t\t\tconst tasks = [];\r\n\t\t\t\t\tlet fileIndex = 0;\r\n\r\n\t\t\t\t\tasyncLib.each(\r\n\t\t\t\t\t\tfiles,\r\n\t\t\t\t\t\t(file, callback) => {\r\n\t\t\t\t\t\t\tconst asset = compilation.getAsset(file);\r\n\t\t\t\t\t\t\tif (asset.info.related && asset.info.related.sourceMap) {\r\n\t\t\t\t\t\t\t\tfileIndex++;\r\n\t\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst cacheItem = cache.getItemCache(\r\n\t\t\t\t\t\t\t\tfile,\r\n\t\t\t\t\t\t\t\tcache.mergeEtags(\r\n\t\t\t\t\t\t\t\t\tcache.getLazyHashedEtag(asset.source),\r\n\t\t\t\t\t\t\t\t\tnamespace\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tcacheItem.get((err, cacheEntry) => {\r\n\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\treturn callback(err);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\tif (cacheEntry) {\r\n\t\t\t\t\t\t\t\t\tconst { assets, assetsInfo } = cacheEntry;\r\n\t\t\t\t\t\t\t\t\tfor (const cachedFile of Object.keys(assets)) {\r\n\t\t\t\t\t\t\t\t\t\tif (cachedFile === file) {\r\n\t\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(\r\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\r\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\r\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\r\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\r\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\r\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\r\n\t\t\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t\t\tif (cachedFile !== file) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\r\n\t\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(cachedFile);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\r\n\t\t\t\t\t\t\t\t\t\tfile,\r\n\t\t\t\t\t\t\t\t\t\t\"restored cached SourceMap\"\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t(0.5 * fileIndex) / files.length,\r\n\t\t\t\t\t\t\t\t\tfile,\r\n\t\t\t\t\t\t\t\t\t\"generate SourceMap\"\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\r\n\t\t\t\t\t\t\t\tconst task = getTaskForFile(\r\n\t\t\t\t\t\t\t\t\tfile,\r\n\t\t\t\t\t\t\t\t\tasset.source,\r\n\t\t\t\t\t\t\t\t\tasset.info,\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tmodule: options.module,\r\n\t\t\t\t\t\t\t\t\t\tcolumns: options.columns\r\n\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\tcompilation,\r\n\t\t\t\t\t\t\t\t\tcacheItem\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tif (task) {\r\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\r\n\r\n\t\t\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\r\n\t\t\t\t\t\t\t\t\t\tconst module = modules[idx];\r\n\t\t\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\r\n\t\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\r\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequestShortener,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\ttasks.push(task);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\r\n\t\t\t\t\t\t\t\t\tfile,\r\n\t\t\t\t\t\t\t\t\t\"generated SourceMap\"\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tcallback();\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\terr => {\r\n\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\treturn callback(err);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treportProgress(0.5, \"resolve sources\");\r\n\t\t\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\r\n\t\t\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\t\t\tconst conflictDetectionSet = new Set();\r\n\r\n\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t * all modules in defined order (longest identifier first)\r\n\t\t\t\t\t\t\t * @type {Array<string | Module>}\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\tconst allModules = Array.from(\r\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.keys()\r\n\t\t\t\t\t\t\t).sort((a, b) => {\r\n\t\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\r\n\t\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\r\n\t\t\t\t\t\t\t\treturn ai.length - bi.length;\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t// find modules with conflicting source names\r\n\t\t\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\r\n\t\t\t\t\t\t\t\tconst module = allModules[idx];\r\n\t\t\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\r\n\t\t\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\r\n\t\t\t\t\t\t\t\tif (!hasName) {\r\n\t\t\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// try the fallback name first\r\n\t\t\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\r\n\t\t\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\r\n\t\t\t\t\t\t\t\t\t\tnamespace: namespace\r\n\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\trequestShortener,\r\n\t\t\t\t\t\t\t\t\t\tchunkGraph,\r\n\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\r\n\t\t\t\t\t\t\t\tif (!hasName) {\r\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\r\n\t\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// otherwise just append stars until we have a valid name\r\n\t\t\t\t\t\t\t\twhile (hasName) {\r\n\t\t\t\t\t\t\t\t\tsourceName += \"*\";\r\n\t\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\r\n\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tlet taskIndex = 0;\r\n\r\n\t\t\t\t\t\t\tasyncLib.each(\r\n\t\t\t\t\t\t\t\ttasks,\r\n\t\t\t\t\t\t\t\t(task, callback) => {\r\n\t\t\t\t\t\t\t\t\tconst assets = Object.create(null);\r\n\t\t\t\t\t\t\t\t\tconst assetsInfo = Object.create(null);\r\n\t\t\t\t\t\t\t\t\tconst file = task.file;\r\n\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\r\n\t\t\t\t\t\t\t\t\tconst sourceMap = task.sourceMap;\r\n\t\t\t\t\t\t\t\t\tconst source = task.source;\r\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\r\n\r\n\t\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * taskIndex) / tasks.length,\r\n\t\t\t\t\t\t\t\t\t\tfile,\r\n\t\t\t\t\t\t\t\t\t\t\"attach SourceMap\"\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\r\n\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\r\n\t\t\t\t\t\t\t\t\tif (options.noSources) {\r\n\t\t\t\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\r\n\t\t\t\t\t\t\t\t\tsourceMap.file = file;\r\n\t\t\t\t\t\t\t\t\tconst usesContentHash =\r\n\t\t\t\t\t\t\t\t\t\tsourceMapFilename &&\r\n\t\t\t\t\t\t\t\t\t\t/\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\r\n\r\n\t\t\t\t\t\t\t\t\t// If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\r\n\t\t\t\t\t\t\t\t\tif (usesContentHash && task.assetInfo.contenthash) {\r\n\t\t\t\t\t\t\t\t\t\tconst contenthash = task.assetInfo.contenthash;\r\n\t\t\t\t\t\t\t\t\t\tlet pattern;\r\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(contenthash)) {\r\n\t\t\t\t\t\t\t\t\t\t\tpattern = contenthash.map(quoteMeta).join(\"|\");\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tpattern = quoteMeta(contenthash);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tsourceMap.file = sourceMap.file.replace(\r\n\t\t\t\t\t\t\t\t\t\t\tnew RegExp(pattern, \"g\"),\r\n\t\t\t\t\t\t\t\t\t\t\tm => \"x\".repeat(m.length)\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t/** @type {string | false} */\r\n\t\t\t\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\r\n\t\t\t\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment =\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment.replace(\r\n\t\t\t\t\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\r\n\t\t\t\t\t\t\t\t\tif (sourceMapFilename) {\r\n\t\t\t\t\t\t\t\t\t\tlet filename = file;\r\n\t\t\t\t\t\t\t\t\t\tconst sourceMapContentHash =\r\n\t\t\t\t\t\t\t\t\t\t\tusesContentHash &&\r\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (\r\n\t\t\t\t\t\t\t\t\t\t\t\tcreateHash(compilation.outputOptions.hashFunction)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.update(sourceMapString)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.digest(\"hex\")\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\tconst pathParams = {\r\n\t\t\t\t\t\t\t\t\t\t\tchunk,\r\n\t\t\t\t\t\t\t\t\t\t\tfilename: options.fileContext\r\n\t\t\t\t\t\t\t\t\t\t\t\t? relative(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${options.fileContext}`,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${filename}`\r\n\t\t\t\t\t\t\t\t\t\t\t\t  )\r\n\t\t\t\t\t\t\t\t\t\t\t\t: filename,\r\n\t\t\t\t\t\t\t\t\t\t\tcontentHash: sourceMapContentHash\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\tconst { path: sourceMapFile, info: sourceMapInfo } =\r\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\r\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapFilename,\r\n\t\t\t\t\t\t\t\t\t\t\t\tpathParams\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\r\n\t\t\t\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile\r\n\t\t\t\t\t\t\t\t\t\t\t: relative(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdirname(outputFs, `/${file}`),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t`/${sourceMapFile}`\r\n\t\t\t\t\t\t\t\t\t\t\t  );\r\n\t\t\t\t\t\t\t\t\t\t/** @type {Source} */\r\n\t\t\t\t\t\t\t\t\t\tlet asset = new RawSource(source);\r\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\r\n\t\t\t\t\t\t\t\t\t\t\t// Add source map url to compilation asset, if currentSourceMappingURLComment is set\r\n\t\t\t\t\t\t\t\t\t\t\tasset = new ConcatSource(\r\n\t\t\t\t\t\t\t\t\t\t\t\tasset,\r\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.getPath(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\r\n\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tconst assetInfo = {\r\n\t\t\t\t\t\t\t\t\t\t\trelated: { sourceMap: sourceMapFile }\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\r\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = assetInfo;\r\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset, assetInfo);\r\n\t\t\t\t\t\t\t\t\t\t// Add source map file to compilation assets and chunk files\r\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAsset = new RawSource(sourceMapString);\r\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAssetInfo = {\r\n\t\t\t\t\t\t\t\t\t\t\t...sourceMapInfo,\r\n\t\t\t\t\t\t\t\t\t\t\tdevelopment: true\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\tassets[sourceMapFile] = sourceMapAsset;\r\n\t\t\t\t\t\t\t\t\t\tassetsInfo[sourceMapFile] = sourceMapAssetInfo;\r\n\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\r\n\t\t\t\t\t\t\t\t\t\t\tsourceMapFile,\r\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAsset,\r\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAssetInfo\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(sourceMapFile);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\r\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\r\n\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t\t\t * Add source map as data url to asset\r\n\t\t\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\r\n\t\t\t\t\t\t\t\t\t\t\tnew RawSource(source),\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\r\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\r\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\r\n\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\r\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = undefined;\r\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\ttask.cacheItem.store({ assets, assetsInfo }, err => {\r\n\t\t\t\t\t\t\t\t\t\treportProgress(\r\n\t\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * ++taskIndex) / tasks.length,\r\n\t\t\t\t\t\t\t\t\t\t\ttask.file,\r\n\t\t\t\t\t\t\t\t\t\t\t\"attached SourceMap\"\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcallback();\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\terr => {\r\n\t\t\t\t\t\t\t\t\treportProgress(1.0);\r\n\t\t\t\t\t\t\t\t\tcallback(err);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = SourceMapDevToolPlugin;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}