{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nconst kPipeline = Symbol('pipeline');\n/** @internal */\nconst kOptions = Symbol('options');\n/**\r\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\r\n * allowing for iteration over the results returned from the underlying query. It supports\r\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\r\n * or higher stream\r\n * @public\r\n */\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n  /** @internal */\n  constructor(client, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(client, namespace, options);\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n  get pipeline() {\n    return this[kPipeline];\n  }\n  clone() {\n    const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.client, this.namespace, this[kPipeline], {\n      ...clonedOptions\n    });\n  }\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {\n      ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server: aggregateOperation.server,\n        session,\n        response\n      });\n    });\n  }\n  explain(verbosity, callback) {\n    if (typeof verbosity === 'function') callback = verbosity, verbosity = true;\n    if (verbosity == null) verbosity = true;\n    return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {\n      ...this[kOptions],\n      ...this.cursorOptions,\n      explain: verbosity\n    }), callback);\n  }\n  group($group) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $group\n    });\n    return this;\n  }\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $limit\n    });\n    return this;\n  }\n  /** Add a match stage to the aggregation pipeline */\n  match($match) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $match\n    });\n    return this;\n  }\n  /** Add an out stage to the aggregation pipeline */\n  out($out) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $out\n    });\n    return this;\n  }\n  /**\r\n   * Add a project stage to the aggregation pipeline\r\n   *\r\n   * @remarks\r\n   * In order to strictly type this function you must provide an interface\r\n   * that represents the effect of your projection on the result documents.\r\n   *\r\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\r\n   * You should specify a parameterized type to have assertions on your final results.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Best way\r\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * // Flexible way\r\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * In order to strictly type this function you must provide an interface\r\n   * that represents the effect of your projection on the result documents.\r\n   *\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling project,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\r\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\r\n   *\r\n   * // or always use chaining and save the final cursor\r\n   *\r\n   * const cursor = coll.aggregate().project<{ a: string }>({\r\n   *   _id: 0,\r\n   *   a: { $convert: { input: '$a', to: 'string' }\r\n   * }});\r\n   * ```\r\n   */\n  project($project) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $project\n    });\n    return this;\n  }\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $lookup\n    });\n    return this;\n  }\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $redact\n    });\n    return this;\n  }\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $skip\n    });\n    return this;\n  }\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $sort\n    });\n    return this;\n  }\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $unwind\n    });\n    return this;\n  }\n  /** Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $geoNear\n    });\n    return this;\n  }\n}\nexports.AggregationCursor = AggregationCursor;","map":{"version":3,"mappings":";;;;;;AAGA;AACA;AAIA;AAEA;AAKA;AACA,MAAMA,SAAS,GAAGC,MAAM,CAAC,UAAU,CAAC;AACpC;AACA,MAAMC,QAAQ,GAAGD,MAAM,CAAC,SAAS,CAAC;AAElC;;;;;;;AAOA,MAAaE,iBAAiC,SAAQC,gCAAuB;EAM3E;EACAC,YACEC,MAAmB,EACnBC,SAA2B,EAEG;IAAA,IAD9BC,+EAAuB,EAAE;IAAA,IACzBC,8EAA4B,EAAE;IAE9B,KAAK,CAACH,MAAM,EAAEC,SAAS,EAAEE,OAAO,CAAC;IAEjC,IAAI,CAACT,SAAS,CAAC,GAAGQ,QAAQ;IAC1B,IAAI,CAACN,QAAQ,CAAC,GAAGO,OAAO;EAC1B;EAEA,IAAID,QAAQ;IACV,OAAO,IAAI,CAACR,SAAS,CAAC;EACxB;EAEAU,KAAK;IACH,MAAMC,aAAa,GAAG,wBAAY,EAAC,EAAE,EAAE,IAAI,CAACT,QAAQ,CAAC,CAAC;IACtD,OAAOS,aAAa,CAACC,OAAO;IAC5B,OAAO,IAAIT,iBAAiB,CAAC,IAAI,CAACG,MAAM,EAAE,IAAI,CAACC,SAAS,EAAE,IAAI,CAACP,SAAS,CAAC,EAAE;MACzE,GAAGW;KACJ,CAAC;EACJ;EAESE,GAAG,CAAIC,SAA8B;IAC5C,OAAO,KAAK,CAACD,GAAG,CAACC,SAAS,CAAyB;EACrD;EAEA;EACAC,WAAW,CAACH,OAAsB,EAAEI,QAAmC;IACrE,MAAMC,kBAAkB,GAAG,IAAIC,8BAAkB,CAAC,IAAI,CAACX,SAAS,EAAE,IAAI,CAACP,SAAS,CAAC,EAAE;MACjF,GAAG,IAAI,CAACE,QAAQ,CAAC;MACjB,GAAG,IAAI,CAACiB,aAAa;MACrBP;KACD,CAAC;IAEF,wCAAgB,EAAC,IAAI,CAACN,MAAM,EAAEW,kBAAkB,EAAE,CAACG,GAAG,EAAEC,QAAQ,KAAI;MAClE,IAAID,GAAG,IAAIC,QAAQ,IAAI,IAAI,EAAE,OAAOL,QAAQ,CAACI,GAAG,CAAC;MAEjD;MACAJ,QAAQ,CAACM,SAAS,EAAE;QAAEC,MAAM,EAAEN,kBAAkB,CAACM,MAAM;QAAEX,OAAO;QAAES;MAAQ,CAAE,CAAC;IAC/E,CAAC,CAAC;EACJ;EAOAG,OAAO,CACLC,SAA2C,EAC3CT,QAA6B;IAE7B,IAAI,OAAOS,SAAS,KAAK,UAAU,EAAGT,QAAQ,GAAGS,SAAS,EAAIA,SAAS,GAAG,IAAK;IAC/E,IAAIA,SAAS,IAAI,IAAI,EAAEA,SAAS,GAAG,IAAI;IAEvC,OAAO,wCAAgB,EACrB,IAAI,CAACnB,MAAM,EACX,IAAIY,8BAAkB,CAAC,IAAI,CAACX,SAAS,EAAE,IAAI,CAACP,SAAS,CAAC,EAAE;MACtD,GAAG,IAAI,CAACE,QAAQ,CAAC;MACjB,GAAG,IAAI,CAACiB,aAAa;MACrBK,OAAO,EAAEC;KACV,CAAC,EACFT,QAAQ,CACT;EACH;EAIAU,KAAK,CAACC,MAAgB;IACpB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAC3B,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAED;IAAM,CAAE,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;EACAE,KAAK,CAACC,MAAc;IAClB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEE;IAAM,CAAE,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;EACAC,KAAK,CAACC,MAAgB;IACpB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAChC,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEI;IAAM,CAAE,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;EACAC,GAAG,CAACC,IAA2C;IAC7C,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAClC,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEM;IAAI,CAAE,CAAC;IAC9B,OAAO,IAAI;EACb;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyCAC,OAAO,CAAgCC,QAAkB;IACvD,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAACpC,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEQ;IAAQ,CAAE,CAAC;IAClC,OAAO,IAAuC;EAChD;EAEA;EACAC,MAAM,CAACC,OAAiB;IACtB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAACtC,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEU;IAAO,CAAE,CAAC;IACjC,OAAO,IAAI;EACb;EAEA;EACAC,MAAM,CAACC,OAAiB;IACtB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAACxC,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEY;IAAO,CAAE,CAAC;IACjC,OAAO,IAAI;EACb;EAEA;EACAC,IAAI,CAACC,KAAa;IAChB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAC1C,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEc;IAAK,CAAE,CAAC;IAC/B,OAAO,IAAI;EACb;EAEA;EACAC,IAAI,CAACC,KAAW;IACd,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAC5C,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEgB;IAAK,CAAE,CAAC;IAC/B,OAAO,IAAI;EACb;EAEA;EACAC,MAAM,CAACC,OAA0B;IAC/B,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAC9C,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEkB;IAAO,CAAE,CAAC;IACjC,OAAO,IAAI;EACb;EAEA;EACAC,OAAO,CAACC,QAAkB;IACxB,yCAAmB,EAAC,IAAI,CAAC;IACzB,IAAI,CAAChD,SAAS,CAAC,CAAC4B,IAAI,CAAC;MAAEoB;IAAQ,CAAE,CAAC;IAClC,OAAO,IAAI;EACb;;AA9LFC","names":["kPipeline","Symbol","kOptions","AggregationCursor","abstract_cursor_1","constructor","client","namespace","pipeline","options","clone","clonedOptions","session","map","transform","_initialize","callback","aggregateOperation","aggregate_1","cursorOptions","err","response","undefined","server","explain","verbosity","group","$group","push","limit","$limit","match","$match","out","$out","project","$project","lookup","$lookup","redact","$redact","skip","$skip","sort","$sort","unwind","$unwind","geoNear","$geoNear","exports"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\cursor\\aggregation_cursor.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport type { ExplainVerbosityLike } from '../explain';\r\nimport type { MongoClient } from '../mongo_client';\r\nimport { AggregateOperation, AggregateOptions } from '../operations/aggregate';\r\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Sort } from '../sort';\r\nimport type { Callback, MongoDBNamespace } from '../utils';\r\nimport { mergeOptions } from '../utils';\r\nimport type { AbstractCursorOptions } from './abstract_cursor';\r\nimport { AbstractCursor, assertUninitialized } from './abstract_cursor';\r\n\r\n/** @public */\r\nexport interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {}\r\n\r\n/** @internal */\r\nconst kPipeline = Symbol('pipeline');\r\n/** @internal */\r\nconst kOptions = Symbol('options');\r\n\r\n/**\r\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\r\n * allowing for iteration over the results returned from the underlying query. It supports\r\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\r\n * or higher stream\r\n * @public\r\n */\r\nexport class AggregationCursor<TSchema = any> extends AbstractCursor<TSchema> {\r\n  /** @internal */\r\n  [kPipeline]: Document[];\r\n  /** @internal */\r\n  [kOptions]: AggregateOptions;\r\n\r\n  /** @internal */\r\n  constructor(\r\n    client: MongoClient,\r\n    namespace: MongoDBNamespace,\r\n    pipeline: Document[] = [],\r\n    options: AggregateOptions = {}\r\n  ) {\r\n    super(client, namespace, options);\r\n\r\n    this[kPipeline] = pipeline;\r\n    this[kOptions] = options;\r\n  }\r\n\r\n  get pipeline(): Document[] {\r\n    return this[kPipeline];\r\n  }\r\n\r\n  clone(): AggregationCursor<TSchema> {\r\n    const clonedOptions = mergeOptions({}, this[kOptions]);\r\n    delete clonedOptions.session;\r\n    return new AggregationCursor(this.client, this.namespace, this[kPipeline], {\r\n      ...clonedOptions\r\n    });\r\n  }\r\n\r\n  override map<T>(transform: (doc: TSchema) => T): AggregationCursor<T> {\r\n    return super.map(transform) as AggregationCursor<T>;\r\n  }\r\n\r\n  /** @internal */\r\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\r\n    const aggregateOperation = new AggregateOperation(this.namespace, this[kPipeline], {\r\n      ...this[kOptions],\r\n      ...this.cursorOptions,\r\n      session\r\n    });\r\n\r\n    executeOperation(this.client, aggregateOperation, (err, response) => {\r\n      if (err || response == null) return callback(err);\r\n\r\n      // TODO: NODE-2882\r\n      callback(undefined, { server: aggregateOperation.server, session, response });\r\n    });\r\n  }\r\n\r\n  /** Execute the explain for the cursor */\r\n  explain(): Promise<Document>;\r\n  explain(verbosity: ExplainVerbosityLike): Promise<Document>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  explain(callback: Callback): void;\r\n  explain(\r\n    verbosity?: ExplainVerbosityLike | Callback,\r\n    callback?: Callback<Document>\r\n  ): Promise<Document> | void {\r\n    if (typeof verbosity === 'function') (callback = verbosity), (verbosity = true);\r\n    if (verbosity == null) verbosity = true;\r\n\r\n    return executeOperation(\r\n      this.client,\r\n      new AggregateOperation(this.namespace, this[kPipeline], {\r\n        ...this[kOptions], // NOTE: order matters here, we may need to refine this\r\n        ...this.cursorOptions,\r\n        explain: verbosity\r\n      }),\r\n      callback\r\n    );\r\n  }\r\n\r\n  /** Add a group stage to the aggregation pipeline */\r\n  group<T = TSchema>($group: Document): AggregationCursor<T>;\r\n  group($group: Document): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $group });\r\n    return this;\r\n  }\r\n\r\n  /** Add a limit stage to the aggregation pipeline */\r\n  limit($limit: number): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $limit });\r\n    return this;\r\n  }\r\n\r\n  /** Add a match stage to the aggregation pipeline */\r\n  match($match: Document): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $match });\r\n    return this;\r\n  }\r\n\r\n  /** Add an out stage to the aggregation pipeline */\r\n  out($out: { db: string; coll: string } | string): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $out });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a project stage to the aggregation pipeline\r\n   *\r\n   * @remarks\r\n   * In order to strictly type this function you must provide an interface\r\n   * that represents the effect of your projection on the result documents.\r\n   *\r\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\r\n   * You should specify a parameterized type to have assertions on your final results.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Best way\r\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * // Flexible way\r\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * In order to strictly type this function you must provide an interface\r\n   * that represents the effect of your projection on the result documents.\r\n   *\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling project,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\r\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\r\n   *\r\n   * // or always use chaining and save the final cursor\r\n   *\r\n   * const cursor = coll.aggregate().project<{ a: string }>({\r\n   *   _id: 0,\r\n   *   a: { $convert: { input: '$a', to: 'string' }\r\n   * }});\r\n   * ```\r\n   */\r\n  project<T extends Document = Document>($project: Document): AggregationCursor<T> {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $project });\r\n    return this as unknown as AggregationCursor<T>;\r\n  }\r\n\r\n  /** Add a lookup stage to the aggregation pipeline */\r\n  lookup($lookup: Document): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $lookup });\r\n    return this;\r\n  }\r\n\r\n  /** Add a redact stage to the aggregation pipeline */\r\n  redact($redact: Document): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $redact });\r\n    return this;\r\n  }\r\n\r\n  /** Add a skip stage to the aggregation pipeline */\r\n  skip($skip: number): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $skip });\r\n    return this;\r\n  }\r\n\r\n  /** Add a sort stage to the aggregation pipeline */\r\n  sort($sort: Sort): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $sort });\r\n    return this;\r\n  }\r\n\r\n  /** Add a unwind stage to the aggregation pipeline */\r\n  unwind($unwind: Document | string): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $unwind });\r\n    return this;\r\n  }\r\n\r\n  /** Add a geoNear stage to the aggregation pipeline */\r\n  geoNear($geoNear: Document): this {\r\n    assertUninitialized(this);\r\n    this[kPipeline].push({ $geoNear });\r\n    return this;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}