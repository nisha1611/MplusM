{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeInto = void 0;\nvar binary_1 = require(\"../binary\");\nvar constants = require(\"../constants\");\nvar ensure_buffer_1 = require(\"../ensure_buffer\");\nvar error_1 = require(\"../error\");\nvar extended_json_1 = require(\"../extended_json\");\nvar long_1 = require(\"../long\");\nvar map_1 = require(\"../map\");\nvar utils_1 = require(\"./utils\");\nvar regexp = /\\x00/; // eslint-disable-line no-control-regex\nvar ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\n/*\r\n * isArray indicates if we are writing to a BSON array (type 0x04)\r\n * which forces the \"key\" which really an array index as a string to be written as ascii\r\n * This will catch any errors in index as a string generation\r\n */\nfunction serializeString(buffer, key, value, index, isArray) {\n  // Encode String type\n  buffer[index++] = constants.BSON_DATA_STRING;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0;\n  // Write the string\n  var size = buffer.write(value, index + 4, undefined, 'utf8');\n  // Write the size of the string to buffer\n  buffer[index + 3] = size + 1 >> 24 & 0xff;\n  buffer[index + 2] = size + 1 >> 16 & 0xff;\n  buffer[index + 1] = size + 1 >> 8 & 0xff;\n  buffer[index] = size + 1 & 0xff;\n  // Update index\n  index = index + 4 + size;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n}\nvar SPACE_FOR_FLOAT64 = new Uint8Array(8);\nvar DV_FOR_FLOAT64 = new DataView(SPACE_FOR_FLOAT64.buffer, SPACE_FOR_FLOAT64.byteOffset, SPACE_FOR_FLOAT64.byteLength);\nfunction serializeNumber(buffer, key, value, index, isArray) {\n  // We have an integer value\n  // TODO(NODE-2529): Add support for big int\n  if (Number.isInteger(value) && value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) {\n    // If the value fits in 32 bits encode as int32\n    // Set int type 32 bits or less\n    buffer[index++] = constants.BSON_DATA_INT;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Write the int value\n    buffer[index++] = value & 0xff;\n    buffer[index++] = value >> 8 & 0xff;\n    buffer[index++] = value >> 16 & 0xff;\n    buffer[index++] = value >> 24 & 0xff;\n  } else {\n    // Encode as double\n    buffer[index++] = constants.BSON_DATA_NUMBER;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Write float\n    DV_FOR_FLOAT64.setFloat64(0, value, true);\n    buffer.set(SPACE_FOR_FLOAT64, index);\n    // Adjust index\n    index = index + 8;\n  }\n  return index;\n}\nfunction serializeNull(buffer, key, _, index, isArray) {\n  // Set long type\n  buffer[index++] = constants.BSON_DATA_NULL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n}\nfunction serializeBoolean(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_BOOLEAN;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Encode the boolean value\n  buffer[index++] = value ? 1 : 0;\n  return index;\n}\nfunction serializeDate(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_DATE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the date\n  var dateInMilis = long_1.Long.fromNumber(value.getTime());\n  var lowBits = dateInMilis.getLowBits();\n  var highBits = dateInMilis.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n}\nfunction serializeRegExp(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw Error('value ' + value.source + ' must not contain null bytes');\n  }\n  // Adjust the index\n  index = index + buffer.write(value.source, index, undefined, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the parameters\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\n  if (value.global) buffer[index++] = 0x73; // s\n  if (value.multiline) buffer[index++] = 0x6d; // m\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_REGEXP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Check the pattern for 0 bytes\n  if (value.pattern.match(regexp) != null) {\n    // The BSON spec doesn't allow keys with null bytes because keys are\n    // null-terminated.\n    throw Error('pattern ' + value.pattern + ' must not contain null bytes');\n  }\n  // Adjust the index\n  index = index + buffer.write(value.pattern, index, undefined, 'utf8');\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the options\n  index = index + buffer.write(value.options.split('').sort().join(''), index, undefined, 'utf8');\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n}\nfunction serializeMinMax(buffer, key, value, index, isArray) {\n  // Write the type of either min or max key\n  if (value === null) {\n    buffer[index++] = constants.BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = constants.BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = constants.BSON_DATA_MAX_KEY;\n  }\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n}\nfunction serializeObjectId(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_OID;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the objectId into the shared buffer\n  if (typeof value.id === 'string') {\n    buffer.write(value.id, index, undefined, 'binary');\n  } else if ((0, utils_1.isUint8Array)(value.id)) {\n    // Use the standard JS methods here because buffer.copy() is buggy with the\n    // browser polyfill\n    buffer.set(value.id.subarray(0, 12), index);\n  } else {\n    throw new error_1.BSONTypeError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n  }\n  // Adjust index\n  return index + 12;\n}\nfunction serializeBuffer(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Get size of the buffer (current write point)\n  var size = value.length;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff;\n  // Write the default subtype\n  buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;\n  // Copy the content form the binary field to the buffer\n  buffer.set((0, ensure_buffer_1.ensureBuffer)(value), index);\n  // Adjust the index\n  index = index + size;\n  return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (path[i] === value) throw new error_1.BSONError('cyclic dependency detected');\n  }\n  // Push value to stack\n  path.push(value);\n  // Write the type\n  buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n  // Pop stack\n  path.pop();\n  return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index, isArray) {\n  buffer[index++] = constants.BSON_DATA_DECIMAL128;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the data from the value\n  // Prefer the standard JS methods because their typechecking is not buggy,\n  // unlike the `buffer` polyfill's.\n  buffer.set(value.bytes.subarray(0, 16), index);\n  return index + 16;\n}\nfunction serializeLong(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the date\n  var lowBits = value.getLowBits();\n  var highBits = value.getHighBits();\n  // Encode low bits\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff;\n  // Encode high bits\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n}\nfunction serializeInt32(buffer, key, value, index, isArray) {\n  value = value.valueOf();\n  // Set int type 32 bits or less\n  buffer[index++] = constants.BSON_DATA_INT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the int value\n  buffer[index++] = value & 0xff;\n  buffer[index++] = value >> 8 & 0xff;\n  buffer[index++] = value >> 16 & 0xff;\n  buffer[index++] = value >> 24 & 0xff;\n  return index;\n}\nfunction serializeDouble(buffer, key, value, index, isArray) {\n  // Encode as double\n  buffer[index++] = constants.BSON_DATA_NUMBER;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write float\n  DV_FOR_FLOAT64.setFloat64(0, value.value, true);\n  buffer.set(SPACE_FOR_FLOAT64, index);\n  // Adjust index\n  index = index + 8;\n  return index;\n}\nfunction serializeFunction(buffer, key, value, index, _checkKeys, _depth, isArray) {\n  if (_checkKeys === void 0) {\n    _checkKeys = false;\n  }\n  if (_depth === void 0) {\n    _depth = 0;\n  }\n  buffer[index++] = constants.BSON_DATA_CODE;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Function string\n  var functionString = (0, utils_1.normalizedFunctionString)(value);\n  // Write the string\n  var size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  if (value.scope && typeof value.scope === 'object') {\n    // Write the type\n    buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Starting index\n    var startIndex = index;\n    // Serialize the function\n    // Get the function string\n    var functionString = typeof value.code === 'string' ? value.code : value.code.toString();\n    // Index adjustment\n    index = index + 4;\n    // Write string into buffer\n    var codeSize = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = codeSize & 0xff;\n    buffer[index + 1] = codeSize >> 8 & 0xff;\n    buffer[index + 2] = codeSize >> 16 & 0xff;\n    buffer[index + 3] = codeSize >> 24 & 0xff;\n    // Write end 0\n    buffer[index + 4 + codeSize - 1] = 0;\n    // Write the\n    index = index + codeSize + 4;\n    //\n    // Serialize the scope value\n    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);\n    index = endIndex - 1;\n    // Writ the total\n    var totalSize = endIndex - startIndex;\n    // Write the total size of the object\n    buffer[startIndex++] = totalSize & 0xff;\n    buffer[startIndex++] = totalSize >> 8 & 0xff;\n    buffer[startIndex++] = totalSize >> 16 & 0xff;\n    buffer[startIndex++] = totalSize >> 24 & 0xff;\n    // Write trailing zero\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = constants.BSON_DATA_CODE;\n    // Number of written bytes\n    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Function string\n    var functionString = value.code.toString();\n    // Write the string\n    var size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;\n    // Write the size of the string to buffer\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    // Update index\n    index = index + 4 + size - 1;\n    // Write zero\n    buffer[index++] = 0;\n  }\n  return index;\n}\nfunction serializeBinary(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_BINARY;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Extract the buffer\n  var data = value.value(true);\n  // Calculate size\n  var size = value.position;\n  // Add the deprecated 02 type 4 bytes of size to total\n  if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n  // Write the size of the string to buffer\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff;\n  // Write the subtype to the buffer\n  buffer[index++] = value.sub_type;\n  // If we have binary type 2 the 4 first bytes are the size\n  if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n  }\n  // Write the data to the object\n  buffer.set(data, index);\n  // Adjust the index\n  index = index + value.position;\n  return index;\n}\nfunction serializeSymbol(buffer, key, value, index, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_SYMBOL;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the string\n  var size = buffer.write(value.value, index + 4, undefined, 'utf8') + 1;\n  // Write the size of the string to buffer\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff;\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0x00;\n  return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, isArray) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_OBJECT;\n  // Number of written bytes\n  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, undefined, 'utf8') : buffer.write(key, index, undefined, 'ascii');\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  var startIndex = index;\n  var output = {\n    $ref: value.collection || value.namespace,\n    $id: value.oid\n  };\n  if (value.db != null) {\n    output.$db = value.db;\n  }\n  output = Object.assign(output, value.fields);\n  var endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions);\n  // Calculate object size\n  var size = endIndex - startIndex;\n  // Write the size\n  buffer[startIndex++] = size & 0xff;\n  buffer[startIndex++] = size >> 8 & 0xff;\n  buffer[startIndex++] = size >> 16 & 0xff;\n  buffer[startIndex++] = size >> 24 & 0xff;\n  // Set index\n  return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n  if (checkKeys === void 0) {\n    checkKeys = false;\n  }\n  if (startingIndex === void 0) {\n    startingIndex = 0;\n  }\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (serializeFunctions === void 0) {\n    serializeFunctions = false;\n  }\n  if (ignoreUndefined === void 0) {\n    ignoreUndefined = true;\n  }\n  if (path === void 0) {\n    path = [];\n  }\n  startingIndex = startingIndex || 0;\n  path = path || [];\n  // Push the object to the path\n  path.push(object);\n  // Start place to serialize into\n  var index = startingIndex + 4;\n  // Special case isArray\n  if (Array.isArray(object)) {\n    // Get object keys\n    for (var i = 0; i < object.length; i++) {\n      var key = \"\".concat(i);\n      var value = object[i];\n      // Is there an override value\n      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === 'function') {\n        value = value.toBSON();\n      }\n      if (typeof value === 'string') {\n        index = serializeString(buffer, key, value, index, true);\n      } else if (typeof value === 'number') {\n        index = serializeNumber(buffer, key, value, index, true);\n      } else if (typeof value === 'bigint') {\n        throw new error_1.BSONTypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (typeof value === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index, true);\n      } else if (value instanceof Date || (0, utils_1.isDate)(value)) {\n        index = serializeDate(buffer, key, value, index, true);\n      } else if (value === undefined) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {\n        index = serializeObjectId(buffer, key, value, index, true);\n      } else if ((0, utils_1.isUint8Array)(value)) {\n        index = serializeBuffer(buffer, key, value, index, true);\n      } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {\n        index = serializeRegExp(buffer, key, value, index, true);\n      } else if (typeof value === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);\n      } else if (typeof value === 'object' && (0, extended_json_1.isBSONType)(value) && value._bsontype === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index, true);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, true);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index, true);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index, true);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new error_1.BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value['_bsontype'])));\n      }\n    }\n  } else if (object instanceof map_1.Map || (0, utils_1.isMap)(object)) {\n    var iterator = object.entries();\n    var done = false;\n    while (!done) {\n      // Unpack the next entry\n      var entry = iterator.next();\n      done = !!entry.done;\n      // Are we done, then skip and terminate\n      if (done) continue;\n      // Get the entry values\n      var key = entry.value[0];\n      var value = entry.value[1];\n      // Check the type of the value\n      var type = typeof value;\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint' || (0, utils_1.isBigInt64Array)(value) || (0, utils_1.isBigUInt64Array)(value)) {\n        throw new error_1.BSONTypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || (0, utils_1.isDate)(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === null || value === undefined && ignoreUndefined === false) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if ((0, utils_1.isUint8Array)(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new error_1.BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value['_bsontype'])));\n      }\n    }\n  } else {\n    if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === 'function') {\n      // Provided a custom serialization method\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object') {\n        throw new error_1.BSONTypeError('toBSON function did not return an object');\n      }\n    }\n    // Iterate over all the keys\n    for (var key in object) {\n      var value = object[key];\n      // Is there an override value\n      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === 'function') {\n        value = value.toBSON();\n      }\n      // Check the type of the value\n      var type = typeof value;\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw Error('key ' + key + ' must not contain null bytes');\n        }\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw Error('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw Error('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        throw new error_1.BSONTypeError('Unsupported type BigInt, please use Decimal128');\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || (0, utils_1.isDate)(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if ((0, utils_1.isUint8Array)(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value['_bsontype'] == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Symbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\n      } else if (value['_bsontype'] === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value['_bsontype'] !== 'undefined') {\n        throw new error_1.BSONTypeError(\"Unrecognized or invalid _bsontype: \".concat(String(value['_bsontype'])));\n      }\n    }\n  }\n  // Remove the path\n  path.pop();\n  // Final padding byte for object\n  buffer[index++] = 0x00;\n  // Final size\n  var size = index - startingIndex;\n  // Write the size of the object\n  buffer[startingIndex++] = size & 0xff;\n  buffer[startingIndex++] = size >> 8 & 0xff;\n  buffer[startingIndex++] = size >> 16 & 0xff;\n  buffer[startingIndex++] = size >> 24 & 0xff;\n  return index;\n}\nexports.serializeInto = serializeInto;","map":{"version":3,"mappings":"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","names":["regexp","ignoreKeys","Set","serializeString","buffer","key","value","index","isArray","constants","BSON_DATA_STRING","numberOfWrittenBytes","write","undefined","size","SPACE_FOR_FLOAT64","Uint8Array","DV_FOR_FLOAT64","DataView","byteOffset","byteLength","serializeNumber","Number","isInteger","BSON_INT32_MIN","BSON_INT32_MAX","BSON_DATA_INT","BSON_DATA_NUMBER","setFloat64","set","serializeNull","_","BSON_DATA_NULL","serializeBoolean","BSON_DATA_BOOLEAN","serializeDate","BSON_DATA_DATE","dateInMilis","long_1","fromNumber","getTime","lowBits","getLowBits","highBits","getHighBits","serializeRegExp","BSON_DATA_REGEXP","source","match","Error","ignoreCase","global","multiline","serializeBSONRegExp","pattern","options","split","sort","join","serializeMinMax","_bsontype","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","serializeObjectId","BSON_DATA_OID","id","subarray","error_1","JSON","stringify","serializeBuffer","BSON_DATA_BINARY","length","BSON_BINARY_SUBTYPE_DEFAULT","serializeObject","checkKeys","depth","serializeFunctions","ignoreUndefined","path","i","push","Array","BSON_DATA_ARRAY","BSON_DATA_OBJECT","endIndex","serializeInto","pop","serializeDecimal128","BSON_DATA_DECIMAL128","bytes","serializeLong","BSON_DATA_LONG","BSON_DATA_TIMESTAMP","serializeInt32","valueOf","serializeDouble","serializeFunction","_checkKeys","_depth","BSON_DATA_CODE","functionString","serializeCode","scope","BSON_DATA_CODE_W_SCOPE","startIndex","code","toString","codeSize","totalSize","serializeBinary","data","position","sub_type","binary_1","SUBTYPE_BYTE_ARRAY","serializeSymbol","BSON_DATA_SYMBOL","serializeDBRef","output","$ref","collection","namespace","$id","oid","db","$db","Object","assign","fields","object","startingIndex","toBSON","Date","RegExp","String","map_1","iterator","entries","done","entry","next","type","has","indexOf","exports"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\parser\\serializer.ts"],"sourcesContent":["import type { Buffer } from 'buffer';\r\nimport { Binary } from '../binary';\r\nimport type { BSONSymbol, DBRef, Document, MaxKey } from '../bson';\r\nimport type { Code } from '../code';\r\nimport * as constants from '../constants';\r\nimport type { DBRefLike } from '../db_ref';\r\nimport type { Decimal128 } from '../decimal128';\r\nimport type { Double } from '../double';\r\nimport { ensureBuffer } from '../ensure_buffer';\r\nimport { BSONError, BSONTypeError } from '../error';\r\nimport { isBSONType } from '../extended_json';\r\nimport type { Int32 } from '../int_32';\r\nimport { Long } from '../long';\r\nimport { Map } from '../map';\r\nimport type { MinKey } from '../min_key';\r\nimport type { ObjectId } from '../objectid';\r\nimport type { BSONRegExp } from '../regexp';\r\nimport {\r\n  isBigInt64Array,\r\n  isBigUInt64Array,\r\n  isDate,\r\n  isMap,\r\n  isRegExp,\r\n  isUint8Array,\r\n  normalizedFunctionString\r\n} from './utils';\r\n\r\n/** @public */\r\nexport interface SerializeOptions {\r\n  /** the serializer will check if keys are valid. */\r\n  checkKeys?: boolean;\r\n  /** serialize the javascript functions **(default:false)**. */\r\n  serializeFunctions?: boolean;\r\n  /** serialize will not emit undefined fields **(default:true)** */\r\n  ignoreUndefined?: boolean;\r\n  /** @internal Resize internal buffer */\r\n  minInternalBufferSize?: number;\r\n  /** the index in the buffer where we wish to start serializing into */\r\n  index?: number;\r\n}\r\n\r\nconst regexp = /\\x00/; // eslint-disable-line no-control-regex\r\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\r\n\r\n/*\r\n * isArray indicates if we are writing to a BSON array (type 0x04)\r\n * which forces the \"key\" which really an array index as a string to be written as ascii\r\n * This will catch any errors in index as a string generation\r\n */\r\n\r\nfunction serializeString(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: string,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Encode String type\r\n  buffer[index++] = constants.BSON_DATA_STRING;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes + 1;\r\n  buffer[index - 1] = 0;\r\n  // Write the string\r\n  const size = buffer.write(value, index + 4, undefined, 'utf8');\r\n  // Write the size of the string to buffer\r\n  buffer[index + 3] = ((size + 1) >> 24) & 0xff;\r\n  buffer[index + 2] = ((size + 1) >> 16) & 0xff;\r\n  buffer[index + 1] = ((size + 1) >> 8) & 0xff;\r\n  buffer[index] = (size + 1) & 0xff;\r\n  // Update index\r\n  index = index + 4 + size;\r\n  // Write zero\r\n  buffer[index++] = 0;\r\n  return index;\r\n}\r\n\r\nconst SPACE_FOR_FLOAT64 = new Uint8Array(8);\r\nconst DV_FOR_FLOAT64 = new DataView(\r\n  SPACE_FOR_FLOAT64.buffer,\r\n  SPACE_FOR_FLOAT64.byteOffset,\r\n  SPACE_FOR_FLOAT64.byteLength\r\n);\r\nfunction serializeNumber(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: number,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // We have an integer value\r\n  // TODO(NODE-2529): Add support for big int\r\n  if (\r\n    Number.isInteger(value) &&\r\n    value >= constants.BSON_INT32_MIN &&\r\n    value <= constants.BSON_INT32_MAX\r\n  ) {\r\n    // If the value fits in 32 bits encode as int32\r\n    // Set int type 32 bits or less\r\n    buffer[index++] = constants.BSON_DATA_INT;\r\n    // Number of written bytes\r\n    const numberOfWrittenBytes = !isArray\r\n      ? buffer.write(key, index, undefined, 'utf8')\r\n      : buffer.write(key, index, undefined, 'ascii');\r\n    // Encode the name\r\n    index = index + numberOfWrittenBytes;\r\n    buffer[index++] = 0;\r\n    // Write the int value\r\n    buffer[index++] = value & 0xff;\r\n    buffer[index++] = (value >> 8) & 0xff;\r\n    buffer[index++] = (value >> 16) & 0xff;\r\n    buffer[index++] = (value >> 24) & 0xff;\r\n  } else {\r\n    // Encode as double\r\n    buffer[index++] = constants.BSON_DATA_NUMBER;\r\n    // Number of written bytes\r\n    const numberOfWrittenBytes = !isArray\r\n      ? buffer.write(key, index, undefined, 'utf8')\r\n      : buffer.write(key, index, undefined, 'ascii');\r\n    // Encode the name\r\n    index = index + numberOfWrittenBytes;\r\n    buffer[index++] = 0;\r\n    // Write float\r\n    DV_FOR_FLOAT64.setFloat64(0, value, true);\r\n    buffer.set(SPACE_FOR_FLOAT64, index);\r\n    // Adjust index\r\n    index = index + 8;\r\n  }\r\n\r\n  return index;\r\n}\r\n\r\nfunction serializeNull(buffer: Buffer, key: string, _: unknown, index: number, isArray?: boolean) {\r\n  // Set long type\r\n  buffer[index++] = constants.BSON_DATA_NULL;\r\n\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  return index;\r\n}\r\n\r\nfunction serializeBoolean(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: boolean,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_BOOLEAN;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Encode the boolean value\r\n  buffer[index++] = value ? 1 : 0;\r\n  return index;\r\n}\r\n\r\nfunction serializeDate(buffer: Buffer, key: string, value: Date, index: number, isArray?: boolean) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_DATE;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n\r\n  // Write the date\r\n  const dateInMilis = Long.fromNumber(value.getTime());\r\n  const lowBits = dateInMilis.getLowBits();\r\n  const highBits = dateInMilis.getHighBits();\r\n  // Encode low bits\r\n  buffer[index++] = lowBits & 0xff;\r\n  buffer[index++] = (lowBits >> 8) & 0xff;\r\n  buffer[index++] = (lowBits >> 16) & 0xff;\r\n  buffer[index++] = (lowBits >> 24) & 0xff;\r\n  // Encode high bits\r\n  buffer[index++] = highBits & 0xff;\r\n  buffer[index++] = (highBits >> 8) & 0xff;\r\n  buffer[index++] = (highBits >> 16) & 0xff;\r\n  buffer[index++] = (highBits >> 24) & 0xff;\r\n  return index;\r\n}\r\n\r\nfunction serializeRegExp(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: RegExp,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_REGEXP;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  if (value.source && value.source.match(regexp) != null) {\r\n    throw Error('value ' + value.source + ' must not contain null bytes');\r\n  }\r\n  // Adjust the index\r\n  index = index + buffer.write(value.source, index, undefined, 'utf8');\r\n  // Write zero\r\n  buffer[index++] = 0x00;\r\n  // Write the parameters\r\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\r\n  if (value.global) buffer[index++] = 0x73; // s\r\n  if (value.multiline) buffer[index++] = 0x6d; // m\r\n\r\n  // Add ending zero\r\n  buffer[index++] = 0x00;\r\n  return index;\r\n}\r\n\r\nfunction serializeBSONRegExp(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: BSONRegExp,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_REGEXP;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n\r\n  // Check the pattern for 0 bytes\r\n  if (value.pattern.match(regexp) != null) {\r\n    // The BSON spec doesn't allow keys with null bytes because keys are\r\n    // null-terminated.\r\n    throw Error('pattern ' + value.pattern + ' must not contain null bytes');\r\n  }\r\n\r\n  // Adjust the index\r\n  index = index + buffer.write(value.pattern, index, undefined, 'utf8');\r\n  // Write zero\r\n  buffer[index++] = 0x00;\r\n  // Write the options\r\n  index = index + buffer.write(value.options.split('').sort().join(''), index, undefined, 'utf8');\r\n  // Add ending zero\r\n  buffer[index++] = 0x00;\r\n  return index;\r\n}\r\n\r\nfunction serializeMinMax(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: MinKey | MaxKey,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type of either min or max key\r\n  if (value === null) {\r\n    buffer[index++] = constants.BSON_DATA_NULL;\r\n  } else if (value._bsontype === 'MinKey') {\r\n    buffer[index++] = constants.BSON_DATA_MIN_KEY;\r\n  } else {\r\n    buffer[index++] = constants.BSON_DATA_MAX_KEY;\r\n  }\r\n\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  return index;\r\n}\r\n\r\nfunction serializeObjectId(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: ObjectId,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_OID;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n\r\n  // Write the objectId into the shared buffer\r\n  if (typeof value.id === 'string') {\r\n    buffer.write(value.id, index, undefined, 'binary');\r\n  } else if (isUint8Array(value.id)) {\r\n    // Use the standard JS methods here because buffer.copy() is buggy with the\r\n    // browser polyfill\r\n    buffer.set(value.id.subarray(0, 12), index);\r\n  } else {\r\n    throw new BSONTypeError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\r\n  }\r\n\r\n  // Adjust index\r\n  return index + 12;\r\n}\r\n\r\nfunction serializeBuffer(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Buffer | Uint8Array,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_BINARY;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Get size of the buffer (current write point)\r\n  const size = value.length;\r\n  // Write the size of the string to buffer\r\n  buffer[index++] = size & 0xff;\r\n  buffer[index++] = (size >> 8) & 0xff;\r\n  buffer[index++] = (size >> 16) & 0xff;\r\n  buffer[index++] = (size >> 24) & 0xff;\r\n  // Write the default subtype\r\n  buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;\r\n  // Copy the content form the binary field to the buffer\r\n  buffer.set(ensureBuffer(value), index);\r\n  // Adjust the index\r\n  index = index + size;\r\n  return index;\r\n}\r\n\r\nfunction serializeObject(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Document,\r\n  index: number,\r\n  checkKeys = false,\r\n  depth = 0,\r\n  serializeFunctions = false,\r\n  ignoreUndefined = true,\r\n  isArray = false,\r\n  path: Document[] = []\r\n) {\r\n  for (let i = 0; i < path.length; i++) {\r\n    if (path[i] === value) throw new BSONError('cyclic dependency detected');\r\n  }\r\n\r\n  // Push value to stack\r\n  path.push(value);\r\n  // Write the type\r\n  buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  const endIndex = serializeInto(\r\n    buffer,\r\n    value,\r\n    checkKeys,\r\n    index,\r\n    depth + 1,\r\n    serializeFunctions,\r\n    ignoreUndefined,\r\n    path\r\n  );\r\n  // Pop stack\r\n  path.pop();\r\n  return endIndex;\r\n}\r\n\r\nfunction serializeDecimal128(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Decimal128,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  buffer[index++] = constants.BSON_DATA_DECIMAL128;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Write the data from the value\r\n  // Prefer the standard JS methods because their typechecking is not buggy,\r\n  // unlike the `buffer` polyfill's.\r\n  buffer.set(value.bytes.subarray(0, 16), index);\r\n  return index + 16;\r\n}\r\n\r\nfunction serializeLong(buffer: Buffer, key: string, value: Long, index: number, isArray?: boolean) {\r\n  // Write the type\r\n  buffer[index++] =\r\n    value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Write the date\r\n  const lowBits = value.getLowBits();\r\n  const highBits = value.getHighBits();\r\n  // Encode low bits\r\n  buffer[index++] = lowBits & 0xff;\r\n  buffer[index++] = (lowBits >> 8) & 0xff;\r\n  buffer[index++] = (lowBits >> 16) & 0xff;\r\n  buffer[index++] = (lowBits >> 24) & 0xff;\r\n  // Encode high bits\r\n  buffer[index++] = highBits & 0xff;\r\n  buffer[index++] = (highBits >> 8) & 0xff;\r\n  buffer[index++] = (highBits >> 16) & 0xff;\r\n  buffer[index++] = (highBits >> 24) & 0xff;\r\n  return index;\r\n}\r\n\r\nfunction serializeInt32(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Int32 | number,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  value = value.valueOf();\r\n  // Set int type 32 bits or less\r\n  buffer[index++] = constants.BSON_DATA_INT;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Write the int value\r\n  buffer[index++] = value & 0xff;\r\n  buffer[index++] = (value >> 8) & 0xff;\r\n  buffer[index++] = (value >> 16) & 0xff;\r\n  buffer[index++] = (value >> 24) & 0xff;\r\n  return index;\r\n}\r\n\r\nfunction serializeDouble(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Double,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Encode as double\r\n  buffer[index++] = constants.BSON_DATA_NUMBER;\r\n\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n\r\n  // Write float\r\n  DV_FOR_FLOAT64.setFloat64(0, value.value, true);\r\n  buffer.set(SPACE_FOR_FLOAT64, index);\r\n\r\n  // Adjust index\r\n  index = index + 8;\r\n  return index;\r\n}\r\n\r\nfunction serializeFunction(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Function,\r\n  index: number,\r\n  _checkKeys = false,\r\n  _depth = 0,\r\n  isArray?: boolean\r\n) {\r\n  buffer[index++] = constants.BSON_DATA_CODE;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Function string\r\n  const functionString = normalizedFunctionString(value);\r\n\r\n  // Write the string\r\n  const size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;\r\n  // Write the size of the string to buffer\r\n  buffer[index] = size & 0xff;\r\n  buffer[index + 1] = (size >> 8) & 0xff;\r\n  buffer[index + 2] = (size >> 16) & 0xff;\r\n  buffer[index + 3] = (size >> 24) & 0xff;\r\n  // Update index\r\n  index = index + 4 + size - 1;\r\n  // Write zero\r\n  buffer[index++] = 0;\r\n  return index;\r\n}\r\n\r\nfunction serializeCode(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Code,\r\n  index: number,\r\n  checkKeys = false,\r\n  depth = 0,\r\n  serializeFunctions = false,\r\n  ignoreUndefined = true,\r\n  isArray = false\r\n) {\r\n  if (value.scope && typeof value.scope === 'object') {\r\n    // Write the type\r\n    buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE;\r\n    // Number of written bytes\r\n    const numberOfWrittenBytes = !isArray\r\n      ? buffer.write(key, index, undefined, 'utf8')\r\n      : buffer.write(key, index, undefined, 'ascii');\r\n    // Encode the name\r\n    index = index + numberOfWrittenBytes;\r\n    buffer[index++] = 0;\r\n\r\n    // Starting index\r\n    let startIndex = index;\r\n\r\n    // Serialize the function\r\n    // Get the function string\r\n    const functionString = typeof value.code === 'string' ? value.code : value.code.toString();\r\n    // Index adjustment\r\n    index = index + 4;\r\n    // Write string into buffer\r\n    const codeSize = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;\r\n    // Write the size of the string to buffer\r\n    buffer[index] = codeSize & 0xff;\r\n    buffer[index + 1] = (codeSize >> 8) & 0xff;\r\n    buffer[index + 2] = (codeSize >> 16) & 0xff;\r\n    buffer[index + 3] = (codeSize >> 24) & 0xff;\r\n    // Write end 0\r\n    buffer[index + 4 + codeSize - 1] = 0;\r\n    // Write the\r\n    index = index + codeSize + 4;\r\n\r\n    //\r\n    // Serialize the scope value\r\n    const endIndex = serializeInto(\r\n      buffer,\r\n      value.scope,\r\n      checkKeys,\r\n      index,\r\n      depth + 1,\r\n      serializeFunctions,\r\n      ignoreUndefined\r\n    );\r\n    index = endIndex - 1;\r\n\r\n    // Writ the total\r\n    const totalSize = endIndex - startIndex;\r\n\r\n    // Write the total size of the object\r\n    buffer[startIndex++] = totalSize & 0xff;\r\n    buffer[startIndex++] = (totalSize >> 8) & 0xff;\r\n    buffer[startIndex++] = (totalSize >> 16) & 0xff;\r\n    buffer[startIndex++] = (totalSize >> 24) & 0xff;\r\n    // Write trailing zero\r\n    buffer[index++] = 0;\r\n  } else {\r\n    buffer[index++] = constants.BSON_DATA_CODE;\r\n    // Number of written bytes\r\n    const numberOfWrittenBytes = !isArray\r\n      ? buffer.write(key, index, undefined, 'utf8')\r\n      : buffer.write(key, index, undefined, 'ascii');\r\n    // Encode the name\r\n    index = index + numberOfWrittenBytes;\r\n    buffer[index++] = 0;\r\n    // Function string\r\n    const functionString = value.code.toString();\r\n    // Write the string\r\n    const size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;\r\n    // Write the size of the string to buffer\r\n    buffer[index] = size & 0xff;\r\n    buffer[index + 1] = (size >> 8) & 0xff;\r\n    buffer[index + 2] = (size >> 16) & 0xff;\r\n    buffer[index + 3] = (size >> 24) & 0xff;\r\n    // Update index\r\n    index = index + 4 + size - 1;\r\n    // Write zero\r\n    buffer[index++] = 0;\r\n  }\r\n\r\n  return index;\r\n}\r\n\r\nfunction serializeBinary(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: Binary,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_BINARY;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Extract the buffer\r\n  const data = value.value(true) as Buffer | Uint8Array;\r\n  // Calculate size\r\n  let size = value.position;\r\n  // Add the deprecated 02 type 4 bytes of size to total\r\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\r\n  // Write the size of the string to buffer\r\n  buffer[index++] = size & 0xff;\r\n  buffer[index++] = (size >> 8) & 0xff;\r\n  buffer[index++] = (size >> 16) & 0xff;\r\n  buffer[index++] = (size >> 24) & 0xff;\r\n  // Write the subtype to the buffer\r\n  buffer[index++] = value.sub_type;\r\n\r\n  // If we have binary type 2 the 4 first bytes are the size\r\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\r\n    size = size - 4;\r\n    buffer[index++] = size & 0xff;\r\n    buffer[index++] = (size >> 8) & 0xff;\r\n    buffer[index++] = (size >> 16) & 0xff;\r\n    buffer[index++] = (size >> 24) & 0xff;\r\n  }\r\n\r\n  // Write the data to the object\r\n  buffer.set(data, index);\r\n  // Adjust the index\r\n  index = index + value.position;\r\n  return index;\r\n}\r\n\r\nfunction serializeSymbol(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: BSONSymbol,\r\n  index: number,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_SYMBOL;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n  // Write the string\r\n  const size = buffer.write(value.value, index + 4, undefined, 'utf8') + 1;\r\n  // Write the size of the string to buffer\r\n  buffer[index] = size & 0xff;\r\n  buffer[index + 1] = (size >> 8) & 0xff;\r\n  buffer[index + 2] = (size >> 16) & 0xff;\r\n  buffer[index + 3] = (size >> 24) & 0xff;\r\n  // Update index\r\n  index = index + 4 + size - 1;\r\n  // Write zero\r\n  buffer[index++] = 0x00;\r\n  return index;\r\n}\r\n\r\nfunction serializeDBRef(\r\n  buffer: Buffer,\r\n  key: string,\r\n  value: DBRef,\r\n  index: number,\r\n  depth: number,\r\n  serializeFunctions: boolean,\r\n  isArray?: boolean\r\n) {\r\n  // Write the type\r\n  buffer[index++] = constants.BSON_DATA_OBJECT;\r\n  // Number of written bytes\r\n  const numberOfWrittenBytes = !isArray\r\n    ? buffer.write(key, index, undefined, 'utf8')\r\n    : buffer.write(key, index, undefined, 'ascii');\r\n\r\n  // Encode the name\r\n  index = index + numberOfWrittenBytes;\r\n  buffer[index++] = 0;\r\n\r\n  let startIndex = index;\r\n  let output: DBRefLike = {\r\n    $ref: value.collection || value.namespace, // \"namespace\" was what library 1.x called \"collection\"\r\n    $id: value.oid\r\n  };\r\n\r\n  if (value.db != null) {\r\n    output.$db = value.db;\r\n  }\r\n\r\n  output = Object.assign(output, value.fields);\r\n  const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions);\r\n\r\n  // Calculate object size\r\n  const size = endIndex - startIndex;\r\n  // Write the size\r\n  buffer[startIndex++] = size & 0xff;\r\n  buffer[startIndex++] = (size >> 8) & 0xff;\r\n  buffer[startIndex++] = (size >> 16) & 0xff;\r\n  buffer[startIndex++] = (size >> 24) & 0xff;\r\n  // Set index\r\n  return endIndex;\r\n}\r\n\r\nexport function serializeInto(\r\n  buffer: Buffer,\r\n  object: Document,\r\n  checkKeys = false,\r\n  startingIndex = 0,\r\n  depth = 0,\r\n  serializeFunctions = false,\r\n  ignoreUndefined = true,\r\n  path: Document[] = []\r\n): number {\r\n  startingIndex = startingIndex || 0;\r\n  path = path || [];\r\n\r\n  // Push the object to the path\r\n  path.push(object);\r\n\r\n  // Start place to serialize into\r\n  let index = startingIndex + 4;\r\n\r\n  // Special case isArray\r\n  if (Array.isArray(object)) {\r\n    // Get object keys\r\n    for (let i = 0; i < object.length; i++) {\r\n      const key = `${i}`;\r\n      let value = object[i];\r\n\r\n      // Is there an override value\r\n      if (typeof value?.toBSON === 'function') {\r\n        value = value.toBSON();\r\n      }\r\n\r\n      if (typeof value === 'string') {\r\n        index = serializeString(buffer, key, value, index, true);\r\n      } else if (typeof value === 'number') {\r\n        index = serializeNumber(buffer, key, value, index, true);\r\n      } else if (typeof value === 'bigint') {\r\n        throw new BSONTypeError('Unsupported type BigInt, please use Decimal128');\r\n      } else if (typeof value === 'boolean') {\r\n        index = serializeBoolean(buffer, key, value, index, true);\r\n      } else if (value instanceof Date || isDate(value)) {\r\n        index = serializeDate(buffer, key, value, index, true);\r\n      } else if (value === undefined) {\r\n        index = serializeNull(buffer, key, value, index, true);\r\n      } else if (value === null) {\r\n        index = serializeNull(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {\r\n        index = serializeObjectId(buffer, key, value, index, true);\r\n      } else if (isUint8Array(value)) {\r\n        index = serializeBuffer(buffer, key, value, index, true);\r\n      } else if (value instanceof RegExp || isRegExp(value)) {\r\n        index = serializeRegExp(buffer, key, value, index, true);\r\n      } else if (typeof value === 'object' && value['_bsontype'] == null) {\r\n        index = serializeObject(\r\n          buffer,\r\n          key,\r\n          value,\r\n          index,\r\n          checkKeys,\r\n          depth,\r\n          serializeFunctions,\r\n          ignoreUndefined,\r\n          true,\r\n          path\r\n        );\r\n      } else if (\r\n        typeof value === 'object' &&\r\n        isBSONType(value) &&\r\n        value._bsontype === 'Decimal128'\r\n      ) {\r\n        index = serializeDecimal128(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\r\n        index = serializeLong(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'Double') {\r\n        index = serializeDouble(buffer, key, value, index, true);\r\n      } else if (typeof value === 'function' && serializeFunctions) {\r\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, true);\r\n      } else if (value['_bsontype'] === 'Code') {\r\n        index = serializeCode(\r\n          buffer,\r\n          key,\r\n          value,\r\n          index,\r\n          checkKeys,\r\n          depth,\r\n          serializeFunctions,\r\n          ignoreUndefined,\r\n          true\r\n        );\r\n      } else if (value['_bsontype'] === 'Binary') {\r\n        index = serializeBinary(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'Symbol') {\r\n        index = serializeSymbol(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'DBRef') {\r\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);\r\n      } else if (value['_bsontype'] === 'BSONRegExp') {\r\n        index = serializeBSONRegExp(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'Int32') {\r\n        index = serializeInt32(buffer, key, value, index, true);\r\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\r\n        index = serializeMinMax(buffer, key, value, index, true);\r\n      } else if (typeof value['_bsontype'] !== 'undefined') {\r\n        throw new BSONTypeError(`Unrecognized or invalid _bsontype: ${String(value['_bsontype'])}`);\r\n      }\r\n    }\r\n  } else if (object instanceof Map || isMap(object)) {\r\n    const iterator = object.entries();\r\n    let done = false;\r\n\r\n    while (!done) {\r\n      // Unpack the next entry\r\n      const entry = iterator.next();\r\n      done = !!entry.done;\r\n      // Are we done, then skip and terminate\r\n      if (done) continue;\r\n\r\n      // Get the entry values\r\n      const key = entry.value[0];\r\n      const value = entry.value[1];\r\n\r\n      // Check the type of the value\r\n      const type = typeof value;\r\n\r\n      // Check the key and throw error if it's illegal\r\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\r\n        if (key.match(regexp) != null) {\r\n          // The BSON spec doesn't allow keys with null bytes because keys are\r\n          // null-terminated.\r\n          throw Error('key ' + key + ' must not contain null bytes');\r\n        }\r\n\r\n        if (checkKeys) {\r\n          if ('$' === key[0]) {\r\n            throw Error('key ' + key + \" must not start with '$'\");\r\n          } else if (~key.indexOf('.')) {\r\n            throw Error('key ' + key + \" must not contain '.'\");\r\n          }\r\n        }\r\n      }\r\n\r\n      if (type === 'string') {\r\n        index = serializeString(buffer, key, value, index);\r\n      } else if (type === 'number') {\r\n        index = serializeNumber(buffer, key, value, index);\r\n      } else if (type === 'bigint' || isBigInt64Array(value) || isBigUInt64Array(value)) {\r\n        throw new BSONTypeError('Unsupported type BigInt, please use Decimal128');\r\n      } else if (type === 'boolean') {\r\n        index = serializeBoolean(buffer, key, value, index);\r\n      } else if (value instanceof Date || isDate(value)) {\r\n        index = serializeDate(buffer, key, value, index);\r\n      } else if (value === null || (value === undefined && ignoreUndefined === false)) {\r\n        index = serializeNull(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {\r\n        index = serializeObjectId(buffer, key, value, index);\r\n      } else if (isUint8Array(value)) {\r\n        index = serializeBuffer(buffer, key, value, index);\r\n      } else if (value instanceof RegExp || isRegExp(value)) {\r\n        index = serializeRegExp(buffer, key, value, index);\r\n      } else if (type === 'object' && value['_bsontype'] == null) {\r\n        index = serializeObject(\r\n          buffer,\r\n          key,\r\n          value,\r\n          index,\r\n          checkKeys,\r\n          depth,\r\n          serializeFunctions,\r\n          ignoreUndefined,\r\n          false,\r\n          path\r\n        );\r\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\r\n        index = serializeDecimal128(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\r\n        index = serializeLong(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Double') {\r\n        index = serializeDouble(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Code') {\r\n        index = serializeCode(\r\n          buffer,\r\n          key,\r\n          value,\r\n          index,\r\n          checkKeys,\r\n          depth,\r\n          serializeFunctions,\r\n          ignoreUndefined\r\n        );\r\n      } else if (typeof value === 'function' && serializeFunctions) {\r\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\r\n      } else if (value['_bsontype'] === 'Binary') {\r\n        index = serializeBinary(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Symbol') {\r\n        index = serializeSymbol(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'DBRef') {\r\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\r\n      } else if (value['_bsontype'] === 'BSONRegExp') {\r\n        index = serializeBSONRegExp(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Int32') {\r\n        index = serializeInt32(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\r\n        index = serializeMinMax(buffer, key, value, index);\r\n      } else if (typeof value['_bsontype'] !== 'undefined') {\r\n        throw new BSONTypeError(`Unrecognized or invalid _bsontype: ${String(value['_bsontype'])}`);\r\n      }\r\n    }\r\n  } else {\r\n    if (typeof object?.toBSON === 'function') {\r\n      // Provided a custom serialization method\r\n      object = object.toBSON();\r\n      if (object != null && typeof object !== 'object') {\r\n        throw new BSONTypeError('toBSON function did not return an object');\r\n      }\r\n    }\r\n\r\n    // Iterate over all the keys\r\n    for (const key in object) {\r\n      let value = object[key];\r\n      // Is there an override value\r\n      if (typeof value?.toBSON === 'function') {\r\n        value = value.toBSON();\r\n      }\r\n\r\n      // Check the type of the value\r\n      const type = typeof value;\r\n\r\n      // Check the key and throw error if it's illegal\r\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\r\n        if (key.match(regexp) != null) {\r\n          // The BSON spec doesn't allow keys with null bytes because keys are\r\n          // null-terminated.\r\n          throw Error('key ' + key + ' must not contain null bytes');\r\n        }\r\n\r\n        if (checkKeys) {\r\n          if ('$' === key[0]) {\r\n            throw Error('key ' + key + \" must not start with '$'\");\r\n          } else if (~key.indexOf('.')) {\r\n            throw Error('key ' + key + \" must not contain '.'\");\r\n          }\r\n        }\r\n      }\r\n\r\n      if (type === 'string') {\r\n        index = serializeString(buffer, key, value, index);\r\n      } else if (type === 'number') {\r\n        index = serializeNumber(buffer, key, value, index);\r\n      } else if (type === 'bigint') {\r\n        throw new BSONTypeError('Unsupported type BigInt, please use Decimal128');\r\n      } else if (type === 'boolean') {\r\n        index = serializeBoolean(buffer, key, value, index);\r\n      } else if (value instanceof Date || isDate(value)) {\r\n        index = serializeDate(buffer, key, value, index);\r\n      } else if (value === undefined) {\r\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\r\n      } else if (value === null) {\r\n        index = serializeNull(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {\r\n        index = serializeObjectId(buffer, key, value, index);\r\n      } else if (isUint8Array(value)) {\r\n        index = serializeBuffer(buffer, key, value, index);\r\n      } else if (value instanceof RegExp || isRegExp(value)) {\r\n        index = serializeRegExp(buffer, key, value, index);\r\n      } else if (type === 'object' && value['_bsontype'] == null) {\r\n        index = serializeObject(\r\n          buffer,\r\n          key,\r\n          value,\r\n          index,\r\n          checkKeys,\r\n          depth,\r\n          serializeFunctions,\r\n          ignoreUndefined,\r\n          false,\r\n          path\r\n        );\r\n      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {\r\n        index = serializeDecimal128(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {\r\n        index = serializeLong(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Double') {\r\n        index = serializeDouble(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Code') {\r\n        index = serializeCode(\r\n          buffer,\r\n          key,\r\n          value,\r\n          index,\r\n          checkKeys,\r\n          depth,\r\n          serializeFunctions,\r\n          ignoreUndefined\r\n        );\r\n      } else if (typeof value === 'function' && serializeFunctions) {\r\n        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);\r\n      } else if (value['_bsontype'] === 'Binary') {\r\n        index = serializeBinary(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Symbol') {\r\n        index = serializeSymbol(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'DBRef') {\r\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);\r\n      } else if (value['_bsontype'] === 'BSONRegExp') {\r\n        index = serializeBSONRegExp(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'Int32') {\r\n        index = serializeInt32(buffer, key, value, index);\r\n      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {\r\n        index = serializeMinMax(buffer, key, value, index);\r\n      } else if (typeof value['_bsontype'] !== 'undefined') {\r\n        throw new BSONTypeError(`Unrecognized or invalid _bsontype: ${String(value['_bsontype'])}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Remove the path\r\n  path.pop();\r\n\r\n  // Final padding byte for object\r\n  buffer[index++] = 0x00;\r\n\r\n  // Final size\r\n  const size = index - startingIndex;\r\n  // Write the size of the object\r\n  buffer[startingIndex++] = size & 0xff;\r\n  buffer[startingIndex++] = (size >> 8) & 0xff;\r\n  buffer[startingIndex++] = (size >> 16) & 0xff;\r\n  buffer[startingIndex++] = (size >> 24) & 0xff;\r\n  return index;\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}