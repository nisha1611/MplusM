{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n\n/**\r\n * Register methods for this model\r\n *\r\n * @param {Model} model\r\n * @param {Schema} schema\r\n * @api private\r\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  const Model = require('../../model');\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function () {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' + 'named \"' + method + '\"');\n    }\n\n    // Avoid making custom methods if user sets a method to itself, e.g.\n    // `schema.method(save, Document.prototype.save)`. Can happen when\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\n    if (typeof fn === 'function' && Model.prototype[method] === fn) {\n      delete schema.methods[method];\n      continue;\n    }\n    if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` + 'internally, overwriting it may cause bugs. If you\\'re sure you know ' + 'what you\\'re doing, you can suppress this error by using ' + `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};","map":{"version":3,"names":["get","require","utils","module","exports","applyMethods","model","schema","Model","apply","method","Object","defineProperty","prototype","h","k","methods","bind","configurable","keys","fn","tree","hasOwnProperty","Error","reserved","warn","$appliedMethods","key","paths","type","$isSingleNested","caster","$isMongooseDocumentArray","Constructor"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/model/applyMethods.js"],"sourcesContent":["'use strict';\r\n\r\nconst get = require('../get');\r\nconst utils = require('../../utils');\r\n\r\n/**\r\n * Register methods for this model\r\n *\r\n * @param {Model} model\r\n * @param {Schema} schema\r\n * @api private\r\n */\r\n\r\nmodule.exports = function applyMethods(model, schema) {\r\n  const Model = require('../../model');\r\n\r\n  function apply(method, schema) {\r\n    Object.defineProperty(model.prototype, method, {\r\n      get: function() {\r\n        const h = {};\r\n        for (const k in schema.methods[method]) {\r\n          h[k] = schema.methods[method][k].bind(this);\r\n        }\r\n        return h;\r\n      },\r\n      configurable: true\r\n    });\r\n  }\r\n  for (const method of Object.keys(schema.methods)) {\r\n    const fn = schema.methods[method];\r\n    if (schema.tree.hasOwnProperty(method)) {\r\n      throw new Error('You have a method and a property in your schema both ' +\r\n        'named \"' + method + '\"');\r\n    }\r\n\r\n    // Avoid making custom methods if user sets a method to itself, e.g.\r\n    // `schema.method(save, Document.prototype.save)`. Can happen when\r\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\r\n    if (typeof fn === 'function' &&\r\n        Model.prototype[method] === fn) {\r\n      delete schema.methods[method];\r\n      continue;\r\n    }\r\n\r\n    if (schema.reserved[method] &&\r\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\r\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\r\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\r\n        'what you\\'re doing, you can suppress this error by using ' +\r\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\r\n    }\r\n    if (typeof fn === 'function') {\r\n      model.prototype[method] = fn;\r\n    } else {\r\n      apply(method, schema);\r\n    }\r\n  }\r\n\r\n  // Recursively call `applyMethods()` on child schemas\r\n  model.$appliedMethods = true;\r\n  for (const key of Object.keys(schema.paths)) {\r\n    const type = schema.paths[key];\r\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\r\n      applyMethods(type.caster, type.schema);\r\n    }\r\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\r\n      applyMethods(type.Constructor, type.schema);\r\n    }\r\n  }\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC7B,MAAMC,KAAK,GAAGD,OAAO,CAAC,aAAa,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAE,MAAM,CAACC,OAAO,GAAG,SAASC,YAAY,CAACC,KAAK,EAAEC,MAAM,EAAE;EACpD,MAAMC,KAAK,GAAGP,OAAO,CAAC,aAAa,CAAC;EAEpC,SAASQ,KAAK,CAACC,MAAM,EAAEH,MAAM,EAAE;IAC7BI,MAAM,CAACC,cAAc,CAACN,KAAK,CAACO,SAAS,EAAEH,MAAM,EAAE;MAC7CV,GAAG,EAAE,YAAW;QACd,MAAMc,CAAC,GAAG,CAAC,CAAC;QACZ,KAAK,MAAMC,CAAC,IAAIR,MAAM,CAACS,OAAO,CAACN,MAAM,CAAC,EAAE;UACtCI,CAAC,CAACC,CAAC,CAAC,GAAGR,MAAM,CAACS,OAAO,CAACN,MAAM,CAAC,CAACK,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC;QAC7C;QACA,OAAOH,CAAC;MACV,CAAC;MACDI,YAAY,EAAE;IAChB,CAAC,CAAC;EACJ;EACA,KAAK,MAAMR,MAAM,IAAIC,MAAM,CAACQ,IAAI,CAACZ,MAAM,CAACS,OAAO,CAAC,EAAE;IAChD,MAAMI,EAAE,GAAGb,MAAM,CAACS,OAAO,CAACN,MAAM,CAAC;IACjC,IAAIH,MAAM,CAACc,IAAI,CAACC,cAAc,CAACZ,MAAM,CAAC,EAAE;MACtC,MAAM,IAAIa,KAAK,CAAC,uDAAuD,GACrE,SAAS,GAAGb,MAAM,GAAG,GAAG,CAAC;IAC7B;;IAEA;IACA;IACA;IACA,IAAI,OAAOU,EAAE,KAAK,UAAU,IACxBZ,KAAK,CAACK,SAAS,CAACH,MAAM,CAAC,KAAKU,EAAE,EAAE;MAClC,OAAOb,MAAM,CAACS,OAAO,CAACN,MAAM,CAAC;MAC7B;IACF;IAEA,IAAIH,MAAM,CAACiB,QAAQ,CAACd,MAAM,CAAC,IACvB,CAACV,GAAG,CAACO,MAAM,EAAG,iBAAgBG,MAAO,kBAAiB,EAAE,KAAK,CAAC,EAAE;MAClER,KAAK,CAACuB,IAAI,CAAE,8BAA6Bf,MAAO,wBAAuB,GACrE,sEAAsE,GACtE,2DAA2D,GAC1D,oBAAmBA,MAAO,sCAAqC,CAAC;IACrE;IACA,IAAI,OAAOU,EAAE,KAAK,UAAU,EAAE;MAC5Bd,KAAK,CAACO,SAAS,CAACH,MAAM,CAAC,GAAGU,EAAE;IAC9B,CAAC,MAAM;MACLX,KAAK,CAACC,MAAM,EAAEH,MAAM,CAAC;IACvB;EACF;;EAEA;EACAD,KAAK,CAACoB,eAAe,GAAG,IAAI;EAC5B,KAAK,MAAMC,GAAG,IAAIhB,MAAM,CAACQ,IAAI,CAACZ,MAAM,CAACqB,KAAK,CAAC,EAAE;IAC3C,MAAMC,IAAI,GAAGtB,MAAM,CAACqB,KAAK,CAACD,GAAG,CAAC;IAC9B,IAAIE,IAAI,CAACC,eAAe,IAAI,CAACD,IAAI,CAACE,MAAM,CAACL,eAAe,EAAE;MACxDrB,YAAY,CAACwB,IAAI,CAACE,MAAM,EAAEF,IAAI,CAACtB,MAAM,CAAC;IACxC;IACA,IAAIsB,IAAI,CAACG,wBAAwB,IAAI,CAACH,IAAI,CAACI,WAAW,CAACP,eAAe,EAAE;MACtErB,YAAY,CAACwB,IAAI,CAACI,WAAW,EAAEJ,IAAI,CAACtB,MAAM,CAAC;IAC7C;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}