{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\nconst zlib = require(\"zlib\");\nconst constants_1 = require(\"../../constants\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\n/** @public */\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nconst MAX_COMPRESSOR_ID = 3;\nconst ZSTD_COMPRESSION_LEVEL = 3;\n// Facilitate compressing a message using an agreed compressor\nfunction compress(self, dataToBeCompressed, callback) {\n  const zlibOptions = {};\n  switch (self.options.agreedCompressor) {\n    case 'snappy':\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.compress(dataToBeCompressed, callback);\n        } else {\n          deps_1.Snappy.compress(dataToBeCompressed).then(buffer => callback(undefined, buffer), error => callback(error));\n        }\n        break;\n      }\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback);\n      break;\n    case 'zstd':\n      if ('kModuleError' in deps_1.ZStandard) {\n        return callback(deps_1.ZStandard['kModuleError']);\n      }\n      deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(buffer => callback(undefined, buffer), error => callback(error));\n      break;\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${self.options.agreedCompressor} failed to compress`);\n  }\n}\nexports.compress = compress;\n// Decompress a message using the given compressor\nfunction decompress(compressorID, compressedData, callback) {\n  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }, callback);\n        } else {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }).then(buffer => callback(undefined, buffer), error => callback(error));\n        }\n        break;\n      }\n    case exports.Compressor.zstd:\n      {\n        if ('kModuleError' in deps_1.ZStandard) {\n          return callback(deps_1.ZStandard['kModuleError']);\n        }\n        deps_1.ZStandard.decompress(compressedData).then(buffer => callback(undefined, buffer), error => callback(error));\n        break;\n      }\n    case exports.Compressor.zlib:\n      zlib.inflate(compressedData, callback);\n      break;\n    default:\n      callback(undefined, compressedData);\n  }\n}\nexports.decompress = decompress;","map":{"version":3,"mappings":"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","names":["exports","Object","freeze","none","snappy","zlib","zstd","Set","constants_1","MAX_COMPRESSOR_ID","ZSTD_COMPRESSION_LEVEL","compress","self","dataToBeCompressed","callback","zlibOptions","options","agreedCompressor","deps_1","major","then","buffer","undefined","error","zlibCompressionLevel","level","deflate","error_1","decompress","compressorID","compressedData","uncompress","asBuffer","inflate"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\compression.ts"],"sourcesContent":["import * as zlib from 'zlib';\r\n\r\nimport { LEGACY_HELLO_COMMAND } from '../../constants';\r\nimport { PKG_VERSION, Snappy, ZStandard } from '../../deps';\r\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\r\nimport type { Callback } from '../../utils';\r\nimport type { OperationDescription } from '../message_stream';\r\n\r\n/** @public */\r\nexport const Compressor = Object.freeze({\r\n  none: 0,\r\n  snappy: 1,\r\n  zlib: 2,\r\n  zstd: 3\r\n} as const);\r\n\r\n/** @public */\r\nexport type Compressor = typeof Compressor[CompressorName];\r\n\r\n/** @public */\r\nexport type CompressorName = keyof typeof Compressor;\r\n\r\nexport const uncompressibleCommands = new Set([\r\n  LEGACY_HELLO_COMMAND,\r\n  'saslStart',\r\n  'saslContinue',\r\n  'getnonce',\r\n  'authenticate',\r\n  'createUser',\r\n  'updateUser',\r\n  'copydbSaslStart',\r\n  'copydbgetnonce',\r\n  'copydb'\r\n]);\r\n\r\nconst MAX_COMPRESSOR_ID = 3;\r\nconst ZSTD_COMPRESSION_LEVEL = 3;\r\n\r\n// Facilitate compressing a message using an agreed compressor\r\nexport function compress(\r\n  self: { options: OperationDescription & zlib.ZlibOptions },\r\n  dataToBeCompressed: Buffer,\r\n  callback: Callback<Buffer>\r\n): void {\r\n  const zlibOptions = {} as zlib.ZlibOptions;\r\n  switch (self.options.agreedCompressor) {\r\n    case 'snappy': {\r\n      if ('kModuleError' in Snappy) {\r\n        return callback(Snappy['kModuleError']);\r\n      }\r\n\r\n      if (Snappy[PKG_VERSION].major <= 6) {\r\n        Snappy.compress(dataToBeCompressed, callback);\r\n      } else {\r\n        Snappy.compress(dataToBeCompressed).then(\r\n          buffer => callback(undefined, buffer),\r\n          error => callback(error)\r\n        );\r\n      }\r\n      break;\r\n    }\r\n    case 'zlib':\r\n      // Determine zlibCompressionLevel\r\n      if (self.options.zlibCompressionLevel) {\r\n        zlibOptions.level = self.options.zlibCompressionLevel;\r\n      }\r\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback as zlib.CompressCallback);\r\n      break;\r\n    case 'zstd':\r\n      if ('kModuleError' in ZStandard) {\r\n        return callback(ZStandard['kModuleError']);\r\n      }\r\n      ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(\r\n        buffer => callback(undefined, buffer),\r\n        error => callback(error)\r\n      );\r\n      break;\r\n    default:\r\n      throw new MongoInvalidArgumentError(\r\n        `Unknown compressor ${self.options.agreedCompressor} failed to compress`\r\n      );\r\n  }\r\n}\r\n\r\n// Decompress a message using the given compressor\r\nexport function decompress(\r\n  compressorID: Compressor,\r\n  compressedData: Buffer,\r\n  callback: Callback<Buffer>\r\n): void {\r\n  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\r\n    throw new MongoDecompressionError(\r\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\r\n    );\r\n  }\r\n\r\n  switch (compressorID) {\r\n    case Compressor.snappy: {\r\n      if ('kModuleError' in Snappy) {\r\n        return callback(Snappy['kModuleError']);\r\n      }\r\n\r\n      if (Snappy[PKG_VERSION].major <= 6) {\r\n        Snappy.uncompress(compressedData, { asBuffer: true }, callback);\r\n      } else {\r\n        Snappy.uncompress(compressedData, { asBuffer: true }).then(\r\n          buffer => callback(undefined, buffer),\r\n          error => callback(error)\r\n        );\r\n      }\r\n      break;\r\n    }\r\n    case Compressor.zstd: {\r\n      if ('kModuleError' in ZStandard) {\r\n        return callback(ZStandard['kModuleError']);\r\n      }\r\n\r\n      ZStandard.decompress(compressedData).then(\r\n        buffer => callback(undefined, buffer),\r\n        error => callback(error)\r\n      );\r\n      break;\r\n    }\r\n    case Compressor.zlib:\r\n      zlib.inflate(compressedData, callback as zlib.CompressCallback);\r\n      break;\r\n    default:\r\n      callback(undefined, compressedData);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}