{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BSONRegExp = void 0;\nvar error_1 = require(\"./error\");\nfunction alphabetize(str) {\n  return str.split('').sort().join('');\n}\n/**\r\n * A class representation of the BSON RegExp type.\r\n * @public\r\n * @category BSONType\r\n */\nvar BSONRegExp = /** @class */function () {\n  /**\r\n   * @param pattern - The regular expression pattern to match\r\n   * @param options - The regular expression options\r\n   */\n  function BSONRegExp(pattern, options) {\n    if (!(this instanceof BSONRegExp)) return new BSONRegExp(pattern, options);\n    this.pattern = pattern;\n    this.options = alphabetize(options !== null && options !== void 0 ? options : '');\n    if (this.pattern.indexOf('\\x00') !== -1) {\n      throw new error_1.BSONError(\"BSON Regex patterns cannot contain null bytes, found: \".concat(JSON.stringify(this.pattern)));\n    }\n    if (this.options.indexOf('\\x00') !== -1) {\n      throw new error_1.BSONError(\"BSON Regex options cannot contain null bytes, found: \".concat(JSON.stringify(this.options)));\n    }\n    // Validate options\n    for (var i = 0; i < this.options.length; i++) {\n      if (!(this.options[i] === 'i' || this.options[i] === 'm' || this.options[i] === 'x' || this.options[i] === 'l' || this.options[i] === 's' || this.options[i] === 'u')) {\n        throw new error_1.BSONError(\"The regular expression option [\".concat(this.options[i], \"] is not supported\"));\n      }\n    }\n  }\n  BSONRegExp.parseOptions = function (options) {\n    return options ? options.split('').sort().join('') : '';\n  };\n  /** @internal */\n  BSONRegExp.prototype.toExtendedJSON = function (options) {\n    options = options || {};\n    if (options.legacy) {\n      return {\n        $regex: this.pattern,\n        $options: this.options\n      };\n    }\n    return {\n      $regularExpression: {\n        pattern: this.pattern,\n        options: this.options\n      }\n    };\n  };\n  /** @internal */\n  BSONRegExp.fromExtendedJSON = function (doc) {\n    if ('$regex' in doc) {\n      if (typeof doc.$regex !== 'string') {\n        // This is for $regex query operators that have extended json values.\n        if (doc.$regex._bsontype === 'BSONRegExp') {\n          return doc;\n        }\n      } else {\n        return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n      }\n    }\n    if ('$regularExpression' in doc) {\n      return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n    }\n    throw new error_1.BSONTypeError(\"Unexpected BSONRegExp EJSON object form: \".concat(JSON.stringify(doc)));\n  };\n  return BSONRegExp;\n}();\nexports.BSONRegExp = BSONRegExp;\nObject.defineProperty(BSONRegExp.prototype, '_bsontype', {\n  value: 'BSONRegExp'\n});","map":{"version":3,"mappings":"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","names":["alphabetize","str","split","sort","join","pattern","options","BSONRegExp","indexOf","error_1","JSON","stringify","i","length","legacy","$regex","$options","$regularExpression","doc","_bsontype","parseOptions","exports","Object","defineProperty","prototype","value"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\regexp.ts"],"sourcesContent":["import { BSONError, BSONTypeError } from './error';\r\nimport type { EJSONOptions } from './extended_json';\r\n\r\nfunction alphabetize(str: string): string {\r\n  return str.split('').sort().join('');\r\n}\r\n\r\n/** @public */\r\nexport interface BSONRegExpExtendedLegacy {\r\n  $regex: string | BSONRegExp;\r\n  $options: string;\r\n}\r\n\r\n/** @public */\r\nexport interface BSONRegExpExtended {\r\n  $regularExpression: {\r\n    pattern: string;\r\n    options: string;\r\n  };\r\n}\r\n\r\n/**\r\n * A class representation of the BSON RegExp type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport class BSONRegExp {\r\n  _bsontype!: 'BSONRegExp';\r\n\r\n  pattern!: string;\r\n  options!: string;\r\n  /**\r\n   * @param pattern - The regular expression pattern to match\r\n   * @param options - The regular expression options\r\n   */\r\n  constructor(pattern: string, options?: string) {\r\n    if (!(this instanceof BSONRegExp)) return new BSONRegExp(pattern, options);\r\n\r\n    this.pattern = pattern;\r\n    this.options = alphabetize(options ?? '');\r\n\r\n    if (this.pattern.indexOf('\\x00') !== -1) {\r\n      throw new BSONError(\r\n        `BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`\r\n      );\r\n    }\r\n    if (this.options.indexOf('\\x00') !== -1) {\r\n      throw new BSONError(\r\n        `BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`\r\n      );\r\n    }\r\n\r\n    // Validate options\r\n    for (let i = 0; i < this.options.length; i++) {\r\n      if (\r\n        !(\r\n          this.options[i] === 'i' ||\r\n          this.options[i] === 'm' ||\r\n          this.options[i] === 'x' ||\r\n          this.options[i] === 'l' ||\r\n          this.options[i] === 's' ||\r\n          this.options[i] === 'u'\r\n        )\r\n      ) {\r\n        throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\r\n      }\r\n    }\r\n  }\r\n\r\n  static parseOptions(options?: string): string {\r\n    return options ? options.split('').sort().join('') : '';\r\n  }\r\n\r\n  /** @internal */\r\n  toExtendedJSON(options?: EJSONOptions): BSONRegExpExtendedLegacy | BSONRegExpExtended {\r\n    options = options || {};\r\n    if (options.legacy) {\r\n      return { $regex: this.pattern, $options: this.options };\r\n    }\r\n    return { $regularExpression: { pattern: this.pattern, options: this.options } };\r\n  }\r\n\r\n  /** @internal */\r\n  static fromExtendedJSON(doc: BSONRegExpExtendedLegacy | BSONRegExpExtended): BSONRegExp {\r\n    if ('$regex' in doc) {\r\n      if (typeof doc.$regex !== 'string') {\r\n        // This is for $regex query operators that have extended json values.\r\n        if (doc.$regex._bsontype === 'BSONRegExp') {\r\n          return doc as unknown as BSONRegExp;\r\n        }\r\n      } else {\r\n        return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\r\n      }\r\n    }\r\n    if ('$regularExpression' in doc) {\r\n      return new BSONRegExp(\r\n        doc.$regularExpression.pattern,\r\n        BSONRegExp.parseOptions(doc.$regularExpression.options)\r\n      );\r\n    }\r\n    throw new BSONTypeError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\r\n  }\r\n}\r\n\r\nObject.defineProperty(BSONRegExp.prototype, '_bsontype', { value: 'BSONRegExp' });\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}