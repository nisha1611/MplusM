{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst {\n  requestToId\n} = require(\"../ids/IdHelpers\");\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n  compareModulesByIdentifier,\n  compareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\r\n * @callback ChunkFilterFunction\r\n * @param {Chunk} chunk\r\n * @returns {boolean}\r\n */\n\n/**\r\n * @callback CombineSizeFunction\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\n\n/**\r\n * @typedef {Object} CacheGroupSource\r\n * @property {string=} key\r\n * @property {number=} priority\r\n * @property {GetName=} getName\r\n * @property {ChunkFilterFunction=} chunksFilter\r\n * @property {boolean=} enforce\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} minSizeReduction\r\n * @property {SplitChunksSizes} minRemainingSize\r\n * @property {SplitChunksSizes} enforceSizeThreshold\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {number=} minChunks\r\n * @property {number=} maxAsyncRequests\r\n * @property {number=} maxInitialRequests\r\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\r\n * @property {string=} idHint\r\n * @property {string} automaticNameDelimiter\r\n * @property {boolean=} reuseExistingChunk\r\n * @property {boolean=} usedExports\r\n */\n\n/**\r\n * @typedef {Object} CacheGroup\r\n * @property {string} key\r\n * @property {number=} priority\r\n * @property {GetName=} getName\r\n * @property {ChunkFilterFunction=} chunksFilter\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} minSizeReduction\r\n * @property {SplitChunksSizes} minRemainingSize\r\n * @property {SplitChunksSizes} enforceSizeThreshold\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {number=} minChunks\r\n * @property {number=} maxAsyncRequests\r\n * @property {number=} maxInitialRequests\r\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\r\n * @property {string=} idHint\r\n * @property {string} automaticNameDelimiter\r\n * @property {boolean} reuseExistingChunk\r\n * @property {boolean} usedExports\r\n * @property {boolean} _validateSize\r\n * @property {boolean} _validateRemainingSize\r\n * @property {SplitChunksSizes} _minSizeForMaxSize\r\n * @property {boolean} _conditionalEnforce\r\n */\n\n/**\r\n * @typedef {Object} FallbackCacheGroup\r\n * @property {ChunkFilterFunction} chunksFilter\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {string} automaticNameDelimiter\r\n */\n\n/**\r\n * @typedef {Object} CacheGroupsContext\r\n * @property {ModuleGraph} moduleGraph\r\n * @property {ChunkGraph} chunkGraph\r\n */\n\n/**\r\n * @callback GetCacheGroups\r\n * @param {Module} module\r\n * @param {CacheGroupsContext} context\r\n * @returns {CacheGroupSource[]}\r\n */\n\n/**\r\n * @callback GetName\r\n * @param {Module=} module\r\n * @param {Chunk[]=} chunks\r\n * @param {string=} key\r\n * @returns {string=}\r\n */\n\n/**\r\n * @typedef {Object} SplitChunksOptions\r\n * @property {ChunkFilterFunction} chunksFilter\r\n * @property {string[]} defaultSizeTypes\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} minSizeReduction\r\n * @property {SplitChunksSizes} minRemainingSize\r\n * @property {SplitChunksSizes} enforceSizeThreshold\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {number} minChunks\r\n * @property {number} maxAsyncRequests\r\n * @property {number} maxInitialRequests\r\n * @property {boolean} hidePathInfo\r\n * @property {string | function(PathData, AssetInfo=): string} filename\r\n * @property {string} automaticNameDelimiter\r\n * @property {GetCacheGroups} getCacheGroups\r\n * @property {GetName} getName\r\n * @property {boolean} usedExports\r\n * @property {FallbackCacheGroup} fallbackCacheGroup\r\n */\n\n/**\r\n * @typedef {Object} ChunksInfoItem\r\n * @property {SortableSet<Module>} modules\r\n * @property {CacheGroup} cacheGroup\r\n * @property {number} cacheGroupIndex\r\n * @property {string} name\r\n * @property {Record<string, number>} sizes\r\n * @property {Set<Chunk>} chunks\r\n * @property {Set<Chunk>} reuseableChunks\r\n * @property {Set<bigint | Chunk>} chunksKeys\r\n */\n\nconst defaultGetName = /** @type {GetName} */() => {};\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\r\n * @param {string} name a filename to hash\r\n * @param {OutputOptions} outputOptions hash function used\r\n * @returns {string} hashed filename\r\n */\nconst hashFilename = (name, outputOptions) => {\n  const digest = /** @type {string} */\n  createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest);\n  return digest.slice(0, 8);\n};\n\n/**\r\n * @param {Chunk} chunk the chunk\r\n * @returns {number} the number of requests\r\n */\nconst getRequests = chunk => {\n  let requests = 0;\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n  return requests;\n};\nconst mapObject = (obj, fn) => {\n  const newObj = Object.create(null);\n  for (const key of Object.keys(obj)) {\n    newObj[key] = fn(obj[key], key);\n  }\n  return newObj;\n};\n\n/**\r\n * @template T\r\n * @param {Set<T>} a set\r\n * @param {Set<T>} b other set\r\n * @returns {boolean} true if at least one item of a is in b\r\n */\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n  return false;\n};\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\r\n * @param {ChunksInfoItem} a item\r\n * @param {ChunksInfoItem} b item\r\n * @returns {number} compare result\r\n */\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority;\n  // 2. by number of chunks\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount;\n  // 3. by size reduction\n  const aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n  const bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce;\n  // 4. by cache group index\n  const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff;\n  // 5. by number of modules (to be able to compare by identifier)\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff;\n  // 6. by module identifiers\n  modulesA.sort();\n  modulesB.sort();\n  return compareModuleIterables(modulesA, modulesB);\n};\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\r\n * @param {OptimizationSplitChunksSizes} value the sizes\r\n * @param {string[]} defaultSizeTypes the default size types\r\n * @returns {SplitChunksSizes} normalized representation\r\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n  if (typeof value === \"number\") {\n    /** @type {Record<string, number>} */\n    const o = {};\n    for (const sizeType of defaultSizeTypes) o[sizeType] = value;\n    return o;\n  } else if (typeof value === \"object\" && value !== null) {\n    return {\n      ...value\n    };\n  } else {\n    return {};\n  }\n};\n\n/**\r\n * @param {...SplitChunksSizes} sizes the sizes\r\n * @returns {SplitChunksSizes} the merged sizes\r\n */\nconst mergeSizes = function () {\n  /** @type {SplitChunksSizes} */\n  let merged = {};\n  for (let i = arguments.length - 1; i >= 0; i--) {\n    merged = Object.assign(merged, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n  return merged;\n};\n\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @returns {boolean} true, if there are sizes > 0\r\n */\nconst hasNonZeroSizes = sizes => {\n  for (const key of Object.keys(sizes)) {\n    if (sizes[key] > 0) return true;\n  }\n  return false;\n};\n\n/**\r\n * @param {SplitChunksSizes} a first sizes\r\n * @param {SplitChunksSizes} b second sizes\r\n * @param {CombineSizeFunction} combine a function to combine sizes\r\n * @returns {SplitChunksSizes} the combine sizes\r\n */\nconst combineSizes = (a, b, combine) => {\n  const aKeys = new Set(Object.keys(a));\n  const bKeys = new Set(Object.keys(b));\n  /** @type {SplitChunksSizes} */\n  const result = {};\n  for (const key of aKeys) {\n    if (bKeys.has(key)) {\n      result[key] = combine(a[key], b[key]);\n    } else {\n      result[key] = a[key];\n    }\n  }\n  for (const key of bKeys) {\n    if (!aKeys.has(key)) {\n      result[key] = b[key];\n    }\n  }\n  return result;\n};\n\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @param {SplitChunksSizes} minSize the min sizes\r\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\r\n */\nconst checkMinSize = (sizes, minSize) => {\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) return false;\n  }\n  return true;\n};\n\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @param {SplitChunksSizes} minSizeReduction the min sizes\r\n * @param {number} chunkCount number of chunks\r\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\r\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n  for (const key of Object.keys(minSizeReduction)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size * chunkCount < minSizeReduction[key]) return false;\n  }\n  return true;\n};\n\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @param {SplitChunksSizes} minSize the min sizes\r\n * @returns {undefined | string[]} list of size types that are below min size\r\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n  let list;\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) {\n      if (list === undefined) list = [key];else list.push(key);\n    }\n  }\n  return list;\n};\n\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @returns {number} the total size\r\n */\nconst totalSize = sizes => {\n  let size = 0;\n  for (const key of Object.keys(sizes)) {\n    size += sizes[key];\n  }\n  return size;\n};\n\n/**\r\n * @param {false|string|Function} name the chunk name\r\n * @returns {GetName} a function to get the name of the chunk\r\n */\nconst normalizeName = name => {\n  if (typeof name === \"string\") {\n    return () => name;\n  }\n  if (typeof name === \"function\") {\n    return (/** @type {GetName} */name\n    );\n  }\n};\n\n/**\r\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\r\n * @returns {ChunkFilterFunction} the chunk filter function\r\n */\nconst normalizeChunksFilter = chunks => {\n  if (chunks === \"initial\") {\n    return INITIAL_CHUNK_FILTER;\n  }\n  if (chunks === \"async\") {\n    return ASYNC_CHUNK_FILTER;\n  }\n  if (chunks === \"all\") {\n    return ALL_CHUNK_FILTER;\n  }\n  if (typeof chunks === \"function\") {\n    return chunks;\n  }\n};\n\n/**\r\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\r\n * @param {string[]} defaultSizeTypes the default size types\r\n * @returns {GetCacheGroups} a function to get the cache groups\r\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n  if (typeof cacheGroups === \"function\") {\n    return cacheGroups;\n  }\n  if (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n    /** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n    const handlers = [];\n    for (const key of Object.keys(cacheGroups)) {\n      const option = cacheGroups[key];\n      if (option === false) {\n        continue;\n      }\n      if (typeof option === \"string\" || option instanceof RegExp) {\n        const source = createCacheGroupSource({}, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option, module, context)) {\n            results.push(source);\n          }\n        });\n      } else if (typeof option === \"function\") {\n        const cache = new WeakMap();\n        handlers.push((module, context, results) => {\n          const result = option(module);\n          if (result) {\n            const groups = Array.isArray(result) ? result : [result];\n            for (const group of groups) {\n              const cachedSource = cache.get(group);\n              if (cachedSource !== undefined) {\n                results.push(cachedSource);\n              } else {\n                const source = createCacheGroupSource(group, key, defaultSizeTypes);\n                cache.set(group, source);\n                results.push(source);\n              }\n            }\n          }\n        });\n      } else {\n        const source = createCacheGroupSource(option, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module)) {\n            results.push(source);\n          }\n        });\n      }\n    }\n    /**\r\n     * @param {Module} module the current module\r\n     * @param {CacheGroupsContext} context the current context\r\n     * @returns {CacheGroupSource[]} the matching cache groups\r\n     */\n    const fn = (module, context) => {\n      /** @type {CacheGroupSource[]} */\n      let results = [];\n      for (const fn of handlers) {\n        fn(module, context, results);\n      }\n      return results;\n    };\n    return fn;\n  }\n  return () => null;\n};\n\n/**\r\n * @param {undefined|boolean|string|RegExp|Function} test test option\r\n * @param {Module} module the module\r\n * @param {CacheGroupsContext} context context object\r\n * @returns {boolean} true, if the module should be selected\r\n */\nconst checkTest = (test, module, context) => {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module, context);\n  }\n  if (typeof test === \"boolean\") return test;\n  if (typeof test === \"string\") {\n    const name = module.nameForCondition();\n    return name && name.startsWith(test);\n  }\n  if (test instanceof RegExp) {\n    const name = module.nameForCondition();\n    return name && test.test(name);\n  }\n  return false;\n};\n\n/**\r\n * @param {undefined|string|RegExp|Function} test type option\r\n * @param {Module} module the module\r\n * @returns {boolean} true, if the module should be selected\r\n */\nconst checkModuleType = (test, module) => {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module.type);\n  }\n  if (typeof test === \"string\") {\n    const type = module.type;\n    return test === type;\n  }\n  if (test instanceof RegExp) {\n    const type = module.type;\n    return test.test(type);\n  }\n  return false;\n};\n\n/**\r\n * @param {undefined|string|RegExp|Function} test type option\r\n * @param {Module} module the module\r\n * @returns {boolean} true, if the module should be selected\r\n */\nconst checkModuleLayer = (test, module) => {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module.layer);\n  }\n  if (typeof test === \"string\") {\n    const layer = module.layer;\n    return test === \"\" ? !layer : layer && layer.startsWith(test);\n  }\n  if (test instanceof RegExp) {\n    const layer = module.layer;\n    return test.test(layer);\n  }\n  return false;\n};\n\n/**\r\n * @param {OptimizationSplitChunksCacheGroup} options the group options\r\n * @param {string} key key of cache group\r\n * @param {string[]} defaultSizeTypes the default size types\r\n * @returns {CacheGroupSource} the normalized cached group\r\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n  const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n  const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n  const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n  return {\n    key,\n    priority: options.priority,\n    getName: normalizeName(options.name),\n    chunksFilter: normalizeChunksFilter(options.chunks),\n    enforce: options.enforce,\n    minSize,\n    minSizeReduction,\n    minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n    enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n    maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n    maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n    minChunks: options.minChunks,\n    maxAsyncRequests: options.maxAsyncRequests,\n    maxInitialRequests: options.maxInitialRequests,\n    filename: options.filename,\n    idHint: options.idHint,\n    automaticNameDelimiter: options.automaticNameDelimiter,\n    reuseExistingChunk: options.reuseExistingChunk,\n    usedExports: options.usedExports\n  };\n};\nmodule.exports = class SplitChunksPlugin {\n  /**\r\n   * @param {OptimizationSplitChunksOptions=} options plugin options\r\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultSizeTypes = options.defaultSizeTypes || [\"javascript\", \"unknown\"];\n    const fallbackCacheGroup = options.fallbackCacheGroup || {};\n    const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n    const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n    const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n    /** @type {SplitChunksOptions} */\n    this.options = {\n      chunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n      defaultSizeTypes,\n      minSize,\n      minSizeReduction,\n      minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n      enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n      maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n      maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),\n      getName: options.name ? normalizeName(options.name) : defaultGetName,\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      usedExports: options.usedExports,\n      fallbackCacheGroup: {\n        chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || \"all\"),\n        minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),\n        maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || \"~\"\n      }\n    };\n\n    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n    this._cacheGroupCache = new WeakMap();\n  }\n\n  /**\r\n   * @param {CacheGroupSource} cacheGroupSource source\r\n   * @returns {CacheGroup} the cache group (cached)\r\n   */\n  _getCacheGroup(cacheGroupSource) {\n    const cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n    if (cacheEntry !== undefined) return cacheEntry;\n    const minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? undefined : this.options.minSize);\n    const minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? undefined : this.options.minSizeReduction);\n    const minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? undefined : this.options.minRemainingSize);\n    const enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold);\n    const cacheGroup = {\n      key: cacheGroupSource.key,\n      priority: cacheGroupSource.priority || 0,\n      chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n      minSize,\n      minSizeReduction,\n      minRemainingSize,\n      enforceSizeThreshold,\n      maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? undefined : this.options.maxAsyncSize),\n      maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? undefined : this.options.maxInitialSize),\n      minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n      maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n      maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n      getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n      usedExports: cacheGroupSource.usedExports !== undefined ? cacheGroupSource.usedExports : this.options.usedExports,\n      filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n      automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n      idHint: cacheGroupSource.idHint !== undefined ? cacheGroupSource.idHint : cacheGroupSource.key,\n      reuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n      _validateSize: hasNonZeroSizes(minSize),\n      _validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n      _minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),\n      _conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n    };\n    this._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n    return cacheGroup;\n  }\n\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler the compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    const cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      const logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"SplitChunksPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true;\n        logger.time(\"prepare\");\n        const chunkGraph = compilation.chunkGraph;\n        const moduleGraph = compilation.moduleGraph;\n        // Give each selected chunk an index (to create strings from chunks)\n        /** @type {Map<Chunk, bigint>} */\n        const chunkIndexMap = new Map();\n        const ZERO = BigInt(\"0\");\n        const ONE = BigInt(\"1\");\n        const START = ONE << BigInt(\"31\");\n        let index = START;\n        for (const chunk of chunks) {\n          chunkIndexMap.set(chunk, index | BigInt(Math.random() * 0x7fffffff | 0));\n          index = index << ONE;\n        }\n        /**\r\n         * @param {Iterable<Chunk>} chunks list of chunks\r\n         * @returns {bigint | Chunk} key of the chunks\r\n         */\n        const getKey = chunks => {\n          const iterator = chunks[Symbol.iterator]();\n          let result = iterator.next();\n          if (result.done) return ZERO;\n          const first = result.value;\n          result = iterator.next();\n          if (result.done) return first;\n          let key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n          while (!(result = iterator.next()).done) {\n            const raw = chunkIndexMap.get(result.value);\n            key = key ^ raw;\n          }\n          return key;\n        };\n        const keyToString = key => {\n          if (typeof key === \"bigint\") return key.toString(16);\n          return chunkIndexMap.get(key).toString(16);\n        };\n        const getChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n          const singleChunkSets = new Set();\n          for (const module of compilation.modules) {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n            if (typeof chunksKey === \"bigint\") {\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(chunks));\n              }\n            } else {\n              singleChunkSets.add(chunksKey);\n            }\n          }\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        });\n\n        /**\r\n         * @param {Module} module the module\r\n         * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\r\n         */\n        const groupChunksByExports = module => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const groupedByUsedExports = new Map();\n          for (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n            const key = exportsInfo.getUsageKey(chunk.runtime);\n            const list = groupedByUsedExports.get(key);\n            if (list !== undefined) {\n              list.push(chunk);\n            } else {\n              groupedByUsedExports.set(key, [chunk]);\n            }\n          }\n          return groupedByUsedExports.values();\n        };\n\n        /** @type {Map<Module, Iterable<Chunk[]>>} */\n        const groupedByExportsMap = new Map();\n        const getExportsChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n          const singleChunkSets = new Set();\n          for (const module of compilation.modules) {\n            const groupedChunks = Array.from(groupChunksByExports(module));\n            groupedByExportsMap.set(module, groupedChunks);\n            for (const chunks of groupedChunks) {\n              if (chunks.length === 1) {\n                singleChunkSets.add(chunks[0]);\n              } else {\n                const chunksKey = /** @type {bigint} */getKey(chunks);\n                if (!chunkSetsInGraph.has(chunksKey)) {\n                  chunkSetsInGraph.set(chunksKey, new Set(chunks));\n                }\n              }\n            }\n          }\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        });\n\n        // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n        const groupChunkSetsByCount = chunkSets => {\n          /** @type {Map<number, Array<Set<Chunk>>>} */\n          const chunkSetsByCount = new Map();\n          for (const chunksSet of chunkSets) {\n            const count = chunksSet.size;\n            let array = chunkSetsByCount.get(count);\n            if (array === undefined) {\n              array = [];\n              chunkSetsByCount.set(count, array);\n            }\n            array.push(chunksSet);\n          }\n          return chunkSetsByCount;\n        };\n        const getChunkSetsByCount = memoize(() => groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values()));\n        const getExportsChunkSetsByCount = memoize(() => groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values()));\n\n        // Create a list of possible combinations\n        const createGetCombinations = (chunkSets, singleChunkSets, chunkSetsByCount) => {\n          /** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n          const combinationsCache = new Map();\n          return key => {\n            const cacheEntry = combinationsCache.get(key);\n            if (cacheEntry !== undefined) return cacheEntry;\n            if (key instanceof Chunk) {\n              const result = [key];\n              combinationsCache.set(key, result);\n              return result;\n            }\n            const chunksSet = chunkSets.get(key);\n            /** @type {(Set<Chunk> | Chunk)[]} */\n            const array = [chunksSet];\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n            for (const chunk of singleChunkSets) {\n              if (chunksSet.has(chunk)) {\n                array.push(chunk);\n              }\n            }\n            combinationsCache.set(key, array);\n            return array;\n          };\n        };\n        const getCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());\n        });\n        const getCombinations = key => getCombinationsFactory()(key);\n        const getExportsCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getExportsChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());\n        });\n        const getExportsCombinations = key => getExportsCombinationsFactory()(key);\n\n        /**\r\n         * @typedef {Object} SelectedChunksResult\r\n         * @property {Chunk[]} chunks the list of chunks\r\n         * @property {bigint | Chunk} key a key of the list\r\n         */\n\n        /** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n        const selectedChunksCacheByChunksSet = new WeakMap();\n\n        /**\r\n         * get list and key by applying the filter function to the list\r\n         * It is cached for performance reasons\r\n         * @param {Set<Chunk> | Chunk} chunks list of chunks\r\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\r\n         * @returns {SelectedChunksResult} list and key\r\n         */\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n          let entry2 = entry.get(chunkFilter);\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n            if (chunks instanceof Chunk) {\n              if (chunkFilter(chunks)) selectedChunks.push(chunks);\n            } else {\n              for (const chunk of chunks) {\n                if (chunkFilter(chunk)) selectedChunks.push(chunk);\n              }\n            }\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n          return entry2;\n        };\n\n        /** @type {Map<string, boolean>} */\n        const alreadyValidatedParents = new Map();\n        /** @type {Set<string>} */\n        const alreadyReportedErrors = new Set();\n\n        // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n        /** @type {Map<string, ChunksInfoItem>} */\n        const chunksInfoMap = new Map();\n\n        /**\r\n         * @param {CacheGroup} cacheGroup the current cache group\r\n         * @param {number} cacheGroupIndex the index of the cache group of ordering\r\n         * @param {Chunk[]} selectedChunks chunks selected for this module\r\n         * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\r\n         * @param {Module} module the current module\r\n         * @returns {void}\r\n         */\n        const addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return;\n          // Determine name for split chunk\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key);\n          // Check if the name is ok\n          const existingChunk = compilation.namedChunks.get(name);\n          if (existingChunk) {\n            const parentValidationKey = `${name}|${typeof selectedChunksKey === \"bigint\" ? selectedChunksKey : selectedChunksKey.debugId}`;\n            const valid = alreadyValidatedParents.get(parentValidationKey);\n            if (valid === false) return;\n            if (valid === undefined) {\n              // Module can only be moved into the existing chunk if the existing chunk\n              // is a parent of all selected chunks\n              let isInAllParents = true;\n              /** @type {Set<ChunkGroup>} */\n              const queue = new Set();\n              for (const chunk of selectedChunks) {\n                for (const group of chunk.groupsIterable) {\n                  queue.add(group);\n                }\n              }\n              for (const group of queue) {\n                if (existingChunk.isInGroup(group)) continue;\n                let hasParent = false;\n                for (const parent of group.parentsIterable) {\n                  hasParent = true;\n                  queue.add(parent);\n                }\n                if (!hasParent) {\n                  isInAllParents = false;\n                }\n              }\n              const valid = isInAllParents;\n              alreadyValidatedParents.set(parentValidationKey, valid);\n              if (!valid) {\n                if (!alreadyReportedErrors.has(name)) {\n                  alreadyReportedErrors.add(name);\n                  compilation.errors.push(new WebpackError(\"SplitChunksPlugin\\n\" + `Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` + `Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` + \"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" + 'HINT: You can omit \"name\" to automatically create a name.\\n' + \"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" + \"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" + \"Remove this entrypoint and add modules to cache group's 'test' instead. \" + \"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" + \"See migration guide of more info.\"));\n                }\n                return;\n              }\n            }\n          }\n          // Create key for maps\n          // When it has a name we use the name as key\n          // Otherwise we create the key from chunks and cache group key\n          // This automatically merges equal names\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${keyToString(selectedChunksKey)}`);\n          // Add module to maps\n          let info = chunksInfoMap.get(key);\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, compareModulesByIdentifier),\n              cacheGroup,\n              cacheGroupIndex,\n              name,\n              sizes: {},\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n          const oldSize = info.modules.size;\n          info.modules.add(module);\n          if (info.modules.size !== oldSize) {\n            for (const type of module.getSourceTypes()) {\n              info.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n            }\n          }\n          const oldChunksKeysSize = info.chunksKeys.size;\n          info.chunksKeys.add(selectedChunksKey);\n          if (oldChunksKeysSize !== info.chunksKeys.size) {\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        };\n        const context = {\n          moduleGraph,\n          chunkGraph\n        };\n        logger.timeEnd(\"prepare\");\n        logger.time(\"modules\");\n\n        // Walk through all modules\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module, context);\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          }\n\n          // Prepare some values (usedExports = false)\n          const getCombs = memoize(() => {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n            return getCombinations(chunksKey);\n          });\n\n          // Prepare some values (usedExports = true)\n          const getCombsByUsedExports = memoize(() => {\n            // fill the groupedByExportsMap\n            getExportsChunkSetsInGraph();\n            /** @type {Set<Set<Chunk> | Chunk>} */\n            const set = new Set();\n            const groupedByUsedExports = groupedByExportsMap.get(module);\n            for (const chunks of groupedByUsedExports) {\n              const chunksKey = getKey(chunks);\n              for (const comb of getExportsCombinations(chunksKey)) set.add(comb);\n            }\n            return set;\n          });\n          let cacheGroupIndex = 0;\n          for (const cacheGroupSource of cacheGroups) {\n            const cacheGroup = this._getCacheGroup(cacheGroupSource);\n            const combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs();\n            // For all combination of chunk selection\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              const count = chunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n              if (count < cacheGroup.minChunks) continue;\n              // Select chunks by configuration\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n            }\n            cacheGroupIndex++;\n          }\n        }\n        logger.timeEnd(\"modules\");\n        logger.time(\"queue\");\n\n        /**\r\n         * @param {ChunksInfoItem} info entry\r\n         * @param {string[]} sourceTypes source types to be removed\r\n         */\n        const removeModulesWithSourceType = (info, sourceTypes) => {\n          for (const module of info.modules) {\n            const types = module.getSourceTypes();\n            if (sourceTypes.some(type => types.has(type))) {\n              info.modules.delete(module);\n              for (const type of types) {\n                info.sizes[type] -= module.size(type);\n              }\n            }\n          }\n        };\n\n        /**\r\n         * @param {ChunksInfoItem} info entry\r\n         * @returns {boolean} true, if entry become empty\r\n         */\n        const removeMinSizeViolatingModules = info => {\n          if (!info.cacheGroup._validateSize) return false;\n          const violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);\n          if (violatingSizes === undefined) return false;\n          removeModulesWithSourceType(info, violatingSizes);\n          return info.modules.size === 0;\n        };\n\n        // Filter items were size < minSize\n        for (const [key, info] of chunksInfoMap) {\n          if (removeMinSizeViolatingModules(info)) {\n            chunksInfoMap.delete(key);\n          } else if (!checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n            chunksInfoMap.delete(key);\n          }\n        }\n\n        /**\r\n         * @typedef {Object} MaxSizeQueueItem\r\n         * @property {SplitChunksSizes} minSize\r\n         * @property {SplitChunksSizes} maxAsyncSize\r\n         * @property {SplitChunksSizes} maxInitialSize\r\n         * @property {string} automaticNameDelimiter\r\n         * @property {string[]} keys\r\n         */\n\n        /** @type {Map<Chunk, MaxSizeQueueItem>} */\n        const maxSizeQueueMap = new Map();\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n            if (bestEntry === undefined || compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name;\n          // Variable for the new chunk (lazy created)\n          /** @type {Chunk} */\n          let newChunk;\n          // When no chunk name, check if we can reuse a chunk instead of creating a new one\n          let isExistingChunk = false;\n          let isReusedWithAllModules = false;\n          if (chunkName) {\n            const chunkByName = compilation.namedChunks.get(chunkName);\n            if (chunkByName !== undefined) {\n              newChunk = chunkByName;\n              const oldSize = item.chunks.size;\n              item.chunks.delete(newChunk);\n              isExistingChunk = item.chunks.size !== oldSize;\n            }\n          } else if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunkGraph.getNumberOfChunkModules(chunk) !== item.modules.size) {\n                continue;\n              }\n              if (item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n                continue;\n              }\n              for (const module of item.modules) {\n                if (!chunkGraph.isModuleInChunk(module, chunk)) {\n                  continue outer;\n                }\n              }\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n            }\n            if (newChunk) {\n              item.chunks.delete(newChunk);\n              chunkName = undefined;\n              isExistingChunk = true;\n              isReusedWithAllModules = true;\n            }\n          }\n          const enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n          const usedChunks = new Set(item.chunks);\n\n          // Check if maxRequests condition can be fulfilled\n          if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n            for (const chunk of usedChunks) {\n              // respect max requests\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n              if (isFinite(maxRequests) && getRequests(chunk) >= maxRequests) {\n                usedChunks.delete(chunk);\n              }\n            }\n          }\n          outer: for (const chunk of usedChunks) {\n            for (const module of item.modules) {\n              if (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n            }\n            usedChunks.delete(chunk);\n          }\n\n          // Were some (invalid) chunks removed from usedChunks?\n          // => readd all modules to the queue, as things could have been changed\n          if (usedChunks.size < item.chunks.size) {\n            if (isExistingChunk) usedChunks.add(newChunk);\n            if (usedChunks.size >= item.cacheGroup.minChunks) {\n              const chunksArr = Array.from(usedChunks);\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);\n              }\n            }\n            continue;\n          }\n\n          // Validate minRemainingSize constraint when a single chunk is left over\n          if (!enforced && item.cacheGroup._validateRemainingSize && usedChunks.size === 1) {\n            const [chunk] = usedChunks;\n            let chunkSizes = Object.create(null);\n            for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n              if (!item.modules.has(module)) {\n                for (const type of module.getSourceTypes()) {\n                  chunkSizes[type] = (chunkSizes[type] || 0) + module.size(type);\n                }\n              }\n            }\n            const violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);\n            if (violatingSizes !== undefined) {\n              const oldModulesSize = item.modules.size;\n              removeModulesWithSourceType(item, violatingSizes);\n              if (item.modules.size > 0 && item.modules.size !== oldModulesSize) {\n                // queue this item again to be processed again\n                // without violating modules\n                chunksInfoMap.set(bestEntryKey, item);\n              }\n              continue;\n            }\n          }\n\n          // Create the new chunk if not reusing one\n          if (newChunk === undefined) {\n            newChunk = compilation.addChunk(chunkName);\n          }\n          // Walk through all chunks\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          }\n\n          // Add a note to the chunk\n          newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") + (isReusedWithAllModules ? \"reused as split chunk\" : \"split chunk\");\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`;\n          }\n          if (item.cacheGroup.filename) {\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n          if (item.cacheGroup.idHint) {\n            newChunk.idNameHints.add(item.cacheGroup.idHint);\n          }\n          if (!isReusedWithAllModules) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (!module.chunkCondition(newChunk, compilation)) continue;\n              // Add module to new chunk\n              chunkGraph.connectChunkAndModule(newChunk, module);\n              // Remove module from used chunks\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          }\n          if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,\n              maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,\n              maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          }\n\n          // remove all modules from other entries and update size\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, usedChunks)) {\n              // update modules and total size\n              // may remove it from the map when < minSize\n              let updated = false;\n              for (const module of item.modules) {\n                if (info.modules.has(module)) {\n                  // remove module\n                  info.modules.delete(module);\n                  // update size\n                  for (const key of module.getSourceTypes()) {\n                    info.sizes[key] -= module.size(key);\n                  }\n                  updated = true;\n                }\n              }\n              if (updated) {\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n                if (removeMinSizeViolatingModules(info) || !checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n              }\n            }\n          }\n        }\n        logger.timeEnd(\"queue\");\n        logger.time(\"maxSize\");\n\n        /** @type {Set<string>} */\n        const incorrectMinMaxSizeSet = new Set();\n        const {\n          outputOptions\n        } = compilation;\n\n        // Make sure that maxSize is fulfilled\n        const {\n          fallbackCacheGroup\n        } = this.options;\n        for (const chunk of Array.from(compilation.chunks)) {\n          const chunkConfig = maxSizeQueueMap.get(chunk);\n          const {\n            minSize,\n            maxAsyncSize,\n            maxInitialSize,\n            automaticNameDelimiter\n          } = chunkConfig || fallbackCacheGroup;\n          if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) continue;\n          /** @type {SplitChunksSizes} */\n          let maxSize;\n          if (chunk.isOnlyInitial()) {\n            maxSize = maxInitialSize;\n          } else if (chunk.canBeInitial()) {\n            maxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n          } else {\n            maxSize = maxAsyncSize;\n          }\n          if (Object.keys(maxSize).length === 0) {\n            continue;\n          }\n          for (const key of Object.keys(maxSize)) {\n            const maxSizeValue = maxSize[key];\n            const minSizeValue = minSize[key];\n            if (typeof minSizeValue === \"number\" && minSizeValue > maxSizeValue) {\n              const keys = chunkConfig && chunkConfig.keys;\n              const warningKey = `${keys && keys.join()} ${minSizeValue} ${maxSizeValue}`;\n              if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                incorrectMinMaxSizeSet.add(warningKey);\n                compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue));\n              }\n            }\n          }\n          const results = deterministicGroupingForModules({\n            minSize,\n            maxSize: mapObject(maxSize, (value, key) => {\n              const minSizeValue = minSize[key];\n              return typeof minSizeValue === \"number\" ? Math.max(value, minSizeValue) : value;\n            }),\n            items: chunkGraph.getChunkModulesIterable(chunk),\n            getKey(module) {\n              const cache = getKeyCache.get(module);\n              if (cache !== undefined) return cache;\n              const ident = cachedMakePathsRelative(module.identifier());\n              const nameForCondition = module.nameForCondition && module.nameForCondition();\n              const name = nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident, outputOptions);\n              const key = requestToId(fullKey);\n              getKeyCache.set(module, key);\n              return key;\n            },\n            getSize(module) {\n              const size = Object.create(null);\n              for (const key of module.getSourceTypes()) {\n                size[key] = module.size(key);\n              }\n              return size;\n            }\n          });\n          if (results.length <= 1) {\n            continue;\n          }\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions);\n            }\n            if (i !== results.length - 1) {\n              const newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason;\n              // Add all modules to the new chunk\n              for (const module of group.items) {\n                if (!module.chunkCondition(newPart, compilation)) {\n                  continue;\n                }\n                // Add module to new chunk\n                chunkGraph.connectChunkAndModule(newPart, module);\n                // Remove module from used chunks\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            } else {\n              // change the chunk to be a part\n              chunk.name = name;\n            }\n          }\n        }\n        logger.timeEnd(\"maxSize\");\n      });\n    });\n  }\n};","map":{"version":3,"names":["Chunk","require","STAGE_ADVANCED","WebpackError","requestToId","isSubset","SortableSet","compareModulesByIdentifier","compareIterables","createHash","deterministicGrouping","makePathsRelative","memoize","MinMaxSizeWarning","defaultGetName","deterministicGroupingForModules","getKeyCache","WeakMap","hashFilename","name","outputOptions","digest","hashFunction","update","hashDigest","slice","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","mapObject","obj","fn","newObj","Object","create","key","keys","isOverlap","a","b","item","has","compareModuleIterables","compareEntries","diffPriority","cacheGroup","priority","diffCount","size","aSizeReduce","totalSize","sizes","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modules","modulesB","diff","sort","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","normalizeSizes","value","defaultSizeTypes","o","sizeType","mergeSizes","merged","i","assign","hasNonZeroSizes","combineSizes","combine","aKeys","Set","bKeys","result","checkMinSize","minSize","undefined","checkMinSizeReduction","minSizeReduction","chunkCount","getViolatingMinSizes","list","push","normalizeName","normalizeChunksFilter","normalizeCacheGroups","cacheGroups","handlers","option","RegExp","source","createCacheGroupSource","module","context","results","checkTest","cache","groups","Array","isArray","group","cachedSource","get","set","test","checkModuleType","type","checkModuleLayer","layer","nameForCondition","startsWith","options","maxSize","getName","chunksFilter","enforce","minRemainingSize","enforceSizeThreshold","maxAsyncSize","maxInitialSize","minChunks","maxAsyncRequests","maxInitialRequests","filename","idHint","automaticNameDelimiter","reuseExistingChunk","usedExports","exports","SplitChunksPlugin","constructor","fallbackCacheGroup","hidePathInfo","getCacheGroups","_cacheGroupCache","_getCacheGroup","cacheGroupSource","cacheEntry","Infinity","_validateSize","_validateRemainingSize","_minSizeForMaxSize","_conditionalEnforce","apply","compiler","cachedMakePathsRelative","bindContextCache","root","hooks","thisCompilation","tap","compilation","logger","getLogger","alreadyOptimized","unseal","optimizeChunks","stage","time","chunkGraph","moduleGraph","chunkIndexMap","Map","ZERO","BigInt","ONE","START","index","random","getKey","iterator","Symbol","next","done","first","raw","keyToString","toString","getChunkSetsInGraph","chunkSetsInGraph","singleChunkSets","getModuleChunksIterable","chunksKey","add","groupChunksByExports","exportsInfo","getExportsInfo","groupedByUsedExports","getUsageKey","runtime","values","groupedByExportsMap","getExportsChunkSetsInGraph","groupedChunks","from","groupChunkSetsByCount","chunkSets","chunkSetsByCount","chunksSet","count","array","getChunkSetsByCount","getExportsChunkSetsByCount","createGetCombinations","combinationsCache","setArray","getCombinationsFactory","getCombinations","getExportsCombinationsFactory","getExportsCombinations","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","alreadyValidatedParents","alreadyReportedErrors","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","existingChunk","namedChunks","parentValidationKey","debugId","valid","isInAllParents","queue","isInGroup","hasParent","parent","parentsIterable","errors","info","reuseableChunks","chunksKeys","oldSize","getSourceTypes","oldChunksKeysSize","timeEnd","getCombs","getCombsByUsedExports","comb","combs","chunkCombination","removeModulesWithSourceType","sourceTypes","types","some","delete","removeMinSizeViolatingModules","violatingSizes","maxSizeQueueMap","bestEntryKey","bestEntry","pair","chunkName","newChunk","isExistingChunk","isReusedWithAllModules","chunkByName","outer","getNumberOfChunkModules","getNumberOfEntryModules","isModuleInChunk","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","chunkSizes","getChunkModulesIterable","oldModulesSize","addChunk","split","chunkReason","filenameTemplate","idNameHints","chunkCondition","connectChunkAndModule","disconnectChunkAndModule","oldMaxSizeSettings","concat","updated","incorrectMinMaxSizeSet","chunkConfig","maxSizeValue","minSizeValue","warningKey","join","warnings","items","ident","identifier","replace","fullKey","getSize","newPart"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst Chunk = require(\"../Chunk\");\r\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\r\nconst WebpackError = require(\"../WebpackError\");\r\nconst { requestToId } = require(\"../ids/IdHelpers\");\r\nconst { isSubset } = require(\"../util/SetHelpers\");\r\nconst SortableSet = require(\"../util/SortableSet\");\r\nconst {\r\n\tcompareModulesByIdentifier,\r\n\tcompareIterables\r\n} = require(\"../util/comparators\");\r\nconst createHash = require(\"../util/createHash\");\r\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\r\nconst { makePathsRelative } = require(\"../util/identifier\");\r\nconst memoize = require(\"../util/memoize\");\r\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\r\n\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\r\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\r\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\r\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\r\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\r\n/** @typedef {import(\"../Compilation\").PathData} PathData */\r\n/** @typedef {import(\"../Compiler\")} Compiler */\r\n/** @typedef {import(\"../Module\")} Module */\r\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\r\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\r\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\r\n\r\n/** @typedef {Record<string, number>} SplitChunksSizes */\r\n\r\n/**\r\n * @callback ChunkFilterFunction\r\n * @param {Chunk} chunk\r\n * @returns {boolean}\r\n */\r\n\r\n/**\r\n * @callback CombineSizeFunction\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\r\n\r\n/**\r\n * @typedef {Object} CacheGroupSource\r\n * @property {string=} key\r\n * @property {number=} priority\r\n * @property {GetName=} getName\r\n * @property {ChunkFilterFunction=} chunksFilter\r\n * @property {boolean=} enforce\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} minSizeReduction\r\n * @property {SplitChunksSizes} minRemainingSize\r\n * @property {SplitChunksSizes} enforceSizeThreshold\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {number=} minChunks\r\n * @property {number=} maxAsyncRequests\r\n * @property {number=} maxInitialRequests\r\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\r\n * @property {string=} idHint\r\n * @property {string} automaticNameDelimiter\r\n * @property {boolean=} reuseExistingChunk\r\n * @property {boolean=} usedExports\r\n */\r\n\r\n/**\r\n * @typedef {Object} CacheGroup\r\n * @property {string} key\r\n * @property {number=} priority\r\n * @property {GetName=} getName\r\n * @property {ChunkFilterFunction=} chunksFilter\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} minSizeReduction\r\n * @property {SplitChunksSizes} minRemainingSize\r\n * @property {SplitChunksSizes} enforceSizeThreshold\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {number=} minChunks\r\n * @property {number=} maxAsyncRequests\r\n * @property {number=} maxInitialRequests\r\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\r\n * @property {string=} idHint\r\n * @property {string} automaticNameDelimiter\r\n * @property {boolean} reuseExistingChunk\r\n * @property {boolean} usedExports\r\n * @property {boolean} _validateSize\r\n * @property {boolean} _validateRemainingSize\r\n * @property {SplitChunksSizes} _minSizeForMaxSize\r\n * @property {boolean} _conditionalEnforce\r\n */\r\n\r\n/**\r\n * @typedef {Object} FallbackCacheGroup\r\n * @property {ChunkFilterFunction} chunksFilter\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {string} automaticNameDelimiter\r\n */\r\n\r\n/**\r\n * @typedef {Object} CacheGroupsContext\r\n * @property {ModuleGraph} moduleGraph\r\n * @property {ChunkGraph} chunkGraph\r\n */\r\n\r\n/**\r\n * @callback GetCacheGroups\r\n * @param {Module} module\r\n * @param {CacheGroupsContext} context\r\n * @returns {CacheGroupSource[]}\r\n */\r\n\r\n/**\r\n * @callback GetName\r\n * @param {Module=} module\r\n * @param {Chunk[]=} chunks\r\n * @param {string=} key\r\n * @returns {string=}\r\n */\r\n\r\n/**\r\n * @typedef {Object} SplitChunksOptions\r\n * @property {ChunkFilterFunction} chunksFilter\r\n * @property {string[]} defaultSizeTypes\r\n * @property {SplitChunksSizes} minSize\r\n * @property {SplitChunksSizes} minSizeReduction\r\n * @property {SplitChunksSizes} minRemainingSize\r\n * @property {SplitChunksSizes} enforceSizeThreshold\r\n * @property {SplitChunksSizes} maxInitialSize\r\n * @property {SplitChunksSizes} maxAsyncSize\r\n * @property {number} minChunks\r\n * @property {number} maxAsyncRequests\r\n * @property {number} maxInitialRequests\r\n * @property {boolean} hidePathInfo\r\n * @property {string | function(PathData, AssetInfo=): string} filename\r\n * @property {string} automaticNameDelimiter\r\n * @property {GetCacheGroups} getCacheGroups\r\n * @property {GetName} getName\r\n * @property {boolean} usedExports\r\n * @property {FallbackCacheGroup} fallbackCacheGroup\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChunksInfoItem\r\n * @property {SortableSet<Module>} modules\r\n * @property {CacheGroup} cacheGroup\r\n * @property {number} cacheGroupIndex\r\n * @property {string} name\r\n * @property {Record<string, number>} sizes\r\n * @property {Set<Chunk>} chunks\r\n * @property {Set<Chunk>} reuseableChunks\r\n * @property {Set<bigint | Chunk>} chunksKeys\r\n */\r\n\r\nconst defaultGetName = /** @type {GetName} */ (() => {});\r\n\r\nconst deterministicGroupingForModules =\r\n\t/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (\r\n\t\tdeterministicGrouping\r\n\t);\r\n\r\n/** @type {WeakMap<Module, string>} */\r\nconst getKeyCache = new WeakMap();\r\n\r\n/**\r\n * @param {string} name a filename to hash\r\n * @param {OutputOptions} outputOptions hash function used\r\n * @returns {string} hashed filename\r\n */\r\nconst hashFilename = (name, outputOptions) => {\r\n\tconst digest = /** @type {string} */ (\r\n\t\tcreateHash(outputOptions.hashFunction)\r\n\t\t\t.update(name)\r\n\t\t\t.digest(outputOptions.hashDigest)\r\n\t);\r\n\treturn digest.slice(0, 8);\r\n};\r\n\r\n/**\r\n * @param {Chunk} chunk the chunk\r\n * @returns {number} the number of requests\r\n */\r\nconst getRequests = chunk => {\r\n\tlet requests = 0;\r\n\tfor (const chunkGroup of chunk.groupsIterable) {\r\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\r\n\t}\r\n\treturn requests;\r\n};\r\n\r\nconst mapObject = (obj, fn) => {\r\n\tconst newObj = Object.create(null);\r\n\tfor (const key of Object.keys(obj)) {\r\n\t\tnewObj[key] = fn(obj[key], key);\r\n\t}\r\n\treturn newObj;\r\n};\r\n\r\n/**\r\n * @template T\r\n * @param {Set<T>} a set\r\n * @param {Set<T>} b other set\r\n * @returns {boolean} true if at least one item of a is in b\r\n */\r\nconst isOverlap = (a, b) => {\r\n\tfor (const item of a) {\r\n\t\tif (b.has(item)) return true;\r\n\t}\r\n\treturn false;\r\n};\r\n\r\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\r\n\r\n/**\r\n * @param {ChunksInfoItem} a item\r\n * @param {ChunksInfoItem} b item\r\n * @returns {number} compare result\r\n */\r\nconst compareEntries = (a, b) => {\r\n\t// 1. by priority\r\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\r\n\tif (diffPriority) return diffPriority;\r\n\t// 2. by number of chunks\r\n\tconst diffCount = a.chunks.size - b.chunks.size;\r\n\tif (diffCount) return diffCount;\r\n\t// 3. by size reduction\r\n\tconst aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\r\n\tconst bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\r\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\r\n\tif (diffSizeReduce) return diffSizeReduce;\r\n\t// 4. by cache group index\r\n\tconst indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\r\n\tif (indexDiff) return indexDiff;\r\n\t// 5. by number of modules (to be able to compare by identifier)\r\n\tconst modulesA = a.modules;\r\n\tconst modulesB = b.modules;\r\n\tconst diff = modulesA.size - modulesB.size;\r\n\tif (diff) return diff;\r\n\t// 6. by module identifiers\r\n\tmodulesA.sort();\r\n\tmodulesB.sort();\r\n\treturn compareModuleIterables(modulesA, modulesB);\r\n};\r\n\r\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\r\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\r\nconst ALL_CHUNK_FILTER = chunk => true;\r\n\r\n/**\r\n * @param {OptimizationSplitChunksSizes} value the sizes\r\n * @param {string[]} defaultSizeTypes the default size types\r\n * @returns {SplitChunksSizes} normalized representation\r\n */\r\nconst normalizeSizes = (value, defaultSizeTypes) => {\r\n\tif (typeof value === \"number\") {\r\n\t\t/** @type {Record<string, number>} */\r\n\t\tconst o = {};\r\n\t\tfor (const sizeType of defaultSizeTypes) o[sizeType] = value;\r\n\t\treturn o;\r\n\t} else if (typeof value === \"object\" && value !== null) {\r\n\t\treturn { ...value };\r\n\t} else {\r\n\t\treturn {};\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {...SplitChunksSizes} sizes the sizes\r\n * @returns {SplitChunksSizes} the merged sizes\r\n */\r\nconst mergeSizes = (...sizes) => {\r\n\t/** @type {SplitChunksSizes} */\r\n\tlet merged = {};\r\n\tfor (let i = sizes.length - 1; i >= 0; i--) {\r\n\t\tmerged = Object.assign(merged, sizes[i]);\r\n\t}\r\n\treturn merged;\r\n};\r\n\r\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @returns {boolean} true, if there are sizes > 0\r\n */\r\nconst hasNonZeroSizes = sizes => {\r\n\tfor (const key of Object.keys(sizes)) {\r\n\t\tif (sizes[key] > 0) return true;\r\n\t}\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * @param {SplitChunksSizes} a first sizes\r\n * @param {SplitChunksSizes} b second sizes\r\n * @param {CombineSizeFunction} combine a function to combine sizes\r\n * @returns {SplitChunksSizes} the combine sizes\r\n */\r\nconst combineSizes = (a, b, combine) => {\r\n\tconst aKeys = new Set(Object.keys(a));\r\n\tconst bKeys = new Set(Object.keys(b));\r\n\t/** @type {SplitChunksSizes} */\r\n\tconst result = {};\r\n\tfor (const key of aKeys) {\r\n\t\tif (bKeys.has(key)) {\r\n\t\t\tresult[key] = combine(a[key], b[key]);\r\n\t\t} else {\r\n\t\t\tresult[key] = a[key];\r\n\t\t}\r\n\t}\r\n\tfor (const key of bKeys) {\r\n\t\tif (!aKeys.has(key)) {\r\n\t\t\tresult[key] = b[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @param {SplitChunksSizes} minSize the min sizes\r\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\r\n */\r\nconst checkMinSize = (sizes, minSize) => {\r\n\tfor (const key of Object.keys(minSize)) {\r\n\t\tconst size = sizes[key];\r\n\t\tif (size === undefined || size === 0) continue;\r\n\t\tif (size < minSize[key]) return false;\r\n\t}\r\n\treturn true;\r\n};\r\n\r\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @param {SplitChunksSizes} minSizeReduction the min sizes\r\n * @param {number} chunkCount number of chunks\r\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\r\n */\r\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\r\n\tfor (const key of Object.keys(minSizeReduction)) {\r\n\t\tconst size = sizes[key];\r\n\t\tif (size === undefined || size === 0) continue;\r\n\t\tif (size * chunkCount < minSizeReduction[key]) return false;\r\n\t}\r\n\treturn true;\r\n};\r\n\r\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @param {SplitChunksSizes} minSize the min sizes\r\n * @returns {undefined | string[]} list of size types that are below min size\r\n */\r\nconst getViolatingMinSizes = (sizes, minSize) => {\r\n\tlet list;\r\n\tfor (const key of Object.keys(minSize)) {\r\n\t\tconst size = sizes[key];\r\n\t\tif (size === undefined || size === 0) continue;\r\n\t\tif (size < minSize[key]) {\r\n\t\t\tif (list === undefined) list = [key];\r\n\t\t\telse list.push(key);\r\n\t\t}\r\n\t}\r\n\treturn list;\r\n};\r\n\r\n/**\r\n * @param {SplitChunksSizes} sizes the sizes\r\n * @returns {number} the total size\r\n */\r\nconst totalSize = sizes => {\r\n\tlet size = 0;\r\n\tfor (const key of Object.keys(sizes)) {\r\n\t\tsize += sizes[key];\r\n\t}\r\n\treturn size;\r\n};\r\n\r\n/**\r\n * @param {false|string|Function} name the chunk name\r\n * @returns {GetName} a function to get the name of the chunk\r\n */\r\nconst normalizeName = name => {\r\n\tif (typeof name === \"string\") {\r\n\t\treturn () => name;\r\n\t}\r\n\tif (typeof name === \"function\") {\r\n\t\treturn /** @type {GetName} */ (name);\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\r\n * @returns {ChunkFilterFunction} the chunk filter function\r\n */\r\nconst normalizeChunksFilter = chunks => {\r\n\tif (chunks === \"initial\") {\r\n\t\treturn INITIAL_CHUNK_FILTER;\r\n\t}\r\n\tif (chunks === \"async\") {\r\n\t\treturn ASYNC_CHUNK_FILTER;\r\n\t}\r\n\tif (chunks === \"all\") {\r\n\t\treturn ALL_CHUNK_FILTER;\r\n\t}\r\n\tif (typeof chunks === \"function\") {\r\n\t\treturn chunks;\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\r\n * @param {string[]} defaultSizeTypes the default size types\r\n * @returns {GetCacheGroups} a function to get the cache groups\r\n */\r\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\r\n\tif (typeof cacheGroups === \"function\") {\r\n\t\treturn cacheGroups;\r\n\t}\r\n\tif (typeof cacheGroups === \"object\" && cacheGroups !== null) {\r\n\t\t/** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\r\n\t\tconst handlers = [];\r\n\t\tfor (const key of Object.keys(cacheGroups)) {\r\n\t\t\tconst option = cacheGroups[key];\r\n\t\t\tif (option === false) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (typeof option === \"string\" || option instanceof RegExp) {\r\n\t\t\t\tconst source = createCacheGroupSource({}, key, defaultSizeTypes);\r\n\t\t\t\thandlers.push((module, context, results) => {\r\n\t\t\t\t\tif (checkTest(option, module, context)) {\r\n\t\t\t\t\t\tresults.push(source);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else if (typeof option === \"function\") {\r\n\t\t\t\tconst cache = new WeakMap();\r\n\t\t\t\thandlers.push((module, context, results) => {\r\n\t\t\t\t\tconst result = option(module);\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\tconst groups = Array.isArray(result) ? result : [result];\r\n\t\t\t\t\t\tfor (const group of groups) {\r\n\t\t\t\t\t\t\tconst cachedSource = cache.get(group);\r\n\t\t\t\t\t\t\tif (cachedSource !== undefined) {\r\n\t\t\t\t\t\t\t\tresults.push(cachedSource);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tconst source = createCacheGroupSource(\r\n\t\t\t\t\t\t\t\t\tgroup,\r\n\t\t\t\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\t\t\t\tdefaultSizeTypes\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\tcache.set(group, source);\r\n\t\t\t\t\t\t\t\tresults.push(source);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tconst source = createCacheGroupSource(option, key, defaultSizeTypes);\r\n\t\t\t\thandlers.push((module, context, results) => {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tcheckTest(option.test, module, context) &&\r\n\t\t\t\t\t\tcheckModuleType(option.type, module) &&\r\n\t\t\t\t\t\tcheckModuleLayer(option.layer, module)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tresults.push(source);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t/**\r\n\t\t * @param {Module} module the current module\r\n\t\t * @param {CacheGroupsContext} context the current context\r\n\t\t * @returns {CacheGroupSource[]} the matching cache groups\r\n\t\t */\r\n\t\tconst fn = (module, context) => {\r\n\t\t\t/** @type {CacheGroupSource[]} */\r\n\t\t\tlet results = [];\r\n\t\t\tfor (const fn of handlers) {\r\n\t\t\t\tfn(module, context, results);\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t};\r\n\t\treturn fn;\r\n\t}\r\n\treturn () => null;\r\n};\r\n\r\n/**\r\n * @param {undefined|boolean|string|RegExp|Function} test test option\r\n * @param {Module} module the module\r\n * @param {CacheGroupsContext} context context object\r\n * @returns {boolean} true, if the module should be selected\r\n */\r\nconst checkTest = (test, module, context) => {\r\n\tif (test === undefined) return true;\r\n\tif (typeof test === \"function\") {\r\n\t\treturn test(module, context);\r\n\t}\r\n\tif (typeof test === \"boolean\") return test;\r\n\tif (typeof test === \"string\") {\r\n\t\tconst name = module.nameForCondition();\r\n\t\treturn name && name.startsWith(test);\r\n\t}\r\n\tif (test instanceof RegExp) {\r\n\t\tconst name = module.nameForCondition();\r\n\t\treturn name && test.test(name);\r\n\t}\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * @param {undefined|string|RegExp|Function} test type option\r\n * @param {Module} module the module\r\n * @returns {boolean} true, if the module should be selected\r\n */\r\nconst checkModuleType = (test, module) => {\r\n\tif (test === undefined) return true;\r\n\tif (typeof test === \"function\") {\r\n\t\treturn test(module.type);\r\n\t}\r\n\tif (typeof test === \"string\") {\r\n\t\tconst type = module.type;\r\n\t\treturn test === type;\r\n\t}\r\n\tif (test instanceof RegExp) {\r\n\t\tconst type = module.type;\r\n\t\treturn test.test(type);\r\n\t}\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * @param {undefined|string|RegExp|Function} test type option\r\n * @param {Module} module the module\r\n * @returns {boolean} true, if the module should be selected\r\n */\r\nconst checkModuleLayer = (test, module) => {\r\n\tif (test === undefined) return true;\r\n\tif (typeof test === \"function\") {\r\n\t\treturn test(module.layer);\r\n\t}\r\n\tif (typeof test === \"string\") {\r\n\t\tconst layer = module.layer;\r\n\t\treturn test === \"\" ? !layer : layer && layer.startsWith(test);\r\n\t}\r\n\tif (test instanceof RegExp) {\r\n\t\tconst layer = module.layer;\r\n\t\treturn test.test(layer);\r\n\t}\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * @param {OptimizationSplitChunksCacheGroup} options the group options\r\n * @param {string} key key of cache group\r\n * @param {string[]} defaultSizeTypes the default size types\r\n * @returns {CacheGroupSource} the normalized cached group\r\n */\r\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\r\n\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\r\n\tconst minSizeReduction = normalizeSizes(\r\n\t\toptions.minSizeReduction,\r\n\t\tdefaultSizeTypes\r\n\t);\r\n\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\r\n\treturn {\r\n\t\tkey,\r\n\t\tpriority: options.priority,\r\n\t\tgetName: normalizeName(options.name),\r\n\t\tchunksFilter: normalizeChunksFilter(options.chunks),\r\n\t\tenforce: options.enforce,\r\n\t\tminSize,\r\n\t\tminSizeReduction,\r\n\t\tminRemainingSize: mergeSizes(\r\n\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\r\n\t\t\tminSize\r\n\t\t),\r\n\t\tenforceSizeThreshold: normalizeSizes(\r\n\t\t\toptions.enforceSizeThreshold,\r\n\t\t\tdefaultSizeTypes\r\n\t\t),\r\n\t\tmaxAsyncSize: mergeSizes(\r\n\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\r\n\t\t\tmaxSize\r\n\t\t),\r\n\t\tmaxInitialSize: mergeSizes(\r\n\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\r\n\t\t\tmaxSize\r\n\t\t),\r\n\t\tminChunks: options.minChunks,\r\n\t\tmaxAsyncRequests: options.maxAsyncRequests,\r\n\t\tmaxInitialRequests: options.maxInitialRequests,\r\n\t\tfilename: options.filename,\r\n\t\tidHint: options.idHint,\r\n\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\r\n\t\treuseExistingChunk: options.reuseExistingChunk,\r\n\t\tusedExports: options.usedExports\r\n\t};\r\n};\r\n\r\nmodule.exports = class SplitChunksPlugin {\r\n\t/**\r\n\t * @param {OptimizationSplitChunksOptions=} options plugin options\r\n\t */\r\n\tconstructor(options = {}) {\r\n\t\tconst defaultSizeTypes = options.defaultSizeTypes || [\r\n\t\t\t\"javascript\",\r\n\t\t\t\"unknown\"\r\n\t\t];\r\n\t\tconst fallbackCacheGroup = options.fallbackCacheGroup || {};\r\n\t\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\r\n\t\tconst minSizeReduction = normalizeSizes(\r\n\t\t\toptions.minSizeReduction,\r\n\t\t\tdefaultSizeTypes\r\n\t\t);\r\n\t\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\r\n\r\n\t\t/** @type {SplitChunksOptions} */\r\n\t\tthis.options = {\r\n\t\t\tchunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\r\n\t\t\tdefaultSizeTypes,\r\n\t\t\tminSize,\r\n\t\t\tminSizeReduction,\r\n\t\t\tminRemainingSize: mergeSizes(\r\n\t\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\r\n\t\t\t\tminSize\r\n\t\t\t),\r\n\t\t\tenforceSizeThreshold: normalizeSizes(\r\n\t\t\t\toptions.enforceSizeThreshold,\r\n\t\t\t\tdefaultSizeTypes\r\n\t\t\t),\r\n\t\t\tmaxAsyncSize: mergeSizes(\r\n\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\r\n\t\t\t\tmaxSize\r\n\t\t\t),\r\n\t\t\tmaxInitialSize: mergeSizes(\r\n\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\r\n\t\t\t\tmaxSize\r\n\t\t\t),\r\n\t\t\tminChunks: options.minChunks || 1,\r\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\r\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\r\n\t\t\thidePathInfo: options.hidePathInfo || false,\r\n\t\t\tfilename: options.filename || undefined,\r\n\t\t\tgetCacheGroups: normalizeCacheGroups(\r\n\t\t\t\toptions.cacheGroups,\r\n\t\t\t\tdefaultSizeTypes\r\n\t\t\t),\r\n\t\t\tgetName: options.name ? normalizeName(options.name) : defaultGetName,\r\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\r\n\t\t\tusedExports: options.usedExports,\r\n\t\t\tfallbackCacheGroup: {\r\n\t\t\t\tchunksFilter: normalizeChunksFilter(\r\n\t\t\t\t\tfallbackCacheGroup.chunks || options.chunks || \"all\"\r\n\t\t\t\t),\r\n\t\t\t\tminSize: mergeSizes(\r\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes),\r\n\t\t\t\t\tminSize\r\n\t\t\t\t),\r\n\t\t\t\tmaxAsyncSize: mergeSizes(\r\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes),\r\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\r\n\t\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\r\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\r\n\t\t\t\t),\r\n\t\t\t\tmaxInitialSize: mergeSizes(\r\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes),\r\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\r\n\t\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\r\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\r\n\t\t\t\t),\r\n\t\t\t\tautomaticNameDelimiter:\r\n\t\t\t\t\tfallbackCacheGroup.automaticNameDelimiter ||\r\n\t\t\t\t\toptions.automaticNameDelimiter ||\r\n\t\t\t\t\t\"~\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/** @type {WeakMap<CacheGroupSource, CacheGroup>} */\r\n\t\tthis._cacheGroupCache = new WeakMap();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {CacheGroupSource} cacheGroupSource source\r\n\t * @returns {CacheGroup} the cache group (cached)\r\n\t */\r\n\t_getCacheGroup(cacheGroupSource) {\r\n\t\tconst cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\r\n\t\tif (cacheEntry !== undefined) return cacheEntry;\r\n\t\tconst minSize = mergeSizes(\r\n\t\t\tcacheGroupSource.minSize,\r\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSize\r\n\t\t);\r\n\t\tconst minSizeReduction = mergeSizes(\r\n\t\t\tcacheGroupSource.minSizeReduction,\r\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSizeReduction\r\n\t\t);\r\n\t\tconst minRemainingSize = mergeSizes(\r\n\t\t\tcacheGroupSource.minRemainingSize,\r\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minRemainingSize\r\n\t\t);\r\n\t\tconst enforceSizeThreshold = mergeSizes(\r\n\t\t\tcacheGroupSource.enforceSizeThreshold,\r\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold\r\n\t\t);\r\n\t\tconst cacheGroup = {\r\n\t\t\tkey: cacheGroupSource.key,\r\n\t\t\tpriority: cacheGroupSource.priority || 0,\r\n\t\t\tchunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\r\n\t\t\tminSize,\r\n\t\t\tminSizeReduction,\r\n\t\t\tminRemainingSize,\r\n\t\t\tenforceSizeThreshold,\r\n\t\t\tmaxAsyncSize: mergeSizes(\r\n\t\t\t\tcacheGroupSource.maxAsyncSize,\r\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxAsyncSize\r\n\t\t\t),\r\n\t\t\tmaxInitialSize: mergeSizes(\r\n\t\t\t\tcacheGroupSource.maxInitialSize,\r\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxInitialSize\r\n\t\t\t),\r\n\t\t\tminChunks:\r\n\t\t\t\tcacheGroupSource.minChunks !== undefined\r\n\t\t\t\t\t? cacheGroupSource.minChunks\r\n\t\t\t\t\t: cacheGroupSource.enforce\r\n\t\t\t\t\t? 1\r\n\t\t\t\t\t: this.options.minChunks,\r\n\t\t\tmaxAsyncRequests:\r\n\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\r\n\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\r\n\t\t\t\t\t: cacheGroupSource.enforce\r\n\t\t\t\t\t? Infinity\r\n\t\t\t\t\t: this.options.maxAsyncRequests,\r\n\t\t\tmaxInitialRequests:\r\n\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\r\n\t\t\t\t\t? cacheGroupSource.maxInitialRequests\r\n\t\t\t\t\t: cacheGroupSource.enforce\r\n\t\t\t\t\t? Infinity\r\n\t\t\t\t\t: this.options.maxInitialRequests,\r\n\t\t\tgetName:\r\n\t\t\t\tcacheGroupSource.getName !== undefined\r\n\t\t\t\t\t? cacheGroupSource.getName\r\n\t\t\t\t\t: this.options.getName,\r\n\t\t\tusedExports:\r\n\t\t\t\tcacheGroupSource.usedExports !== undefined\r\n\t\t\t\t\t? cacheGroupSource.usedExports\r\n\t\t\t\t\t: this.options.usedExports,\r\n\t\t\tfilename:\r\n\t\t\t\tcacheGroupSource.filename !== undefined\r\n\t\t\t\t\t? cacheGroupSource.filename\r\n\t\t\t\t\t: this.options.filename,\r\n\t\t\tautomaticNameDelimiter:\r\n\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\r\n\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\r\n\t\t\t\t\t: this.options.automaticNameDelimiter,\r\n\t\t\tidHint:\r\n\t\t\t\tcacheGroupSource.idHint !== undefined\r\n\t\t\t\t\t? cacheGroupSource.idHint\r\n\t\t\t\t\t: cacheGroupSource.key,\r\n\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\r\n\t\t\t_validateSize: hasNonZeroSizes(minSize),\r\n\t\t\t_validateRemainingSize: hasNonZeroSizes(minRemainingSize),\r\n\t\t\t_minSizeForMaxSize: mergeSizes(\r\n\t\t\t\tcacheGroupSource.minSize,\r\n\t\t\t\tthis.options.minSize\r\n\t\t\t),\r\n\t\t\t_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\r\n\t\t};\r\n\t\tthis._cacheGroupCache.set(cacheGroupSource, cacheGroup);\r\n\t\treturn cacheGroup;\r\n\t}\r\n\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler the compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\r\n\t\t\tcompiler.context,\r\n\t\t\tcompiler.root\r\n\t\t);\r\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\r\n\t\t\tconst logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\r\n\t\t\tlet alreadyOptimized = false;\r\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\r\n\t\t\t\talreadyOptimized = false;\r\n\t\t\t});\r\n\t\t\tcompilation.hooks.optimizeChunks.tap(\r\n\t\t\t\t{\r\n\t\t\t\t\tname: \"SplitChunksPlugin\",\r\n\t\t\t\t\tstage: STAGE_ADVANCED\r\n\t\t\t\t},\r\n\t\t\t\tchunks => {\r\n\t\t\t\t\tif (alreadyOptimized) return;\r\n\t\t\t\t\talreadyOptimized = true;\r\n\t\t\t\t\tlogger.time(\"prepare\");\r\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\r\n\t\t\t\t\tconst moduleGraph = compilation.moduleGraph;\r\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\r\n\t\t\t\t\t/** @type {Map<Chunk, bigint>} */\r\n\t\t\t\t\tconst chunkIndexMap = new Map();\r\n\t\t\t\t\tconst ZERO = BigInt(\"0\");\r\n\t\t\t\t\tconst ONE = BigInt(\"1\");\r\n\t\t\t\t\tconst START = ONE << BigInt(\"31\");\r\n\t\t\t\t\tlet index = START;\r\n\t\t\t\t\tfor (const chunk of chunks) {\r\n\t\t\t\t\t\tchunkIndexMap.set(\r\n\t\t\t\t\t\t\tchunk,\r\n\t\t\t\t\t\t\tindex | BigInt((Math.random() * 0x7fffffff) | 0)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tindex = index << ONE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {Iterable<Chunk>} chunks list of chunks\r\n\t\t\t\t\t * @returns {bigint | Chunk} key of the chunks\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst getKey = chunks => {\r\n\t\t\t\t\t\tconst iterator = chunks[Symbol.iterator]();\r\n\t\t\t\t\t\tlet result = iterator.next();\r\n\t\t\t\t\t\tif (result.done) return ZERO;\r\n\t\t\t\t\t\tconst first = result.value;\r\n\t\t\t\t\t\tresult = iterator.next();\r\n\t\t\t\t\t\tif (result.done) return first;\r\n\t\t\t\t\t\tlet key =\r\n\t\t\t\t\t\t\tchunkIndexMap.get(first) | chunkIndexMap.get(result.value);\r\n\t\t\t\t\t\twhile (!(result = iterator.next()).done) {\r\n\t\t\t\t\t\t\tconst raw = chunkIndexMap.get(result.value);\r\n\t\t\t\t\t\t\tkey = key ^ raw;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn key;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst keyToString = key => {\r\n\t\t\t\t\t\tif (typeof key === \"bigint\") return key.toString(16);\r\n\t\t\t\t\t\treturn chunkIndexMap.get(key).toString(16);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tconst getChunkSetsInGraph = memoize(() => {\r\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\r\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\r\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\r\n\t\t\t\t\t\tconst singleChunkSets = new Set();\r\n\t\t\t\t\t\tfor (const module of compilation.modules) {\r\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\r\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\r\n\t\t\t\t\t\t\tif (typeof chunksKey === \"bigint\") {\r\n\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\r\n\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tsingleChunkSets.add(chunksKey);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {Module} module the module\r\n\t\t\t\t\t * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst groupChunksByExports = module => {\r\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\r\n\t\t\t\t\t\tconst groupedByUsedExports = new Map();\r\n\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(module)) {\r\n\t\t\t\t\t\t\tconst key = exportsInfo.getUsageKey(chunk.runtime);\r\n\t\t\t\t\t\t\tconst list = groupedByUsedExports.get(key);\r\n\t\t\t\t\t\t\tif (list !== undefined) {\r\n\t\t\t\t\t\t\t\tlist.push(chunk);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tgroupedByUsedExports.set(key, [chunk]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn groupedByUsedExports.values();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/** @type {Map<Module, Iterable<Chunk[]>>} */\r\n\t\t\t\t\tconst groupedByExportsMap = new Map();\r\n\r\n\t\t\t\t\tconst getExportsChunkSetsInGraph = memoize(() => {\r\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\r\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\r\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\r\n\t\t\t\t\t\tconst singleChunkSets = new Set();\r\n\t\t\t\t\t\tfor (const module of compilation.modules) {\r\n\t\t\t\t\t\t\tconst groupedChunks = Array.from(groupChunksByExports(module));\r\n\t\t\t\t\t\t\tgroupedByExportsMap.set(module, groupedChunks);\r\n\t\t\t\t\t\t\tfor (const chunks of groupedChunks) {\r\n\t\t\t\t\t\t\t\tif (chunks.length === 1) {\r\n\t\t\t\t\t\t\t\t\tsingleChunkSets.add(chunks[0]);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tconst chunksKey = /** @type {bigint} */ (getKey(chunks));\r\n\t\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\r\n\t\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// group these set of chunks by count\r\n\t\t\t\t\t// to allow to check less sets via isSubset\r\n\t\t\t\t\t// (only smaller sets can be subset)\r\n\t\t\t\t\tconst groupChunkSetsByCount = chunkSets => {\r\n\t\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\r\n\t\t\t\t\t\tconst chunkSetsByCount = new Map();\r\n\t\t\t\t\t\tfor (const chunksSet of chunkSets) {\r\n\t\t\t\t\t\t\tconst count = chunksSet.size;\r\n\t\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\r\n\t\t\t\t\t\t\tif (array === undefined) {\r\n\t\t\t\t\t\t\t\tarray = [];\r\n\t\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tarray.push(chunksSet);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn chunkSetsByCount;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst getChunkSetsByCount = memoize(() =>\r\n\t\t\t\t\t\tgroupChunkSetsByCount(\r\n\t\t\t\t\t\t\tgetChunkSetsInGraph().chunkSetsInGraph.values()\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tconst getExportsChunkSetsByCount = memoize(() =>\r\n\t\t\t\t\t\tgroupChunkSetsByCount(\r\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph().chunkSetsInGraph.values()\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Create a list of possible combinations\r\n\t\t\t\t\tconst createGetCombinations = (\r\n\t\t\t\t\t\tchunkSets,\r\n\t\t\t\t\t\tsingleChunkSets,\r\n\t\t\t\t\t\tchunkSetsByCount\r\n\t\t\t\t\t) => {\r\n\t\t\t\t\t\t/** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\r\n\t\t\t\t\t\tconst combinationsCache = new Map();\r\n\r\n\t\t\t\t\t\treturn key => {\r\n\t\t\t\t\t\t\tconst cacheEntry = combinationsCache.get(key);\r\n\t\t\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\r\n\t\t\t\t\t\t\tif (key instanceof Chunk) {\r\n\t\t\t\t\t\t\t\tconst result = [key];\r\n\t\t\t\t\t\t\t\tcombinationsCache.set(key, result);\r\n\t\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst chunksSet = chunkSets.get(key);\r\n\t\t\t\t\t\t\t/** @type {(Set<Chunk> | Chunk)[]} */\r\n\t\t\t\t\t\t\tconst array = [chunksSet];\r\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\r\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\r\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\r\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\r\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\r\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (const chunk of singleChunkSets) {\r\n\t\t\t\t\t\t\t\tif (chunksSet.has(chunk)) {\r\n\t\t\t\t\t\t\t\t\tarray.push(chunk);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcombinationsCache.set(key, array);\r\n\t\t\t\t\t\t\treturn array;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tconst getCombinationsFactory = memoize(() => {\r\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } = getChunkSetsInGraph();\r\n\t\t\t\t\t\treturn createGetCombinations(\r\n\t\t\t\t\t\t\tchunkSetsInGraph,\r\n\t\t\t\t\t\t\tsingleChunkSets,\r\n\t\t\t\t\t\t\tgetChunkSetsByCount()\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst getCombinations = key => getCombinationsFactory()(key);\r\n\r\n\t\t\t\t\tconst getExportsCombinationsFactory = memoize(() => {\r\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } =\r\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\r\n\t\t\t\t\t\treturn createGetCombinations(\r\n\t\t\t\t\t\t\tchunkSetsInGraph,\r\n\t\t\t\t\t\t\tsingleChunkSets,\r\n\t\t\t\t\t\t\tgetExportsChunkSetsByCount()\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst getExportsCombinations = key =>\r\n\t\t\t\t\t\tgetExportsCombinationsFactory()(key);\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\r\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\r\n\t\t\t\t\t * @property {bigint | Chunk} key a key of the list\r\n\t\t\t\t\t */\r\n\r\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\r\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * get list and key by applying the filter function to the list\r\n\t\t\t\t\t * It is cached for performance reasons\r\n\t\t\t\t\t * @param {Set<Chunk> | Chunk} chunks list of chunks\r\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\r\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\r\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\r\n\t\t\t\t\t\tif (entry === undefined) {\r\n\t\t\t\t\t\t\tentry = new WeakMap();\r\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\r\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\r\n\t\t\t\t\t\tif (entry2 === undefined) {\r\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\r\n\t\t\t\t\t\t\tconst selectedChunks = [];\r\n\t\t\t\t\t\t\tif (chunks instanceof Chunk) {\r\n\t\t\t\t\t\t\t\tif (chunkFilter(chunks)) selectedChunks.push(chunks);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\r\n\t\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tentry2 = {\r\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\r\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn entry2;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/** @type {Map<string, boolean>} */\r\n\t\t\t\t\tconst alreadyValidatedParents = new Map();\r\n\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\tconst alreadyReportedErrors = new Set();\r\n\r\n\t\t\t\t\t// Map a list of chunks to a list of modules\r\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\r\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\r\n\t\t\t\t\tconst chunksInfoMap = new Map();\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {CacheGroup} cacheGroup the current cache group\r\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\r\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\r\n\t\t\t\t\t * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\r\n\t\t\t\t\t * @param {Module} module the current module\r\n\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\r\n\t\t\t\t\t\tcacheGroup,\r\n\t\t\t\t\t\tcacheGroupIndex,\r\n\t\t\t\t\t\tselectedChunks,\r\n\t\t\t\t\t\tselectedChunksKey,\r\n\t\t\t\t\t\tmodule\r\n\t\t\t\t\t) => {\r\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\r\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\r\n\t\t\t\t\t\t// Determine name for split chunk\r\n\t\t\t\t\t\tconst name = cacheGroup.getName(\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tselectedChunks,\r\n\t\t\t\t\t\t\tcacheGroup.key\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\t// Check if the name is ok\r\n\t\t\t\t\t\tconst existingChunk = compilation.namedChunks.get(name);\r\n\t\t\t\t\t\tif (existingChunk) {\r\n\t\t\t\t\t\t\tconst parentValidationKey = `${name}|${\r\n\t\t\t\t\t\t\t\ttypeof selectedChunksKey === \"bigint\"\r\n\t\t\t\t\t\t\t\t\t? selectedChunksKey\r\n\t\t\t\t\t\t\t\t\t: selectedChunksKey.debugId\r\n\t\t\t\t\t\t\t}`;\r\n\t\t\t\t\t\t\tconst valid = alreadyValidatedParents.get(parentValidationKey);\r\n\t\t\t\t\t\t\tif (valid === false) return;\r\n\t\t\t\t\t\t\tif (valid === undefined) {\r\n\t\t\t\t\t\t\t\t// Module can only be moved into the existing chunk if the existing chunk\r\n\t\t\t\t\t\t\t\t// is a parent of all selected chunks\r\n\t\t\t\t\t\t\t\tlet isInAllParents = true;\r\n\t\t\t\t\t\t\t\t/** @type {Set<ChunkGroup>} */\r\n\t\t\t\t\t\t\t\tconst queue = new Set();\r\n\t\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\r\n\t\t\t\t\t\t\t\t\tfor (const group of chunk.groupsIterable) {\r\n\t\t\t\t\t\t\t\t\t\tqueue.add(group);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfor (const group of queue) {\r\n\t\t\t\t\t\t\t\t\tif (existingChunk.isInGroup(group)) continue;\r\n\t\t\t\t\t\t\t\t\tlet hasParent = false;\r\n\t\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\r\n\t\t\t\t\t\t\t\t\t\thasParent = true;\r\n\t\t\t\t\t\t\t\t\t\tqueue.add(parent);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!hasParent) {\r\n\t\t\t\t\t\t\t\t\t\tisInAllParents = false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst valid = isInAllParents;\r\n\t\t\t\t\t\t\t\talreadyValidatedParents.set(parentValidationKey, valid);\r\n\t\t\t\t\t\t\t\tif (!valid) {\r\n\t\t\t\t\t\t\t\t\tif (!alreadyReportedErrors.has(name)) {\r\n\t\t\t\t\t\t\t\t\t\talreadyReportedErrors.add(name);\r\n\t\t\t\t\t\t\t\t\t\tcompilation.errors.push(\r\n\t\t\t\t\t\t\t\t\t\t\tnew WebpackError(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin\\n\" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t'HINT: You can omit \"name\" to automatically create a name.\\n' +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remove this entrypoint and add modules to cache group's 'test' instead. \" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"See migration guide of more info.\"\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Create key for maps\r\n\t\t\t\t\t\t// When it has a name we use the name as key\r\n\t\t\t\t\t\t// Otherwise we create the key from chunks and cache group key\r\n\t\t\t\t\t\t// This automatically merges equal names\r\n\t\t\t\t\t\tconst key =\r\n\t\t\t\t\t\t\tcacheGroup.key +\r\n\t\t\t\t\t\t\t(name\r\n\t\t\t\t\t\t\t\t? ` name:${name}`\r\n\t\t\t\t\t\t\t\t: ` chunks:${keyToString(selectedChunksKey)}`);\r\n\t\t\t\t\t\t// Add module to maps\r\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\r\n\t\t\t\t\t\tif (info === undefined) {\r\n\t\t\t\t\t\t\tchunksInfoMap.set(\r\n\t\t\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\t\t\t(info = {\r\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(\r\n\t\t\t\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\t\t\t\tcompareModulesByIdentifier\r\n\t\t\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t\t\t\tcacheGroup,\r\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\r\n\t\t\t\t\t\t\t\t\tname,\r\n\t\t\t\t\t\t\t\t\tsizes: {},\r\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\r\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\r\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst oldSize = info.modules.size;\r\n\t\t\t\t\t\tinfo.modules.add(module);\r\n\t\t\t\t\t\tif (info.modules.size !== oldSize) {\r\n\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\r\n\t\t\t\t\t\t\t\tinfo.sizes[type] = (info.sizes[type] || 0) + module.size(type);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst oldChunksKeysSize = info.chunksKeys.size;\r\n\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\r\n\t\t\t\t\t\tif (oldChunksKeysSize !== info.chunksKeys.size) {\r\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\r\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tconst context = {\r\n\t\t\t\t\t\tmoduleGraph,\r\n\t\t\t\t\t\tchunkGraph\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tlogger.timeEnd(\"prepare\");\r\n\r\n\t\t\t\t\tlogger.time(\"modules\");\r\n\r\n\t\t\t\t\t// Walk through all modules\r\n\t\t\t\t\tfor (const module of compilation.modules) {\r\n\t\t\t\t\t\t// Get cache group\r\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module, context);\r\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Prepare some values (usedExports = false)\r\n\t\t\t\t\t\tconst getCombs = memoize(() => {\r\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\r\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\r\n\t\t\t\t\t\t\treturn getCombinations(chunksKey);\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Prepare some values (usedExports = true)\r\n\t\t\t\t\t\tconst getCombsByUsedExports = memoize(() => {\r\n\t\t\t\t\t\t\t// fill the groupedByExportsMap\r\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\r\n\t\t\t\t\t\t\t/** @type {Set<Set<Chunk> | Chunk>} */\r\n\t\t\t\t\t\t\tconst set = new Set();\r\n\t\t\t\t\t\t\tconst groupedByUsedExports = groupedByExportsMap.get(module);\r\n\t\t\t\t\t\t\tfor (const chunks of groupedByUsedExports) {\r\n\t\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\r\n\t\t\t\t\t\t\t\tfor (const comb of getExportsCombinations(chunksKey))\r\n\t\t\t\t\t\t\t\t\tset.add(comb);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn set;\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\r\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\r\n\t\t\t\t\t\t\tconst cacheGroup = this._getCacheGroup(cacheGroupSource);\r\n\r\n\t\t\t\t\t\t\tconst combs = cacheGroup.usedExports\r\n\t\t\t\t\t\t\t\t? getCombsByUsedExports()\r\n\t\t\t\t\t\t\t\t: getCombs();\r\n\t\t\t\t\t\t\t// For all combination of chunk selection\r\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\r\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\r\n\t\t\t\t\t\t\t\tconst count =\r\n\t\t\t\t\t\t\t\t\tchunkCombination instanceof Chunk ? 1 : chunkCombination.size;\r\n\t\t\t\t\t\t\t\tif (count < cacheGroup.minChunks) continue;\r\n\t\t\t\t\t\t\t\t// Select chunks by configuration\r\n\t\t\t\t\t\t\t\tconst { chunks: selectedChunks, key: selectedChunksKey } =\r\n\t\t\t\t\t\t\t\t\tgetSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\r\n\r\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\r\n\t\t\t\t\t\t\t\t\tcacheGroup,\r\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\r\n\t\t\t\t\t\t\t\t\tselectedChunks,\r\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\r\n\t\t\t\t\t\t\t\t\tmodule\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcacheGroupIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlogger.timeEnd(\"modules\");\r\n\r\n\t\t\t\t\tlogger.time(\"queue\");\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\r\n\t\t\t\t\t * @param {string[]} sourceTypes source types to be removed\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst removeModulesWithSourceType = (info, sourceTypes) => {\r\n\t\t\t\t\t\tfor (const module of info.modules) {\r\n\t\t\t\t\t\t\tconst types = module.getSourceTypes();\r\n\t\t\t\t\t\t\tif (sourceTypes.some(type => types.has(type))) {\r\n\t\t\t\t\t\t\t\tinfo.modules.delete(module);\r\n\t\t\t\t\t\t\t\tfor (const type of types) {\r\n\t\t\t\t\t\t\t\t\tinfo.sizes[type] -= module.size(type);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\r\n\t\t\t\t\t * @returns {boolean} true, if entry become empty\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst removeMinSizeViolatingModules = info => {\r\n\t\t\t\t\t\tif (!info.cacheGroup._validateSize) return false;\r\n\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\r\n\t\t\t\t\t\t\tinfo.sizes,\r\n\t\t\t\t\t\t\tinfo.cacheGroup.minSize\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tif (violatingSizes === undefined) return false;\r\n\t\t\t\t\t\tremoveModulesWithSourceType(info, violatingSizes);\r\n\t\t\t\t\t\treturn info.modules.size === 0;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Filter items were size < minSize\r\n\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\r\n\t\t\t\t\t\tif (removeMinSizeViolatingModules(info)) {\r\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\r\n\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t!checkMinSizeReduction(\r\n\t\t\t\t\t\t\t\tinfo.sizes,\r\n\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\r\n\t\t\t\t\t\t\t\tinfo.chunks.size\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @typedef {Object} MaxSizeQueueItem\r\n\t\t\t\t\t * @property {SplitChunksSizes} minSize\r\n\t\t\t\t\t * @property {SplitChunksSizes} maxAsyncSize\r\n\t\t\t\t\t * @property {SplitChunksSizes} maxInitialSize\r\n\t\t\t\t\t * @property {string} automaticNameDelimiter\r\n\t\t\t\t\t * @property {string[]} keys\r\n\t\t\t\t\t */\r\n\r\n\t\t\t\t\t/** @type {Map<Chunk, MaxSizeQueueItem>} */\r\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\r\n\r\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\r\n\t\t\t\t\t\t// Find best matching entry\r\n\t\t\t\t\t\tlet bestEntryKey;\r\n\t\t\t\t\t\tlet bestEntry;\r\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\r\n\t\t\t\t\t\t\tconst key = pair[0];\r\n\t\t\t\t\t\t\tconst info = pair[1];\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tbestEntry === undefined ||\r\n\t\t\t\t\t\t\t\tcompareEntries(bestEntry, info) < 0\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tbestEntry = info;\r\n\t\t\t\t\t\t\t\tbestEntryKey = key;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconst item = bestEntry;\r\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\r\n\r\n\t\t\t\t\t\tlet chunkName = item.name;\r\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\r\n\t\t\t\t\t\t/** @type {Chunk} */\r\n\t\t\t\t\t\tlet newChunk;\r\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\r\n\t\t\t\t\t\tlet isExistingChunk = false;\r\n\t\t\t\t\t\tlet isReusedWithAllModules = false;\r\n\t\t\t\t\t\tif (chunkName) {\r\n\t\t\t\t\t\t\tconst chunkByName = compilation.namedChunks.get(chunkName);\r\n\t\t\t\t\t\t\tif (chunkByName !== undefined) {\r\n\t\t\t\t\t\t\t\tnewChunk = chunkByName;\r\n\t\t\t\t\t\t\t\tconst oldSize = item.chunks.size;\r\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\r\n\t\t\t\t\t\t\t\tisExistingChunk = item.chunks.size !== oldSize;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (item.cacheGroup.reuseExistingChunk) {\r\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) !==\r\n\t\t\t\t\t\t\t\t\titem.modules.size\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\titem.chunks.size > 1 &&\r\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) > 0\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\r\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, chunk)) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\r\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\r\n\t\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\t\tchunk.name &&\r\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\r\n\t\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\t\tchunk.name &&\r\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\r\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (newChunk) {\r\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\r\n\t\t\t\t\t\t\t\tchunkName = undefined;\r\n\t\t\t\t\t\t\t\tisExistingChunk = true;\r\n\t\t\t\t\t\t\t\tisReusedWithAllModules = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconst enforced =\r\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\r\n\t\t\t\t\t\t\tcheckMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\r\n\r\n\t\t\t\t\t\tconst usedChunks = new Set(item.chunks);\r\n\r\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t!enforced &&\r\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\r\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\r\n\t\t\t\t\t\t\t\t// respect max requests\r\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\r\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\r\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\r\n\t\t\t\t\t\t\t\t\t? Math.min(\r\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\r\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\r\n\t\t\t\t\t\t\t\t\t  )\r\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\r\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\r\n\t\t\t\t\t\t\tfor (const module of item.modules) {\r\n\t\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\r\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\r\n\t\t\t\t\t\tif (usedChunks.size < item.chunks.size) {\r\n\t\t\t\t\t\t\tif (isExistingChunk) usedChunks.add(newChunk);\r\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\r\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\r\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\r\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\r\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\r\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\r\n\t\t\t\t\t\t\t\t\t\tchunksArr,\r\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\r\n\t\t\t\t\t\t\t\t\t\tmodule\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Validate minRemainingSize constraint when a single chunk is left over\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t!enforced &&\r\n\t\t\t\t\t\t\titem.cacheGroup._validateRemainingSize &&\r\n\t\t\t\t\t\t\tusedChunks.size === 1\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tconst [chunk] = usedChunks;\r\n\t\t\t\t\t\t\tlet chunkSizes = Object.create(null);\r\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\r\n\t\t\t\t\t\t\t\tif (!item.modules.has(module)) {\r\n\t\t\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\r\n\t\t\t\t\t\t\t\t\t\tchunkSizes[type] =\r\n\t\t\t\t\t\t\t\t\t\t\t(chunkSizes[type] || 0) + module.size(type);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\r\n\t\t\t\t\t\t\t\tchunkSizes,\r\n\t\t\t\t\t\t\t\titem.cacheGroup.minRemainingSize\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif (violatingSizes !== undefined) {\r\n\t\t\t\t\t\t\t\tconst oldModulesSize = item.modules.size;\r\n\t\t\t\t\t\t\t\tremoveModulesWithSourceType(item, violatingSizes);\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\titem.modules.size > 0 &&\r\n\t\t\t\t\t\t\t\t\titem.modules.size !== oldModulesSize\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t// queue this item again to be processed again\r\n\t\t\t\t\t\t\t\t\t// without violating modules\r\n\t\t\t\t\t\t\t\t\tchunksInfoMap.set(bestEntryKey, item);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Create the new chunk if not reusing one\r\n\t\t\t\t\t\tif (newChunk === undefined) {\r\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Walk through all chunks\r\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\r\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\r\n\t\t\t\t\t\t\tchunk.split(newChunk);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Add a note to the chunk\r\n\t\t\t\t\t\tnewChunk.chunkReason =\r\n\t\t\t\t\t\t\t(newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") +\r\n\t\t\t\t\t\t\t(isReusedWithAllModules\r\n\t\t\t\t\t\t\t\t? \"reused as split chunk\"\r\n\t\t\t\t\t\t\t\t: \"split chunk\");\r\n\t\t\t\t\t\tif (item.cacheGroup.key) {\r\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (chunkName) {\r\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\r\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (item.cacheGroup.idHint) {\r\n\t\t\t\t\t\t\tnewChunk.idNameHints.add(item.cacheGroup.idHint);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!isReusedWithAllModules) {\r\n\t\t\t\t\t\t\t// Add all modules to the new chunk\r\n\t\t\t\t\t\t\tfor (const module of item.modules) {\r\n\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk, compilation)) continue;\r\n\t\t\t\t\t\t\t\t// Add module to new chunk\r\n\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newChunk, module);\r\n\t\t\t\t\t\t\t\t// Remove module from used chunks\r\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\r\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Remove all modules from used chunks\r\n\t\t\t\t\t\t\tfor (const module of item.modules) {\r\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\r\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxAsyncSize).length > 0 ||\r\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxInitialSize).length > 0\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\r\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\r\n\t\t\t\t\t\t\t\tminSize: oldMaxSizeSettings\r\n\t\t\t\t\t\t\t\t\t? combineSizes(\r\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.minSize,\r\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup._minSizeForMaxSize,\r\n\t\t\t\t\t\t\t\t\t\t\tMath.max\r\n\t\t\t\t\t\t\t\t\t  )\r\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.minSize,\r\n\t\t\t\t\t\t\t\tmaxAsyncSize: oldMaxSizeSettings\r\n\t\t\t\t\t\t\t\t\t? combineSizes(\r\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxAsyncSize,\r\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncSize,\r\n\t\t\t\t\t\t\t\t\t\t\tMath.min\r\n\t\t\t\t\t\t\t\t\t  )\r\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncSize,\r\n\t\t\t\t\t\t\t\tmaxInitialSize: oldMaxSizeSettings\r\n\t\t\t\t\t\t\t\t\t? combineSizes(\r\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxInitialSize,\r\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialSize,\r\n\t\t\t\t\t\t\t\t\t\t\tMath.min\r\n\t\t\t\t\t\t\t\t\t  )\r\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxInitialSize,\r\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\r\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\r\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\r\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// remove all modules from other entries and update size\r\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\r\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\r\n\t\t\t\t\t\t\t\t// update modules and total size\r\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\r\n\t\t\t\t\t\t\t\tlet updated = false;\r\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\r\n\t\t\t\t\t\t\t\t\tif (info.modules.has(module)) {\r\n\t\t\t\t\t\t\t\t\t\t// remove module\r\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\r\n\t\t\t\t\t\t\t\t\t\t// update size\r\n\t\t\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\r\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes[key] -= module.size(key);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tupdated = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (updated) {\r\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\r\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\tremoveMinSizeViolatingModules(info) ||\r\n\t\t\t\t\t\t\t\t\t\t!checkMinSizeReduction(\r\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes,\r\n\t\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\r\n\t\t\t\t\t\t\t\t\t\t\tinfo.chunks.size\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlogger.timeEnd(\"queue\");\r\n\r\n\t\t\t\t\tlogger.time(\"maxSize\");\r\n\r\n\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\r\n\r\n\t\t\t\t\tconst { outputOptions } = compilation;\r\n\r\n\t\t\t\t\t// Make sure that maxSize is fulfilled\r\n\t\t\t\t\tconst { fallbackCacheGroup } = this.options;\r\n\t\t\t\t\tfor (const chunk of Array.from(compilation.chunks)) {\r\n\t\t\t\t\t\tconst chunkConfig = maxSizeQueueMap.get(chunk);\r\n\t\t\t\t\t\tconst {\r\n\t\t\t\t\t\t\tminSize,\r\n\t\t\t\t\t\t\tmaxAsyncSize,\r\n\t\t\t\t\t\t\tmaxInitialSize,\r\n\t\t\t\t\t\t\tautomaticNameDelimiter\r\n\t\t\t\t\t\t} = chunkConfig || fallbackCacheGroup;\r\n\t\t\t\t\t\tif (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk))\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t/** @type {SplitChunksSizes} */\r\n\t\t\t\t\t\tlet maxSize;\r\n\t\t\t\t\t\tif (chunk.isOnlyInitial()) {\r\n\t\t\t\t\t\t\tmaxSize = maxInitialSize;\r\n\t\t\t\t\t\t} else if (chunk.canBeInitial()) {\r\n\t\t\t\t\t\t\tmaxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmaxSize = maxAsyncSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (Object.keys(maxSize).length === 0) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (const key of Object.keys(maxSize)) {\r\n\t\t\t\t\t\t\tconst maxSizeValue = maxSize[key];\r\n\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\ttypeof minSizeValue === \"number\" &&\r\n\t\t\t\t\t\t\t\tminSizeValue > maxSizeValue\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tconst keys = chunkConfig && chunkConfig.keys;\r\n\t\t\t\t\t\t\t\tconst warningKey = `${\r\n\t\t\t\t\t\t\t\t\tkeys && keys.join()\r\n\t\t\t\t\t\t\t\t} ${minSizeValue} ${maxSizeValue}`;\r\n\t\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\r\n\t\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\r\n\t\t\t\t\t\t\t\t\tcompilation.warnings.push(\r\n\t\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\r\n\t\t\t\t\t\t\tminSize,\r\n\t\t\t\t\t\t\tmaxSize: mapObject(maxSize, (value, key) => {\r\n\t\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\r\n\t\t\t\t\t\t\t\treturn typeof minSizeValue === \"number\"\r\n\t\t\t\t\t\t\t\t\t? Math.max(value, minSizeValue)\r\n\t\t\t\t\t\t\t\t\t: value;\r\n\t\t\t\t\t\t\t}),\r\n\t\t\t\t\t\t\titems: chunkGraph.getChunkModulesIterable(chunk),\r\n\t\t\t\t\t\t\tgetKey(module) {\r\n\t\t\t\t\t\t\t\tconst cache = getKeyCache.get(module);\r\n\t\t\t\t\t\t\t\tif (cache !== undefined) return cache;\r\n\t\t\t\t\t\t\t\tconst ident = cachedMakePathsRelative(module.identifier());\r\n\t\t\t\t\t\t\t\tconst nameForCondition =\r\n\t\t\t\t\t\t\t\t\tmodule.nameForCondition && module.nameForCondition();\r\n\t\t\t\t\t\t\t\tconst name = nameForCondition\r\n\t\t\t\t\t\t\t\t\t? cachedMakePathsRelative(nameForCondition)\r\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\r\n\t\t\t\t\t\t\t\tconst fullKey =\r\n\t\t\t\t\t\t\t\t\tname +\r\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\r\n\t\t\t\t\t\t\t\t\thashFilename(ident, outputOptions);\r\n\t\t\t\t\t\t\t\tconst key = requestToId(fullKey);\r\n\t\t\t\t\t\t\t\tgetKeyCache.set(module, key);\r\n\t\t\t\t\t\t\t\treturn key;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tgetSize(module) {\r\n\t\t\t\t\t\t\t\tconst size = Object.create(null);\r\n\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\r\n\t\t\t\t\t\t\t\t\tsize[key] = module.size(key);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn size;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif (results.length <= 1) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\t\tconst group = results[i];\r\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\r\n\t\t\t\t\t\t\t\t? hashFilename(group.key, outputOptions)\r\n\t\t\t\t\t\t\t\t: group.key;\r\n\t\t\t\t\t\t\tlet name = chunk.name\r\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\r\n\t\t\t\t\t\t\t\t: null;\r\n\t\t\t\t\t\t\tif (name && name.length > 100) {\r\n\t\t\t\t\t\t\t\tname =\r\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\r\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\r\n\t\t\t\t\t\t\t\t\thashFilename(name, outputOptions);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\r\n\t\t\t\t\t\t\t\tconst newPart = compilation.addChunk(name);\r\n\t\t\t\t\t\t\t\tchunk.split(newPart);\r\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\r\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\r\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\r\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart, compilation)) {\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\r\n\t\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newPart, module);\r\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\r\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// change the chunk to be a part\r\n\t\t\t\t\t\t\t\tchunk.name = name;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlogger.timeEnd(\"maxSize\");\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}