{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst {\n  RawSource\n} = require(\"webpack-sources\");\nconst Generator = require(\"../Generator\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\nconst t = require(\"@webassemblyjs/ast\");\nconst {\n  moduleContextFromModuleAST\n} = require(\"@webassemblyjs/ast\");\nconst {\n  editWithAST,\n  addWithAST\n} = require(\"@webassemblyjs/wasm-edit\");\nconst {\n  decode\n} = require(\"@webassemblyjs/wasm-parser\");\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/**\r\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\r\n */\n\n/**\r\n * @template T\r\n * @param {Function[]} fns transforms\r\n * @returns {Function} composed transform\r\n */\nconst compose = function () {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return fns.reduce((prevFn, nextFn) => {\n    return value => nextFn(prevFn(value));\n  }, value => value);\n};\n\n/**\r\n * Removes the start instruction\r\n *\r\n * @param {Object} state unused state\r\n * @returns {ArrayBufferTransform} transform\r\n */\nconst removeStartFunc = state => bin => {\n  return editWithAST(state.ast, bin, {\n    Start(path) {\n      path.remove();\n    }\n  });\n};\n\n/**\r\n * Get imported globals\r\n *\r\n * @param {Object} ast Module's AST\r\n * @returns {Array<t.ModuleImport>} - nodes\r\n */\nconst getImportedGlobals = ast => {\n  const importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport(_ref) {\n      let {\n        node\n      } = _ref;\n      if (t.isGlobalType(node.descr)) {\n        importedGlobals.push(node);\n      }\n    }\n  });\n  return importedGlobals;\n};\n\n/**\r\n * Get the count for imported func\r\n *\r\n * @param {Object} ast Module's AST\r\n * @returns {Number} - count\r\n */\nconst getCountImportedFunc = ast => {\n  let count = 0;\n  t.traverse(ast, {\n    ModuleImport(_ref2) {\n      let {\n        node\n      } = _ref2;\n      if (t.isFuncImportDescr(node.descr)) {\n        count++;\n      }\n    }\n  });\n  return count;\n};\n\n/**\r\n * Get next type index\r\n *\r\n * @param {Object} ast Module's AST\r\n * @returns {t.Index} - index\r\n */\nconst getNextTypeIndex = ast => {\n  const typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\r\n * Get next func index\r\n *\r\n * The Func section metadata provide informations for implemented funcs\r\n * in order to have the correct index we shift the index by number of external\r\n * functions.\r\n *\r\n * @param {Object} ast Module's AST\r\n * @param {Number} countImportedFunc number of imported funcs\r\n * @returns {t.Index} - index\r\n */\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n  const funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n  const vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\r\n * Creates an init instruction for a global type\r\n * @param {t.GlobalType} globalType the global type\r\n * @returns {t.Instruction} init expression\r\n */\nconst createDefaultInitForGlobal = globalType => {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n\n/**\r\n * Rewrite the import globals:\r\n * - removes the ModuleImport instruction\r\n * - injects at the same offset a mutable global of the same type\r\n *\r\n * Since the imported globals are before the other global declarations, our\r\n * indices will be preserved.\r\n *\r\n * Note that globals will become mutable.\r\n *\r\n * @param {Object} state unused state\r\n * @returns {ArrayBufferTransform} transform\r\n */\nconst rewriteImportedGlobals = state => bin => {\n  const additionalInitCode = state.additionalInitCode;\n  const newGlobals = [];\n  bin = editWithAST(state.ast, bin, {\n    ModuleImport(path) {\n      if (t.isGlobalType(path.node.descr)) {\n        const globalType = path.node.descr;\n        globalType.mutability = \"var\";\n        const init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n        newGlobals.push(t.global(globalType, init));\n        path.remove();\n      }\n    },\n    // in order to preserve non-imported global's order we need to re-inject\n    // those as well\n    Global(path) {\n      const {\n        node\n      } = path;\n      const [init] = node.init;\n      if (init.id === \"get_global\") {\n        node.globalType.mutability = \"var\";\n        const initialGlobalIdx = init.args[0];\n        node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n        additionalInitCode.push(\n        /**\r\n         * get_global in global initializer only works for imported globals.\r\n         * They have the same indices as the init params, so use the\r\n         * same index.\r\n         */\n        t.instruction(\"get_local\", [initialGlobalIdx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n      }\n      newGlobals.push(node);\n      path.remove();\n    }\n  });\n\n  // Add global declaration instructions\n  return addWithAST(state.ast, bin, newGlobals);\n};\n\n/**\r\n * Rewrite the export names\r\n * @param {Object} state state\r\n * @param {Object} state.ast Module's ast\r\n * @param {Module} state.module Module\r\n * @param {ModuleGraph} state.moduleGraph module graph\r\n * @param {Set<string>} state.externalExports Module\r\n * @param {RuntimeSpec} state.runtime runtime\r\n * @returns {ArrayBufferTransform} transform\r\n */\nconst rewriteExportNames = _ref3 => {\n  let {\n    ast,\n    moduleGraph,\n    module,\n    externalExports,\n    runtime\n  } = _ref3;\n  return bin => {\n    return editWithAST(ast, bin, {\n      ModuleExport(path) {\n        const isExternal = externalExports.has(path.node.name);\n        if (isExternal) {\n          path.remove();\n          return;\n        }\n        const usedName = moduleGraph.getExportsInfo(module).getUsedName(path.node.name, runtime);\n        if (!usedName) {\n          path.remove();\n          return;\n        }\n        path.node.name = usedName;\n      }\n    });\n  };\n};\n\n/**\r\n * Mangle import names and modules\r\n * @param {Object} state state\r\n * @param {Object} state.ast Module's ast\r\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\r\n * @returns {ArrayBufferTransform} transform\r\n */\nconst rewriteImports = _ref4 => {\n  let {\n    ast,\n    usedDependencyMap\n  } = _ref4;\n  return bin => {\n    return editWithAST(ast, bin, {\n      ModuleImport(path) {\n        const result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n        if (result !== undefined) {\n          path.node.module = result.module;\n          path.node.name = result.name;\n        }\n      }\n    });\n  };\n};\n\n/**\r\n * Add an init function.\r\n *\r\n * The init function fills the globals given input arguments.\r\n *\r\n * @param {Object} state transformation state\r\n * @param {Object} state.ast Module's ast\r\n * @param {t.Identifier} state.initFuncId identifier of the init function\r\n * @param {t.Index} state.startAtFuncOffset index of the start function\r\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\r\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\r\n * @param {t.Index} state.nextFuncIndex index of the next function\r\n * @param {t.Index} state.nextTypeIndex index of the next type\r\n * @returns {ArrayBufferTransform} transform\r\n */\nconst addInitFunction = _ref5 => {\n  let {\n    ast,\n    initFuncId,\n    startAtFuncOffset,\n    importedGlobals,\n    additionalInitCode,\n    nextFuncIndex,\n    nextTypeIndex\n  } = _ref5;\n  return bin => {\n    const funcParams = importedGlobals.map(importedGlobal => {\n      // used for debugging\n      const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);\n      return t.funcParam(importedGlobal.descr.valtype, id);\n    });\n    const funcBody = [];\n    importedGlobals.forEach((importedGlobal, index) => {\n      const args = [t.indexLiteral(index)];\n      const body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n      funcBody.push(...body);\n    });\n    if (typeof startAtFuncOffset === \"number\") {\n      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n    }\n    for (const instr of additionalInitCode) {\n      funcBody.push(instr);\n    }\n    funcBody.push(t.instruction(\"end\"));\n    const funcResults = [];\n\n    // Code section\n    const funcSignature = t.signature(funcParams, funcResults);\n    const func = t.func(initFuncId, funcSignature, funcBody);\n\n    // Type section\n    const functype = t.typeInstruction(undefined, funcSignature);\n\n    // Func section\n    const funcindex = t.indexInFuncSection(nextTypeIndex);\n\n    // Export section\n    const moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n  };\n};\n\n/**\r\n * Extract mangle mappings from module\r\n * @param {ModuleGraph} moduleGraph module graph\r\n * @param {Module} module current module\r\n * @param {boolean} mangle mangle imports\r\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\r\n */\nconst getUsedDependencyMap = (moduleGraph, module, mangle) => {\n  /** @type {Map<string, UsedWasmDependency>} */\n  const map = new Map();\n  for (const usedDep of WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle)) {\n    const dep = usedDep.dependency;\n    const request = dep.request;\n    const exportName = dep.name;\n    map.set(request + \":\" + exportName, usedDep);\n  }\n  return map;\n};\nconst TYPES = new Set([\"webassembly\"]);\nclass WebAssemblyGenerator extends Generator {\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n\n  /**\r\n   * @param {NormalModule} module fresh module\r\n   * @returns {Set<string>} available types (do not mutate)\r\n   */\n  getTypes(module) {\n    return TYPES;\n  }\n\n  /**\r\n   * @param {NormalModule} module the module\r\n   * @param {string=} type source type\r\n   * @returns {number} estimate size of the module\r\n   */\n  getSize(module, type) {\n    const originalSource = module.originalSource();\n    if (!originalSource) {\n      return 0;\n    }\n    return originalSource.size();\n  }\n\n  /**\r\n   * @param {NormalModule} module module for which the code should be generated\r\n   * @param {GenerateContext} generateContext context for generate\r\n   * @returns {Source} generated code\r\n   */\n  generate(module, _ref6) {\n    let {\n      moduleGraph,\n      runtime\n    } = _ref6;\n    const bin = module.originalSource().source();\n    const initFuncId = t.identifier(\"\");\n\n    // parse it\n    const ast = decode(bin, {\n      ignoreDataSection: true,\n      ignoreCodeSection: true,\n      ignoreCustomNameSection: true\n    });\n    const moduleContext = moduleContextFromModuleAST(ast.body[0]);\n    const importedGlobals = getImportedGlobals(ast);\n    const countImportedFunc = getCountImportedFunc(ast);\n    const startAtFuncOffset = moduleContext.getStart();\n    const nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n    const nextTypeIndex = getNextTypeIndex(ast);\n    const usedDependencyMap = getUsedDependencyMap(moduleGraph, module, this.options.mangleImports);\n    const externalExports = new Set(module.dependencies.filter(d => d instanceof WebAssemblyExportImportedDependency).map(d => {\n      const wasmDep = /** @type {WebAssemblyExportImportedDependency} */\n      d;\n      return wasmDep.exportName;\n    }));\n\n    /** @type {t.Instruction[]} */\n    const additionalInitCode = [];\n    const transform = compose(rewriteExportNames({\n      ast,\n      moduleGraph,\n      module,\n      externalExports,\n      runtime\n    }), removeStartFunc({\n      ast\n    }), rewriteImportedGlobals({\n      ast,\n      additionalInitCode\n    }), rewriteImports({\n      ast,\n      usedDependencyMap\n    }), addInitFunction({\n      ast,\n      initFuncId,\n      importedGlobals,\n      additionalInitCode,\n      startAtFuncOffset,\n      nextFuncIndex,\n      nextTypeIndex\n    }));\n    const newBin = transform(bin);\n    const newBuf = Buffer.from(newBin);\n    return new RawSource(newBuf);\n  }\n}\nmodule.exports = WebAssemblyGenerator;","map":{"version":3,"names":["RawSource","require","Generator","WebAssemblyUtils","t","moduleContextFromModuleAST","editWithAST","addWithAST","decode","WebAssemblyExportImportedDependency","compose","fns","reduce","prevFn","nextFn","value","removeStartFunc","state","bin","ast","Start","path","remove","getImportedGlobals","importedGlobals","traverse","ModuleImport","node","isGlobalType","descr","push","getCountImportedFunc","count","isFuncImportDescr","getNextTypeIndex","typeSectionMetadata","getSectionMetadata","undefined","indexLiteral","vectorOfSize","getNextFuncIndex","countImportedFunc","funcSectionMetadata","createDefaultInitForGlobal","globalType","valtype","objectInstruction","numberLiteralFromRaw","floatLiteral","Error","rewriteImportedGlobals","additionalInitCode","newGlobals","mutability","init","instruction","global","Global","id","initialGlobalIdx","args","length","rewriteExportNames","moduleGraph","module","externalExports","runtime","ModuleExport","isExternal","has","name","usedName","getExportsInfo","getUsedName","rewriteImports","usedDependencyMap","result","get","addInitFunction","initFuncId","startAtFuncOffset","nextFuncIndex","nextTypeIndex","funcParams","map","importedGlobal","identifier","funcParam","funcBody","forEach","index","body","callInstruction","instr","funcResults","funcSignature","signature","func","functype","typeInstruction","funcindex","indexInFuncSection","moduleExport","moduleExportDescr","getUsedDependencyMap","mangle","Map","usedDep","getUsedDependencies","dep","dependency","request","exportName","set","TYPES","Set","WebAssemblyGenerator","constructor","options","getTypes","getSize","type","originalSource","size","generate","source","ignoreDataSection","ignoreCodeSection","ignoreCustomNameSection","moduleContext","getStart","mangleImports","dependencies","filter","d","wasmDep","transform","newBin","newBuf","Buffer","from","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/wasm-sync/WebAssemblyGenerator.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { RawSource } = require(\"webpack-sources\");\r\nconst Generator = require(\"../Generator\");\r\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\r\n\r\nconst t = require(\"@webassemblyjs/ast\");\r\nconst { moduleContextFromModuleAST } = require(\"@webassemblyjs/ast\");\r\nconst { editWithAST, addWithAST } = require(\"@webassemblyjs/wasm-edit\");\r\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\r\n\r\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\r\n\r\n/** @typedef {import(\"webpack-sources\").Source} Source */\r\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\r\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\r\n/** @typedef {import(\"../Module\")} Module */\r\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\r\n/** @typedef {import(\"../NormalModule\")} NormalModule */\r\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\r\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\r\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\r\n\r\n/**\r\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\r\n */\r\n\r\n/**\r\n * @template T\r\n * @param {Function[]} fns transforms\r\n * @returns {Function} composed transform\r\n */\r\nconst compose = (...fns) => {\r\n\treturn fns.reduce(\r\n\t\t(prevFn, nextFn) => {\r\n\t\t\treturn value => nextFn(prevFn(value));\r\n\t\t},\r\n\t\tvalue => value\r\n\t);\r\n};\r\n\r\n/**\r\n * Removes the start instruction\r\n *\r\n * @param {Object} state unused state\r\n * @returns {ArrayBufferTransform} transform\r\n */\r\nconst removeStartFunc = state => bin => {\r\n\treturn editWithAST(state.ast, bin, {\r\n\t\tStart(path) {\r\n\t\t\tpath.remove();\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/**\r\n * Get imported globals\r\n *\r\n * @param {Object} ast Module's AST\r\n * @returns {Array<t.ModuleImport>} - nodes\r\n */\r\nconst getImportedGlobals = ast => {\r\n\tconst importedGlobals = [];\r\n\r\n\tt.traverse(ast, {\r\n\t\tModuleImport({ node }) {\r\n\t\t\tif (t.isGlobalType(node.descr)) {\r\n\t\t\t\timportedGlobals.push(node);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn importedGlobals;\r\n};\r\n\r\n/**\r\n * Get the count for imported func\r\n *\r\n * @param {Object} ast Module's AST\r\n * @returns {Number} - count\r\n */\r\nconst getCountImportedFunc = ast => {\r\n\tlet count = 0;\r\n\r\n\tt.traverse(ast, {\r\n\t\tModuleImport({ node }) {\r\n\t\t\tif (t.isFuncImportDescr(node.descr)) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn count;\r\n};\r\n\r\n/**\r\n * Get next type index\r\n *\r\n * @param {Object} ast Module's AST\r\n * @returns {t.Index} - index\r\n */\r\nconst getNextTypeIndex = ast => {\r\n\tconst typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\r\n\r\n\tif (typeSectionMetadata === undefined) {\r\n\t\treturn t.indexLiteral(0);\r\n\t}\r\n\r\n\treturn t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\r\n};\r\n\r\n/**\r\n * Get next func index\r\n *\r\n * The Func section metadata provide informations for implemented funcs\r\n * in order to have the correct index we shift the index by number of external\r\n * functions.\r\n *\r\n * @param {Object} ast Module's AST\r\n * @param {Number} countImportedFunc number of imported funcs\r\n * @returns {t.Index} - index\r\n */\r\nconst getNextFuncIndex = (ast, countImportedFunc) => {\r\n\tconst funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\r\n\r\n\tif (funcSectionMetadata === undefined) {\r\n\t\treturn t.indexLiteral(0 + countImportedFunc);\r\n\t}\r\n\r\n\tconst vectorOfSize = funcSectionMetadata.vectorOfSize.value;\r\n\r\n\treturn t.indexLiteral(vectorOfSize + countImportedFunc);\r\n};\r\n\r\n/**\r\n * Creates an init instruction for a global type\r\n * @param {t.GlobalType} globalType the global type\r\n * @returns {t.Instruction} init expression\r\n */\r\nconst createDefaultInitForGlobal = globalType => {\r\n\tif (globalType.valtype[0] === \"i\") {\r\n\t\t// create NumberLiteral global initializer\r\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\r\n\t\t\tt.numberLiteralFromRaw(66)\r\n\t\t]);\r\n\t} else if (globalType.valtype[0] === \"f\") {\r\n\t\t// create FloatLiteral global initializer\r\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\r\n\t\t\tt.floatLiteral(66, false, false, \"66\")\r\n\t\t]);\r\n\t} else {\r\n\t\tthrow new Error(\"unknown type: \" + globalType.valtype);\r\n\t}\r\n};\r\n\r\n/**\r\n * Rewrite the import globals:\r\n * - removes the ModuleImport instruction\r\n * - injects at the same offset a mutable global of the same type\r\n *\r\n * Since the imported globals are before the other global declarations, our\r\n * indices will be preserved.\r\n *\r\n * Note that globals will become mutable.\r\n *\r\n * @param {Object} state unused state\r\n * @returns {ArrayBufferTransform} transform\r\n */\r\nconst rewriteImportedGlobals = state => bin => {\r\n\tconst additionalInitCode = state.additionalInitCode;\r\n\tconst newGlobals = [];\r\n\r\n\tbin = editWithAST(state.ast, bin, {\r\n\t\tModuleImport(path) {\r\n\t\t\tif (t.isGlobalType(path.node.descr)) {\r\n\t\t\t\tconst globalType = path.node.descr;\r\n\r\n\t\t\t\tglobalType.mutability = \"var\";\r\n\r\n\t\t\t\tconst init = [\r\n\t\t\t\t\tcreateDefaultInitForGlobal(globalType),\r\n\t\t\t\t\tt.instruction(\"end\")\r\n\t\t\t\t];\r\n\r\n\t\t\t\tnewGlobals.push(t.global(globalType, init));\r\n\r\n\t\t\t\tpath.remove();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// in order to preserve non-imported global's order we need to re-inject\r\n\t\t// those as well\r\n\t\tGlobal(path) {\r\n\t\t\tconst { node } = path;\r\n\t\t\tconst [init] = node.init;\r\n\r\n\t\t\tif (init.id === \"get_global\") {\r\n\t\t\t\tnode.globalType.mutability = \"var\";\r\n\r\n\t\t\t\tconst initialGlobalIdx = init.args[0];\r\n\r\n\t\t\t\tnode.init = [\r\n\t\t\t\t\tcreateDefaultInitForGlobal(node.globalType),\r\n\t\t\t\t\tt.instruction(\"end\")\r\n\t\t\t\t];\r\n\r\n\t\t\t\tadditionalInitCode.push(\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * get_global in global initializer only works for imported globals.\r\n\t\t\t\t\t * They have the same indices as the init params, so use the\r\n\t\t\t\t\t * same index.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tt.instruction(\"get_local\", [initialGlobalIdx]),\r\n\t\t\t\t\tt.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)])\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tnewGlobals.push(node);\r\n\r\n\t\t\tpath.remove();\r\n\t\t}\r\n\t});\r\n\r\n\t// Add global declaration instructions\r\n\treturn addWithAST(state.ast, bin, newGlobals);\r\n};\r\n\r\n/**\r\n * Rewrite the export names\r\n * @param {Object} state state\r\n * @param {Object} state.ast Module's ast\r\n * @param {Module} state.module Module\r\n * @param {ModuleGraph} state.moduleGraph module graph\r\n * @param {Set<string>} state.externalExports Module\r\n * @param {RuntimeSpec} state.runtime runtime\r\n * @returns {ArrayBufferTransform} transform\r\n */\r\nconst rewriteExportNames =\r\n\t({ ast, moduleGraph, module, externalExports, runtime }) =>\r\n\tbin => {\r\n\t\treturn editWithAST(ast, bin, {\r\n\t\t\tModuleExport(path) {\r\n\t\t\t\tconst isExternal = externalExports.has(path.node.name);\r\n\t\t\t\tif (isExternal) {\r\n\t\t\t\t\tpath.remove();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst usedName = moduleGraph\r\n\t\t\t\t\t.getExportsInfo(module)\r\n\t\t\t\t\t.getUsedName(path.node.name, runtime);\r\n\t\t\t\tif (!usedName) {\r\n\t\t\t\t\tpath.remove();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tpath.node.name = usedName;\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n/**\r\n * Mangle import names and modules\r\n * @param {Object} state state\r\n * @param {Object} state.ast Module's ast\r\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\r\n * @returns {ArrayBufferTransform} transform\r\n */\r\nconst rewriteImports =\r\n\t({ ast, usedDependencyMap }) =>\r\n\tbin => {\r\n\t\treturn editWithAST(ast, bin, {\r\n\t\t\tModuleImport(path) {\r\n\t\t\t\tconst result = usedDependencyMap.get(\r\n\t\t\t\t\tpath.node.module + \":\" + path.node.name\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif (result !== undefined) {\r\n\t\t\t\t\tpath.node.module = result.module;\r\n\t\t\t\t\tpath.node.name = result.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n/**\r\n * Add an init function.\r\n *\r\n * The init function fills the globals given input arguments.\r\n *\r\n * @param {Object} state transformation state\r\n * @param {Object} state.ast Module's ast\r\n * @param {t.Identifier} state.initFuncId identifier of the init function\r\n * @param {t.Index} state.startAtFuncOffset index of the start function\r\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\r\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\r\n * @param {t.Index} state.nextFuncIndex index of the next function\r\n * @param {t.Index} state.nextTypeIndex index of the next type\r\n * @returns {ArrayBufferTransform} transform\r\n */\r\nconst addInitFunction =\r\n\t({\r\n\t\tast,\r\n\t\tinitFuncId,\r\n\t\tstartAtFuncOffset,\r\n\t\timportedGlobals,\r\n\t\tadditionalInitCode,\r\n\t\tnextFuncIndex,\r\n\t\tnextTypeIndex\r\n\t}) =>\r\n\tbin => {\r\n\t\tconst funcParams = importedGlobals.map(importedGlobal => {\r\n\t\t\t// used for debugging\r\n\t\t\tconst id = t.identifier(\r\n\t\t\t\t`${importedGlobal.module}.${importedGlobal.name}`\r\n\t\t\t);\r\n\r\n\t\t\treturn t.funcParam(importedGlobal.descr.valtype, id);\r\n\t\t});\r\n\r\n\t\tconst funcBody = [];\r\n\t\timportedGlobals.forEach((importedGlobal, index) => {\r\n\t\t\tconst args = [t.indexLiteral(index)];\r\n\t\t\tconst body = [\r\n\t\t\t\tt.instruction(\"get_local\", args),\r\n\t\t\t\tt.instruction(\"set_global\", args)\r\n\t\t\t];\r\n\r\n\t\t\tfuncBody.push(...body);\r\n\t\t});\r\n\r\n\t\tif (typeof startAtFuncOffset === \"number\") {\r\n\t\t\tfuncBody.push(\r\n\t\t\t\tt.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset))\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfor (const instr of additionalInitCode) {\r\n\t\t\tfuncBody.push(instr);\r\n\t\t}\r\n\r\n\t\tfuncBody.push(t.instruction(\"end\"));\r\n\r\n\t\tconst funcResults = [];\r\n\r\n\t\t// Code section\r\n\t\tconst funcSignature = t.signature(funcParams, funcResults);\r\n\t\tconst func = t.func(initFuncId, funcSignature, funcBody);\r\n\r\n\t\t// Type section\r\n\t\tconst functype = t.typeInstruction(undefined, funcSignature);\r\n\r\n\t\t// Func section\r\n\t\tconst funcindex = t.indexInFuncSection(nextTypeIndex);\r\n\r\n\t\t// Export section\r\n\t\tconst moduleExport = t.moduleExport(\r\n\t\t\tinitFuncId.value,\r\n\t\t\tt.moduleExportDescr(\"Func\", nextFuncIndex)\r\n\t\t);\r\n\r\n\t\treturn addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\r\n\t};\r\n\r\n/**\r\n * Extract mangle mappings from module\r\n * @param {ModuleGraph} moduleGraph module graph\r\n * @param {Module} module current module\r\n * @param {boolean} mangle mangle imports\r\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\r\n */\r\nconst getUsedDependencyMap = (moduleGraph, module, mangle) => {\r\n\t/** @type {Map<string, UsedWasmDependency>} */\r\n\tconst map = new Map();\r\n\tfor (const usedDep of WebAssemblyUtils.getUsedDependencies(\r\n\t\tmoduleGraph,\r\n\t\tmodule,\r\n\t\tmangle\r\n\t)) {\r\n\t\tconst dep = usedDep.dependency;\r\n\t\tconst request = dep.request;\r\n\t\tconst exportName = dep.name;\r\n\t\tmap.set(request + \":\" + exportName, usedDep);\r\n\t}\r\n\treturn map;\r\n};\r\n\r\nconst TYPES = new Set([\"webassembly\"]);\r\n\r\nclass WebAssemblyGenerator extends Generator {\r\n\tconstructor(options) {\r\n\t\tsuper();\r\n\t\tthis.options = options;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {NormalModule} module fresh module\r\n\t * @returns {Set<string>} available types (do not mutate)\r\n\t */\r\n\tgetTypes(module) {\r\n\t\treturn TYPES;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {NormalModule} module the module\r\n\t * @param {string=} type source type\r\n\t * @returns {number} estimate size of the module\r\n\t */\r\n\tgetSize(module, type) {\r\n\t\tconst originalSource = module.originalSource();\r\n\t\tif (!originalSource) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn originalSource.size();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {NormalModule} module module for which the code should be generated\r\n\t * @param {GenerateContext} generateContext context for generate\r\n\t * @returns {Source} generated code\r\n\t */\r\n\tgenerate(module, { moduleGraph, runtime }) {\r\n\t\tconst bin = module.originalSource().source();\r\n\r\n\t\tconst initFuncId = t.identifier(\"\");\r\n\r\n\t\t// parse it\r\n\t\tconst ast = decode(bin, {\r\n\t\t\tignoreDataSection: true,\r\n\t\t\tignoreCodeSection: true,\r\n\t\t\tignoreCustomNameSection: true\r\n\t\t});\r\n\r\n\t\tconst moduleContext = moduleContextFromModuleAST(ast.body[0]);\r\n\r\n\t\tconst importedGlobals = getImportedGlobals(ast);\r\n\t\tconst countImportedFunc = getCountImportedFunc(ast);\r\n\t\tconst startAtFuncOffset = moduleContext.getStart();\r\n\t\tconst nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\r\n\t\tconst nextTypeIndex = getNextTypeIndex(ast);\r\n\r\n\t\tconst usedDependencyMap = getUsedDependencyMap(\r\n\t\t\tmoduleGraph,\r\n\t\t\tmodule,\r\n\t\t\tthis.options.mangleImports\r\n\t\t);\r\n\t\tconst externalExports = new Set(\r\n\t\t\tmodule.dependencies\r\n\t\t\t\t.filter(d => d instanceof WebAssemblyExportImportedDependency)\r\n\t\t\t\t.map(d => {\r\n\t\t\t\t\tconst wasmDep = /** @type {WebAssemblyExportImportedDependency} */ (\r\n\t\t\t\t\t\td\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn wasmDep.exportName;\r\n\t\t\t\t})\r\n\t\t);\r\n\r\n\t\t/** @type {t.Instruction[]} */\r\n\t\tconst additionalInitCode = [];\r\n\r\n\t\tconst transform = compose(\r\n\t\t\trewriteExportNames({\r\n\t\t\t\tast,\r\n\t\t\t\tmoduleGraph,\r\n\t\t\t\tmodule,\r\n\t\t\t\texternalExports,\r\n\t\t\t\truntime\r\n\t\t\t}),\r\n\r\n\t\t\tremoveStartFunc({ ast }),\r\n\r\n\t\t\trewriteImportedGlobals({ ast, additionalInitCode }),\r\n\r\n\t\t\trewriteImports({\r\n\t\t\t\tast,\r\n\t\t\t\tusedDependencyMap\r\n\t\t\t}),\r\n\r\n\t\t\taddInitFunction({\r\n\t\t\t\tast,\r\n\t\t\t\tinitFuncId,\r\n\t\t\t\timportedGlobals,\r\n\t\t\t\tadditionalInitCode,\r\n\t\t\t\tstartAtFuncOffset,\r\n\t\t\t\tnextFuncIndex,\r\n\t\t\t\tnextTypeIndex\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tconst newBin = transform(bin);\r\n\r\n\t\tconst newBuf = Buffer.from(newBin);\r\n\r\n\t\treturn new RawSource(newBuf);\r\n\t}\r\n}\r\n\r\nmodule.exports = WebAssemblyGenerator;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}