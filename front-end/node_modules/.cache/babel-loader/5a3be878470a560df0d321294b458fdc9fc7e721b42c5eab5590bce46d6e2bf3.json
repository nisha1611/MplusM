{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollectionsOperation = void 0;\nconst collection_1 = require(\"../collection\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass CollectionsOperation extends operation_1.AbstractOperation {\n  constructor(db, options) {\n    super(options);\n    this.options = options;\n    this.db = db;\n  }\n  execute(server, session, callback) {\n    const db = this.db;\n    // Let's get the collection names\n    db.listCollections({}, {\n      ...this.options,\n      nameOnly: true,\n      readPreference: this.readPreference,\n      session\n    }).toArray((err, documents) => {\n      if (err || !documents) return callback(err);\n      // Filter collections removing any illegal ones\n      documents = documents.filter(doc => doc.name.indexOf('$') === -1);\n      // Return the collection objects\n      callback(undefined, documents.map(d => {\n        return new collection_1.Collection(db, d.name, db.s.options);\n      }));\n    });\n  }\n}\nexports.CollectionsOperation = CollectionsOperation;","map":{"version":3,"mappings":";;;;;;AAAA;AAKA;AAMA;AACA,MAAaA,oBAAqB,SAAQC,6BAA+B;EAIvEC,YAAYC,EAAM,EAAEC,OAA2B;IAC7C,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACD,EAAE,GAAGA,EAAE;EACd;EAESE,OAAO,CACdC,MAAc,EACdC,OAAkC,EAClCC,QAAgC;IAEhC,MAAML,EAAE,GAAG,IAAI,CAACA,EAAE;IAElB;IACAA,EAAE,CAACM,eAAe,CAChB,EAAE,EACF;MAAE,GAAG,IAAI,CAACL,OAAO;MAAEM,QAAQ,EAAE,IAAI;MAAEC,cAAc,EAAE,IAAI,CAACA,cAAc;MAAEJ;IAAO,CAAE,CAClF,CAACK,OAAO,CAAC,CAACC,GAAG,EAAEC,SAAS,KAAI;MAC3B,IAAID,GAAG,IAAI,CAACC,SAAS,EAAE,OAAON,QAAQ,CAACK,GAAG,CAAC;MAC3C;MACAC,SAAS,GAAGA,SAAS,CAACC,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACC,IAAI,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;MAEjE;MACAV,QAAQ,CACNW,SAAS,EACTL,SAAS,CAACM,GAAG,CAACC,CAAC,IAAG;QAChB,OAAO,IAAIC,uBAAU,CAACnB,EAAE,EAAEkB,CAAC,CAACJ,IAAI,EAAEd,EAAE,CAACoB,CAAC,CAACnB,OAAO,CAAC;MACjD,CAAC,CAAC,CACH;IACH,CAAC,CAAC;EACJ;;AAlCFoB","names":["CollectionsOperation","operation_1","constructor","db","options","execute","server","session","callback","listCollections","nameOnly","readPreference","toArray","err","documents","filter","doc","name","indexOf","undefined","map","d","collection_1","s","exports"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\operations\\collections.ts"],"sourcesContent":["import { Collection } from '../collection';\r\nimport type { Db } from '../db';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Callback } from '../utils';\r\nimport { AbstractOperation, OperationOptions } from './operation';\r\n\r\nexport interface CollectionsOptions extends OperationOptions {\r\n  nameOnly?: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport class CollectionsOperation extends AbstractOperation<Collection[]> {\r\n  override options: CollectionsOptions;\r\n  db: Db;\r\n\r\n  constructor(db: Db, options: CollectionsOptions) {\r\n    super(options);\r\n    this.options = options;\r\n    this.db = db;\r\n  }\r\n\r\n  override execute(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Collection[]>\r\n  ): void {\r\n    const db = this.db;\r\n\r\n    // Let's get the collection names\r\n    db.listCollections(\r\n      {},\r\n      { ...this.options, nameOnly: true, readPreference: this.readPreference, session }\r\n    ).toArray((err, documents) => {\r\n      if (err || !documents) return callback(err);\r\n      // Filter collections removing any illegal ones\r\n      documents = documents.filter(doc => doc.name.indexOf('$') === -1);\r\n\r\n      // Return the collection objects\r\n      callback(\r\n        undefined,\r\n        documents.map(d => {\r\n          return new Collection(db, d.name, db.s.options);\r\n        })\r\n      );\r\n    });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}