{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignatureV4 = void 0;\nconst util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\nconst util_middleware_1 = require(\"@aws-sdk/util-middleware\");\nconst constants_1 = require(\"./constants\");\nconst credentialDerivation_1 = require(\"./credentialDerivation\");\nconst getCanonicalHeaders_1 = require(\"./getCanonicalHeaders\");\nconst getCanonicalQuery_1 = require(\"./getCanonicalQuery\");\nconst getPayloadHash_1 = require(\"./getPayloadHash\");\nconst headerUtil_1 = require(\"./headerUtil\");\nconst moveHeadersToQuery_1 = require(\"./moveHeadersToQuery\");\nconst prepareRequest_1 = require(\"./prepareRequest\");\nconst utilDate_1 = require(\"./utilDate\");\nclass SignatureV4 {\n  constructor(_ref) {\n    let {\n      applyChecksum,\n      credentials,\n      region,\n      service,\n      sha256,\n      uriEscapePath = true\n    } = _ref;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);\n    this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);\n  }\n  async presign(originalRequest) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService\n    } = options;\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {\n      return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n    }\n    const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n    const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), {\n      unhoistableHeaders\n    });\n    if (credentials.sessionToken) {\n      request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;\n    request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n    const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);\n    request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n    request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));\n    return request;\n  }\n  async sign(toSign, options) {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n  async signEvent(_ref2, _ref3) {\n    let {\n      headers,\n      payload\n    } = _ref2;\n    let {\n      signingDate = new Date(),\n      priorSignature,\n      signingRegion,\n      signingService\n    } = _ref3;\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const {\n      shortDate,\n      longDate\n    } = formatDate(signingDate);\n    const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n    const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({\n      headers: {},\n      body: payload\n    }, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());\n    const stringToSign = [constants_1.EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n    return this.signString(stringToSign, {\n      signingDate,\n      signingRegion: region,\n      signingService\n    });\n  }\n  async signString(stringToSign) {\n    let {\n      signingDate = new Date(),\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const {\n      shortDate\n    } = formatDate(signingDate);\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(stringToSign);\n    return (0, util_hex_encoding_1.toHex)(await hash.digest());\n  }\n  async signRequest(requestToSign) {\n    let {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const request = (0, prepareRequest_1.prepareRequest)(requestToSign);\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n    request.headers[constants_1.AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;\n    }\n    const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);\n    if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[constants_1.SHA256_HEADER] = payloadHash;\n    }\n    const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n    request.headers[constants_1.AUTH_HEADER] = `${constants_1.ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;\n    return request;\n  }\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}\n${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n  async createStringToSign(longDate, credentialScope, canonicalRequest) {\n    const hash = new this.sha256();\n    hash.update(canonicalRequest);\n    const hashedRequest = await hash.digest();\n    return `${constants_1.ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;\n  }\n  getCanonicalPath(_ref4) {\n    let {\n      path\n    } = _ref4;\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n      for (const pathSegment of path.split(\"/\")) {\n        if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0) continue;\n        if (pathSegment === \".\") continue;\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n      const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith(\"/\")) ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith(\"/\")) ? \"/\" : \"\"}`;\n      const doubleEncoded = encodeURIComponent(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n    return path;\n  }\n  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n    const hash = new this.sha256(await keyPromise);\n    hash.update(stringToSign);\n    return (0, util_hex_encoding_1.toHex)(await hash.digest());\n  }\n  getSigningKey(credentials, region, shortDate, service) {\n    return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n}\nexports.SignatureV4 = SignatureV4;\nconst formatDate = now => {\n  const longDate = (0, utilDate_1.iso8601)(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.slice(0, 8)\n  };\n};\nconst getCanonicalHeaderList = headers => Object.keys(headers).sort().join(\";\");","map":{"version":3,"names":["Object","defineProperty","exports","value","SignatureV4","util_hex_encoding_1","require","util_middleware_1","constants_1","credentialDerivation_1","getCanonicalHeaders_1","getCanonicalQuery_1","getPayloadHash_1","headerUtil_1","moveHeadersToQuery_1","prepareRequest_1","utilDate_1","constructor","applyChecksum","credentials","region","service","sha256","uriEscapePath","regionProvider","normalizeProvider","credentialProvider","presign","originalRequest","options","signingDate","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","validateResolvedCredentials","longDate","shortDate","formatDate","MAX_PRESIGNED_TTL","Promise","reject","scope","createScope","request","moveHeadersToQuery","prepareRequest","sessionToken","query","TOKEN_QUERY_PARAM","ALGORITHM_QUERY_PARAM","ALGORITHM_IDENTIFIER","CREDENTIAL_QUERY_PARAM","accessKeyId","AMZ_DATE_QUERY_PARAM","EXPIRES_QUERY_PARAM","toString","canonicalHeaders","getCanonicalHeaders","SIGNED_HEADERS_QUERY_PARAM","getCanonicalHeaderList","SIGNATURE_QUERY_PARAM","getSignature","getSigningKey","createCanonicalRequest","getPayloadHash","sign","toSign","signString","headers","payload","signEvent","signRequest","priorSignature","hashedPayload","body","hash","update","hashedHeaders","toHex","digest","stringToSign","EVENT_ALGORITHM_IDENTIFIER","join","requestToSign","AMZ_DATE_HEADER","TOKEN_HEADER","payloadHash","hasHeader","SHA256_HEADER","signature","AUTH_HEADER","sortedHeaders","keys","sort","method","getCanonicalPath","getCanonicalQuery","map","name","createStringToSign","credentialScope","canonicalRequest","hashedRequest","path","normalizedPathSegments","pathSegment","split","length","pop","push","normalizedPath","startsWith","endsWith","doubleEncoded","encodeURIComponent","replace","keyPromise","secretAccessKey","Error","now","iso8601","slice"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/signature-v4/dist-cjs/SignatureV4.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SignatureV4 = void 0;\r\nconst util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\r\nconst util_middleware_1 = require(\"@aws-sdk/util-middleware\");\r\nconst constants_1 = require(\"./constants\");\r\nconst credentialDerivation_1 = require(\"./credentialDerivation\");\r\nconst getCanonicalHeaders_1 = require(\"./getCanonicalHeaders\");\r\nconst getCanonicalQuery_1 = require(\"./getCanonicalQuery\");\r\nconst getPayloadHash_1 = require(\"./getPayloadHash\");\r\nconst headerUtil_1 = require(\"./headerUtil\");\r\nconst moveHeadersToQuery_1 = require(\"./moveHeadersToQuery\");\r\nconst prepareRequest_1 = require(\"./prepareRequest\");\r\nconst utilDate_1 = require(\"./utilDate\");\r\nclass SignatureV4 {\r\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\r\n        this.service = service;\r\n        this.sha256 = sha256;\r\n        this.uriEscapePath = uriEscapePath;\r\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\r\n        this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);\r\n        this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);\r\n    }\r\n    async presign(originalRequest, options = {}) {\r\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;\r\n        const credentials = await this.credentialProvider();\r\n        this.validateResolvedCredentials(credentials);\r\n        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());\r\n        const { longDate, shortDate } = formatDate(signingDate);\r\n        if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {\r\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\r\n        }\r\n        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\r\n        const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), { unhoistableHeaders });\r\n        if (credentials.sessionToken) {\r\n            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;\r\n        }\r\n        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;\r\n        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\r\n        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;\r\n        request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\r\n        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);\r\n        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\r\n        request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));\r\n        return request;\r\n    }\r\n    async sign(toSign, options) {\r\n        if (typeof toSign === \"string\") {\r\n            return this.signString(toSign, options);\r\n        }\r\n        else if (toSign.headers && toSign.payload) {\r\n            return this.signEvent(toSign, options);\r\n        }\r\n        else {\r\n            return this.signRequest(toSign, options);\r\n        }\r\n    }\r\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\r\n        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());\r\n        const { shortDate, longDate } = formatDate(signingDate);\r\n        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\r\n        const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({ headers: {}, body: payload }, this.sha256);\r\n        const hash = new this.sha256();\r\n        hash.update(headers);\r\n        const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());\r\n        const stringToSign = [\r\n            constants_1.EVENT_ALGORITHM_IDENTIFIER,\r\n            longDate,\r\n            scope,\r\n            priorSignature,\r\n            hashedHeaders,\r\n            hashedPayload,\r\n        ].join(\"\\n\");\r\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\r\n    }\r\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\r\n        const credentials = await this.credentialProvider();\r\n        this.validateResolvedCredentials(credentials);\r\n        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());\r\n        const { shortDate } = formatDate(signingDate);\r\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\r\n        hash.update(stringToSign);\r\n        return (0, util_hex_encoding_1.toHex)(await hash.digest());\r\n    }\r\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\r\n        const credentials = await this.credentialProvider();\r\n        this.validateResolvedCredentials(credentials);\r\n        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());\r\n        const request = (0, prepareRequest_1.prepareRequest)(requestToSign);\r\n        const { longDate, shortDate } = formatDate(signingDate);\r\n        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\r\n        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;\r\n        if (credentials.sessionToken) {\r\n            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;\r\n        }\r\n        const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);\r\n        if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {\r\n            request.headers[constants_1.SHA256_HEADER] = payloadHash;\r\n        }\r\n        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);\r\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\r\n        request.headers[constants_1.AUTH_HEADER] =\r\n            `${constants_1.ALGORITHM_IDENTIFIER} ` +\r\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\r\n                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\r\n                `Signature=${signature}`;\r\n        return request;\r\n    }\r\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\r\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\r\n        return `${request.method}\r\n${this.getCanonicalPath(request)}\r\n${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}\r\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\r\n\r\n${sortedHeaders.join(\";\")}\r\n${payloadHash}`;\r\n    }\r\n    async createStringToSign(longDate, credentialScope, canonicalRequest) {\r\n        const hash = new this.sha256();\r\n        hash.update(canonicalRequest);\r\n        const hashedRequest = await hash.digest();\r\n        return `${constants_1.ALGORITHM_IDENTIFIER}\r\n${longDate}\r\n${credentialScope}\r\n${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;\r\n    }\r\n    getCanonicalPath({ path }) {\r\n        if (this.uriEscapePath) {\r\n            const normalizedPathSegments = [];\r\n            for (const pathSegment of path.split(\"/\")) {\r\n                if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0)\r\n                    continue;\r\n                if (pathSegment === \".\")\r\n                    continue;\r\n                if (pathSegment === \"..\") {\r\n                    normalizedPathSegments.pop();\r\n                }\r\n                else {\r\n                    normalizedPathSegments.push(pathSegment);\r\n                }\r\n            }\r\n            const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith(\"/\")) ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith(\"/\")) ? \"/\" : \"\"}`;\r\n            const doubleEncoded = encodeURIComponent(normalizedPath);\r\n            return doubleEncoded.replace(/%2F/g, \"/\");\r\n        }\r\n        return path;\r\n    }\r\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\r\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\r\n        const hash = new this.sha256(await keyPromise);\r\n        hash.update(stringToSign);\r\n        return (0, util_hex_encoding_1.toHex)(await hash.digest());\r\n    }\r\n    getSigningKey(credentials, region, shortDate, service) {\r\n        return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);\r\n    }\r\n    validateResolvedCredentials(credentials) {\r\n        if (typeof credentials !== \"object\" ||\r\n            typeof credentials.accessKeyId !== \"string\" ||\r\n            typeof credentials.secretAccessKey !== \"string\") {\r\n            throw new Error(\"Resolved credential object is not valid\");\r\n        }\r\n    }\r\n}\r\nexports.SignatureV4 = SignatureV4;\r\nconst formatDate = (now) => {\r\n    const longDate = (0, utilDate_1.iso8601)(now).replace(/[\\-:]/g, \"\");\r\n    return {\r\n        longDate,\r\n        shortDate: longDate.slice(0, 8),\r\n    };\r\n};\r\nconst getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(\";\");\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B,MAAMC,mBAAmB,GAAGC,OAAO,CAAC,4BAA4B,CAAC;AACjE,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,0BAA0B,CAAC;AAC7D,MAAME,WAAW,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMG,sBAAsB,GAAGH,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMI,qBAAqB,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AAC9D,MAAMK,mBAAmB,GAAGL,OAAO,CAAC,qBAAqB,CAAC;AAC1D,MAAMM,gBAAgB,GAAGN,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMO,YAAY,GAAGP,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAMQ,oBAAoB,GAAGR,OAAO,CAAC,sBAAsB,CAAC;AAC5D,MAAMS,gBAAgB,GAAGT,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMU,UAAU,GAAGV,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMF,WAAW,CAAC;EACda,WAAW,OAAiF;IAAA,IAAhF;MAAEC,aAAa;MAAEC,WAAW;MAAEC,MAAM;MAAEC,OAAO;MAAEC,MAAM;MAAEC,aAAa,GAAG;IAAM,CAAC;IACtF,IAAI,CAACF,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACL,aAAa,GAAG,OAAOA,aAAa,KAAK,SAAS,GAAGA,aAAa,GAAG,IAAI;IAC9E,IAAI,CAACM,cAAc,GAAG,CAAC,CAAC,EAAEjB,iBAAiB,CAACkB,iBAAiB,EAAEL,MAAM,CAAC;IACtE,IAAI,CAACM,kBAAkB,GAAG,CAAC,CAAC,EAAEnB,iBAAiB,CAACkB,iBAAiB,EAAEN,WAAW,CAAC;EACnF;EACA,MAAMQ,OAAO,CAACC,eAAe,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IACvC,MAAM;MAAEC,WAAW,GAAG,IAAIC,IAAI,EAAE;MAAEC,SAAS,GAAG,IAAI;MAAEC,iBAAiB;MAAEC,kBAAkB;MAAEC,eAAe;MAAEC,aAAa;MAAEC;IAAgB,CAAC,GAAGR,OAAO;IACtJ,MAAMV,WAAW,GAAG,MAAM,IAAI,CAACO,kBAAkB,EAAE;IACnD,IAAI,CAACY,2BAA2B,CAACnB,WAAW,CAAC;IAC7C,MAAMC,MAAM,GAAGgB,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAI,MAAM,IAAI,CAACZ,cAAc,EAAG;IACjH,MAAM;MAAEe,QAAQ;MAAEC;IAAU,CAAC,GAAGC,UAAU,CAACX,WAAW,CAAC;IACvD,IAAIE,SAAS,GAAGxB,WAAW,CAACkC,iBAAiB,EAAE;MAC3C,OAAOC,OAAO,CAACC,MAAM,CAAC,oCAAoC,GAAG,qDAAqD,GAAG,aAAa,CAAC;IACvI;IACA,MAAMC,KAAK,GAAG,CAAC,CAAC,EAAEpC,sBAAsB,CAACqC,WAAW,EAAEN,SAAS,EAAEpB,MAAM,EAAEiB,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,IAAI,CAAChB,OAAO,CAAC;IAC9J,MAAM0B,OAAO,GAAG,CAAC,CAAC,EAAEjC,oBAAoB,CAACkC,kBAAkB,EAAE,CAAC,CAAC,EAAEjC,gBAAgB,CAACkC,cAAc,EAAErB,eAAe,CAAC,EAAE;MAAEM;IAAmB,CAAC,CAAC;IAC3I,IAAIf,WAAW,CAAC+B,YAAY,EAAE;MAC1BH,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAAC4C,iBAAiB,CAAC,GAAGjC,WAAW,CAAC+B,YAAY;IAC3E;IACAH,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAAC6C,qBAAqB,CAAC,GAAG7C,WAAW,CAAC8C,oBAAoB;IACnFP,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAAC+C,sBAAsB,CAAC,GAAI,GAAEpC,WAAW,CAACqC,WAAY,IAAGX,KAAM,EAAC;IACzFE,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAACiD,oBAAoB,CAAC,GAAGlB,QAAQ;IAC1DQ,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAACkD,mBAAmB,CAAC,GAAG1B,SAAS,CAAC2B,QAAQ,CAAC,EAAE,CAAC;IACvE,MAAMC,gBAAgB,GAAG,CAAC,CAAC,EAAElD,qBAAqB,CAACmD,mBAAmB,EAAEd,OAAO,EAAEd,iBAAiB,EAAEE,eAAe,CAAC;IACpHY,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAACsD,0BAA0B,CAAC,GAAGC,sBAAsB,CAACH,gBAAgB,CAAC;IAChGb,OAAO,CAACI,KAAK,CAAC3C,WAAW,CAACwD,qBAAqB,CAAC,GAAG,MAAM,IAAI,CAACC,YAAY,CAAC1B,QAAQ,EAAEM,KAAK,EAAE,IAAI,CAACqB,aAAa,CAAC/C,WAAW,EAAEC,MAAM,EAAEoB,SAAS,EAAEH,cAAc,CAAC,EAAE,IAAI,CAAC8B,sBAAsB,CAACpB,OAAO,EAAEa,gBAAgB,EAAE,MAAM,CAAC,CAAC,EAAEhD,gBAAgB,CAACwD,cAAc,EAAExC,eAAe,EAAE,IAAI,CAACN,MAAM,CAAC,CAAC,CAAC;IACjS,OAAOyB,OAAO;EAClB;EACA,MAAMsB,IAAI,CAACC,MAAM,EAAEzC,OAAO,EAAE;IACxB,IAAI,OAAOyC,MAAM,KAAK,QAAQ,EAAE;MAC5B,OAAO,IAAI,CAACC,UAAU,CAACD,MAAM,EAAEzC,OAAO,CAAC;IAC3C,CAAC,MACI,IAAIyC,MAAM,CAACE,OAAO,IAAIF,MAAM,CAACG,OAAO,EAAE;MACvC,OAAO,IAAI,CAACC,SAAS,CAACJ,MAAM,EAAEzC,OAAO,CAAC;IAC1C,CAAC,MACI;MACD,OAAO,IAAI,CAAC8C,WAAW,CAACL,MAAM,EAAEzC,OAAO,CAAC;IAC5C;EACJ;EACA,MAAM6C,SAAS,eAAoG;IAAA,IAAnG;MAAEF,OAAO;MAAEC;IAAQ,CAAC;IAAA,IAAE;MAAE3C,WAAW,GAAG,IAAIC,IAAI,EAAE;MAAE6C,cAAc;MAAExC,aAAa;MAAEC;IAAe,CAAC;IAC7G,MAAMjB,MAAM,GAAGgB,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAI,MAAM,IAAI,CAACZ,cAAc,EAAG;IACjH,MAAM;MAAEgB,SAAS;MAAED;IAAS,CAAC,GAAGE,UAAU,CAACX,WAAW,CAAC;IACvD,MAAMe,KAAK,GAAG,CAAC,CAAC,EAAEpC,sBAAsB,CAACqC,WAAW,EAAEN,SAAS,EAAEpB,MAAM,EAAEiB,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,IAAI,CAAChB,OAAO,CAAC;IAC9J,MAAMwD,aAAa,GAAG,MAAM,CAAC,CAAC,EAAEjE,gBAAgB,CAACwD,cAAc,EAAE;MAAEI,OAAO,EAAE,CAAC,CAAC;MAAEM,IAAI,EAAEL;IAAQ,CAAC,EAAE,IAAI,CAACnD,MAAM,CAAC;IAC7G,MAAMyD,IAAI,GAAG,IAAI,IAAI,CAACzD,MAAM,EAAE;IAC9ByD,IAAI,CAACC,MAAM,CAACR,OAAO,CAAC;IACpB,MAAMS,aAAa,GAAG,CAAC,CAAC,EAAE5E,mBAAmB,CAAC6E,KAAK,EAAE,MAAMH,IAAI,CAACI,MAAM,EAAE,CAAC;IACzE,MAAMC,YAAY,GAAG,CACjB5E,WAAW,CAAC6E,0BAA0B,EACtC9C,QAAQ,EACRM,KAAK,EACL+B,cAAc,EACdK,aAAa,EACbJ,aAAa,CAChB,CAACS,IAAI,CAAC,IAAI,CAAC;IACZ,OAAO,IAAI,CAACf,UAAU,CAACa,YAAY,EAAE;MAAEtD,WAAW;MAAEM,aAAa,EAAEhB,MAAM;MAAEiB;IAAe,CAAC,CAAC;EAChG;EACA,MAAMkC,UAAU,CAACa,YAAY,EAAoE;IAAA,IAAlE;MAAEtD,WAAW,GAAG,IAAIC,IAAI,EAAE;MAAEK,aAAa;MAAEC;IAAe,CAAC,uEAAG,CAAC,CAAC;IAC3F,MAAMlB,WAAW,GAAG,MAAM,IAAI,CAACO,kBAAkB,EAAE;IACnD,IAAI,CAACY,2BAA2B,CAACnB,WAAW,CAAC;IAC7C,MAAMC,MAAM,GAAGgB,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAI,MAAM,IAAI,CAACZ,cAAc,EAAG;IACjH,MAAM;MAAEgB;IAAU,CAAC,GAAGC,UAAU,CAACX,WAAW,CAAC;IAC7C,MAAMiD,IAAI,GAAG,IAAI,IAAI,CAACzD,MAAM,CAAC,MAAM,IAAI,CAAC4C,aAAa,CAAC/C,WAAW,EAAEC,MAAM,EAAEoB,SAAS,EAAEH,cAAc,CAAC,CAAC;IACtG0C,IAAI,CAACC,MAAM,CAACI,YAAY,CAAC;IACzB,OAAO,CAAC,CAAC,EAAE/E,mBAAmB,CAAC6E,KAAK,EAAE,MAAMH,IAAI,CAACI,MAAM,EAAE,CAAC;EAC9D;EACA,MAAMR,WAAW,CAACY,aAAa,EAAyG;IAAA,IAAvG;MAAEzD,WAAW,GAAG,IAAIC,IAAI,EAAE;MAAEI,eAAe;MAAEF,iBAAiB;MAAEG,aAAa;MAAEC;IAAgB,CAAC,uEAAG,CAAC,CAAC;IAClI,MAAMlB,WAAW,GAAG,MAAM,IAAI,CAACO,kBAAkB,EAAE;IACnD,IAAI,CAACY,2BAA2B,CAACnB,WAAW,CAAC;IAC7C,MAAMC,MAAM,GAAGgB,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAI,MAAM,IAAI,CAACZ,cAAc,EAAG;IACjH,MAAMuB,OAAO,GAAG,CAAC,CAAC,EAAEhC,gBAAgB,CAACkC,cAAc,EAAEsC,aAAa,CAAC;IACnE,MAAM;MAAEhD,QAAQ;MAAEC;IAAU,CAAC,GAAGC,UAAU,CAACX,WAAW,CAAC;IACvD,MAAMe,KAAK,GAAG,CAAC,CAAC,EAAEpC,sBAAsB,CAACqC,WAAW,EAAEN,SAAS,EAAEpB,MAAM,EAAEiB,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,IAAI,CAAChB,OAAO,CAAC;IAC9J0B,OAAO,CAACyB,OAAO,CAAChE,WAAW,CAACgF,eAAe,CAAC,GAAGjD,QAAQ;IACvD,IAAIpB,WAAW,CAAC+B,YAAY,EAAE;MAC1BH,OAAO,CAACyB,OAAO,CAAChE,WAAW,CAACiF,YAAY,CAAC,GAAGtE,WAAW,CAAC+B,YAAY;IACxE;IACA,MAAMwC,WAAW,GAAG,MAAM,CAAC,CAAC,EAAE9E,gBAAgB,CAACwD,cAAc,EAAErB,OAAO,EAAE,IAAI,CAACzB,MAAM,CAAC;IACpF,IAAI,CAAC,CAAC,CAAC,EAAET,YAAY,CAAC8E,SAAS,EAAEnF,WAAW,CAACoF,aAAa,EAAE7C,OAAO,CAACyB,OAAO,CAAC,IAAI,IAAI,CAACtD,aAAa,EAAE;MAChG6B,OAAO,CAACyB,OAAO,CAAChE,WAAW,CAACoF,aAAa,CAAC,GAAGF,WAAW;IAC5D;IACA,MAAM9B,gBAAgB,GAAG,CAAC,CAAC,EAAElD,qBAAqB,CAACmD,mBAAmB,EAAEd,OAAO,EAAEd,iBAAiB,EAAEE,eAAe,CAAC;IACpH,MAAM0D,SAAS,GAAG,MAAM,IAAI,CAAC5B,YAAY,CAAC1B,QAAQ,EAAEM,KAAK,EAAE,IAAI,CAACqB,aAAa,CAAC/C,WAAW,EAAEC,MAAM,EAAEoB,SAAS,EAAEH,cAAc,CAAC,EAAE,IAAI,CAAC8B,sBAAsB,CAACpB,OAAO,EAAEa,gBAAgB,EAAE8B,WAAW,CAAC,CAAC;IACnM3C,OAAO,CAACyB,OAAO,CAAChE,WAAW,CAACsF,WAAW,CAAC,GACnC,GAAEtF,WAAW,CAAC8C,oBAAqB,GAAE,GACjC,cAAanC,WAAW,CAACqC,WAAY,IAAGX,KAAM,IAAG,GACjD,iBAAgBkB,sBAAsB,CAACH,gBAAgB,CAAE,IAAG,GAC5D,aAAYiC,SAAU,EAAC;IAChC,OAAO9C,OAAO;EAClB;EACAoB,sBAAsB,CAACpB,OAAO,EAAEa,gBAAgB,EAAE8B,WAAW,EAAE;IAC3D,MAAMK,aAAa,GAAG/F,MAAM,CAACgG,IAAI,CAACpC,gBAAgB,CAAC,CAACqC,IAAI,EAAE;IAC1D,OAAQ,GAAElD,OAAO,CAACmD,MAAO;AACjC,EAAE,IAAI,CAACC,gBAAgB,CAACpD,OAAO,CAAE;AACjC,EAAE,CAAC,CAAC,EAAEpC,mBAAmB,CAACyF,iBAAiB,EAAErD,OAAO,CAAE;AACtD,EAAEgD,aAAa,CAACM,GAAG,CAAEC,IAAI,IAAM,GAAEA,IAAK,IAAG1C,gBAAgB,CAAC0C,IAAI,CAAE,EAAC,CAAC,CAAChB,IAAI,CAAC,IAAI,CAAE;AAC9E;AACA,EAAES,aAAa,CAACT,IAAI,CAAC,GAAG,CAAE;AAC1B,EAAEI,WAAY,EAAC;EACX;EACA,MAAMa,kBAAkB,CAAChE,QAAQ,EAAEiE,eAAe,EAAEC,gBAAgB,EAAE;IAClE,MAAM1B,IAAI,GAAG,IAAI,IAAI,CAACzD,MAAM,EAAE;IAC9ByD,IAAI,CAACC,MAAM,CAACyB,gBAAgB,CAAC;IAC7B,MAAMC,aAAa,GAAG,MAAM3B,IAAI,CAACI,MAAM,EAAE;IACzC,OAAQ,GAAE3E,WAAW,CAAC8C,oBAAqB;AACnD,EAAEf,QAAS;AACX,EAAEiE,eAAgB;AAClB,EAAE,CAAC,CAAC,EAAEnG,mBAAmB,CAAC6E,KAAK,EAAEwB,aAAa,CAAE,EAAC;EAC7C;EACAP,gBAAgB,QAAW;IAAA,IAAV;MAAEQ;IAAK,CAAC;IACrB,IAAI,IAAI,CAACpF,aAAa,EAAE;MACpB,MAAMqF,sBAAsB,GAAG,EAAE;MACjC,KAAK,MAAMC,WAAW,IAAIF,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC,EAAE;QACvC,IAAI,CAACD,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACE,MAAM,MAAM,CAAC,EACpF;QACJ,IAAIF,WAAW,KAAK,GAAG,EACnB;QACJ,IAAIA,WAAW,KAAK,IAAI,EAAE;UACtBD,sBAAsB,CAACI,GAAG,EAAE;QAChC,CAAC,MACI;UACDJ,sBAAsB,CAACK,IAAI,CAACJ,WAAW,CAAC;QAC5C;MACJ;MACA,MAAMK,cAAc,GAAI,GAAE,CAACP,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACQ,UAAU,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,EAAG,GAAEP,sBAAsB,CAACtB,IAAI,CAAC,GAAG,CAAE,GAAEsB,sBAAsB,CAACG,MAAM,GAAG,CAAC,KAAKJ,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACS,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,EAAG,EAAC;MAC/P,MAAMC,aAAa,GAAGC,kBAAkB,CAACJ,cAAc,CAAC;MACxD,OAAOG,aAAa,CAACE,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;IAC7C;IACA,OAAOZ,IAAI;EACf;EACA,MAAM1C,YAAY,CAAC1B,QAAQ,EAAEiE,eAAe,EAAEgB,UAAU,EAAEf,gBAAgB,EAAE;IACxE,MAAMrB,YAAY,GAAG,MAAM,IAAI,CAACmB,kBAAkB,CAAChE,QAAQ,EAAEiE,eAAe,EAAEC,gBAAgB,CAAC;IAC/F,MAAM1B,IAAI,GAAG,IAAI,IAAI,CAACzD,MAAM,CAAC,MAAMkG,UAAU,CAAC;IAC9CzC,IAAI,CAACC,MAAM,CAACI,YAAY,CAAC;IACzB,OAAO,CAAC,CAAC,EAAE/E,mBAAmB,CAAC6E,KAAK,EAAE,MAAMH,IAAI,CAACI,MAAM,EAAE,CAAC;EAC9D;EACAjB,aAAa,CAAC/C,WAAW,EAAEC,MAAM,EAAEoB,SAAS,EAAEnB,OAAO,EAAE;IACnD,OAAO,CAAC,CAAC,EAAEZ,sBAAsB,CAACyD,aAAa,EAAE,IAAI,CAAC5C,MAAM,EAAEH,WAAW,EAAEqB,SAAS,EAAEpB,MAAM,EAAEC,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC;EAC1H;EACAiB,2BAA2B,CAACnB,WAAW,EAAE;IACrC,IAAI,OAAOA,WAAW,KAAK,QAAQ,IAC/B,OAAOA,WAAW,CAACqC,WAAW,KAAK,QAAQ,IAC3C,OAAOrC,WAAW,CAACsG,eAAe,KAAK,QAAQ,EAAE;MACjD,MAAM,IAAIC,KAAK,CAAC,yCAAyC,CAAC;IAC9D;EACJ;AACJ;AACAxH,OAAO,CAACE,WAAW,GAAGA,WAAW;AACjC,MAAMqC,UAAU,GAAIkF,GAAG,IAAK;EACxB,MAAMpF,QAAQ,GAAG,CAAC,CAAC,EAAEvB,UAAU,CAAC4G,OAAO,EAAED,GAAG,CAAC,CAACJ,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;EACnE,OAAO;IACHhF,QAAQ;IACRC,SAAS,EAAED,QAAQ,CAACsF,KAAK,CAAC,CAAC,EAAE,CAAC;EAClC,CAAC;AACL,CAAC;AACD,MAAM9D,sBAAsB,GAAIS,OAAO,IAAKxE,MAAM,CAACgG,IAAI,CAACxB,OAAO,CAAC,CAACyB,IAAI,EAAE,CAACX,IAAI,CAAC,GAAG,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}