{"ast":null,"code":"const typeChecker = type => {\n  const typeString = \"[object \" + type + \"]\";\n  return function (value) {\n    return getClassName(value) === typeString;\n  };\n};\nconst getClassName = value => Object.prototype.toString.call(value);\nconst comparable = value => {\n  if (value instanceof Date) {\n    return value.getTime();\n  } else if (isArray(value)) {\n    return value.map(comparable);\n  } else if (value && typeof value.toJSON === \"function\") {\n    return value.toJSON();\n  }\n  return value;\n};\nconst isArray = typeChecker(\"Array\");\nconst isObject = typeChecker(\"Object\");\nconst isFunction = typeChecker(\"Function\");\nconst isVanillaObject = value => {\n  return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === \"function Object() { [native code] }\" || value.constructor.toString() === \"function Array() { [native code] }\") && !value.toJSON;\n};\nconst equals = (a, b) => {\n  if (a == null && a == b) {\n    return true;\n  }\n  if (a === b) {\n    return true;\n  }\n  if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n    return false;\n  }\n  if (isArray(a)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, {\n        length\n      } = a; i < length; i++) {\n      if (!equals(a[i], b[i])) return false;\n    }\n    return true;\n  } else if (isObject(a)) {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n    for (const key in a) {\n      if (!equals(a[key], b[key])) return false;\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Walks through each value given the context - used for nested operations. E.g:\r\n * { \"person.address\": { $eq: \"blarg\" }}\r\n */\nconst walkKeyPathValues = (item, keyPath, next, depth, key, owner) => {\n  const currentKey = keyPath[depth];\n  // if array, then try matching. Might fall through for cases like:\n  // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\n  if (isArray(item) && isNaN(Number(currentKey))) {\n    for (let i = 0, {\n        length\n      } = item; i < length; i++) {\n      // if FALSE is returned, then terminate walker. For operations, this simply\n      // means that the search critera was met.\n      if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\n        return false;\n      }\n    }\n  }\n  if (depth === keyPath.length || item == null) {\n    return next(item, key, owner, depth === 0);\n  }\n  return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);\n};\nclass BaseOperation {\n  constructor(params, owneryQuery, options, name) {\n    this.params = params;\n    this.owneryQuery = owneryQuery;\n    this.options = options;\n    this.name = name;\n    this.init();\n  }\n  init() {}\n  reset() {\n    this.done = false;\n    this.keep = false;\n  }\n}\nclass GroupOperation extends BaseOperation {\n  constructor(params, owneryQuery, options, children) {\n    super(params, owneryQuery, options);\n    this.children = children;\n  }\n  /**\r\n   */\n  reset() {\n    this.keep = false;\n    this.done = false;\n    for (let i = 0, {\n        length\n      } = this.children; i < length; i++) {\n      this.children[i].reset();\n    }\n  }\n  /**\r\n   */\n  childrenNext(item, key, owner, root) {\n    let done = true;\n    let keep = true;\n    for (let i = 0, {\n        length\n      } = this.children; i < length; i++) {\n      const childOperation = this.children[i];\n      if (!childOperation.done) {\n        childOperation.next(item, key, owner, root);\n      }\n      if (!childOperation.keep) {\n        keep = false;\n      }\n      if (childOperation.done) {\n        if (!childOperation.keep) {\n          break;\n        }\n      } else {\n        done = false;\n      }\n    }\n    this.done = done;\n    this.keep = keep;\n  }\n}\nclass NamedGroupOperation extends GroupOperation {\n  constructor(params, owneryQuery, options, children, name) {\n    super(params, owneryQuery, options, children);\n    this.name = name;\n  }\n}\nclass QueryOperation extends GroupOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  /**\r\n   */\n  next(item, key, parent, root) {\n    this.childrenNext(item, key, parent, root);\n  }\n}\nclass NestedOperation extends GroupOperation {\n  constructor(keyPath, params, owneryQuery, options, children) {\n    super(params, owneryQuery, options, children);\n    this.keyPath = keyPath;\n    this.propop = true;\n    /**\r\n     */\n    this._nextNestedValue = (value, key, owner, root) => {\n      this.childrenNext(value, key, owner, root);\n      return !this.done;\n    };\n  }\n  /**\r\n   */\n  next(item, key, parent) {\n    walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);\n  }\n}\nconst createTester = (a, compare) => {\n  if (a instanceof Function) {\n    return a;\n  }\n  if (a instanceof RegExp) {\n    return b => {\n      const result = typeof b === \"string\" && a.test(b);\n      a.lastIndex = 0;\n      return result;\n    };\n  }\n  const comparableA = comparable(a);\n  return b => compare(comparableA, comparable(b));\n};\nclass EqualsOperation extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._test = createTester(this.params, this.options.compare);\n  }\n  next(item, key, parent) {\n    if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\n      if (this._test(item, key, parent)) {\n        this.done = true;\n        this.keep = true;\n      }\n    }\n  }\n}\nconst createEqualsOperation = (params, owneryQuery, options) => new EqualsOperation(params, owneryQuery, options);\nclass NopeOperation extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  next() {\n    this.done = true;\n    this.keep = false;\n  }\n}\nconst numericalOperationCreator = createNumericalOperation => (params, owneryQuery, options, name) => {\n  if (params == null) {\n    return new NopeOperation(params, owneryQuery, options, name);\n  }\n  return createNumericalOperation(params, owneryQuery, options, name);\n};\nconst numericalOperation = createTester => numericalOperationCreator((params, owneryQuery, options, name) => {\n  const typeofParams = typeof comparable(params);\n  const test = createTester(params);\n  return new EqualsOperation(b => {\n    return typeof comparable(b) === typeofParams && test(b);\n  }, owneryQuery, options, name);\n});\nconst createNamedOperation = (name, params, parentQuery, options) => {\n  const operationCreator = options.operations[name];\n  if (!operationCreator) {\n    throwUnsupportedOperation(name);\n  }\n  return operationCreator(params, parentQuery, options, name);\n};\nconst throwUnsupportedOperation = name => {\n  throw new Error(`Unsupported operation: ${name}`);\n};\nconst containsOperation = (query, options) => {\n  for (const key in query) {\n    if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\") return true;\n  }\n  return false;\n};\nconst createNestedOperation = (keyPath, nestedQuery, parentKey, owneryQuery, options) => {\n  if (containsOperation(nestedQuery, options)) {\n    const [selfOperations, nestedOperations] = createQueryOperations(nestedQuery, parentKey, options);\n    if (nestedOperations.length) {\n      throw new Error(`Property queries must contain only operations, or exact objects.`);\n    }\n    return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);\n  }\n  return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [new EqualsOperation(nestedQuery, owneryQuery, options)]);\n};\nconst createQueryOperation = function (query) {\n  let owneryQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let {\n    compare,\n    operations\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const options = {\n    compare: compare || equals,\n    operations: Object.assign({}, operations || {})\n  };\n  const [selfOperations, nestedOperations] = createQueryOperations(query, null, options);\n  const ops = [];\n  if (selfOperations.length) {\n    ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));\n  }\n  ops.push(...nestedOperations);\n  if (ops.length === 1) {\n    return ops[0];\n  }\n  return new QueryOperation(query, owneryQuery, options, ops);\n};\nconst createQueryOperations = (query, parentKey, options) => {\n  const selfOperations = [];\n  const nestedOperations = [];\n  if (!isVanillaObject(query)) {\n    selfOperations.push(new EqualsOperation(query, query, options));\n    return [selfOperations, nestedOperations];\n  }\n  for (const key in query) {\n    if (options.operations.hasOwnProperty(key)) {\n      const op = createNamedOperation(key, query[key], query, options);\n      if (op) {\n        if (!op.propop && parentKey && !options.operations[parentKey]) {\n          throw new Error(`Malformed query. ${key} cannot be matched against property.`);\n        }\n      }\n      // probably just a flag for another operation (like $options)\n      if (op != null) {\n        selfOperations.push(op);\n      }\n    } else if (key.charAt(0) === \"$\") {\n      throwUnsupportedOperation(key);\n    } else {\n      nestedOperations.push(createNestedOperation(key.split(\".\"), query[key], key, query, options));\n    }\n  }\n  return [selfOperations, nestedOperations];\n};\nconst createOperationTester = operation => (item, key, owner) => {\n  operation.reset();\n  operation.next(item, key, owner);\n  return operation.keep;\n};\nconst createQueryTester = function (query) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return createOperationTester(createQueryOperation(query, null, options));\n};\nclass $Ne extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._test = createTester(this.params, this.options.compare);\n  }\n  reset() {\n    super.reset();\n    this.keep = true;\n  }\n  next(item) {\n    if (this._test(item)) {\n      this.done = true;\n      this.keep = false;\n    }\n  }\n}\n// https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\nclass $ElemMatch extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    if (!this.params || typeof this.params !== \"object\") {\n      throw new Error(`Malformed query. $elemMatch must by an object.`);\n    }\n    this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n  }\n  reset() {\n    super.reset();\n    this._queryOperation.reset();\n  }\n  next(item) {\n    if (isArray(item)) {\n      for (let i = 0, {\n          length\n        } = item; i < length; i++) {\n        // reset query operation since item being tested needs to pass _all_ query\n        // operations for it to be a success\n        this._queryOperation.reset();\n        const child = item[i];\n        this._queryOperation.next(child, i, item, false);\n        this.keep = this.keep || this._queryOperation.keep;\n      }\n      this.done = true;\n    } else {\n      this.done = false;\n      this.keep = false;\n    }\n  }\n}\nclass $Not extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n  }\n  reset() {\n    super.reset();\n    this._queryOperation.reset();\n  }\n  next(item, key, owner, root) {\n    this._queryOperation.next(item, key, owner, root);\n    this.done = this._queryOperation.done;\n    this.keep = !this._queryOperation.keep;\n  }\n}\nclass $Size extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {}\n  next(item) {\n    if (isArray(item) && item.length === this.params) {\n      this.done = true;\n      this.keep = true;\n    }\n    // if (parent && parent.length === this.params) {\n    //   this.done = true;\n    //   this.keep = true;\n    // }\n  }\n}\n\nconst assertGroupNotEmpty = values => {\n  if (values.length === 0) {\n    throw new Error(`$and/$or/$nor must be a nonempty array`);\n  }\n};\nclass $Or extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = false;\n  }\n  init() {\n    assertGroupNotEmpty(this.params);\n    this._ops = this.params.map(op => createQueryOperation(op, null, this.options));\n  }\n  reset() {\n    this.done = false;\n    this.keep = false;\n    for (let i = 0, {\n        length\n      } = this._ops; i < length; i++) {\n      this._ops[i].reset();\n    }\n  }\n  next(item, key, owner) {\n    let done = false;\n    let success = false;\n    for (let i = 0, {\n        length\n      } = this._ops; i < length; i++) {\n      const op = this._ops[i];\n      op.next(item, key, owner);\n      if (op.keep) {\n        done = true;\n        success = op.keep;\n        break;\n      }\n    }\n    this.keep = success;\n    this.done = done;\n  }\n}\nclass $Nor extends $Or {\n  constructor() {\n    super(...arguments);\n    this.propop = false;\n  }\n  next(item, key, owner) {\n    super.next(item, key, owner);\n    this.keep = !this.keep;\n  }\n}\nclass $In extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  init() {\n    this._testers = this.params.map(value => {\n      if (containsOperation(value, this.options)) {\n        throw new Error(`cannot nest $ under ${this.name.toLowerCase()}`);\n      }\n      return createTester(value, this.options.compare);\n    });\n  }\n  next(item, key, owner) {\n    let done = false;\n    let success = false;\n    for (let i = 0, {\n        length\n      } = this._testers; i < length; i++) {\n      const test = this._testers[i];\n      if (test(item)) {\n        done = true;\n        success = true;\n        break;\n      }\n    }\n    this.keep = success;\n    this.done = done;\n  }\n}\nclass $Nin extends BaseOperation {\n  constructor(params, ownerQuery, options, name) {\n    super(params, ownerQuery, options, name);\n    this.propop = true;\n    this._in = new $In(params, ownerQuery, options, name);\n  }\n  next(item, key, owner, root) {\n    this._in.next(item, key, owner);\n    if (isArray(owner) && !root) {\n      if (this._in.keep) {\n        this.keep = false;\n        this.done = true;\n      } else if (key == owner.length - 1) {\n        this.keep = true;\n        this.done = true;\n      }\n    } else {\n      this.keep = !this._in.keep;\n      this.done = true;\n    }\n  }\n  reset() {\n    super.reset();\n    this._in.reset();\n  }\n}\nclass $Exists extends BaseOperation {\n  constructor() {\n    super(...arguments);\n    this.propop = true;\n  }\n  next(item, key, owner) {\n    if (owner.hasOwnProperty(key) === this.params) {\n      this.done = true;\n      this.keep = true;\n    }\n  }\n}\nclass $And extends NamedGroupOperation {\n  constructor(params, owneryQuery, options, name) {\n    super(params, owneryQuery, options, params.map(query => createQueryOperation(query, owneryQuery, options)), name);\n    this.propop = false;\n    assertGroupNotEmpty(params);\n  }\n  next(item, key, owner, root) {\n    this.childrenNext(item, key, owner, root);\n  }\n}\nclass $All extends NamedGroupOperation {\n  constructor(params, owneryQuery, options, name) {\n    super(params, owneryQuery, options, params.map(query => createQueryOperation(query, owneryQuery, options)), name);\n    this.propop = true;\n  }\n  next(item, key, owner, root) {\n    this.childrenNext(item, key, owner, root);\n  }\n}\nconst $eq = (params, owneryQuery, options) => new EqualsOperation(params, owneryQuery, options);\nconst $ne = (params, owneryQuery, options, name) => new $Ne(params, owneryQuery, options, name);\nconst $or = (params, owneryQuery, options, name) => new $Or(params, owneryQuery, options, name);\nconst $nor = (params, owneryQuery, options, name) => new $Nor(params, owneryQuery, options, name);\nconst $elemMatch = (params, owneryQuery, options, name) => new $ElemMatch(params, owneryQuery, options, name);\nconst $nin = (params, owneryQuery, options, name) => new $Nin(params, owneryQuery, options, name);\nconst $in = (params, owneryQuery, options, name) => {\n  return new $In(params, owneryQuery, options, name);\n};\nconst $lt = numericalOperation(params => b => b < params);\nconst $lte = numericalOperation(params => b => b <= params);\nconst $gt = numericalOperation(params => b => b > params);\nconst $gte = numericalOperation(params => b => b >= params);\nconst $mod = (_ref, owneryQuery, options) => {\n  let [mod, equalsValue] = _ref;\n  return new EqualsOperation(b => comparable(b) % mod === equalsValue, owneryQuery, options);\n};\nconst $exists = (params, owneryQuery, options, name) => new $Exists(params, owneryQuery, options, name);\nconst $regex = (pattern, owneryQuery, options) => new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);\nconst $not = (params, owneryQuery, options, name) => new $Not(params, owneryQuery, options, name);\nconst typeAliases = {\n  number: v => typeof v === \"number\",\n  string: v => typeof v === \"string\",\n  bool: v => typeof v === \"boolean\",\n  array: v => Array.isArray(v),\n  null: v => v === null,\n  timestamp: v => v instanceof Date\n};\nconst $type = (clazz, owneryQuery, options) => new EqualsOperation(b => {\n  if (typeof clazz === \"string\") {\n    if (!typeAliases[clazz]) {\n      throw new Error(`Type alias does not exist`);\n    }\n    return typeAliases[clazz](b);\n  }\n  return b != null ? b instanceof clazz || b.constructor === clazz : false;\n}, owneryQuery, options);\nconst $and = (params, ownerQuery, options, name) => new $And(params, ownerQuery, options, name);\nconst $all = (params, ownerQuery, options, name) => new $All(params, ownerQuery, options, name);\nconst $size = (params, ownerQuery, options) => new $Size(params, ownerQuery, options, \"$size\");\nconst $options = () => null;\nconst $where = (params, ownerQuery, options) => {\n  let test;\n  if (isFunction(params)) {\n    test = params;\n  } else if (!process.env.CSP_ENABLED) {\n    test = new Function(\"obj\", \"return \" + params);\n  } else {\n    throw new Error(`In CSP mode, sift does not support strings in \"$where\" condition`);\n  }\n  return new EqualsOperation(b => test.bind(b)(b), ownerQuery, options);\n};\nvar defaultOperations = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  $Size: $Size,\n  $eq: $eq,\n  $ne: $ne,\n  $or: $or,\n  $nor: $nor,\n  $elemMatch: $elemMatch,\n  $nin: $nin,\n  $in: $in,\n  $lt: $lt,\n  $lte: $lte,\n  $gt: $gt,\n  $gte: $gte,\n  $mod: $mod,\n  $exists: $exists,\n  $regex: $regex,\n  $not: $not,\n  $type: $type,\n  $and: $and,\n  $all: $all,\n  $size: $size,\n  $options: $options,\n  $where: $where\n});\nconst createDefaultQueryOperation = function (query, ownerQuery) {\n  let {\n    compare,\n    operations\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createQueryOperation(query, ownerQuery, {\n    compare,\n    operations: Object.assign({}, defaultOperations, operations || {})\n  });\n};\nconst createDefaultQueryTester = function (query) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const op = createDefaultQueryOperation(query, null, options);\n  return createOperationTester(op);\n};\nexport default createDefaultQueryTester;\nexport { $Size, $all, $and, $elemMatch, $eq, $exists, $gt, $gte, $in, $lt, $lte, $mod, $ne, $nin, $nor, $not, $options, $or, $regex, $size, $type, $where, EqualsOperation, createDefaultQueryOperation, createEqualsOperation, createOperationTester, createQueryOperation, createQueryTester };","map":{"version":3,"mappings":"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","names":["typeChecker","type","typeString","value","getClassName","Object","prototype","toString","call","comparable","Date","getTime","isArray","map","toJSON","isObject","isFunction","isVanillaObject","constructor","Array","equals","a","b","length","i","keys","key","walkKeyPathValues","item","keyPath","next","depth","owner","currentKey","isNaN","Number","BaseOperation","params","owneryQuery","options","name","init","reset","done","keep","GroupOperation","children","childrenNext","root","childOperation","NamedGroupOperation","QueryOperation","parent","NestedOperation","_nextNestedValue","createTester","compare","Function","RegExp","result","test","lastIndex","comparableA","EqualsOperation","_test","hasOwnProperty","createEqualsOperation","NopeOperation","numericalOperationCreator","createNumericalOperation","numericalOperation","typeofParams","createNamedOperation","parentQuery","operationCreator","operations","throwUnsupportedOperation","Error","containsOperation","query","charAt","createNestedOperation","nestedQuery","parentKey","selfOperations","nestedOperations","createQueryOperations","createQueryOperation","assign","ops","push","op","propop","split","createOperationTester","operation","createQueryTester","$Ne","$ElemMatch","_queryOperation","child","$Not","$Size","assertGroupNotEmpty","values","$Or","_ops","success","$Nor","$In","_testers","toLowerCase","$Nin","ownerQuery","_in","$Exists","$And","$All","$eq","$ne","$or","$nor","$elemMatch","$nin","$in","$lt","$lte","$gt","$gte","$mod","mod","equalsValue","$exists","$regex","pattern","$options","$not","typeAliases","number","v","string","bool","array","null","timestamp","$type","clazz","$and","$all","$size","$where","process","env","CSP_ENABLED","bind","createDefaultQueryOperation","defaultOperations","createDefaultQueryTester"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\sift\\src\\utils.ts","C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\sift\\src\\core.ts","C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\sift\\src\\operations.ts","C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\sift\\src\\index.ts"],"sourcesContent":["export type Key = string | number;\r\nexport type Comparator = (a, b) => boolean;\r\nexport const typeChecker = <TType>(type) => {\r\n  const typeString = \"[object \" + type + \"]\";\r\n  return function(value): value is TType {\r\n    return getClassName(value) === typeString;\r\n  };\r\n};\r\n\r\nconst getClassName = value => Object.prototype.toString.call(value);\r\n\r\nexport const comparable = (value: any) => {\r\n  if (value instanceof Date) {\r\n    return value.getTime();\r\n  } else if (isArray(value)) {\r\n    return value.map(comparable);\r\n  } else if (value && typeof value.toJSON === \"function\") {\r\n    return value.toJSON();\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\nexport const isArray = typeChecker<Array<any>>(\"Array\");\r\nexport const isObject = typeChecker<Object>(\"Object\");\r\nexport const isFunction = typeChecker<Function>(\"Function\");\r\nexport const isVanillaObject = value => {\r\n  return (\r\n    value &&\r\n    (value.constructor === Object ||\r\n      value.constructor === Array ||\r\n      value.constructor.toString() === \"function Object() { [native code] }\" ||\r\n      value.constructor.toString() === \"function Array() { [native code] }\") &&\r\n    !value.toJSON\r\n  );\r\n};\r\n\r\nexport const equals = (a, b) => {\r\n  if (a == null && a == b) {\r\n    return true;\r\n  }\r\n  if (a === b) {\r\n    return true;\r\n  }\r\n\r\n  if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\r\n    return false;\r\n  }\r\n\r\n  if (isArray(a)) {\r\n    if (a.length !== b.length) {\r\n      return false;\r\n    }\r\n    for (let i = 0, { length } = a; i < length; i++) {\r\n      if (!equals(a[i], b[i])) return false;\r\n    }\r\n    return true;\r\n  } else if (isObject(a)) {\r\n    if (Object.keys(a).length !== Object.keys(b).length) {\r\n      return false;\r\n    }\r\n    for (const key in a) {\r\n      if (!equals(a[key], b[key])) return false;\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n","import {\r\n  isArray,\r\n  Key,\r\n  Comparator,\r\n  isVanillaObject,\r\n  comparable,\r\n  equals\r\n} from \"./utils\";\r\n\r\nexport interface Operation<TItem> {\r\n  readonly keep: boolean;\r\n  readonly done: boolean;\r\n  propop: boolean;\r\n  reset();\r\n  next(item: TItem, key?: Key, owner?: any, root?: boolean);\r\n}\r\n\r\nexport type Tester = (\r\n  item: any,\r\n  key?: Key,\r\n  owner?: any,\r\n  root?: boolean\r\n) => boolean;\r\n\r\nexport interface NamedOperation {\r\n  name: string;\r\n}\r\n\r\nexport type OperationCreator<TItem> = (\r\n  params: any,\r\n  parentQuery: any,\r\n  options: Options,\r\n  name: string\r\n) => Operation<TItem>;\r\n\r\nexport type BasicValueQuery<TValue> = {\r\n  $eq?: TValue;\r\n  $ne?: TValue;\r\n  $lt?: TValue;\r\n  $gt?: TValue;\r\n  $lte?: TValue;\r\n  $gte?: TValue;\r\n  $in?: TValue[];\r\n  $nin?: TValue[];\r\n  $all?: TValue[];\r\n  $mod?: [number, number];\r\n  $exists?: boolean;\r\n  $regex?: string | RegExp;\r\n  $size?: number;\r\n  $where?: ((this: TValue, obj: TValue) => boolean) | string;\r\n  $options?: \"i\" | \"g\" | \"m\" | \"u\";\r\n  $type?: Function;\r\n  $not?: NestedQuery<TValue>;\r\n  $or?: NestedQuery<TValue>[];\r\n  $nor?: NestedQuery<TValue>[];\r\n  $and?: NestedQuery<TValue>[];\r\n};\r\n\r\nexport type ArrayValueQuery<TValue> = {\r\n  $elemMatch?: Query<TValue>;\r\n} & BasicValueQuery<TValue>;\r\ntype Unpacked<T> = T extends (infer U)[] ? U : T;\r\n\r\nexport type ValueQuery<TValue> = TValue extends Array<any>\r\n  ? ArrayValueQuery<Unpacked<TValue>>\r\n  : BasicValueQuery<TValue>;\r\n\r\ntype NotObject = string | number | Date | boolean | Array<any>;\r\nexport type ShapeQuery<TItemSchema> = TItemSchema extends NotObject\r\n  ? {}\r\n  : { [k in keyof TItemSchema]?: TItemSchema[k] | ValueQuery<TItemSchema[k]> };\r\n\r\nexport type NestedQuery<TItemSchema> = ValueQuery<TItemSchema> &\r\n  ShapeQuery<TItemSchema>;\r\nexport type Query<TItemSchema> =\r\n  | TItemSchema\r\n  | RegExp\r\n  | NestedQuery<TItemSchema>;\r\n\r\nexport type QueryOperators<TValue = any> = keyof ValueQuery<TValue>;\r\n\r\n/**\r\n * Walks through each value given the context - used for nested operations. E.g:\r\n * { \"person.address\": { $eq: \"blarg\" }}\r\n */\r\n\r\nconst walkKeyPathValues = (\r\n  item: any,\r\n  keyPath: Key[],\r\n  next: Tester,\r\n  depth: number,\r\n  key: Key,\r\n  owner: any\r\n) => {\r\n  const currentKey = keyPath[depth];\r\n\r\n  // if array, then try matching. Might fall through for cases like:\r\n  // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\r\n  if (isArray(item) && isNaN(Number(currentKey))) {\r\n    for (let i = 0, { length } = item; i < length; i++) {\r\n      // if FALSE is returned, then terminate walker. For operations, this simply\r\n      // means that the search critera was met.\r\n      if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (depth === keyPath.length || item == null) {\r\n    return next(item, key, owner, depth === 0);\r\n  }\r\n\r\n  return walkKeyPathValues(\r\n    item[currentKey],\r\n    keyPath,\r\n    next,\r\n    depth + 1,\r\n    currentKey,\r\n    item\r\n  );\r\n};\r\n\r\nexport abstract class BaseOperation<TParams, TItem = any>\r\n  implements Operation<TItem> {\r\n  keep: boolean;\r\n  done: boolean;\r\n  abstract propop: boolean;\r\n  constructor(\r\n    readonly params: TParams,\r\n    readonly owneryQuery: any,\r\n    readonly options: Options,\r\n    readonly name?: string\r\n  ) {\r\n    this.init();\r\n  }\r\n  protected init() {}\r\n  reset() {\r\n    this.done = false;\r\n    this.keep = false;\r\n  }\r\n  abstract next(item: any, key: Key, parent: any, root: boolean);\r\n}\r\n\r\nabstract class GroupOperation extends BaseOperation<any> {\r\n  keep: boolean;\r\n  done: boolean;\r\n\r\n  constructor(\r\n    params: any,\r\n    owneryQuery: any,\r\n    options: Options,\r\n    public readonly children: Operation<any>[]\r\n  ) {\r\n    super(params, owneryQuery, options);\r\n  }\r\n\r\n  /**\r\n   */\r\n\r\n  reset() {\r\n    this.keep = false;\r\n    this.done = false;\r\n    for (let i = 0, { length } = this.children; i < length; i++) {\r\n      this.children[i].reset();\r\n    }\r\n  }\r\n\r\n  abstract next(item: any, key: Key, owner: any, root: boolean);\r\n\r\n  /**\r\n   */\r\n\r\n  protected childrenNext(item: any, key: Key, owner: any, root: boolean) {\r\n    let done = true;\r\n    let keep = true;\r\n    for (let i = 0, { length } = this.children; i < length; i++) {\r\n      const childOperation = this.children[i];\r\n      if (!childOperation.done) {\r\n        childOperation.next(item, key, owner, root);\r\n      }\r\n      if (!childOperation.keep) {\r\n        keep = false;\r\n      }\r\n      if (childOperation.done) {\r\n        if (!childOperation.keep) {\r\n          break;\r\n        }\r\n      } else {\r\n        done = false;\r\n      }\r\n    }\r\n    this.done = done;\r\n    this.keep = keep;\r\n  }\r\n}\r\n\r\nexport abstract class NamedGroupOperation extends GroupOperation\r\n  implements NamedOperation {\r\n  abstract propop: boolean;\r\n  constructor(\r\n    params: any,\r\n    owneryQuery: any,\r\n    options: Options,\r\n    children: Operation<any>[],\r\n    readonly name: string\r\n  ) {\r\n    super(params, owneryQuery, options, children);\r\n  }\r\n}\r\n\r\nexport class QueryOperation<TItem> extends GroupOperation {\r\n  readonly propop = true;\r\n  /**\r\n   */\r\n\r\n  next(item: TItem, key: Key, parent: any, root: boolean) {\r\n    this.childrenNext(item, key, parent, root);\r\n  }\r\n}\r\n\r\nexport class NestedOperation extends GroupOperation {\r\n  readonly propop = true;\r\n  constructor(\r\n    readonly keyPath: Key[],\r\n    params: any,\r\n    owneryQuery: any,\r\n    options: Options,\r\n    children: Operation<any>[]\r\n  ) {\r\n    super(params, owneryQuery, options, children);\r\n  }\r\n  /**\r\n   */\r\n\r\n  next(item: any, key: Key, parent: any) {\r\n    walkKeyPathValues(\r\n      item,\r\n      this.keyPath,\r\n      this._nextNestedValue,\r\n      0,\r\n      key,\r\n      parent\r\n    );\r\n  }\r\n\r\n  /**\r\n   */\r\n\r\n  private _nextNestedValue = (\r\n    value: any,\r\n    key: Key,\r\n    owner: any,\r\n    root: boolean\r\n  ) => {\r\n    this.childrenNext(value, key, owner, root);\r\n    return !this.done;\r\n  };\r\n}\r\n\r\nexport const createTester = (a, compare: Comparator) => {\r\n  if (a instanceof Function) {\r\n    return a;\r\n  }\r\n  if (a instanceof RegExp) {\r\n    return b => {\r\n      const result = typeof b === \"string\" && a.test(b);\r\n      a.lastIndex = 0;\r\n      return result;\r\n    };\r\n  }\r\n  const comparableA = comparable(a);\r\n  return b => compare(comparableA, comparable(b));\r\n};\r\n\r\nexport class EqualsOperation<TParam> extends BaseOperation<TParam> {\r\n  readonly propop = true;\r\n  private _test: Tester;\r\n  init() {\r\n    this._test = createTester(this.params, this.options.compare);\r\n  }\r\n  next(item, key: Key, parent: any) {\r\n    if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\r\n      if (this._test(item, key, parent)) {\r\n        this.done = true;\r\n        this.keep = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const createEqualsOperation = (\r\n  params: any,\r\n  owneryQuery: any,\r\n  options: Options\r\n) => new EqualsOperation(params, owneryQuery, options);\r\n\r\nexport class NopeOperation<TParam> extends BaseOperation<TParam> {\r\n  readonly propop = true;\r\n  next() {\r\n    this.done = true;\r\n    this.keep = false;\r\n  }\r\n}\r\n\r\nexport const numericalOperationCreator = (\r\n  createNumericalOperation: OperationCreator<any>\r\n) => (params: any, owneryQuery: any, options: Options, name: string) => {\r\n  if (params == null) {\r\n    return new NopeOperation(params, owneryQuery, options, name);\r\n  }\r\n\r\n  return createNumericalOperation(params, owneryQuery, options, name);\r\n};\r\n\r\nexport const numericalOperation = (createTester: (any) => Tester) =>\r\n  numericalOperationCreator(\r\n    (params: any, owneryQuery: Query<any>, options: Options, name: string) => {\r\n      const typeofParams = typeof comparable(params);\r\n      const test = createTester(params);\r\n      return new EqualsOperation(\r\n        b => {\r\n          return typeof comparable(b) === typeofParams && test(b);\r\n        },\r\n        owneryQuery,\r\n        options,\r\n        name\r\n      );\r\n    }\r\n  );\r\n\r\nexport type Options = {\r\n  operations: {\r\n    [identifier: string]: OperationCreator<any>;\r\n  };\r\n  compare: (a, b) => boolean;\r\n};\r\n\r\nconst createNamedOperation = (\r\n  name: string,\r\n  params: any,\r\n  parentQuery: any,\r\n  options: Options\r\n) => {\r\n  const operationCreator = options.operations[name];\r\n  if (!operationCreator) {\r\n    throwUnsupportedOperation(name);\r\n  }\r\n  return operationCreator(params, parentQuery, options, name);\r\n};\r\n\r\nconst throwUnsupportedOperation = (name: string) => {\r\n  throw new Error(`Unsupported operation: ${name}`);\r\n};\r\n\r\nexport const containsOperation = (query: any, options: Options) => {\r\n  for (const key in query) {\r\n    if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\")\r\n      return true;\r\n  }\r\n  return false;\r\n};\r\nconst createNestedOperation = (\r\n  keyPath: Key[],\r\n  nestedQuery: any,\r\n  parentKey: string,\r\n  owneryQuery: any,\r\n  options: Options\r\n) => {\r\n  if (containsOperation(nestedQuery, options)) {\r\n    const [selfOperations, nestedOperations] = createQueryOperations(\r\n      nestedQuery,\r\n      parentKey,\r\n      options\r\n    );\r\n    if (nestedOperations.length) {\r\n      throw new Error(\r\n        `Property queries must contain only operations, or exact objects.`\r\n      );\r\n    }\r\n    return new NestedOperation(\r\n      keyPath,\r\n      nestedQuery,\r\n      owneryQuery,\r\n      options,\r\n      selfOperations\r\n    );\r\n  }\r\n  return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [\r\n    new EqualsOperation(nestedQuery, owneryQuery, options)\r\n  ]);\r\n};\r\n\r\nexport const createQueryOperation = <TItem, TSchema = TItem>(\r\n  query: Query<TSchema>,\r\n  owneryQuery: any = null,\r\n  { compare, operations }: Partial<Options> = {}\r\n): QueryOperation<TItem> => {\r\n  const options = {\r\n    compare: compare || equals,\r\n    operations: Object.assign({}, operations || {})\r\n  };\r\n\r\n  const [selfOperations, nestedOperations] = createQueryOperations(\r\n    query,\r\n    null,\r\n    options\r\n  );\r\n\r\n  const ops = [];\r\n\r\n  if (selfOperations.length) {\r\n    ops.push(\r\n      new NestedOperation([], query, owneryQuery, options, selfOperations)\r\n    );\r\n  }\r\n\r\n  ops.push(...nestedOperations);\r\n\r\n  if (ops.length === 1) {\r\n    return ops[0];\r\n  }\r\n  return new QueryOperation(query, owneryQuery, options, ops);\r\n};\r\n\r\nconst createQueryOperations = (\r\n  query: any,\r\n  parentKey: string,\r\n  options: Options\r\n) => {\r\n  const selfOperations = [];\r\n  const nestedOperations = [];\r\n  if (!isVanillaObject(query)) {\r\n    selfOperations.push(new EqualsOperation(query, query, options));\r\n    return [selfOperations, nestedOperations];\r\n  }\r\n  for (const key in query) {\r\n    if (options.operations.hasOwnProperty(key)) {\r\n      const op = createNamedOperation(key, query[key], query, options);\r\n\r\n      if (op) {\r\n        if (!op.propop && parentKey && !options.operations[parentKey]) {\r\n          throw new Error(\r\n            `Malformed query. ${key} cannot be matched against property.`\r\n          );\r\n        }\r\n      }\r\n\r\n      // probably just a flag for another operation (like $options)\r\n      if (op != null) {\r\n        selfOperations.push(op);\r\n      }\r\n    } else if (key.charAt(0) === \"$\") {\r\n      throwUnsupportedOperation(key);\r\n    } else {\r\n      nestedOperations.push(\r\n        createNestedOperation(key.split(\".\"), query[key], key, query, options)\r\n      );\r\n    }\r\n  }\r\n\r\n  return [selfOperations, nestedOperations];\r\n};\r\n\r\nexport const createOperationTester = <TItem>(operation: Operation<TItem>) => (\r\n  item: TItem,\r\n  key?: Key,\r\n  owner?: any\r\n) => {\r\n  operation.reset();\r\n  operation.next(item, key, owner);\r\n  return operation.keep;\r\n};\r\n\r\nexport const createQueryTester = <TItem, TSchema = TItem>(\r\n  query: Query<TSchema>,\r\n  options: Partial<Options> = {}\r\n) => {\r\n  return createOperationTester(\r\n    createQueryOperation<TItem, TSchema>(query, null, options)\r\n  );\r\n};\r\n","import {\r\n  BaseOperation,\r\n  EqualsOperation,\r\n  Options,\r\n  createTester,\r\n  Tester,\r\n  createQueryOperation,\r\n  QueryOperation,\r\n  Operation,\r\n  Query,\r\n  NamedGroupOperation,\r\n  numericalOperation,\r\n  containsOperation,\r\n  NamedOperation\r\n} from \"./core\";\r\nimport { Key, comparable, isFunction, isArray } from \"./utils\";\r\n\r\nclass $Ne extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  private _test: Tester;\r\n  init() {\r\n    this._test = createTester(this.params, this.options.compare);\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this.keep = true;\r\n  }\r\n  next(item: any) {\r\n    if (this._test(item)) {\r\n      this.done = true;\r\n      this.keep = false;\r\n    }\r\n  }\r\n}\r\n// https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\r\nclass $ElemMatch extends BaseOperation<Query<any>> {\r\n  readonly propop = true;\r\n  private _queryOperation: QueryOperation<any>;\r\n  init() {\r\n    if (!this.params || typeof this.params !== \"object\") {\r\n      throw new Error(`Malformed query. $elemMatch must by an object.`);\r\n    }\r\n    this._queryOperation = createQueryOperation(\r\n      this.params,\r\n      this.owneryQuery,\r\n      this.options\r\n    );\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this._queryOperation.reset();\r\n  }\r\n  next(item: any) {\r\n    if (isArray(item)) {\r\n      for (let i = 0, { length } = item; i < length; i++) {\r\n        // reset query operation since item being tested needs to pass _all_ query\r\n        // operations for it to be a success\r\n        this._queryOperation.reset();\r\n\r\n        const child = item[i];\r\n        this._queryOperation.next(child, i, item, false);\r\n        this.keep = this.keep || this._queryOperation.keep;\r\n      }\r\n      this.done = true;\r\n    } else {\r\n      this.done = false;\r\n      this.keep = false;\r\n    }\r\n  }\r\n}\r\n\r\nclass $Not extends BaseOperation<Query<any>> {\r\n  readonly propop = true;\r\n  private _queryOperation: QueryOperation<any>;\r\n  init() {\r\n    this._queryOperation = createQueryOperation(\r\n      this.params,\r\n      this.owneryQuery,\r\n      this.options\r\n    );\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this._queryOperation.reset();\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this._queryOperation.next(item, key, owner, root);\r\n    this.done = this._queryOperation.done;\r\n    this.keep = !this._queryOperation.keep;\r\n  }\r\n}\r\n\r\nexport class $Size extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  init() {}\r\n  next(item) {\r\n    if (isArray(item) && item.length === this.params) {\r\n      this.done = true;\r\n      this.keep = true;\r\n    }\r\n    // if (parent && parent.length === this.params) {\r\n    //   this.done = true;\r\n    //   this.keep = true;\r\n    // }\r\n  }\r\n}\r\n\r\nconst assertGroupNotEmpty = (values: any[]) => {\r\n  if (values.length === 0) {\r\n    throw new Error(`$and/$or/$nor must be a nonempty array`);\r\n  }\r\n};\r\n\r\nclass $Or extends BaseOperation<any> {\r\n  readonly propop = false;\r\n  private _ops: Operation<any>[];\r\n  init() {\r\n    assertGroupNotEmpty(this.params);\r\n    this._ops = this.params.map(op =>\r\n      createQueryOperation(op, null, this.options)\r\n    );\r\n  }\r\n  reset() {\r\n    this.done = false;\r\n    this.keep = false;\r\n    for (let i = 0, { length } = this._ops; i < length; i++) {\r\n      this._ops[i].reset();\r\n    }\r\n  }\r\n  next(item: any, key: Key, owner: any) {\r\n    let done = false;\r\n    let success = false;\r\n    for (let i = 0, { length } = this._ops; i < length; i++) {\r\n      const op = this._ops[i];\r\n      op.next(item, key, owner);\r\n      if (op.keep) {\r\n        done = true;\r\n        success = op.keep;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.keep = success;\r\n    this.done = done;\r\n  }\r\n}\r\n\r\nclass $Nor extends $Or {\r\n  readonly propop = false;\r\n  next(item: any, key: Key, owner: any) {\r\n    super.next(item, key, owner);\r\n    this.keep = !this.keep;\r\n  }\r\n}\r\n\r\nclass $In extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  private _testers: Tester[];\r\n  init() {\r\n    this._testers = this.params.map(value => {\r\n      if (containsOperation(value, this.options)) {\r\n        throw new Error(`cannot nest $ under ${this.name.toLowerCase()}`);\r\n      }\r\n      return createTester(value, this.options.compare);\r\n    });\r\n  }\r\n  next(item: any, key: Key, owner: any) {\r\n    let done = false;\r\n    let success = false;\r\n    for (let i = 0, { length } = this._testers; i < length; i++) {\r\n      const test = this._testers[i];\r\n      if (test(item)) {\r\n        done = true;\r\n        success = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.keep = success;\r\n    this.done = done;\r\n  }\r\n}\r\n\r\nclass $Nin extends BaseOperation<any> {\r\n  readonly propop = true;\r\n  private _in: $In;\r\n  constructor(params: any, ownerQuery: any, options: Options, name: string) {\r\n    super(params, ownerQuery, options, name);\r\n    this._in = new $In(params, ownerQuery, options, name);\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this._in.next(item, key, owner);\r\n\r\n    if (isArray(owner) && !root) {\r\n      if (this._in.keep) {\r\n        this.keep = false;\r\n        this.done = true;\r\n      } else if (key == owner.length - 1) {\r\n        this.keep = true;\r\n        this.done = true;\r\n      }\r\n    } else {\r\n      this.keep = !this._in.keep;\r\n      this.done = true;\r\n    }\r\n  }\r\n  reset() {\r\n    super.reset();\r\n    this._in.reset();\r\n  }\r\n}\r\n\r\nclass $Exists extends BaseOperation<boolean> {\r\n  readonly propop = true;\r\n  next(item: any, key: Key, owner: any) {\r\n    if (owner.hasOwnProperty(key) === this.params) {\r\n      this.done = true;\r\n      this.keep = true;\r\n    }\r\n  }\r\n}\r\n\r\nclass $And extends NamedGroupOperation {\r\n  readonly propop = false;\r\n  constructor(\r\n    params: Query<any>[],\r\n    owneryQuery: Query<any>,\r\n    options: Options,\r\n    name: string\r\n  ) {\r\n    super(\r\n      params,\r\n      owneryQuery,\r\n      options,\r\n      params.map(query => createQueryOperation(query, owneryQuery, options)),\r\n      name\r\n    );\r\n\r\n    assertGroupNotEmpty(params);\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this.childrenNext(item, key, owner, root);\r\n  }\r\n}\r\n\r\nclass $All extends NamedGroupOperation {\r\n  readonly propop = true;\r\n  constructor(\r\n    params: Query<any>[],\r\n    owneryQuery: Query<any>,\r\n    options: Options,\r\n    name: string\r\n  ) {\r\n    super(\r\n      params,\r\n      owneryQuery,\r\n      options,\r\n      params.map(query => createQueryOperation(query, owneryQuery, options)),\r\n      name\r\n    );\r\n  }\r\n  next(item: any, key: Key, owner: any, root: boolean) {\r\n    this.childrenNext(item, key, owner, root);\r\n  }\r\n}\r\n\r\nexport const $eq = (params: any, owneryQuery: Query<any>, options: Options) =>\r\n  new EqualsOperation(params, owneryQuery, options);\r\nexport const $ne = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Ne(params, owneryQuery, options, name);\r\nexport const $or = (\r\n  params: Query<any>[],\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Or(params, owneryQuery, options, name);\r\nexport const $nor = (\r\n  params: Query<any>[],\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Nor(params, owneryQuery, options, name);\r\nexport const $elemMatch = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $ElemMatch(params, owneryQuery, options, name);\r\nexport const $nin = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Nin(params, owneryQuery, options, name);\r\nexport const $in = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => {\r\n  return new $In(params, owneryQuery, options, name);\r\n};\r\n\r\nexport const $lt = numericalOperation(params => b => b < params);\r\nexport const $lte = numericalOperation(params => b => b <= params);\r\nexport const $gt = numericalOperation(params => b => b > params);\r\nexport const $gte = numericalOperation(params => b => b >= params);\r\nexport const $mod = (\r\n  [mod, equalsValue]: number[],\r\n  owneryQuery: Query<any>,\r\n  options: Options\r\n) =>\r\n  new EqualsOperation(\r\n    b => comparable(b) % mod === equalsValue,\r\n    owneryQuery,\r\n    options\r\n  );\r\nexport const $exists = (\r\n  params: boolean,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Exists(params, owneryQuery, options, name);\r\nexport const $regex = (\r\n  pattern: string,\r\n  owneryQuery: Query<any>,\r\n  options: Options\r\n) =>\r\n  new EqualsOperation(\r\n    new RegExp(pattern, owneryQuery.$options),\r\n    owneryQuery,\r\n    options\r\n  );\r\nexport const $not = (\r\n  params: any,\r\n  owneryQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $Not(params, owneryQuery, options, name);\r\n\r\nconst typeAliases = {\r\n  number: v => typeof v === \"number\",\r\n  string: v => typeof v === \"string\",\r\n  bool: v => typeof v === \"boolean\",\r\n  array: v => Array.isArray(v),\r\n  null: v => v === null,\r\n  timestamp: v => v instanceof Date\r\n};\r\n\r\nexport const $type = (\r\n  clazz: Function | string,\r\n  owneryQuery: Query<any>,\r\n  options: Options\r\n) =>\r\n  new EqualsOperation(\r\n    b => {\r\n      if (typeof clazz === \"string\") {\r\n        if (!typeAliases[clazz]) {\r\n          throw new Error(`Type alias does not exist`);\r\n        }\r\n\r\n        return typeAliases[clazz](b);\r\n      }\r\n\r\n      return b != null ? b instanceof clazz || b.constructor === clazz : false;\r\n    },\r\n    owneryQuery,\r\n    options\r\n  );\r\nexport const $and = (\r\n  params: Query<any>[],\r\n  ownerQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $And(params, ownerQuery, options, name);\r\n\r\nexport const $all = (\r\n  params: Query<any>[],\r\n  ownerQuery: Query<any>,\r\n  options: Options,\r\n  name: string\r\n) => new $All(params, ownerQuery, options, name);\r\nexport const $size = (\r\n  params: number,\r\n  ownerQuery: Query<any>,\r\n  options: Options\r\n) => new $Size(params, ownerQuery, options, \"$size\");\r\nexport const $options = () => null;\r\nexport const $where = (\r\n  params: string | Function,\r\n  ownerQuery: Query<any>,\r\n  options: Options\r\n) => {\r\n  let test;\r\n\r\n  if (isFunction(params)) {\r\n    test = params;\r\n  } else if (!process.env.CSP_ENABLED) {\r\n    test = new Function(\"obj\", \"return \" + params);\r\n  } else {\r\n    throw new Error(\r\n      `In CSP mode, sift does not support strings in \"$where\" condition`\r\n    );\r\n  }\r\n\r\n  return new EqualsOperation(b => test.bind(b)(b), ownerQuery, options);\r\n};\r\n","import * as defaultOperations from \"./operations\";\r\nimport {\r\n  Query,\r\n  QueryOperators,\r\n  BasicValueQuery,\r\n  ArrayValueQuery,\r\n  ValueQuery,\r\n  NestedQuery,\r\n  ShapeQuery,\r\n  Options,\r\n  createQueryTester,\r\n  EqualsOperation,\r\n  createQueryOperation,\r\n  createEqualsOperation,\r\n  createOperationTester\r\n} from \"./core\";\r\n\r\nconst createDefaultQueryOperation = <TItem, TSchema extends TItem = TItem>(\r\n  query: Query<TSchema>,\r\n  ownerQuery: any,\r\n  { compare, operations }: Partial<Options> = {}\r\n) => {\r\n  return createQueryOperation(query, ownerQuery, {\r\n    compare,\r\n    operations: Object.assign({}, defaultOperations, operations || {})\r\n  });\r\n};\r\n\r\nconst createDefaultQueryTester = <TItem, TSchema extends TItem = TItem>(\r\n  query: Query<TSchema>,\r\n  options: Partial<Options> = {}\r\n) => {\r\n  const op = createDefaultQueryOperation(query, null, options);\r\n  return createOperationTester(op);\r\n};\r\n\r\nexport {\r\n  Query,\r\n  QueryOperators,\r\n  BasicValueQuery,\r\n  ArrayValueQuery,\r\n  ValueQuery,\r\n  NestedQuery,\r\n  ShapeQuery,\r\n  EqualsOperation,\r\n  createQueryTester,\r\n  createOperationTester,\r\n  createDefaultQueryOperation,\r\n  createEqualsOperation,\r\n  createQueryOperation\r\n};\r\nexport * from \"./operations\";\r\n\r\nexport default createDefaultQueryTester;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}