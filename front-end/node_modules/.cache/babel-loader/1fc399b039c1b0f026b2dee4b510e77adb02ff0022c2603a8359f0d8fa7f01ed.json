{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserialize = void 0;\nvar buffer_1 = require(\"buffer\");\nvar binary_1 = require(\"../binary\");\nvar code_1 = require(\"../code\");\nvar constants = require(\"../constants\");\nvar db_ref_1 = require(\"../db_ref\");\nvar decimal128_1 = require(\"../decimal128\");\nvar double_1 = require(\"../double\");\nvar error_1 = require(\"../error\");\nvar int_32_1 = require(\"../int_32\");\nvar long_1 = require(\"../long\");\nvar max_key_1 = require(\"../max_key\");\nvar min_key_1 = require(\"../min_key\");\nvar objectid_1 = require(\"../objectid\");\nvar regexp_1 = require(\"../regexp\");\nvar symbol_1 = require(\"../symbol\");\nvar timestamp_1 = require(\"../timestamp\");\nvar validate_utf8_1 = require(\"../validate_utf8\");\n// Internal long versions\nvar JS_INT_MAX_LONG = long_1.Long.fromNumber(constants.JS_INT_MAX);\nvar JS_INT_MIN_LONG = long_1.Long.fromNumber(constants.JS_INT_MIN);\nvar functionCache = {};\nfunction deserialize(buffer, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0;\n  // Read the document size\n  var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n  if (size < 5) {\n    throw new error_1.BSONError(\"bson size must be >= 5, is \".concat(size));\n  }\n  if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n    throw new error_1.BSONError(\"buffer length \".concat(buffer.length, \" must be >= bson size \").concat(size));\n  }\n  if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n    throw new error_1.BSONError(\"buffer length \".concat(buffer.length, \" must === bson size \").concat(size));\n  }\n  if (size + index > buffer.byteLength) {\n    throw new error_1.BSONError(\"(bson size \".concat(size, \" + options.index \").concat(index, \" must be <= buffer length \").concat(buffer.byteLength, \")\"));\n  }\n  // Illegal end value\n  if (buffer[index + size - 1] !== 0) {\n    throw new error_1.BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  }\n  // Start deserializtion\n  return deserializeObject(buffer, index, options, isArray);\n}\nexports.deserialize = deserialize;\nvar allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray) {\n  if (isArray === void 0) {\n    isArray = false;\n  }\n  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\n  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n  // Return raw bson buffer instead of parsing it\n  var raw = options['raw'] == null ? false : options['raw'];\n  // Return BSONRegExp objects instead of native regular expressions\n  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n  // Controls the promotion of values vs wrapper classes\n  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\n  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\n  var promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];\n  // Ensures default validation option if none given\n  var validation = options.validation == null ? {\n    utf8: true\n  } : options.validation;\n  // Shows if global utf-8 validation is enabled or disabled\n  var globalUTFValidation = true;\n  // Reflects utf-8 validation setting regardless of global or specific key validation\n  var validationSetting;\n  // Set of keys either to enable or disable validation on\n  var utf8KeysSet = new Set();\n  // Check for boolean uniformity and empty validation option\n  var utf8ValidatedKeys = validation.utf8;\n  if (typeof utf8ValidatedKeys === 'boolean') {\n    validationSetting = utf8ValidatedKeys;\n  } else {\n    globalUTFValidation = false;\n    var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n      return utf8ValidatedKeys[key];\n    });\n    if (utf8ValidationValues.length === 0) {\n      throw new error_1.BSONError('UTF-8 validation setting cannot be empty');\n    }\n    if (typeof utf8ValidationValues[0] !== 'boolean') {\n      throw new error_1.BSONError('Invalid UTF-8 validation option, must specify boolean values');\n    }\n    validationSetting = utf8ValidationValues[0];\n    // Ensures boolean uniformity in utf-8 validation (all true or all false)\n    if (!utf8ValidationValues.every(function (item) {\n      return item === validationSetting;\n    })) {\n      throw new error_1.BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n    }\n  }\n  // Add keys to set that will either be validated or not based on validationSetting\n  if (!globalUTFValidation) {\n    for (var _i = 0, _a = Object.keys(utf8ValidatedKeys); _i < _a.length; _i++) {\n      var key = _a[_i];\n      utf8KeysSet.add(key);\n    }\n  }\n  // Set the start index\n  var startIndex = index;\n  // Validate that we have at least 4 bytes of buffer\n  if (buffer.length < 5) throw new error_1.BSONError('corrupt bson message < 5 bytes long');\n  // Read the document size\n  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n  // Ensure buffer is valid size\n  if (size < 5 || size > buffer.length) throw new error_1.BSONError('corrupt bson message');\n  // Create holding object\n  var object = isArray ? [] : {};\n  // Used for arrays to skip having to perform utf8 decoding\n  var arrayIndex = 0;\n  var done = false;\n  var isPossibleDBRef = isArray ? false : null;\n  // While we have more left data left keep parsing\n  var dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  while (!done) {\n    // Read the type\n    var elementType = buffer[index++];\n    // If we get a zero it's the last byte, exit\n    if (elementType === 0) break;\n    // Get the start search index\n    var i = index;\n    // Locate the end of the c string\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    }\n    // If are at the end of the buffer there is a problem with the document\n    if (i >= buffer.byteLength) throw new error_1.BSONError('Bad BSON Document: illegal CString');\n    // Represents the key\n    var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\n    // shouldValidateKey is true if the key should be validated, false otherwise\n    var shouldValidateKey = true;\n    if (globalUTFValidation || utf8KeysSet.has(name)) {\n      shouldValidateKey = validationSetting;\n    } else {\n      shouldValidateKey = !validationSetting;\n    }\n    if (isPossibleDBRef !== false && name[0] === '$') {\n      isPossibleDBRef = allowedDBRefKeys.test(name);\n    }\n    var value = void 0;\n    index = i + 1;\n    if (elementType === constants.BSON_DATA_STRING) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new error_1.BSONError('bad string length in bson');\n      }\n      value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n    } else if (elementType === constants.BSON_DATA_OID) {\n      var oid = buffer_1.Buffer.alloc(12);\n      buffer.copy(oid, 0, index, index + 12);\n      value = new objectid_1.ObjectId(oid);\n      index = index + 12;\n    } else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {\n      value = new int_32_1.Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n    } else if (elementType === constants.BSON_DATA_INT) {\n      value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    } else if (elementType === constants.BSON_DATA_NUMBER && promoteValues === false) {\n      value = new double_1.Double(dataview.getFloat64(index, true));\n      index = index + 8;\n    } else if (elementType === constants.BSON_DATA_NUMBER) {\n      value = dataview.getFloat64(index, true);\n      index = index + 8;\n    } else if (elementType === constants.BSON_DATA_DATE) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      value = new Date(new long_1.Long(lowBits, highBits).toNumber());\n    } else if (elementType === constants.BSON_DATA_BOOLEAN) {\n      if (buffer[index] !== 0 && buffer[index] !== 1) throw new error_1.BSONError('illegal boolean type value');\n      value = buffer[index++] === 1;\n    } else if (elementType === constants.BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer.length - index) throw new error_1.BSONError('bad embedded document length in bson');\n      // We have a raw value\n      if (raw) {\n        value = buffer.slice(index, index + objectSize);\n      } else {\n        var objectOptions = options;\n        if (!globalUTFValidation) {\n          objectOptions = __assign(__assign({}, options), {\n            validation: {\n              utf8: shouldValidateKey\n            }\n          });\n        }\n        value = deserializeObject(buffer, _index, objectOptions, false);\n      }\n      index = index + objectSize;\n    } else if (elementType === constants.BSON_DATA_ARRAY) {\n      var _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      var arrayOptions = options;\n      // Stop index\n      var stopIndex = index + objectSize;\n      // All elements of array to be returned as raw bson\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n        for (var n in options) {\n          arrayOptions[n] = options[n];\n        }\n        arrayOptions['raw'] = true;\n      }\n      if (!globalUTFValidation) {\n        arrayOptions = __assign(__assign({}, arrayOptions), {\n          validation: {\n            utf8: shouldValidateKey\n          }\n        });\n      }\n      value = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer[index - 1] !== 0) throw new error_1.BSONError('invalid array terminator byte');\n      if (index !== stopIndex) throw new error_1.BSONError('corrupted array bson');\n    } else if (elementType === constants.BSON_DATA_UNDEFINED) {\n      value = undefined;\n    } else if (elementType === constants.BSON_DATA_NULL) {\n      value = null;\n    } else if (elementType === constants.BSON_DATA_LONG) {\n      // Unpack the low and high bits\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var long = new long_1.Long(lowBits, highBits);\n      // Promote the long if possible\n      if (promoteLongs && promoteValues === true) {\n        value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        value = long;\n      }\n    } else if (elementType === constants.BSON_DATA_DECIMAL128) {\n      // Buffer to contain the decimal bytes\n      var bytes = buffer_1.Buffer.alloc(16);\n      // Copy the next 16 bytes into the bytes buffer\n      buffer.copy(bytes, 0, index, index + 16);\n      // Update index\n      index = index + 16;\n      // Assign the new Decimal128 value\n      var decimal128 = new decimal128_1.Decimal128(bytes);\n      // If we have an alternative mapper use that\n      if ('toObject' in decimal128 && typeof decimal128.toObject === 'function') {\n        value = decimal128.toObject();\n      } else {\n        value = decimal128;\n      }\n    } else if (elementType === constants.BSON_DATA_BINARY) {\n      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var totalBinarySize = binarySize;\n      var subType = buffer[index++];\n      // Did we have a negative binary size, throw\n      if (binarySize < 0) throw new error_1.BSONError('Negative binary type element size found');\n      // Is the length longer than the document\n      if (binarySize > buffer.byteLength) throw new error_1.BSONError('Binary type size larger than document size');\n      // Decode as raw Buffer object if options specifies it\n      if (buffer['slice'] != null) {\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new error_1.BSONError('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new error_1.BSONError('Binary type with subtype 0x02 contains too long binary size');\n          if (binarySize < totalBinarySize - 4) throw new error_1.BSONError('Binary type with subtype 0x02 contains too short binary size');\n        }\n        if (promoteBuffers && promoteValues) {\n          value = buffer.slice(index, index + binarySize);\n        } else {\n          value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType);\n          if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW) {\n            value = value.toUUID();\n          }\n        }\n      } else {\n        var _buffer = buffer_1.Buffer.alloc(binarySize);\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new error_1.BSONError('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new error_1.BSONError('Binary type with subtype 0x02 contains too long binary size');\n          if (binarySize < totalBinarySize - 4) throw new error_1.BSONError('Binary type with subtype 0x02 contains too short binary size');\n        }\n        // Copy the data\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n        if (promoteBuffers && promoteValues) {\n          value = _buffer;\n        } else if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW) {\n          value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType).toUUID();\n        } else {\n          value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType);\n        }\n      }\n      // Update the index\n      index = index + binarySize;\n    } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new error_1.BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      var source = buffer.toString('utf8', index, i);\n      // Create the regexp\n      index = i + 1;\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new error_1.BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n      // For each option add the corresponding one for javascript\n      var optionsArray = new Array(regExpOptions.length);\n      // Parse options\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n      value = new RegExp(source, optionsArray.join(''));\n    } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new error_1.BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      var source = buffer.toString('utf8', index, i);\n      index = i + 1;\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new error_1.BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n      // Set the object\n      value = new regexp_1.BSONRegExp(source, regExpOptions);\n    } else if (elementType === constants.BSON_DATA_SYMBOL) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new error_1.BSONError('bad string length in bson');\n      }\n      var symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      value = promoteValues ? symbol : new symbol_1.BSONSymbol(symbol);\n      index = index + stringSize;\n    } else if (elementType === constants.BSON_DATA_TIMESTAMP) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      value = new timestamp_1.Timestamp(lowBits, highBits);\n    } else if (elementType === constants.BSON_DATA_MIN_KEY) {\n      value = new min_key_1.MinKey();\n    } else if (elementType === constants.BSON_DATA_MAX_KEY) {\n      value = new max_key_1.MaxKey();\n    } else if (elementType === constants.BSON_DATA_CODE) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new error_1.BSONError('bad string length in bson');\n      }\n      var functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      // If we are evaluating the functions\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          value = isolateEval(functionString, functionCache, object);\n        } else {\n          value = isolateEval(functionString);\n        }\n      } else {\n        value = new code_1.Code(functionString);\n      }\n      // Update parse index position\n      index = index + stringSize;\n    } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new error_1.BSONError('code_w_scope total size shorter minimum expected length');\n      }\n      // Get the code string size\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      // Check if we have a valid string\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new error_1.BSONError('bad string length in bson');\n      }\n      // Javascript function\n      var functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      // Update parse index position\n      index = index + stringSize;\n      // Parse the element\n      var _index = index;\n      // Decode the size of the object document\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      // Decode the scope object\n      var scopeObject = deserializeObject(buffer, _index, options, false);\n      // Adjust the index\n      index = index + objectSize;\n      // Check if field length is too short\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new error_1.BSONError('code_w_scope total size is too short, truncating scope');\n      }\n      // Check if totalSize field is too long\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new error_1.BSONError('code_w_scope total size is too long, clips outer document');\n      }\n      // If we are evaluating the functions\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          value = isolateEval(functionString, functionCache, object);\n        } else {\n          value = isolateEval(functionString);\n        }\n        value.scope = scopeObject;\n      } else {\n        value = new code_1.Code(functionString, scopeObject);\n      }\n    } else if (elementType === constants.BSON_DATA_DBPOINTER) {\n      // Get the code string size\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      // Check if we have a valid string\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new error_1.BSONError('bad string length in bson');\n      // Namespace\n      if (validation != null && validation.utf8) {\n        if (!(0, validate_utf8_1.validateUtf8)(buffer, index, index + stringSize - 1)) {\n          throw new error_1.BSONError('Invalid UTF-8 string in BSON document');\n        }\n      }\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1);\n      // Update parse index position\n      index = index + stringSize;\n      // Read the oid\n      var oidBuffer = buffer_1.Buffer.alloc(12);\n      buffer.copy(oidBuffer, 0, index, index + 12);\n      var oid = new objectid_1.ObjectId(oidBuffer);\n      // Update the index\n      index = index + 12;\n      // Upgrade to DBRef type\n      value = new db_ref_1.DBRef(namespace, oid);\n    } else {\n      throw new error_1.BSONError(\"Detected unknown BSON type \".concat(elementType.toString(16), \" for fieldname \\\"\").concat(name, \"\\\"\"));\n    }\n    if (name === '__proto__') {\n      Object.defineProperty(object, name, {\n        value: value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      object[name] = value;\n    }\n  }\n  // Check if the deserialization was against a valid array/object\n  if (size !== index - startIndex) {\n    if (isArray) throw new error_1.BSONError('corrupt array bson');\n    throw new error_1.BSONError('corrupt object bson');\n  }\n  // if we did not find \"$ref\", \"$id\", \"$db\", or found an extraneous $key, don't make a DBRef\n  if (!isPossibleDBRef) return object;\n  if ((0, db_ref_1.isDBRefLike)(object)) {\n    var copy = Object.assign({}, object);\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new db_ref_1.DBRef(object.$ref, object.$id, object.$db, copy);\n  }\n  return object;\n}\n/**\r\n * Ensure eval is isolated, store the result in functionCache.\r\n *\r\n * @internal\r\n */\nfunction isolateEval(functionString, functionCache, object) {\n  // eslint-disable-next-line @typescript-eslint/no-implied-eval\n  if (!functionCache) return new Function(functionString);\n  // Check for cache hit, eval if missing and return cached function\n  if (functionCache[functionString] == null) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    functionCache[functionString] = new Function(functionString);\n  }\n  // Set the object\n  return functionCache[functionString].bind(object);\n}\nfunction getValidatedString(buffer, start, end, shouldValidateUtf8) {\n  var value = buffer.toString('utf8', start, end);\n  // if utf8 validation is on, do the check\n  if (shouldValidateUtf8) {\n    for (var i = 0; i < value.length; i++) {\n      if (value.charCodeAt(i) === 0xfffd) {\n        if (!(0, validate_utf8_1.validateUtf8)(buffer, start, end)) {\n          throw new error_1.BSONError('Invalid UTF-8 string in BSON document');\n        }\n        break;\n      }\n    }\n  }\n  return value;\n}","map":{"version":3,"mappings":"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","names":["JS_INT_MAX_LONG","long_1","fromNumber","constants","JS_INT_MAX","JS_INT_MIN_LONG","JS_INT_MIN","functionCache","deserialize","buffer","options","isArray","index","size","error_1","allowObjectSmallerThanBufferSize","length","byteLength","deserializeObject","exports","allowedDBRefKeys","evalFunctions","cacheFunctions","fieldsAsRaw","raw","bsonRegExp","promoteBuffers","promoteLongs","promoteValues","validation","utf8","globalUTFValidation","validationSetting","utf8KeysSet","Set","utf8ValidatedKeys","utf8ValidationValues","Object","keys","map","key","every","_a","_i","add","startIndex","object","arrayIndex","done","isPossibleDBRef","dataview","DataView","byteOffset","elementType","i","name","toString","shouldValidateKey","has","test","value","BSON_DATA_STRING","stringSize","getValidatedString","BSON_DATA_OID","oid","buffer_1","alloc","copy","objectid_1","BSON_DATA_INT","int_32_1","BSON_DATA_NUMBER","double_1","getFloat64","BSON_DATA_DATE","lowBits","highBits","Date","toNumber","BSON_DATA_BOOLEAN","BSON_DATA_OBJECT","_index","objectSize","slice","objectOptions","BSON_DATA_ARRAY","arrayOptions","stopIndex","n","BSON_DATA_UNDEFINED","undefined","BSON_DATA_NULL","BSON_DATA_LONG","long","lessThanOrEqual","greaterThanOrEqual","BSON_DATA_DECIMAL128","bytes","decimal128","decimal128_1","toObject","BSON_DATA_BINARY","binarySize","totalBinarySize","subType","binary_1","SUBTYPE_BYTE_ARRAY","BSON_BINARY_SUBTYPE_UUID_NEW","toUUID","_buffer","BSON_DATA_REGEXP","source","regExpOptions","optionsArray","Array","RegExp","join","regexp_1","BSON_DATA_SYMBOL","symbol","symbol_1","BSON_DATA_TIMESTAMP","timestamp_1","BSON_DATA_MIN_KEY","min_key_1","BSON_DATA_MAX_KEY","max_key_1","BSON_DATA_CODE","functionString","isolateEval","code_1","BSON_DATA_CODE_W_SCOPE","totalSize","scopeObject","scope","BSON_DATA_DBPOINTER","namespace","oidBuffer","db_ref_1","defineProperty","writable","enumerable","configurable","assign","$ref","$id","$db","Function","bind","start","end","shouldValidateUtf8","charCodeAt"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\parser\\deserializer.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport { Binary } from '../binary';\r\nimport type { Document } from '../bson';\r\nimport { Code } from '../code';\r\nimport * as constants from '../constants';\r\nimport { DBRef, DBRefLike, isDBRefLike } from '../db_ref';\r\nimport { Decimal128 } from '../decimal128';\r\nimport { Double } from '../double';\r\nimport { BSONError } from '../error';\r\nimport { Int32 } from '../int_32';\r\nimport { Long } from '../long';\r\nimport { MaxKey } from '../max_key';\r\nimport { MinKey } from '../min_key';\r\nimport { ObjectId } from '../objectid';\r\nimport { BSONRegExp } from '../regexp';\r\nimport { BSONSymbol } from '../symbol';\r\nimport { Timestamp } from '../timestamp';\r\nimport { validateUtf8 } from '../validate_utf8';\r\n\r\n/** @public */\r\nexport interface DeserializeOptions {\r\n  /** evaluate functions in the BSON document scoped to the object deserialized. */\r\n  evalFunctions?: boolean;\r\n  /** cache evaluated functions for reuse. */\r\n  cacheFunctions?: boolean;\r\n  /**\r\n   * use a crc32 code for caching, otherwise use the string of the function.\r\n   * @deprecated this option to use the crc32 function never worked as intended\r\n   * due to the fact that the crc32 function itself was never implemented.\r\n   * */\r\n  cacheFunctionsCrc32?: boolean;\r\n  /** when deserializing a Long will fit it into a Number if it's smaller than 53 bits */\r\n  promoteLongs?: boolean;\r\n  /** when deserializing a Binary will return it as a node.js Buffer instance. */\r\n  promoteBuffers?: boolean;\r\n  /** when deserializing will promote BSON values to their Node.js closest equivalent types. */\r\n  promoteValues?: boolean;\r\n  /** allow to specify if there what fields we wish to return as unserialized raw buffer. */\r\n  fieldsAsRaw?: Document;\r\n  /** return BSON regular expressions as BSONRegExp instances. */\r\n  bsonRegExp?: boolean;\r\n  /** allows the buffer to be larger than the parsed BSON object */\r\n  allowObjectSmallerThanBufferSize?: boolean;\r\n  /** Offset into buffer to begin reading document from */\r\n  index?: number;\r\n\r\n  raw?: boolean;\r\n  /** Allows for opt-out utf-8 validation for all keys or\r\n   * specified keys. Must be all true or all false.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // disables validation on all keys\r\n   *  validation: { utf8: false }\r\n   *\r\n   * // enables validation only on specified keys a, b, and c\r\n   *  validation: { utf8: { a: true, b: true, c: true } }\r\n   *\r\n   *  // disables validation only on specified keys a, b\r\n   *  validation: { utf8: { a: false, b: false } }\r\n   * ```\r\n   */\r\n  validation?: { utf8: boolean | Record<string, true> | Record<string, false> };\r\n}\r\n\r\n// Internal long versions\r\nconst JS_INT_MAX_LONG = Long.fromNumber(constants.JS_INT_MAX);\r\nconst JS_INT_MIN_LONG = Long.fromNumber(constants.JS_INT_MIN);\r\n\r\nconst functionCache: { [hash: string]: Function } = {};\r\n\r\nexport function deserialize(\r\n  buffer: Buffer,\r\n  options: DeserializeOptions,\r\n  isArray?: boolean\r\n): Document {\r\n  options = options == null ? {} : options;\r\n  const index = options && options.index ? options.index : 0;\r\n  // Read the document size\r\n  const size =\r\n    buffer[index] |\r\n    (buffer[index + 1] << 8) |\r\n    (buffer[index + 2] << 16) |\r\n    (buffer[index + 3] << 24);\r\n\r\n  if (size < 5) {\r\n    throw new BSONError(`bson size must be >= 5, is ${size}`);\r\n  }\r\n\r\n  if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\r\n    throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\r\n  }\r\n\r\n  if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\r\n    throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\r\n  }\r\n\r\n  if (size + index > buffer.byteLength) {\r\n    throw new BSONError(\r\n      `(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`\r\n    );\r\n  }\r\n\r\n  // Illegal end value\r\n  if (buffer[index + size - 1] !== 0) {\r\n    throw new BSONError(\r\n      \"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\"\r\n    );\r\n  }\r\n\r\n  // Start deserializtion\r\n  return deserializeObject(buffer, index, options, isArray);\r\n}\r\n\r\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\r\n\r\nfunction deserializeObject(\r\n  buffer: Buffer,\r\n  index: number,\r\n  options: DeserializeOptions,\r\n  isArray = false\r\n) {\r\n  const evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\r\n  const cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\r\n\r\n  const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\r\n\r\n  // Return raw bson buffer instead of parsing it\r\n  const raw = options['raw'] == null ? false : options['raw'];\r\n\r\n  // Return BSONRegExp objects instead of native regular expressions\r\n  const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\r\n\r\n  // Controls the promotion of values vs wrapper classes\r\n  const promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\r\n  const promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\r\n  const promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];\r\n\r\n  // Ensures default validation option if none given\r\n  const validation = options.validation == null ? { utf8: true } : options.validation;\r\n\r\n  // Shows if global utf-8 validation is enabled or disabled\r\n  let globalUTFValidation = true;\r\n  // Reflects utf-8 validation setting regardless of global or specific key validation\r\n  let validationSetting: boolean;\r\n  // Set of keys either to enable or disable validation on\r\n  const utf8KeysSet = new Set();\r\n\r\n  // Check for boolean uniformity and empty validation option\r\n  const utf8ValidatedKeys = validation.utf8;\r\n  if (typeof utf8ValidatedKeys === 'boolean') {\r\n    validationSetting = utf8ValidatedKeys;\r\n  } else {\r\n    globalUTFValidation = false;\r\n    const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\r\n      return utf8ValidatedKeys[key];\r\n    });\r\n    if (utf8ValidationValues.length === 0) {\r\n      throw new BSONError('UTF-8 validation setting cannot be empty');\r\n    }\r\n    if (typeof utf8ValidationValues[0] !== 'boolean') {\r\n      throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\r\n    }\r\n    validationSetting = utf8ValidationValues[0];\r\n    // Ensures boolean uniformity in utf-8 validation (all true or all false)\r\n    if (!utf8ValidationValues.every(item => item === validationSetting)) {\r\n      throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\r\n    }\r\n  }\r\n\r\n  // Add keys to set that will either be validated or not based on validationSetting\r\n  if (!globalUTFValidation) {\r\n    for (const key of Object.keys(utf8ValidatedKeys)) {\r\n      utf8KeysSet.add(key);\r\n    }\r\n  }\r\n\r\n  // Set the start index\r\n  const startIndex = index;\r\n\r\n  // Validate that we have at least 4 bytes of buffer\r\n  if (buffer.length < 5) throw new BSONError('corrupt bson message < 5 bytes long');\r\n\r\n  // Read the document size\r\n  const size =\r\n    buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\r\n\r\n  // Ensure buffer is valid size\r\n  if (size < 5 || size > buffer.length) throw new BSONError('corrupt bson message');\r\n\r\n  // Create holding object\r\n  const object: Document = isArray ? [] : {};\r\n  // Used for arrays to skip having to perform utf8 decoding\r\n  let arrayIndex = 0;\r\n  const done = false;\r\n\r\n  let isPossibleDBRef = isArray ? false : null;\r\n\r\n  // While we have more left data left keep parsing\r\n  const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n  while (!done) {\r\n    // Read the type\r\n    const elementType = buffer[index++];\r\n\r\n    // If we get a zero it's the last byte, exit\r\n    if (elementType === 0) break;\r\n\r\n    // Get the start search index\r\n    let i = index;\r\n    // Locate the end of the c string\r\n    while (buffer[i] !== 0x00 && i < buffer.length) {\r\n      i++;\r\n    }\r\n\r\n    // If are at the end of the buffer there is a problem with the document\r\n    if (i >= buffer.byteLength) throw new BSONError('Bad BSON Document: illegal CString');\r\n\r\n    // Represents the key\r\n    const name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\r\n\r\n    // shouldValidateKey is true if the key should be validated, false otherwise\r\n    let shouldValidateKey = true;\r\n    if (globalUTFValidation || utf8KeysSet.has(name)) {\r\n      shouldValidateKey = validationSetting;\r\n    } else {\r\n      shouldValidateKey = !validationSetting;\r\n    }\r\n\r\n    if (isPossibleDBRef !== false && (name as string)[0] === '$') {\r\n      isPossibleDBRef = allowedDBRefKeys.test(name as string);\r\n    }\r\n    let value;\r\n\r\n    index = i + 1;\r\n\r\n    if (elementType === constants.BSON_DATA_STRING) {\r\n      const stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      ) {\r\n        throw new BSONError('bad string length in bson');\r\n      }\r\n      value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\r\n      index = index + stringSize;\r\n    } else if (elementType === constants.BSON_DATA_OID) {\r\n      const oid = Buffer.alloc(12);\r\n      buffer.copy(oid, 0, index, index + 12);\r\n      value = new ObjectId(oid);\r\n      index = index + 12;\r\n    } else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {\r\n      value = new Int32(\r\n        buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24)\r\n      );\r\n    } else if (elementType === constants.BSON_DATA_INT) {\r\n      value =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n    } else if (elementType === constants.BSON_DATA_NUMBER && promoteValues === false) {\r\n      value = new Double(dataview.getFloat64(index, true));\r\n      index = index + 8;\r\n    } else if (elementType === constants.BSON_DATA_NUMBER) {\r\n      value = dataview.getFloat64(index, true);\r\n      index = index + 8;\r\n    } else if (elementType === constants.BSON_DATA_DATE) {\r\n      const lowBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      const highBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      value = new Date(new Long(lowBits, highBits).toNumber());\r\n    } else if (elementType === constants.BSON_DATA_BOOLEAN) {\r\n      if (buffer[index] !== 0 && buffer[index] !== 1)\r\n        throw new BSONError('illegal boolean type value');\r\n      value = buffer[index++] === 1;\r\n    } else if (elementType === constants.BSON_DATA_OBJECT) {\r\n      const _index = index;\r\n      const objectSize =\r\n        buffer[index] |\r\n        (buffer[index + 1] << 8) |\r\n        (buffer[index + 2] << 16) |\r\n        (buffer[index + 3] << 24);\r\n      if (objectSize <= 0 || objectSize > buffer.length - index)\r\n        throw new BSONError('bad embedded document length in bson');\r\n\r\n      // We have a raw value\r\n      if (raw) {\r\n        value = buffer.slice(index, index + objectSize);\r\n      } else {\r\n        let objectOptions = options;\r\n        if (!globalUTFValidation) {\r\n          objectOptions = { ...options, validation: { utf8: shouldValidateKey } };\r\n        }\r\n        value = deserializeObject(buffer, _index, objectOptions, false);\r\n      }\r\n\r\n      index = index + objectSize;\r\n    } else if (elementType === constants.BSON_DATA_ARRAY) {\r\n      const _index = index;\r\n      const objectSize =\r\n        buffer[index] |\r\n        (buffer[index + 1] << 8) |\r\n        (buffer[index + 2] << 16) |\r\n        (buffer[index + 3] << 24);\r\n      let arrayOptions = options;\r\n\r\n      // Stop index\r\n      const stopIndex = index + objectSize;\r\n\r\n      // All elements of array to be returned as raw bson\r\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\r\n        arrayOptions = {};\r\n        for (const n in options) {\r\n          (\r\n            arrayOptions as {\r\n              [key: string]: DeserializeOptions[keyof DeserializeOptions];\r\n            }\r\n          )[n] = options[n as keyof DeserializeOptions];\r\n        }\r\n        arrayOptions['raw'] = true;\r\n      }\r\n      if (!globalUTFValidation) {\r\n        arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };\r\n      }\r\n      value = deserializeObject(buffer, _index, arrayOptions, true);\r\n      index = index + objectSize;\r\n\r\n      if (buffer[index - 1] !== 0) throw new BSONError('invalid array terminator byte');\r\n      if (index !== stopIndex) throw new BSONError('corrupted array bson');\r\n    } else if (elementType === constants.BSON_DATA_UNDEFINED) {\r\n      value = undefined;\r\n    } else if (elementType === constants.BSON_DATA_NULL) {\r\n      value = null;\r\n    } else if (elementType === constants.BSON_DATA_LONG) {\r\n      // Unpack the low and high bits\r\n      const lowBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      const highBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      const long = new Long(lowBits, highBits);\r\n      // Promote the long if possible\r\n      if (promoteLongs && promoteValues === true) {\r\n        value =\r\n          long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\r\n            ? long.toNumber()\r\n            : long;\r\n      } else {\r\n        value = long;\r\n      }\r\n    } else if (elementType === constants.BSON_DATA_DECIMAL128) {\r\n      // Buffer to contain the decimal bytes\r\n      const bytes = Buffer.alloc(16);\r\n      // Copy the next 16 bytes into the bytes buffer\r\n      buffer.copy(bytes, 0, index, index + 16);\r\n      // Update index\r\n      index = index + 16;\r\n      // Assign the new Decimal128 value\r\n      const decimal128 = new Decimal128(bytes) as Decimal128 | { toObject(): unknown };\r\n      // If we have an alternative mapper use that\r\n      if ('toObject' in decimal128 && typeof decimal128.toObject === 'function') {\r\n        value = decimal128.toObject();\r\n      } else {\r\n        value = decimal128;\r\n      }\r\n    } else if (elementType === constants.BSON_DATA_BINARY) {\r\n      let binarySize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      const totalBinarySize = binarySize;\r\n      const subType = buffer[index++];\r\n\r\n      // Did we have a negative binary size, throw\r\n      if (binarySize < 0) throw new BSONError('Negative binary type element size found');\r\n\r\n      // Is the length longer than the document\r\n      if (binarySize > buffer.byteLength)\r\n        throw new BSONError('Binary type size larger than document size');\r\n\r\n      // Decode as raw Buffer object if options specifies it\r\n      if (buffer['slice'] != null) {\r\n        // If we have subtype 2 skip the 4 bytes for the size\r\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\r\n          binarySize =\r\n            buffer[index++] |\r\n            (buffer[index++] << 8) |\r\n            (buffer[index++] << 16) |\r\n            (buffer[index++] << 24);\r\n          if (binarySize < 0)\r\n            throw new BSONError('Negative binary type element size found for subtype 0x02');\r\n          if (binarySize > totalBinarySize - 4)\r\n            throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\r\n          if (binarySize < totalBinarySize - 4)\r\n            throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\r\n        }\r\n\r\n        if (promoteBuffers && promoteValues) {\r\n          value = buffer.slice(index, index + binarySize);\r\n        } else {\r\n          value = new Binary(buffer.slice(index, index + binarySize), subType);\r\n          if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW) {\r\n            value = value.toUUID();\r\n          }\r\n        }\r\n      } else {\r\n        const _buffer = Buffer.alloc(binarySize);\r\n        // If we have subtype 2 skip the 4 bytes for the size\r\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\r\n          binarySize =\r\n            buffer[index++] |\r\n            (buffer[index++] << 8) |\r\n            (buffer[index++] << 16) |\r\n            (buffer[index++] << 24);\r\n          if (binarySize < 0)\r\n            throw new BSONError('Negative binary type element size found for subtype 0x02');\r\n          if (binarySize > totalBinarySize - 4)\r\n            throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\r\n          if (binarySize < totalBinarySize - 4)\r\n            throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\r\n        }\r\n\r\n        // Copy the data\r\n        for (i = 0; i < binarySize; i++) {\r\n          _buffer[i] = buffer[index + i];\r\n        }\r\n\r\n        if (promoteBuffers && promoteValues) {\r\n          value = _buffer;\r\n        } else if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW) {\r\n          value = new Binary(buffer.slice(index, index + binarySize), subType).toUUID();\r\n        } else {\r\n          value = new Binary(buffer.slice(index, index + binarySize), subType);\r\n        }\r\n      }\r\n\r\n      // Update the index\r\n      index = index + binarySize;\r\n    } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      const source = buffer.toString('utf8', index, i);\r\n      // Create the regexp\r\n      index = i + 1;\r\n\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      const regExpOptions = buffer.toString('utf8', index, i);\r\n      index = i + 1;\r\n\r\n      // For each option add the corresponding one for javascript\r\n      const optionsArray = new Array(regExpOptions.length);\r\n\r\n      // Parse options\r\n      for (i = 0; i < regExpOptions.length; i++) {\r\n        switch (regExpOptions[i]) {\r\n          case 'm':\r\n            optionsArray[i] = 'm';\r\n            break;\r\n          case 's':\r\n            optionsArray[i] = 'g';\r\n            break;\r\n          case 'i':\r\n            optionsArray[i] = 'i';\r\n            break;\r\n        }\r\n      }\r\n\r\n      value = new RegExp(source, optionsArray.join(''));\r\n    } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      const source = buffer.toString('utf8', index, i);\r\n      index = i + 1;\r\n\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      const regExpOptions = buffer.toString('utf8', index, i);\r\n      index = i + 1;\r\n\r\n      // Set the object\r\n      value = new BSONRegExp(source, regExpOptions);\r\n    } else if (elementType === constants.BSON_DATA_SYMBOL) {\r\n      const stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      ) {\r\n        throw new BSONError('bad string length in bson');\r\n      }\r\n      const symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\r\n      value = promoteValues ? symbol : new BSONSymbol(symbol);\r\n      index = index + stringSize;\r\n    } else if (elementType === constants.BSON_DATA_TIMESTAMP) {\r\n      const lowBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      const highBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n\r\n      value = new Timestamp(lowBits, highBits);\r\n    } else if (elementType === constants.BSON_DATA_MIN_KEY) {\r\n      value = new MinKey();\r\n    } else if (elementType === constants.BSON_DATA_MAX_KEY) {\r\n      value = new MaxKey();\r\n    } else if (elementType === constants.BSON_DATA_CODE) {\r\n      const stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      ) {\r\n        throw new BSONError('bad string length in bson');\r\n      }\r\n      const functionString = getValidatedString(\r\n        buffer,\r\n        index,\r\n        index + stringSize - 1,\r\n        shouldValidateKey\r\n      );\r\n\r\n      // If we are evaluating the functions\r\n      if (evalFunctions) {\r\n        // If we have cache enabled let's look for the md5 of the function in the cache\r\n        if (cacheFunctions) {\r\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\r\n          value = isolateEval(functionString, functionCache, object);\r\n        } else {\r\n          value = isolateEval(functionString);\r\n        }\r\n      } else {\r\n        value = new Code(functionString);\r\n      }\r\n\r\n      // Update parse index position\r\n      index = index + stringSize;\r\n    } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {\r\n      const totalSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n\r\n      // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\r\n      if (totalSize < 4 + 4 + 4 + 1) {\r\n        throw new BSONError('code_w_scope total size shorter minimum expected length');\r\n      }\r\n\r\n      // Get the code string size\r\n      const stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      // Check if we have a valid string\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      ) {\r\n        throw new BSONError('bad string length in bson');\r\n      }\r\n\r\n      // Javascript function\r\n      const functionString = getValidatedString(\r\n        buffer,\r\n        index,\r\n        index + stringSize - 1,\r\n        shouldValidateKey\r\n      );\r\n      // Update parse index position\r\n      index = index + stringSize;\r\n      // Parse the element\r\n      const _index = index;\r\n      // Decode the size of the object document\r\n      const objectSize =\r\n        buffer[index] |\r\n        (buffer[index + 1] << 8) |\r\n        (buffer[index + 2] << 16) |\r\n        (buffer[index + 3] << 24);\r\n      // Decode the scope object\r\n      const scopeObject = deserializeObject(buffer, _index, options, false);\r\n      // Adjust the index\r\n      index = index + objectSize;\r\n\r\n      // Check if field length is too short\r\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\r\n        throw new BSONError('code_w_scope total size is too short, truncating scope');\r\n      }\r\n\r\n      // Check if totalSize field is too long\r\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\r\n        throw new BSONError('code_w_scope total size is too long, clips outer document');\r\n      }\r\n\r\n      // If we are evaluating the functions\r\n      if (evalFunctions) {\r\n        // If we have cache enabled let's look for the md5 of the function in the cache\r\n        if (cacheFunctions) {\r\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\r\n          value = isolateEval(functionString, functionCache, object);\r\n        } else {\r\n          value = isolateEval(functionString);\r\n        }\r\n\r\n        value.scope = scopeObject;\r\n      } else {\r\n        value = new Code(functionString, scopeObject);\r\n      }\r\n    } else if (elementType === constants.BSON_DATA_DBPOINTER) {\r\n      // Get the code string size\r\n      const stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      // Check if we have a valid string\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      )\r\n        throw new BSONError('bad string length in bson');\r\n      // Namespace\r\n      if (validation != null && validation.utf8) {\r\n        if (!validateUtf8(buffer, index, index + stringSize - 1)) {\r\n          throw new BSONError('Invalid UTF-8 string in BSON document');\r\n        }\r\n      }\r\n      const namespace = buffer.toString('utf8', index, index + stringSize - 1);\r\n      // Update parse index position\r\n      index = index + stringSize;\r\n\r\n      // Read the oid\r\n      const oidBuffer = Buffer.alloc(12);\r\n      buffer.copy(oidBuffer, 0, index, index + 12);\r\n      const oid = new ObjectId(oidBuffer);\r\n\r\n      // Update the index\r\n      index = index + 12;\r\n\r\n      // Upgrade to DBRef type\r\n      value = new DBRef(namespace, oid);\r\n    } else {\r\n      throw new BSONError(\r\n        `Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`\r\n      );\r\n    }\r\n    if (name === '__proto__') {\r\n      Object.defineProperty(object, name, {\r\n        value,\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: true\r\n      });\r\n    } else {\r\n      object[name] = value;\r\n    }\r\n  }\r\n\r\n  // Check if the deserialization was against a valid array/object\r\n  if (size !== index - startIndex) {\r\n    if (isArray) throw new BSONError('corrupt array bson');\r\n    throw new BSONError('corrupt object bson');\r\n  }\r\n\r\n  // if we did not find \"$ref\", \"$id\", \"$db\", or found an extraneous $key, don't make a DBRef\r\n  if (!isPossibleDBRef) return object;\r\n\r\n  if (isDBRefLike(object)) {\r\n    const copy = Object.assign({}, object) as Partial<DBRefLike>;\r\n    delete copy.$ref;\r\n    delete copy.$id;\r\n    delete copy.$db;\r\n    return new DBRef(object.$ref, object.$id, object.$db, copy);\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\n/**\r\n * Ensure eval is isolated, store the result in functionCache.\r\n *\r\n * @internal\r\n */\r\nfunction isolateEval(\r\n  functionString: string,\r\n  functionCache?: { [hash: string]: Function },\r\n  object?: Document\r\n) {\r\n  // eslint-disable-next-line @typescript-eslint/no-implied-eval\r\n  if (!functionCache) return new Function(functionString);\r\n  // Check for cache hit, eval if missing and return cached function\r\n  if (functionCache[functionString] == null) {\r\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\r\n    functionCache[functionString] = new Function(functionString);\r\n  }\r\n\r\n  // Set the object\r\n  return functionCache[functionString].bind(object);\r\n}\r\n\r\nfunction getValidatedString(\r\n  buffer: Buffer,\r\n  start: number,\r\n  end: number,\r\n  shouldValidateUtf8: boolean\r\n) {\r\n  const value = buffer.toString('utf8', start, end);\r\n  // if utf8 validation is on, do the check\r\n  if (shouldValidateUtf8) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      if (value.charCodeAt(i) === 0xfffd) {\r\n        if (!validateUtf8(buffer, start, end)) {\r\n          throw new BSONError('Invalid UTF-8 string in BSON document');\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return value;\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}