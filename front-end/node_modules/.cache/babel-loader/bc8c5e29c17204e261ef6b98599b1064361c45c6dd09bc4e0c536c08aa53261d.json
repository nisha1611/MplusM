{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n// avoid casting '$add' or '$subtract', because expressions can be either number or date,\n// and we don't have a good way of inferring which arguments should be numbers and which should\n// be dates.\n'$multiply', '$divide', '$log', '$mod', '$trunc', '$avg', '$max', '$min', '$stdDevPop', '$stdDevSamp', '$sum']);\nconst arithmeticOperatorNumber = new Set(['$abs', '$exp', '$ceil', '$floor', '$ln', '$log10', '$round', '$sqrt', '$sin', '$cos', '$tan', '$asin', '$acos', '$atan', '$atan2', '$asinh', '$acosh', '$atanh', '$sinh', '$cosh', '$tanh', '$degreesToRadians', '$radiansToDegrees']);\nconst arrayElementOperators = new Set(['$arrayElemAt', '$first', '$last']);\nconst dateOperators = new Set(['$year', '$month', '$week', '$dayOfMonth', '$dayOfYear', '$hour', '$minute', '$second', '$isoDayOfWeek', '$isoWeekYear', '$isoWeek', '$millisecond']);\nconst expressionOperator = new Set(['$not']);\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n  return _castExpression(val, schema, strictQuery);\n};\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\n    val.default = _castExpression(val.default, schema, strictQuery);\n  }\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  _omitUndefined(val);\n  return val;\n}\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    val[keys[i]] === void 0 && delete val[keys[i]];\n  }\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n    return void 0;\n  }\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n  return [schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search), path];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = {\n          $literal: schematype.cast(val[1].$literal)\n        };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = {\n            $literal: caster(val[1].$literal)\n          };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n  return val;\n}\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://docs.mongodb.com/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","castNumber","booleanComparison","Set","comparisonOperator","arithmeticOperatorArray","arithmeticOperatorNumber","arrayElementOperators","dateOperators","expressionOperator","module","exports","cast$expr","val","schema","strictQuery","Error","_castExpression","isPath","$cond","Array","isArray","map","expr","if","then","else","$ifNull","v","$switch","branches","default","keys","Object","key","has","castComparison","castArithmetic","castNumberOperator","$in","castIn","$size","_omitUndefined","i","len","length","isLiteral","err","path","search","schematype","slice","$isMongooseArray","$isMongooseDocumentArray","$embeddedSchemaType","cast","caster","lhs","is$literal","$literal","name","replace","find"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/query/cast$expr.js"],"sourcesContent":["'use strict';\r\n\r\nconst CastError = require('../../error/cast');\r\nconst StrictModeError = require('../../error/strict');\r\nconst castNumber = require('../../cast/number');\r\n\r\nconst booleanComparison = new Set(['$and', '$or']);\r\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\r\nconst arithmeticOperatorArray = new Set([\r\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\r\n  // and we don't have a good way of inferring which arguments should be numbers and which should\r\n  // be dates.\r\n  '$multiply',\r\n  '$divide',\r\n  '$log',\r\n  '$mod',\r\n  '$trunc',\r\n  '$avg',\r\n  '$max',\r\n  '$min',\r\n  '$stdDevPop',\r\n  '$stdDevSamp',\r\n  '$sum'\r\n]);\r\nconst arithmeticOperatorNumber = new Set([\r\n  '$abs',\r\n  '$exp',\r\n  '$ceil',\r\n  '$floor',\r\n  '$ln',\r\n  '$log10',\r\n  '$round',\r\n  '$sqrt',\r\n  '$sin',\r\n  '$cos',\r\n  '$tan',\r\n  '$asin',\r\n  '$acos',\r\n  '$atan',\r\n  '$atan2',\r\n  '$asinh',\r\n  '$acosh',\r\n  '$atanh',\r\n  '$sinh',\r\n  '$cosh',\r\n  '$tanh',\r\n  '$degreesToRadians',\r\n  '$radiansToDegrees'\r\n]);\r\nconst arrayElementOperators = new Set([\r\n  '$arrayElemAt',\r\n  '$first',\r\n  '$last'\r\n]);\r\nconst dateOperators = new Set([\r\n  '$year',\r\n  '$month',\r\n  '$week',\r\n  '$dayOfMonth',\r\n  '$dayOfYear',\r\n  '$hour',\r\n  '$minute',\r\n  '$second',\r\n  '$isoDayOfWeek',\r\n  '$isoWeekYear',\r\n  '$isoWeek',\r\n  '$millisecond'\r\n]);\r\nconst expressionOperator = new Set(['$not']);\r\n\r\nmodule.exports = function cast$expr(val, schema, strictQuery) {\r\n  if (typeof val !== 'object' || val === null) {\r\n    throw new Error('`$expr` must be an object');\r\n  }\r\n\r\n  return _castExpression(val, schema, strictQuery);\r\n};\r\n\r\nfunction _castExpression(val, schema, strictQuery) {\r\n  // Preserve the value if it represents a path or if it's null\r\n  if (isPath(val) || val === null) {\r\n    return val;\r\n  }\r\n\r\n  if (val.$cond != null) {\r\n    if (Array.isArray(val.$cond)) {\r\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\r\n    } else {\r\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\r\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\r\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\r\n    }\r\n  } else if (val.$ifNull != null) {\r\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\r\n  } else if (val.$switch != null) {\r\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\r\n    val.default = _castExpression(val.default, schema, strictQuery);\r\n  }\r\n\r\n  const keys = Object.keys(val);\r\n  for (const key of keys) {\r\n    if (booleanComparison.has(key)) {\r\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\r\n    } else if (comparisonOperator.has(key)) {\r\n      val[key] = castComparison(val[key], schema, strictQuery);\r\n    } else if (arithmeticOperatorArray.has(key)) {\r\n      val[key] = castArithmetic(val[key], schema, strictQuery);\r\n    } else if (arithmeticOperatorNumber.has(key)) {\r\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\r\n    } else if (expressionOperator.has(key)) {\r\n      val[key] = _castExpression(val[key], schema, strictQuery);\r\n    }\r\n  }\r\n\r\n  if (val.$in) {\r\n    val.$in = castIn(val.$in, schema, strictQuery);\r\n  }\r\n  if (val.$size) {\r\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\r\n  }\r\n\r\n  _omitUndefined(val);\r\n\r\n  return val;\r\n}\r\n\r\nfunction _omitUndefined(val) {\r\n  const keys = Object.keys(val);\r\n  for (let i = 0, len = keys.length; i < len; ++i) {\r\n    (val[keys[i]] === void 0) && delete val[keys[i]];\r\n  }\r\n}\r\n\r\n// { $op: <number> }\r\nfunction castNumberOperator(val) {\r\n  if (!isLiteral(val)) {\r\n    return val;\r\n  }\r\n\r\n  try {\r\n    return castNumber(val);\r\n  } catch (err) {\r\n    throw new CastError('Number', val);\r\n  }\r\n}\r\n\r\nfunction castIn(val, schema, strictQuery) {\r\n  const path = val[1];\r\n  if (!isPath(path)) {\r\n    return val;\r\n  }\r\n  const search = val[0];\r\n\r\n  const schematype = schema.path(path.slice(1));\r\n  if (schematype === null) {\r\n    if (strictQuery === false) {\r\n      return val;\r\n    } else if (strictQuery === 'throw') {\r\n      throw new StrictModeError('$in');\r\n    }\r\n\r\n    return void 0;\r\n  }\r\n\r\n  if (!schematype.$isMongooseArray) {\r\n    throw new Error('Path must be an array for $in');\r\n  }\r\n\r\n  return [\r\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\r\n    path\r\n  ];\r\n}\r\n\r\n// { $op: [<number>, <number>] }\r\nfunction castArithmetic(val) {\r\n  if (!Array.isArray(val)) {\r\n    if (!isLiteral(val)) {\r\n      return val;\r\n    }\r\n    try {\r\n      return castNumber(val);\r\n    } catch (err) {\r\n      throw new CastError('Number', val);\r\n    }\r\n  }\r\n\r\n  return val.map(v => {\r\n    if (!isLiteral(v)) {\r\n      return v;\r\n    }\r\n    try {\r\n      return castNumber(v);\r\n    } catch (err) {\r\n      throw new CastError('Number', v);\r\n    }\r\n  });\r\n}\r\n\r\n// { $op: [expression, expression] }\r\nfunction castComparison(val, schema, strictQuery) {\r\n  if (!Array.isArray(val) || val.length !== 2) {\r\n    throw new Error('Comparison operator must be an array of length 2');\r\n  }\r\n\r\n  val[0] = _castExpression(val[0], schema, strictQuery);\r\n  const lhs = val[0];\r\n\r\n  if (isLiteral(val[1])) {\r\n    let path = null;\r\n    let schematype = null;\r\n    let caster = null;\r\n    if (isPath(lhs)) {\r\n      path = lhs.slice(1);\r\n      schematype = schema.path(path);\r\n    } else if (typeof lhs === 'object' && lhs != null) {\r\n      for (const key of Object.keys(lhs)) {\r\n        if (dateOperators.has(key) && isPath(lhs[key])) {\r\n          path = lhs[key].slice(1) + '.' + key;\r\n          caster = castNumber;\r\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\r\n          path = lhs[key].slice(1) + '.' + key;\r\n          schematype = schema.path(lhs[key].slice(1));\r\n          if (schematype != null) {\r\n            if (schematype.$isMongooseDocumentArray) {\r\n              schematype = schematype.$embeddedSchemaType;\r\n            } else if (schematype.$isMongooseArray) {\r\n              schematype = schematype.caster;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\r\n    if (schematype != null) {\r\n      if (is$literal) {\r\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\r\n      } else {\r\n        val[1] = schematype.cast(val[1]);\r\n      }\r\n    } else if (caster != null) {\r\n      if (is$literal) {\r\n        try {\r\n          val[1] = { $literal: caster(val[1].$literal) };\r\n        } catch (err) {\r\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\r\n        }\r\n      } else {\r\n        try {\r\n          val[1] = caster(val[1]);\r\n        } catch (err) {\r\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\r\n        }\r\n      }\r\n    } else if (path != null && strictQuery === true) {\r\n      return void 0;\r\n    } else if (path != null && strictQuery === 'throw') {\r\n      throw new StrictModeError(path);\r\n    }\r\n  } else {\r\n    val[1] = _castExpression(val[1]);\r\n  }\r\n\r\n  return val;\r\n}\r\n\r\nfunction isPath(val) {\r\n  return typeof val === 'string' && val[0] === '$';\r\n}\r\n\r\nfunction isLiteral(val) {\r\n  if (typeof val === 'string' && val[0] === '$') {\r\n    return false;\r\n  }\r\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\r\n    // The `$literal` expression can make an object a literal\r\n    // https://docs.mongodb.com/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\r\n    return val.$literal != null;\r\n  }\r\n  return true;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}