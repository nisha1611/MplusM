{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\n\n/**\r\n * Casts an update op based on the given schema\r\n *\r\n * @param {Schema} schema\r\n * @param {Object} obj\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.overwrite] defaults to false\r\n * @param {Boolean|String} [options.strict] defaults to true\r\n * @param {Query} context passed to setters\r\n * @return {Boolean} true iff the update is non-empty\r\n * @api private\r\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n  if (options.upsert && !options.overwrite) {\n    moveImmutableProperties(schema, obj, context);\n  }\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    const toUnset = {};\n    for (const key of Object.keys(val)) {\n      if (val[key] === undefined) {\n        toUnset[key] = 1;\n      }\n    }\n    if (val && typeof val === 'object' && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. ' + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n      if (op === '$set' && !utils.isEmptyObject(toUnset)) {\n        // Unset all undefined values\n        ret['$unset'] = toUnset;\n      }\n    }\n  }\n  if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    return {\n      $setOnInsert: filter\n    };\n  }\n  return ret;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' + ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\r\n * Walk each path of obj and cast its values\r\n * according to its schema.\r\n *\r\n * @param {Schema} schema\r\n * @param {Object} obj part of a query\r\n * @param {String} op the atomic operator ($pull, $set, etc)\r\n * @param {Object} [options]\r\n * @param {Boolean|String} [options.strict]\r\n * @param {Query} context\r\n * @param {Object} filter\r\n * @param {String} pref path prefix (internal only)\r\n * @return {Bool} true if this path has keys to update\r\n * @api private\r\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n  let aggregatedError = null;\n  const strictMode = strict != null ? strict : schema.options.strict;\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n    const discriminatorKey = prefix ? prefix + key : key;\n    if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && !options.overwriteDiscriminatorKey) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (op !== '$setOnInsert' && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(val, context, {\n                strict: _strict\n              });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n          hasKeys = true;\n        }\n      } else if (op === '$currentDate' || op in castOps && schematype) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else {\n        const pathToCheck = prefix + key;\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;\n      }\n    } else {\n      const checkPath = key === '$each' || key === '$or' || key === '$and' || key === '$in' ? pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n      const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = {\n              $each: obj[key]\n            };\n          }\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      }\n    }\n  }\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n  return hasKeys;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\r\n * These operators should be cast to numbers instead\r\n * of their path schema type.\r\n * @api private\r\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\r\n * These ops require no casting because the RHS doesn't do anything.\r\n * @api private\r\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\r\n * These operators require casting docs\r\n * to real Documents for Update operations.\r\n * @api private\r\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\r\n * ignore\r\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\r\n * Casts `val` according to `schema` and atomic `op`.\r\n *\r\n * @param {SchemaType} schema\r\n * @param {Object} val\r\n * @param {String} op the atomic operator ($pull, $set, etc)\r\n * @param {String} $conditional\r\n * @param {Query} context\r\n * @param {String} path\r\n * @api private\r\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQueryWrapper({\n        val: val,\n        context: context\n      });\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {\n        $type: val.$type\n      };\n    }\n    return Boolean(val);\n  }\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQueryWrapper({\n      $conditional: $conditional,\n      val: val,\n      context: context\n    });\n  }\n  if (overwriteOps[op]) {\n    return schema.castForQueryWrapper({\n      val: val,\n      context: context,\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/),\n      $applySetters: schema[schemaMixedSymbol] != null\n    });\n  }\n  return schema.castForQueryWrapper({\n    val: val,\n    context: context\n  });\n}","map":{"version":3,"names":["CastError","require","MongooseError","StrictModeError","ValidationError","castNumber","cast","getConstructorName","getEmbeddedDiscriminatorPath","handleImmutable","moveImmutableProperties","schemaMixedSymbol","setDottedPath","utils","module","exports","castUpdate","schema","obj","options","context","filter","undefined","Array","isArray","len","length","i","ops","Object","keys","op","castPipelineOperator","upsert","overwrite","ret","val","hasDollarKey","$set","splice","indexOf","push","startsWith","toUnset","key","Buffer","isBuffer","walkUpdatePath","msg","Error","isEmptyObject","$setOnInsert","find","v","pref","strict","prefix","hasKeys","schematype","aggregatedError","strictMode","_getSchema","discriminatorKey","discriminatorMapping","overwriteDiscriminatorKey","err","_appendError","_res","caster","castOps","$each","castUpdateVal","error","$slice","$sort","$position","$isSingleNested","_strict","castForQuery","pathToCheck","_getPathType","pathType","isObject","checkPath","pathDetails","type","isStrict","skip","test","virtuals","$isMongooseArray","query","multipleCastError","addError","numberOps","$pop","$inc","noCastOps","$unset","$push","$addToSet","overwriteOps","$conditional","path","cond","schemaArrayDepth","cur","arrayDepth","_val","additionalNesting","tmp","applySetters","castForQueryWrapper","$type","Boolean","$skipQueryCastForUpdate","$fullPath","match","$applySetters"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\r\n\r\nconst CastError = require('../../error/cast');\r\nconst MongooseError = require('../../error/mongooseError');\r\nconst StrictModeError = require('../../error/strict');\r\nconst ValidationError = require('../../error/validation');\r\nconst castNumber = require('../../cast/number');\r\nconst cast = require('../../cast');\r\nconst getConstructorName = require('../getConstructorName');\r\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\r\nconst handleImmutable = require('./handleImmutable');\r\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\r\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\r\nconst setDottedPath = require('../path/setDottedPath');\r\nconst utils = require('../../utils');\r\n\r\n/**\r\n * Casts an update op based on the given schema\r\n *\r\n * @param {Schema} schema\r\n * @param {Object} obj\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.overwrite] defaults to false\r\n * @param {Boolean|String} [options.strict] defaults to true\r\n * @param {Query} context passed to setters\r\n * @return {Boolean} true iff the update is non-empty\r\n * @api private\r\n */\r\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\r\n  if (obj == null) {\r\n    return undefined;\r\n  }\r\n  options = options || {};\r\n  // Update pipeline\r\n  if (Array.isArray(obj)) {\r\n    const len = obj.length;\r\n    for (let i = 0; i < len; ++i) {\r\n      const ops = Object.keys(obj[i]);\r\n      for (const op of ops) {\r\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  if (options.upsert && !options.overwrite) {\r\n    moveImmutableProperties(schema, obj, context);\r\n  }\r\n\r\n  const ops = Object.keys(obj);\r\n  let i = ops.length;\r\n  const ret = {};\r\n  let val;\r\n  let hasDollarKey = false;\r\n  const overwrite = options.overwrite;\r\n\r\n  filter = filter || {};\r\n  while (i--) {\r\n    const op = ops[i];\r\n    // if overwrite is set, don't do any of the special $set stuff\r\n    if (op[0] !== '$' && !overwrite) {\r\n      // fix up $set sugar\r\n      if (!ret.$set) {\r\n        if (obj.$set) {\r\n          ret.$set = obj.$set;\r\n        } else {\r\n          ret.$set = {};\r\n        }\r\n      }\r\n      ret.$set[op] = obj[op];\r\n      ops.splice(i, 1);\r\n      if (!~ops.indexOf('$set')) ops.push('$set');\r\n    } else if (op === '$set') {\r\n      if (!ret.$set) {\r\n        ret[op] = obj[op];\r\n      }\r\n    } else {\r\n      ret[op] = obj[op];\r\n    }\r\n  }\r\n  // cast each value\r\n  i = ops.length;\r\n  while (i--) {\r\n    const op = ops[i];\r\n    val = ret[op];\r\n    hasDollarKey = hasDollarKey || op.startsWith('$');\r\n    const toUnset = {};\r\n    for (const key of Object.keys(val)) {\r\n      if (val[key] === undefined) {\r\n        toUnset[key] = 1;\r\n      }\r\n    }\r\n\r\n    if (val &&\r\n        typeof val === 'object' &&\r\n        !Buffer.isBuffer(val) &&\r\n        (!overwrite || hasDollarKey)) {\r\n      walkUpdatePath(schema, val, op, options, context, filter);\r\n    } else if (overwrite && ret && typeof ret === 'object') {\r\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\r\n    } else {\r\n      const msg = 'Invalid atomic update value for ' + op + '. '\r\n          + 'Expected an object, received ' + typeof val;\r\n      throw new Error(msg);\r\n    }\r\n\r\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\r\n      delete ret[op];\r\n      if (op === '$set' && !utils.isEmptyObject(toUnset)) {\r\n        // Unset all undefined values\r\n        ret['$unset'] = toUnset;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Object.keys(ret).length === 0 &&\r\n      options.upsert &&\r\n      Object.keys(filter).length > 0) {\r\n    // Trick the driver into allowing empty upserts to work around\r\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\r\n    return { $setOnInsert: filter };\r\n  }\r\n  return ret;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction castPipelineOperator(op, val) {\r\n  if (op === '$unset') {\r\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\r\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\r\n        ' a string or an array of strings');\r\n    }\r\n    return val;\r\n  }\r\n  if (op === '$project') {\r\n    if (val == null || typeof val !== 'object') {\r\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\r\n    }\r\n    return val;\r\n  }\r\n  if (op === '$addFields' || op === '$set') {\r\n    if (val == null || typeof val !== 'object') {\r\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\r\n    }\r\n    return val;\r\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\r\n    if (val == null || typeof val !== 'object') {\r\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\r\n    }\r\n    return val;\r\n  }\r\n\r\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\r\n}\r\n\r\n/**\r\n * Walk each path of obj and cast its values\r\n * according to its schema.\r\n *\r\n * @param {Schema} schema\r\n * @param {Object} obj part of a query\r\n * @param {String} op the atomic operator ($pull, $set, etc)\r\n * @param {Object} [options]\r\n * @param {Boolean|String} [options.strict]\r\n * @param {Query} context\r\n * @param {Object} filter\r\n * @param {String} pref path prefix (internal only)\r\n * @return {Bool} true if this path has keys to update\r\n * @api private\r\n */\r\n\r\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\r\n  const strict = options.strict;\r\n  const prefix = pref ? pref + '.' : '';\r\n  const keys = Object.keys(obj);\r\n  let i = keys.length;\r\n  let hasKeys = false;\r\n  let schematype;\r\n  let key;\r\n  let val;\r\n\r\n  let aggregatedError = null;\r\n\r\n  const strictMode = strict != null ? strict : schema.options.strict;\r\n\r\n  while (i--) {\r\n    key = keys[i];\r\n    val = obj[key];\r\n\r\n    // `$pull` is special because we need to cast the RHS as a query, not as\r\n    // an update.\r\n    if (op === '$pull') {\r\n      schematype = schema._getSchema(prefix + key);\r\n      if (schematype != null && schematype.schema != null) {\r\n        obj[key] = cast(schematype.schema, obj[key], options, context);\r\n        hasKeys = true;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    const discriminatorKey = (prefix ? prefix + key : key);\r\n    if (\r\n      schema.discriminatorMapping != null &&\r\n      discriminatorKey === schema.options.discriminatorKey &&\r\n      !options.overwriteDiscriminatorKey\r\n    ) {\r\n      if (strictMode === 'throw') {\r\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\r\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\r\n        continue;\r\n      } else if (strictMode) {\r\n        delete obj[key];\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (getConstructorName(val) === 'Object') {\r\n      // watch for embedded doc schemas\r\n      schematype = schema._getSchema(prefix + key);\r\n\r\n      if (schematype == null) {\r\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\r\n        if (_res.schematype != null) {\r\n          schematype = _res.schematype;\r\n        }\r\n      }\r\n\r\n      if (op !== '$setOnInsert' &&\r\n          !options.overwrite &&\r\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\r\n        continue;\r\n      }\r\n\r\n      if (schematype && schematype.caster && op in castOps) {\r\n        // embedded doc schema\r\n        if ('$each' in val) {\r\n          hasKeys = true;\r\n          try {\r\n            obj[key] = {\r\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\r\n            };\r\n          } catch (error) {\r\n            aggregatedError = _appendError(error, context, key, aggregatedError);\r\n          }\r\n\r\n          if (val.$slice != null) {\r\n            obj[key].$slice = val.$slice | 0;\r\n          }\r\n\r\n          if (val.$sort) {\r\n            obj[key].$sort = val.$sort;\r\n          }\r\n\r\n          if (val.$position != null) {\r\n            obj[key].$position = castNumber(val.$position);\r\n          }\r\n        } else {\r\n          if (schematype != null && schematype.$isSingleNested) {\r\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\r\n            try {\r\n              obj[key] = schematype.castForQuery(val, context, { strict: _strict });\r\n            } catch (error) {\r\n              aggregatedError = _appendError(error, context, key, aggregatedError);\r\n            }\r\n          } else {\r\n            try {\r\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\r\n            } catch (error) {\r\n              aggregatedError = _appendError(error, context, key, aggregatedError);\r\n            }\r\n          }\r\n\r\n          if (obj[key] === void 0) {\r\n            delete obj[key];\r\n            continue;\r\n          }\r\n\r\n          hasKeys = true;\r\n        }\r\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\r\n        // $currentDate can take an object\r\n        try {\r\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\r\n        } catch (error) {\r\n          aggregatedError = _appendError(error, context, key, aggregatedError);\r\n        }\r\n\r\n        if (obj[key] === void 0) {\r\n          delete obj[key];\r\n          continue;\r\n        }\r\n\r\n        hasKeys = true;\r\n      } else {\r\n        const pathToCheck = (prefix + key);\r\n        const v = schema._getPathType(pathToCheck);\r\n        let _strict = strict;\r\n        if (v && v.schema && _strict == null) {\r\n          _strict = v.schema.options.strict;\r\n        }\r\n\r\n        if (v.pathType === 'undefined') {\r\n          if (_strict === 'throw') {\r\n            throw new StrictModeError(pathToCheck);\r\n          } else if (_strict) {\r\n            delete obj[key];\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // gh-2314\r\n        // we should be able to set a schema-less field\r\n        // to an empty object literal\r\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\r\n          (utils.isObject(val) && Object.keys(val).length === 0);\r\n      }\r\n    } else {\r\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\r\n        pref : prefix + key;\r\n      schematype = schema._getSchema(checkPath);\r\n\r\n      // You can use `$setOnInsert` with immutable keys\r\n      if (op !== '$setOnInsert' &&\r\n          !options.overwrite &&\r\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\r\n        continue;\r\n      }\r\n\r\n      let pathDetails = schema._getPathType(checkPath);\r\n\r\n      // If no schema type, check for embedded discriminators because the\r\n      // filter or update may imply an embedded discriminator type. See #8378\r\n      if (schematype == null) {\r\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\r\n        if (_res.schematype != null) {\r\n          schematype = _res.schematype;\r\n          pathDetails = _res.type;\r\n        }\r\n      }\r\n\r\n      let isStrict = strict;\r\n      if (pathDetails && pathDetails.schema && strict == null) {\r\n        isStrict = pathDetails.schema.options.strict;\r\n      }\r\n\r\n      const skip = isStrict &&\r\n        !schematype &&\r\n        !/real|nested/.test(pathDetails.pathType);\r\n\r\n      if (skip) {\r\n        // Even if strict is `throw`, avoid throwing an error because of\r\n        // virtuals because of #6731\r\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\r\n          throw new StrictModeError(prefix + key);\r\n        } else {\r\n          delete obj[key];\r\n        }\r\n      } else {\r\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\r\n        // improving this.\r\n        if (op === '$rename') {\r\n          hasKeys = true;\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\r\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\r\n          } else {\r\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\r\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\r\n            // dotted properties in the updated object. See (gh-10200)\r\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\r\n            delete obj[key];\r\n          }\r\n        } catch (error) {\r\n          aggregatedError = _appendError(error, context, key, aggregatedError);\r\n        }\r\n\r\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\r\n          if (schematype &&\r\n              schematype.caster &&\r\n              !schematype.caster.$isMongooseArray &&\r\n              !schematype.caster[schemaMixedSymbol]) {\r\n            obj[key] = { $each: obj[key] };\r\n          }\r\n        }\r\n\r\n        if (obj[key] === void 0) {\r\n          delete obj[key];\r\n          continue;\r\n        }\r\n\r\n        hasKeys = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (aggregatedError != null) {\r\n    throw aggregatedError;\r\n  }\r\n\r\n  return hasKeys;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _appendError(error, query, key, aggregatedError) {\r\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\r\n    throw error;\r\n  }\r\n  aggregatedError = aggregatedError || new ValidationError();\r\n  aggregatedError.addError(key, error);\r\n  return aggregatedError;\r\n}\r\n\r\n/**\r\n * These operators should be cast to numbers instead\r\n * of their path schema type.\r\n * @api private\r\n */\r\n\r\nconst numberOps = {\r\n  $pop: 1,\r\n  $inc: 1\r\n};\r\n\r\n/**\r\n * These ops require no casting because the RHS doesn't do anything.\r\n * @api private\r\n */\r\n\r\nconst noCastOps = {\r\n  $unset: 1\r\n};\r\n\r\n/**\r\n * These operators require casting docs\r\n * to real Documents for Update operations.\r\n * @api private\r\n */\r\n\r\nconst castOps = {\r\n  $push: 1,\r\n  $addToSet: 1,\r\n  $set: 1,\r\n  $setOnInsert: 1\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nconst overwriteOps = {\r\n  $set: 1,\r\n  $setOnInsert: 1\r\n};\r\n\r\n/**\r\n * Casts `val` according to `schema` and atomic `op`.\r\n *\r\n * @param {SchemaType} schema\r\n * @param {Object} val\r\n * @param {String} op the atomic operator ($pull, $set, etc)\r\n * @param {String} $conditional\r\n * @param {Query} context\r\n * @param {String} path\r\n * @api private\r\n */\r\n\r\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\r\n  if (!schema) {\r\n    // non-existing schema path\r\n    if (op in numberOps) {\r\n      try {\r\n        return castNumber(val);\r\n      } catch (err) {\r\n        throw new CastError('number', val, path);\r\n      }\r\n    }\r\n    return val;\r\n  }\r\n\r\n  // console.log('CastUpdateVal', path, op, val, schema);\r\n\r\n  const cond = schema.caster && op in castOps &&\r\n      (utils.isObject(val) || Array.isArray(val));\r\n  if (cond && !overwriteOps[op]) {\r\n    // Cast values for ops that add data to MongoDB.\r\n    // Ensures embedded documents get ObjectIds etc.\r\n    let schemaArrayDepth = 0;\r\n    let cur = schema;\r\n    while (cur.$isMongooseArray) {\r\n      ++schemaArrayDepth;\r\n      cur = cur.caster;\r\n    }\r\n    let arrayDepth = 0;\r\n    let _val = val;\r\n    while (Array.isArray(_val)) {\r\n      ++arrayDepth;\r\n      _val = _val[0];\r\n    }\r\n\r\n    const additionalNesting = schemaArrayDepth - arrayDepth;\r\n    while (arrayDepth < schemaArrayDepth) {\r\n      val = [val];\r\n      ++arrayDepth;\r\n    }\r\n\r\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\r\n\r\n    for (let i = 0; i < additionalNesting; ++i) {\r\n      tmp = tmp[0];\r\n    }\r\n    return tmp;\r\n  }\r\n\r\n  if (op in noCastOps) {\r\n    return val;\r\n  }\r\n  if (op in numberOps) {\r\n    // Null and undefined not allowed for $pop, $inc\r\n    if (val == null) {\r\n      throw new CastError('number', val, schema.path);\r\n    }\r\n    if (op === '$inc') {\r\n      // Support `$inc` with long, int32, etc. (gh-4283)\r\n      return schema.castForQueryWrapper({\r\n        val: val,\r\n        context: context\r\n      });\r\n    }\r\n    try {\r\n      return castNumber(val);\r\n    } catch (error) {\r\n      throw new CastError('number', val, schema.path);\r\n    }\r\n  }\r\n  if (op === '$currentDate') {\r\n    if (typeof val === 'object') {\r\n      return { $type: val.$type };\r\n    }\r\n    return Boolean(val);\r\n  }\r\n\r\n  if (/^\\$/.test($conditional)) {\r\n    return schema.castForQueryWrapper({\r\n      $conditional: $conditional,\r\n      val: val,\r\n      context: context\r\n    });\r\n  }\r\n\r\n  if (overwriteOps[op]) {\r\n    return schema.castForQueryWrapper({\r\n      val: val,\r\n      context: context,\r\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/),\r\n      $applySetters: schema[schemaMixedSymbol] != null\r\n    });\r\n  }\r\n\r\n  return schema.castForQueryWrapper({ val: val, context: context });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}