{"ast":null,"code":"'use strict';\n\nconst utils = require('./utils');\n\n/**\r\n * VirtualType constructor\r\n *\r\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\r\n *\r\n * #### Example:\r\n *\r\n *     const fullname = schema.virtual('fullname');\r\n *     fullname instanceof mongoose.VirtualType // true\r\n *\r\n * @param {Object} options\r\n * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](/docs/populate.html#populate-virtuals)\r\n * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.\r\n * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\r\n * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\r\n * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\r\n * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](./api/query.html#query_Query-countDocuments)\r\n * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`\r\n * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query\r\n * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query\r\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\r\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\r\n * @param {String} name\r\n * @api public\r\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = Object.assign({}, options);\n}\n\n/**\r\n * If no getters/setters, add a default\r\n *\r\n * @api private\r\n */\n\nVirtualType.prototype._applyDefaultGetters = function () {\n  if (this.getters.length > 0 || this.setters.length > 0) {\n    return;\n  }\n  const path = this.path;\n  const internalProperty = '$' + path;\n  this.getters.push(function () {\n    return this.$locals[internalProperty];\n  });\n  this.setters.push(function (v) {\n    this.$locals[internalProperty] = v;\n  });\n};\n\n/*!\r\n * ignore\r\n */\n\nVirtualType.prototype.clone = function () {\n  const clone = new VirtualType(this.options, this.path);\n  clone.getters = [].concat(this.getters);\n  clone.setters = [].concat(this.setters);\n  return clone;\n};\n\n/**\r\n * Adds a custom getter to this virtual.\r\n *\r\n * Mongoose calls the getter function with the below 3 parameters.\r\n *\r\n * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\r\n * - `virtual`: the virtual object you called `.get()` on.\r\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\r\n *\r\n * #### Example:\r\n *\r\n *     const virtual = schema.virtual('fullname');\r\n *     virtual.get(function(value, virtual, doc) {\r\n *       return this.name.first + ' ' + this.name.last;\r\n *     });\r\n *\r\n * @param {Function} fn\r\n * @return {VirtualType} this\r\n * @api public\r\n */\n\nVirtualType.prototype.get = function (fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\r\n * Adds a custom setter to this virtual.\r\n *\r\n * Mongoose calls the setter function with the below 3 parameters.\r\n *\r\n * - `value`: the value being set.\r\n * - `virtual`: the virtual object you're calling `.set()` on.\r\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\r\n *\r\n * #### Example:\r\n *\r\n *     const virtual = schema.virtual('fullname');\r\n *     virtual.set(function(value, virtual, doc) {\r\n *       const parts = value.split(' ');\r\n *       this.name.first = parts[0];\r\n *       this.name.last = parts[1];\r\n *     });\r\n *\r\n *     const Model = mongoose.model('Test', schema);\r\n *     const doc = new Model();\r\n *     // Calls the setter with `value = 'Jean-Luc Picard'`\r\n *     doc.fullname = 'Jean-Luc Picard';\r\n *     doc.name.first; // 'Jean-Luc'\r\n *     doc.name.last; // 'Picard'\r\n *\r\n * @param {Function} fn\r\n * @return {VirtualType} this\r\n * @api public\r\n */\n\nVirtualType.prototype.set = function (fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\r\n * Applies getters to `value`.\r\n *\r\n * @param {Object} value\r\n * @param {Document} doc The document this virtual is attached to\r\n * @return {Any} the value after applying all getters\r\n * @api public\r\n */\n\nVirtualType.prototype.applyGetters = function (value, doc) {\n  if (utils.hasUserDefinedProperty(this.options, ['ref', 'refPath']) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {\n    value = doc.$$populatedVirtuals[this.path];\n  }\n  let v = value;\n  for (const getter of this.getters) {\n    v = getter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/**\r\n * Applies setters to `value`.\r\n *\r\n * @param {Object} value\r\n * @param {Document} doc\r\n * @return {Any} the value after applying all setters\r\n * @api public\r\n */\n\nVirtualType.prototype.applySetters = function (value, doc) {\n  let v = value;\n  for (const setter of this.setters) {\n    v = setter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/*!\r\n * exports\r\n */\n\nmodule.exports = VirtualType;","map":{"version":3,"names":["utils","require","VirtualType","options","name","path","getters","setters","Object","assign","prototype","_applyDefaultGetters","length","internalProperty","push","$locals","v","clone","concat","get","fn","set","applyGetters","value","doc","hasUserDefinedProperty","$$populatedVirtuals","hasOwnProperty","getter","call","applySetters","setter","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/virtualtype.js"],"sourcesContent":["'use strict';\r\n\r\nconst utils = require('./utils');\r\n\r\n/**\r\n * VirtualType constructor\r\n *\r\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\r\n *\r\n * #### Example:\r\n *\r\n *     const fullname = schema.virtual('fullname');\r\n *     fullname instanceof mongoose.VirtualType // true\r\n *\r\n * @param {Object} options\r\n * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](/docs/populate.html#populate-virtuals)\r\n * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.\r\n * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\r\n * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\r\n * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\r\n * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](./api/query.html#query_Query-countDocuments)\r\n * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`\r\n * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query\r\n * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query\r\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\r\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\r\n * @param {String} name\r\n * @api public\r\n */\r\n\r\nfunction VirtualType(options, name) {\r\n  this.path = name;\r\n  this.getters = [];\r\n  this.setters = [];\r\n  this.options = Object.assign({}, options);\r\n}\r\n\r\n/**\r\n * If no getters/setters, add a default\r\n *\r\n * @api private\r\n */\r\n\r\nVirtualType.prototype._applyDefaultGetters = function() {\r\n  if (this.getters.length > 0 || this.setters.length > 0) {\r\n    return;\r\n  }\r\n\r\n  const path = this.path;\r\n  const internalProperty = '$' + path;\r\n  this.getters.push(function() {\r\n    return this.$locals[internalProperty];\r\n  });\r\n  this.setters.push(function(v) {\r\n    this.$locals[internalProperty] = v;\r\n  });\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nVirtualType.prototype.clone = function() {\r\n  const clone = new VirtualType(this.options, this.path);\r\n  clone.getters = [].concat(this.getters);\r\n  clone.setters = [].concat(this.setters);\r\n  return clone;\r\n};\r\n\r\n/**\r\n * Adds a custom getter to this virtual.\r\n *\r\n * Mongoose calls the getter function with the below 3 parameters.\r\n *\r\n * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\r\n * - `virtual`: the virtual object you called `.get()` on.\r\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\r\n *\r\n * #### Example:\r\n *\r\n *     const virtual = schema.virtual('fullname');\r\n *     virtual.get(function(value, virtual, doc) {\r\n *       return this.name.first + ' ' + this.name.last;\r\n *     });\r\n *\r\n * @param {Function} fn\r\n * @return {VirtualType} this\r\n * @api public\r\n */\r\n\r\nVirtualType.prototype.get = function(fn) {\r\n  this.getters.push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds a custom setter to this virtual.\r\n *\r\n * Mongoose calls the setter function with the below 3 parameters.\r\n *\r\n * - `value`: the value being set.\r\n * - `virtual`: the virtual object you're calling `.set()` on.\r\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\r\n *\r\n * #### Example:\r\n *\r\n *     const virtual = schema.virtual('fullname');\r\n *     virtual.set(function(value, virtual, doc) {\r\n *       const parts = value.split(' ');\r\n *       this.name.first = parts[0];\r\n *       this.name.last = parts[1];\r\n *     });\r\n *\r\n *     const Model = mongoose.model('Test', schema);\r\n *     const doc = new Model();\r\n *     // Calls the setter with `value = 'Jean-Luc Picard'`\r\n *     doc.fullname = 'Jean-Luc Picard';\r\n *     doc.name.first; // 'Jean-Luc'\r\n *     doc.name.last; // 'Picard'\r\n *\r\n * @param {Function} fn\r\n * @return {VirtualType} this\r\n * @api public\r\n */\r\n\r\nVirtualType.prototype.set = function(fn) {\r\n  this.setters.push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Applies getters to `value`.\r\n *\r\n * @param {Object} value\r\n * @param {Document} doc The document this virtual is attached to\r\n * @return {Any} the value after applying all getters\r\n * @api public\r\n */\r\n\r\nVirtualType.prototype.applyGetters = function(value, doc) {\r\n  if (utils.hasUserDefinedProperty(this.options, ['ref', 'refPath']) &&\r\n      doc.$$populatedVirtuals &&\r\n      doc.$$populatedVirtuals.hasOwnProperty(this.path)) {\r\n    value = doc.$$populatedVirtuals[this.path];\r\n  }\r\n\r\n  let v = value;\r\n  for (const getter of this.getters) {\r\n    v = getter.call(doc, v, this, doc);\r\n  }\r\n  return v;\r\n};\r\n\r\n/**\r\n * Applies setters to `value`.\r\n *\r\n * @param {Object} value\r\n * @param {Document} doc\r\n * @return {Any} the value after applying all setters\r\n * @api public\r\n */\r\n\r\nVirtualType.prototype.applySetters = function(value, doc) {\r\n  let v = value;\r\n  for (const setter of this.setters) {\r\n    v = setter.call(doc, v, this, doc);\r\n  }\r\n  return v;\r\n};\r\n\r\n/*!\r\n * exports\r\n */\r\n\r\nmodule.exports = VirtualType;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}