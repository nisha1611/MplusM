{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\nconst {\n  inspect\n} = require('util');\nconst mustCallChecks = [];\nfunction noop() {}\nfunction runCallChecks(exitCode) {\n  if (exitCode !== 0) return;\n  const failed = mustCallChecks.filter(context => {\n    if ('minimum' in context) {\n      context.messageSegment = `at least ${context.minimum}`;\n      return context.actual < context.minimum;\n    }\n    context.messageSegment = `exactly ${context.exact}`;\n    return context.actual !== context.exact;\n  });\n  failed.forEach(context => {\n    console.error('Mismatched %s function calls. Expected %s, actual %d.', context.name, context.messageSegment, context.actual);\n    console.error(context.stack.split('\\n').slice(2).join('\\n'));\n  });\n  if (failed.length) process.exit(1);\n}\nfunction mustCall(fn, exact) {\n  return _mustCallInner(fn, exact, 'exact');\n}\nfunction mustCallAtLeast(fn, minimum) {\n  return _mustCallInner(fn, minimum, 'minimum');\n}\nfunction _mustCallInner(fn) {\n  let criteria = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let field = arguments.length > 2 ? arguments[2] : undefined;\n  if (process._exiting) throw new Error('Cannot use common.mustCall*() in process exit handler');\n  if (typeof fn === 'number') {\n    criteria = fn;\n    fn = noop;\n  } else if (fn === undefined) {\n    fn = noop;\n  }\n  if (typeof criteria !== 'number') throw new TypeError(`Invalid ${field} value: ${criteria}`);\n  const context = {\n    [field]: criteria,\n    actual: 0,\n    stack: inspect(new Error()),\n    name: fn.name || '<anonymous>'\n  };\n\n  // Add the exit listener only once to avoid listener leak warnings\n  if (mustCallChecks.length === 0) process.on('exit', runCallChecks);\n  mustCallChecks.push(context);\n  function wrapped() {\n    ++context.actual;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return fn.call(this, ...args);\n  }\n  // TODO: remove origFn?\n  wrapped.origFn = fn;\n  return wrapped;\n}\nfunction getCallSite(top) {\n  const originalStackFormatter = Error.prepareStackTrace;\n  Error.prepareStackTrace = (err, stack) => `${stack[0].getFileName()}:${stack[0].getLineNumber()}`;\n  const err = new Error();\n  Error.captureStackTrace(err, top);\n  // With the V8 Error API, the stack is not formatted until it is accessed\n  // eslint-disable-next-line no-unused-expressions\n  err.stack;\n  Error.prepareStackTrace = originalStackFormatter;\n  return err.stack;\n}\nfunction mustNotCall(msg) {\n  const callSite = getCallSite(mustNotCall);\n  return function mustNotCall() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    args = args.map(inspect).join(', ');\n    const argsInfo = args.length > 0 ? `\\ncalled with arguments: ${args}` : '';\n    assert.fail(`${msg || 'function should not have been called'} at ${callSite}` + argsInfo);\n  };\n}\nmodule.exports = {\n  mustCall,\n  mustCallAtLeast,\n  mustNotCall\n};","map":{"version":3,"names":["assert","require","inspect","mustCallChecks","noop","runCallChecks","exitCode","failed","filter","context","messageSegment","minimum","actual","exact","forEach","console","error","name","stack","split","slice","join","length","process","exit","mustCall","fn","_mustCallInner","mustCallAtLeast","criteria","field","_exiting","Error","undefined","TypeError","on","push","wrapped","args","call","origFn","getCallSite","top","originalStackFormatter","prepareStackTrace","err","getFileName","getLineNumber","captureStackTrace","mustNotCall","msg","callSite","map","argsInfo","fail","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/busboy/test/common.js"],"sourcesContent":["'use strict';\n\nconst assert = require('assert');\nconst { inspect } = require('util');\n\nconst mustCallChecks = [];\n\nfunction noop() {}\n\nfunction runCallChecks(exitCode) {\n  if (exitCode !== 0) return;\n\n  const failed = mustCallChecks.filter((context) => {\n    if ('minimum' in context) {\n      context.messageSegment = `at least ${context.minimum}`;\n      return context.actual < context.minimum;\n    }\n    context.messageSegment = `exactly ${context.exact}`;\n    return context.actual !== context.exact;\n  });\n\n  failed.forEach((context) => {\n    console.error('Mismatched %s function calls. Expected %s, actual %d.',\n                  context.name,\n                  context.messageSegment,\n                  context.actual);\n    console.error(context.stack.split('\\n').slice(2).join('\\n'));\n  });\n\n  if (failed.length)\n    process.exit(1);\n}\n\nfunction mustCall(fn, exact) {\n  return _mustCallInner(fn, exact, 'exact');\n}\n\nfunction mustCallAtLeast(fn, minimum) {\n  return _mustCallInner(fn, minimum, 'minimum');\n}\n\nfunction _mustCallInner(fn, criteria = 1, field) {\n  if (process._exiting)\n    throw new Error('Cannot use common.mustCall*() in process exit handler');\n\n  if (typeof fn === 'number') {\n    criteria = fn;\n    fn = noop;\n  } else if (fn === undefined) {\n    fn = noop;\n  }\n\n  if (typeof criteria !== 'number')\n    throw new TypeError(`Invalid ${field} value: ${criteria}`);\n\n  const context = {\n    [field]: criteria,\n    actual: 0,\n    stack: inspect(new Error()),\n    name: fn.name || '<anonymous>'\n  };\n\n  // Add the exit listener only once to avoid listener leak warnings\n  if (mustCallChecks.length === 0)\n    process.on('exit', runCallChecks);\n\n  mustCallChecks.push(context);\n\n  function wrapped(...args) {\n    ++context.actual;\n    return fn.call(this, ...args);\n  }\n  // TODO: remove origFn?\n  wrapped.origFn = fn;\n\n  return wrapped;\n}\n\nfunction getCallSite(top) {\n  const originalStackFormatter = Error.prepareStackTrace;\n  Error.prepareStackTrace = (err, stack) =>\n    `${stack[0].getFileName()}:${stack[0].getLineNumber()}`;\n  const err = new Error();\n  Error.captureStackTrace(err, top);\n  // With the V8 Error API, the stack is not formatted until it is accessed\n  // eslint-disable-next-line no-unused-expressions\n  err.stack;\n  Error.prepareStackTrace = originalStackFormatter;\n  return err.stack;\n}\n\nfunction mustNotCall(msg) {\n  const callSite = getCallSite(mustNotCall);\n  return function mustNotCall(...args) {\n    args = args.map(inspect).join(', ');\n    const argsInfo = (args.length > 0\n                      ? `\\ncalled with arguments: ${args}`\n                      : '');\n    assert.fail(\n      `${msg || 'function should not have been called'} at ${callSite}`\n        + argsInfo);\n  };\n}\n\nmodule.exports = {\n  mustCall,\n  mustCallAtLeast,\n  mustNotCall,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}