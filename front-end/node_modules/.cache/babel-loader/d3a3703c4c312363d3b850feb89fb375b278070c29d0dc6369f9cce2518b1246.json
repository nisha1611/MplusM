{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\r\n * @typedef {Object} PathItem\r\n * @property {any} schema the part of the schema\r\n * @property {string} path the path in the config\r\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\r\n * @typedef {Object} Problem\r\n * @property {ProblemType} type\r\n * @property {string} path\r\n * @property {string} argument\r\n * @property {any=} value\r\n * @property {number=} index\r\n * @property {string=} expected\r\n */\n\n/**\r\n * @typedef {Object} LocalProblem\r\n * @property {ProblemType} type\r\n * @property {string} path\r\n * @property {string=} expected\r\n */\n\n/**\r\n * @typedef {Object} ArgumentConfig\r\n * @property {string} description\r\n * @property {string} [negatedDescription]\r\n * @property {string} path\r\n * @property {boolean} multiple\r\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\r\n * @property {any[]=} values\r\n */\n\n/**\r\n * @typedef {Object} Argument\r\n * @property {string} description\r\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\r\n * @property {boolean} multiple\r\n * @property {ArgumentConfig[]} configs\r\n */\n\n/**\r\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\r\n * @returns {Record<string, Argument>} object of arguments\r\n */\nconst getArguments = function () {\n  let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : webpackSchema;\n  /** @type {Record<string, Argument>} */\n  const flags = {};\n  const pathToArgumentName = input => {\n    return input.replace(/\\./g, \"-\").replace(/\\[\\]/g, \"\").replace(/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu, \"$1-$2\").replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\").toLowerCase();\n  };\n  const getSchemaPart = path => {\n    const newPath = path.split(\"/\");\n    let schemaPart = schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  };\n\n  /**\r\n   *\r\n   * @param {PathItem[]} path path in the schema\r\n   * @returns {string | undefined} description\r\n   */\n  const getDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.description) return schema.cli.description;\n      }\n      if (schema.description) return schema.description;\n    }\n  };\n\n  /**\r\n   *\r\n   * @param {PathItem[]} path path in the schema\r\n   * @returns {string | undefined} negative description\r\n   */\n  const getNegatedDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n      }\n    }\n  };\n\n  /**\r\n   *\r\n   * @param {PathItem[]} path path in the schema\r\n   * @returns {string | undefined} reset description\r\n   */\n  const getResetDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.resetDescription) return schema.cli.resetDescription;\n      }\n    }\n  };\n\n  /**\r\n   *\r\n   * @param {any} schemaPart schema\r\n   * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\r\n   */\n  const schemaToArgumentConfig = schemaPart => {\n    if (schemaPart.enum) {\n      return {\n        type: \"enum\",\n        values: schemaPart.enum\n      };\n    }\n    switch (schemaPart.type) {\n      case \"number\":\n        return {\n          type: \"number\"\n        };\n      case \"string\":\n        return {\n          type: schemaPart.absolutePath ? \"path\" : \"string\"\n        };\n      case \"boolean\":\n        return {\n          type: \"boolean\"\n        };\n    }\n    if (schemaPart.instanceof === \"RegExp\") {\n      return {\n        type: \"RegExp\"\n      };\n    }\n    return undefined;\n  };\n\n  /**\r\n   * @param {PathItem[]} path path in the schema\r\n   * @returns {void}\r\n   */\n  const addResetFlag = path => {\n    const schemaPath = path[0].path;\n    const name = pathToArgumentName(`${schemaPath}.reset`);\n    const description = getResetDescription(path) || `Clear all items provided in '${schemaPath}' configuration. ${getDescription(path)}`;\n    flags[name] = {\n      configs: [{\n        type: \"reset\",\n        multiple: false,\n        description,\n        path: schemaPath\n      }],\n      description: undefined,\n      simpleType: undefined,\n      multiple: undefined\n    };\n  };\n\n  /**\r\n   * @param {PathItem[]} path full path in schema\r\n   * @param {boolean} multiple inside of an array\r\n   * @returns {number} number of arguments added\r\n   */\n  const addFlag = (path, multiple) => {\n    const argConfigBase = schemaToArgumentConfig(path[0].schema);\n    if (!argConfigBase) return 0;\n    const negatedDescription = getNegatedDescription(path);\n    const name = pathToArgumentName(path[0].path);\n    /** @type {ArgumentConfig} */\n    const argConfig = {\n      ...argConfigBase,\n      multiple,\n      description: getDescription(path),\n      path: path[0].path\n    };\n    if (negatedDescription) {\n      argConfig.negatedDescription = negatedDescription;\n    }\n    if (!flags[name]) {\n      flags[name] = {\n        configs: [],\n        description: undefined,\n        simpleType: undefined,\n        multiple: undefined\n      };\n    }\n    if (flags[name].configs.some(item => JSON.stringify(item) === JSON.stringify(argConfig))) {\n      return 0;\n    }\n    if (flags[name].configs.some(item => item.type === argConfig.type && item.multiple !== multiple)) {\n      if (multiple) {\n        throw new Error(`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`);\n      }\n      return 0;\n    }\n    flags[name].configs.push(argConfig);\n    return 1;\n  };\n\n  // TODO support `not` and `if/then/else`\n  // TODO support `const`, but we don't use it on our schema\n  /**\r\n   *\r\n   * @param {object} schemaPart the current schema\r\n   * @param {string} schemaPath the current path in the schema\r\n   * @param {{schema: object, path: string}[]} path all previous visited schemaParts\r\n   * @param {string | null} inArray if inside of an array, the path to the array\r\n   * @returns {number} added arguments\r\n   */\n  const traverse = function (schemaPart) {\n    let schemaPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let inArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    while (schemaPart.$ref) {\n      schemaPart = getSchemaPart(schemaPart.$ref);\n    }\n    const repetitions = path.filter(_ref => {\n      let {\n        schema\n      } = _ref;\n      return schema === schemaPart;\n    });\n    if (repetitions.length >= 2 || repetitions.some(_ref2 => {\n      let {\n        path\n      } = _ref2;\n      return path === schemaPath;\n    })) {\n      return 0;\n    }\n    if (schemaPart.cli && schemaPart.cli.exclude) return 0;\n    const fullPath = [{\n      schema: schemaPart,\n      path: schemaPath\n    }, ...path];\n    let addedArguments = 0;\n    addedArguments += addFlag(fullPath, !!inArray);\n    if (schemaPart.type === \"object\") {\n      if (schemaPart.properties) {\n        for (const property of Object.keys(schemaPart.properties)) {\n          addedArguments += traverse(schemaPart.properties[property], schemaPath ? `${schemaPath}.${property}` : property, fullPath, inArray);\n        }\n      }\n      return addedArguments;\n    }\n    if (schemaPart.type === \"array\") {\n      if (inArray) {\n        return 0;\n      }\n      if (Array.isArray(schemaPart.items)) {\n        let i = 0;\n        for (const item of schemaPart.items) {\n          addedArguments += traverse(item, `${schemaPath}.${i}`, fullPath, schemaPath);\n        }\n        return addedArguments;\n      }\n      addedArguments += traverse(schemaPart.items, `${schemaPath}[]`, fullPath, schemaPath);\n      if (addedArguments > 0) {\n        addResetFlag(fullPath);\n        addedArguments++;\n      }\n      return addedArguments;\n    }\n    const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n    if (maybeOf) {\n      const items = maybeOf;\n      for (let i = 0; i < items.length; i++) {\n        addedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n      }\n      return addedArguments;\n    }\n    return addedArguments;\n  };\n  traverse(schema);\n\n  // Summarize flags\n  for (const name of Object.keys(flags)) {\n    const argument = flags[name];\n    argument.description = argument.configs.reduce((desc, _ref3) => {\n      let {\n        description\n      } = _ref3;\n      if (!desc) return description;\n      if (!description) return desc;\n      if (desc.includes(description)) return desc;\n      return `${desc} ${description}`;\n    }, /** @type {string | undefined} */undefined);\n    argument.simpleType = argument.configs.reduce((t, argConfig) => {\n      /** @type {\"string\" | \"number\" | \"boolean\"} */\n      let type = \"string\";\n      switch (argConfig.type) {\n        case \"number\":\n          type = \"number\";\n          break;\n        case \"reset\":\n        case \"boolean\":\n          type = \"boolean\";\n          break;\n        case \"enum\":\n          if (argConfig.values.every(v => typeof v === \"boolean\")) type = \"boolean\";\n          if (argConfig.values.every(v => typeof v === \"number\")) type = \"number\";\n          break;\n      }\n      if (t === undefined) return type;\n      return t === type ? t : \"string\";\n    }, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */undefined);\n    argument.multiple = argument.configs.some(c => c.multiple);\n  }\n  return flags;\n};\nconst cliAddedItems = new WeakMap();\n\n/**\r\n * @param {any} config configuration\r\n * @param {string} schemaPath path in the config\r\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\r\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\r\n */\nconst getObjectAndProperty = function (config, schemaPath) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!schemaPath) return {\n    value: config\n  };\n  const parts = schemaPath.split(\".\");\n  let property = parts.pop();\n  let current = config;\n  let i = 0;\n  for (const part of parts) {\n    const isArray = part.endsWith(\"[]\");\n    const name = isArray ? part.slice(0, -2) : part;\n    let value = current[name];\n    if (isArray) {\n      if (value === undefined) {\n        value = {};\n        current[name] = [...Array.from({\n          length: index\n        }), value];\n        cliAddedItems.set(current[name], index + 1);\n      } else if (!Array.isArray(value)) {\n        return {\n          problem: {\n            type: \"unexpected-non-array-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      } else {\n        let addedItems = cliAddedItems.get(value) || 0;\n        while (addedItems <= index) {\n          value.push(undefined);\n          addedItems++;\n        }\n        cliAddedItems.set(value, addedItems);\n        const x = value.length - addedItems + index;\n        if (value[x] === undefined) {\n          value[x] = {};\n        } else if (value[x] === null || typeof value[x] !== \"object\") {\n          return {\n            problem: {\n              type: \"unexpected-non-object-in-path\",\n              path: parts.slice(0, i).join(\".\")\n            }\n          };\n        }\n        value = value[x];\n      }\n    } else {\n      if (value === undefined) {\n        value = current[name] = {};\n      } else if (value === null || typeof value !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      }\n    }\n    current = value;\n    i++;\n  }\n  let value = current[property];\n  if (property.endsWith(\"[]\")) {\n    const name = property.slice(0, -2);\n    const value = current[name];\n    if (value === undefined) {\n      current[name] = [...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index,\n        value: undefined\n      };\n    } else if (!Array.isArray(value)) {\n      current[name] = [value, ...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index + 1,\n        value: undefined\n      };\n    } else {\n      let addedItems = cliAddedItems.get(value) || 0;\n      while (addedItems <= index) {\n        value.push(undefined);\n        addedItems++;\n      }\n      cliAddedItems.set(value, addedItems);\n      const x = value.length - addedItems + index;\n      if (value[x] === undefined) {\n        value[x] = {};\n      } else if (value[x] === null || typeof value[x] !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: schemaPath\n          }\n        };\n      }\n      return {\n        object: value,\n        property: x,\n        value: value[x]\n      };\n    }\n  }\n  return {\n    object: current,\n    property,\n    value\n  };\n};\n\n/**\r\n * @param {any} config configuration\r\n * @param {string} schemaPath path in the config\r\n * @param {any} value parsed value\r\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\r\n * @returns {LocalProblem | null} problem or null for success\r\n */\nconst setValue = (config, schemaPath, value, index) => {\n  const {\n    problem,\n    object,\n    property\n  } = getObjectAndProperty(config, schemaPath, index);\n  if (problem) return problem;\n  object[property] = value;\n  return null;\n};\n\n/**\r\n * @param {ArgumentConfig} argConfig processing instructions\r\n * @param {any} config configuration\r\n * @param {any} value the value\r\n * @param {number | undefined} index the index if multiple values provided\r\n * @returns {LocalProblem | null} a problem if any\r\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n  if (index !== undefined && !argConfig.multiple) {\n    return {\n      type: \"multiple-values-unexpected\",\n      path: argConfig.path\n    };\n  }\n  const parsed = parseValueForArgumentConfig(argConfig, value);\n  if (parsed === undefined) {\n    return {\n      type: \"invalid-value\",\n      path: argConfig.path,\n      expected: getExpectedValue(argConfig)\n    };\n  }\n  const problem = setValue(config, argConfig.path, parsed, index);\n  if (problem) return problem;\n  return null;\n};\n\n/**\r\n * @param {ArgumentConfig} argConfig processing instructions\r\n * @returns {string | undefined} expected message\r\n */\nconst getExpectedValue = argConfig => {\n  switch (argConfig.type) {\n    default:\n      return argConfig.type;\n    case \"boolean\":\n      return \"true | false\";\n    case \"RegExp\":\n      return \"regular expression (example: /ab?c*/)\";\n    case \"enum\":\n      return argConfig.values.map(v => `${v}`).join(\" | \");\n    case \"reset\":\n      return \"true (will reset the previous value to an empty array)\";\n  }\n};\n\n/**\r\n * @param {ArgumentConfig} argConfig processing instructions\r\n * @param {any} value the value\r\n * @returns {any | undefined} parsed value\r\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n  switch (argConfig.type) {\n    case \"string\":\n      if (typeof value === \"string\") {\n        return value;\n      }\n      break;\n    case \"path\":\n      if (typeof value === \"string\") {\n        return path.resolve(value);\n      }\n      break;\n    case \"number\":\n      if (typeof value === \"number\") return value;\n      if (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n        const n = +value;\n        if (!isNaN(n)) return n;\n      }\n      break;\n    case \"boolean\":\n      if (typeof value === \"boolean\") return value;\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n      break;\n    case \"RegExp\":\n      if (value instanceof RegExp) return value;\n      if (typeof value === \"string\") {\n        // cspell:word yugi\n        const match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n        if (match && !/[^\\\\]\\//.test(match[1])) return new RegExp(match[1], match[2]);\n      }\n      break;\n    case \"enum\":\n      if (argConfig.values.includes(value)) return value;\n      for (const item of argConfig.values) {\n        if (`${item}` === value) return item;\n      }\n      break;\n    case \"reset\":\n      if (value === true) return [];\n      break;\n  }\n};\n\n/**\r\n * @param {Record<string, Argument>} args object of arguments\r\n * @param {any} config configuration\r\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\r\n * @returns {Problem[] | null} problems or null for success\r\n */\nconst processArguments = (args, config, values) => {\n  /** @type {Problem[]} */\n  const problems = [];\n  for (const key of Object.keys(values)) {\n    const arg = args[key];\n    if (!arg) {\n      problems.push({\n        type: \"unknown-argument\",\n        path: \"\",\n        argument: key\n      });\n      continue;\n    }\n    const processValue = (value, i) => {\n      const currentProblems = [];\n      for (const argConfig of arg.configs) {\n        const problem = processArgumentConfig(argConfig, config, value, i);\n        if (!problem) {\n          return;\n        }\n        currentProblems.push({\n          ...problem,\n          argument: key,\n          value: value,\n          index: i\n        });\n      }\n      problems.push(...currentProblems);\n    };\n    let value = values[key];\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        processValue(value[i], i);\n      }\n    } else {\n      processValue(value, undefined);\n    }\n  }\n  if (problems.length === 0) return null;\n  return problems;\n};\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;","map":{"version":3,"names":["path","require","webpackSchema","getArguments","schema","flags","pathToArgumentName","input","replace","toLowerCase","getSchemaPart","newPath","split","schemaPart","i","length","inner","getDescription","cli","helper","description","getNegatedDescription","negatedDescription","getResetDescription","resetDescription","schemaToArgumentConfig","enum","type","values","absolutePath","instanceof","undefined","addResetFlag","schemaPath","name","configs","multiple","simpleType","addFlag","argConfigBase","argConfig","some","item","JSON","stringify","Error","push","traverse","inArray","$ref","repetitions","filter","exclude","fullPath","addedArguments","properties","property","Object","keys","Array","isArray","items","maybeOf","oneOf","anyOf","allOf","argument","reduce","desc","includes","t","every","v","c","cliAddedItems","WeakMap","getObjectAndProperty","config","index","value","parts","pop","current","part","endsWith","slice","from","set","problem","join","addedItems","get","x","object","setValue","processArgumentConfig","parsed","parseValueForArgumentConfig","expected","getExpectedValue","map","resolve","n","isNaN","RegExp","match","exec","test","processArguments","args","problems","key","arg","processValue","currentProblems","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/cli.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst path = require(\"path\");\r\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\r\n\r\n// TODO add originPath to PathItem for better errors\r\n/**\r\n * @typedef {Object} PathItem\r\n * @property {any} schema the part of the schema\r\n * @property {string} path the path in the config\r\n */\r\n\r\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\r\n\r\n/**\r\n * @typedef {Object} Problem\r\n * @property {ProblemType} type\r\n * @property {string} path\r\n * @property {string} argument\r\n * @property {any=} value\r\n * @property {number=} index\r\n * @property {string=} expected\r\n */\r\n\r\n/**\r\n * @typedef {Object} LocalProblem\r\n * @property {ProblemType} type\r\n * @property {string} path\r\n * @property {string=} expected\r\n */\r\n\r\n/**\r\n * @typedef {Object} ArgumentConfig\r\n * @property {string} description\r\n * @property {string} [negatedDescription]\r\n * @property {string} path\r\n * @property {boolean} multiple\r\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\r\n * @property {any[]=} values\r\n */\r\n\r\n/**\r\n * @typedef {Object} Argument\r\n * @property {string} description\r\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\r\n * @property {boolean} multiple\r\n * @property {ArgumentConfig[]} configs\r\n */\r\n\r\n/**\r\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\r\n * @returns {Record<string, Argument>} object of arguments\r\n */\r\nconst getArguments = (schema = webpackSchema) => {\r\n\t/** @type {Record<string, Argument>} */\r\n\tconst flags = {};\r\n\r\n\tconst pathToArgumentName = input => {\r\n\t\treturn input\r\n\t\t\t.replace(/\\./g, \"-\")\r\n\t\t\t.replace(/\\[\\]/g, \"\")\r\n\t\t\t.replace(\r\n\t\t\t\t/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu,\r\n\t\t\t\t\"$1-$2\"\r\n\t\t\t)\r\n\t\t\t.replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\")\r\n\t\t\t.toLowerCase();\r\n\t};\r\n\r\n\tconst getSchemaPart = path => {\r\n\t\tconst newPath = path.split(\"/\");\r\n\r\n\t\tlet schemaPart = schema;\r\n\r\n\t\tfor (let i = 1; i < newPath.length; i++) {\r\n\t\t\tconst inner = schemaPart[newPath[i]];\r\n\r\n\t\t\tif (!inner) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tschemaPart = inner;\r\n\t\t}\r\n\r\n\t\treturn schemaPart;\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t * @param {PathItem[]} path path in the schema\r\n\t * @returns {string | undefined} description\r\n\t */\r\n\tconst getDescription = path => {\r\n\t\tfor (const { schema } of path) {\r\n\t\t\tif (schema.cli) {\r\n\t\t\t\tif (schema.cli.helper) continue;\r\n\t\t\t\tif (schema.cli.description) return schema.cli.description;\r\n\t\t\t}\r\n\t\t\tif (schema.description) return schema.description;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t * @param {PathItem[]} path path in the schema\r\n\t * @returns {string | undefined} negative description\r\n\t */\r\n\tconst getNegatedDescription = path => {\r\n\t\tfor (const { schema } of path) {\r\n\t\t\tif (schema.cli) {\r\n\t\t\t\tif (schema.cli.helper) continue;\r\n\t\t\t\tif (schema.cli.negatedDescription) return schema.cli.negatedDescription;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t * @param {PathItem[]} path path in the schema\r\n\t * @returns {string | undefined} reset description\r\n\t */\r\n\tconst getResetDescription = path => {\r\n\t\tfor (const { schema } of path) {\r\n\t\t\tif (schema.cli) {\r\n\t\t\t\tif (schema.cli.helper) continue;\r\n\t\t\t\tif (schema.cli.resetDescription) return schema.cli.resetDescription;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t * @param {any} schemaPart schema\r\n\t * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\r\n\t */\r\n\tconst schemaToArgumentConfig = schemaPart => {\r\n\t\tif (schemaPart.enum) {\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"enum\",\r\n\t\t\t\tvalues: schemaPart.enum\r\n\t\t\t};\r\n\t\t}\r\n\t\tswitch (schemaPart.type) {\r\n\t\t\tcase \"number\":\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \"number\"\r\n\t\t\t\t};\r\n\t\t\tcase \"string\":\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: schemaPart.absolutePath ? \"path\" : \"string\"\r\n\t\t\t\t};\r\n\t\t\tcase \"boolean\":\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \"boolean\"\r\n\t\t\t\t};\r\n\t\t}\r\n\t\tif (schemaPart.instanceof === \"RegExp\") {\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"RegExp\"\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn undefined;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {PathItem[]} path path in the schema\r\n\t * @returns {void}\r\n\t */\r\n\tconst addResetFlag = path => {\r\n\t\tconst schemaPath = path[0].path;\r\n\t\tconst name = pathToArgumentName(`${schemaPath}.reset`);\r\n\t\tconst description =\r\n\t\t\tgetResetDescription(path) ||\r\n\t\t\t`Clear all items provided in '${schemaPath}' configuration. ${getDescription(\r\n\t\t\t\tpath\r\n\t\t\t)}`;\r\n\t\tflags[name] = {\r\n\t\t\tconfigs: [\r\n\t\t\t\t{\r\n\t\t\t\t\ttype: \"reset\",\r\n\t\t\t\t\tmultiple: false,\r\n\t\t\t\t\tdescription,\r\n\t\t\t\t\tpath: schemaPath\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: undefined,\r\n\t\t\tsimpleType: undefined,\r\n\t\t\tmultiple: undefined\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * @param {PathItem[]} path full path in schema\r\n\t * @param {boolean} multiple inside of an array\r\n\t * @returns {number} number of arguments added\r\n\t */\r\n\tconst addFlag = (path, multiple) => {\r\n\t\tconst argConfigBase = schemaToArgumentConfig(path[0].schema);\r\n\t\tif (!argConfigBase) return 0;\r\n\r\n\t\tconst negatedDescription = getNegatedDescription(path);\r\n\t\tconst name = pathToArgumentName(path[0].path);\r\n\t\t/** @type {ArgumentConfig} */\r\n\t\tconst argConfig = {\r\n\t\t\t...argConfigBase,\r\n\t\t\tmultiple,\r\n\t\t\tdescription: getDescription(path),\r\n\t\t\tpath: path[0].path\r\n\t\t};\r\n\r\n\t\tif (negatedDescription) {\r\n\t\t\targConfig.negatedDescription = negatedDescription;\r\n\t\t}\r\n\r\n\t\tif (!flags[name]) {\r\n\t\t\tflags[name] = {\r\n\t\t\t\tconfigs: [],\r\n\t\t\t\tdescription: undefined,\r\n\t\t\t\tsimpleType: undefined,\r\n\t\t\t\tmultiple: undefined\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tflags[name].configs.some(\r\n\t\t\t\titem => JSON.stringify(item) === JSON.stringify(argConfig)\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tflags[name].configs.some(\r\n\t\t\t\titem => item.type === argConfig.type && item.multiple !== multiple\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\tif (multiple) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tflags[name].configs.push(argConfig);\r\n\r\n\t\treturn 1;\r\n\t};\r\n\r\n\t// TODO support `not` and `if/then/else`\r\n\t// TODO support `const`, but we don't use it on our schema\r\n\t/**\r\n\t *\r\n\t * @param {object} schemaPart the current schema\r\n\t * @param {string} schemaPath the current path in the schema\r\n\t * @param {{schema: object, path: string}[]} path all previous visited schemaParts\r\n\t * @param {string | null} inArray if inside of an array, the path to the array\r\n\t * @returns {number} added arguments\r\n\t */\r\n\tconst traverse = (schemaPart, schemaPath = \"\", path = [], inArray = null) => {\r\n\t\twhile (schemaPart.$ref) {\r\n\t\t\tschemaPart = getSchemaPart(schemaPart.$ref);\r\n\t\t}\r\n\r\n\t\tconst repetitions = path.filter(({ schema }) => schema === schemaPart);\r\n\t\tif (\r\n\t\t\trepetitions.length >= 2 ||\r\n\t\t\trepetitions.some(({ path }) => path === schemaPath)\r\n\t\t) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (schemaPart.cli && schemaPart.cli.exclude) return 0;\r\n\r\n\t\tconst fullPath = [{ schema: schemaPart, path: schemaPath }, ...path];\r\n\r\n\t\tlet addedArguments = 0;\r\n\r\n\t\taddedArguments += addFlag(fullPath, !!inArray);\r\n\r\n\t\tif (schemaPart.type === \"object\") {\r\n\t\t\tif (schemaPart.properties) {\r\n\t\t\t\tfor (const property of Object.keys(schemaPart.properties)) {\r\n\t\t\t\t\taddedArguments += traverse(\r\n\t\t\t\t\t\tschemaPart.properties[property],\r\n\t\t\t\t\t\tschemaPath ? `${schemaPath}.${property}` : property,\r\n\t\t\t\t\t\tfullPath,\r\n\t\t\t\t\t\tinArray\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn addedArguments;\r\n\t\t}\r\n\r\n\t\tif (schemaPart.type === \"array\") {\r\n\t\t\tif (inArray) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tif (Array.isArray(schemaPart.items)) {\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tfor (const item of schemaPart.items) {\r\n\t\t\t\t\taddedArguments += traverse(\r\n\t\t\t\t\t\titem,\r\n\t\t\t\t\t\t`${schemaPath}.${i}`,\r\n\t\t\t\t\t\tfullPath,\r\n\t\t\t\t\t\tschemaPath\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn addedArguments;\r\n\t\t\t}\r\n\r\n\t\t\taddedArguments += traverse(\r\n\t\t\t\tschemaPart.items,\r\n\t\t\t\t`${schemaPath}[]`,\r\n\t\t\t\tfullPath,\r\n\t\t\t\tschemaPath\r\n\t\t\t);\r\n\r\n\t\t\tif (addedArguments > 0) {\r\n\t\t\t\taddResetFlag(fullPath);\r\n\t\t\t\taddedArguments++;\r\n\t\t\t}\r\n\r\n\t\t\treturn addedArguments;\r\n\t\t}\r\n\r\n\t\tconst maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\r\n\r\n\t\tif (maybeOf) {\r\n\t\t\tconst items = maybeOf;\r\n\r\n\t\t\tfor (let i = 0; i < items.length; i++) {\r\n\t\t\t\taddedArguments += traverse(items[i], schemaPath, fullPath, inArray);\r\n\t\t\t}\r\n\r\n\t\t\treturn addedArguments;\r\n\t\t}\r\n\r\n\t\treturn addedArguments;\r\n\t};\r\n\r\n\ttraverse(schema);\r\n\r\n\t// Summarize flags\r\n\tfor (const name of Object.keys(flags)) {\r\n\t\tconst argument = flags[name];\r\n\t\targument.description = argument.configs.reduce((desc, { description }) => {\r\n\t\t\tif (!desc) return description;\r\n\t\t\tif (!description) return desc;\r\n\t\t\tif (desc.includes(description)) return desc;\r\n\t\t\treturn `${desc} ${description}`;\r\n\t\t}, /** @type {string | undefined} */ (undefined));\r\n\t\targument.simpleType = argument.configs.reduce((t, argConfig) => {\r\n\t\t\t/** @type {\"string\" | \"number\" | \"boolean\"} */\r\n\t\t\tlet type = \"string\";\r\n\t\t\tswitch (argConfig.type) {\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\ttype = \"number\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"reset\":\r\n\t\t\t\tcase \"boolean\":\r\n\t\t\t\t\ttype = \"boolean\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"enum\":\r\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"boolean\"))\r\n\t\t\t\t\t\ttype = \"boolean\";\r\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"number\"))\r\n\t\t\t\t\t\ttype = \"number\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (t === undefined) return type;\r\n\t\t\treturn t === type ? t : \"string\";\r\n\t\t}, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */ (undefined));\r\n\t\targument.multiple = argument.configs.some(c => c.multiple);\r\n\t}\r\n\r\n\treturn flags;\r\n};\r\n\r\nconst cliAddedItems = new WeakMap();\r\n\r\n/**\r\n * @param {any} config configuration\r\n * @param {string} schemaPath path in the config\r\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\r\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\r\n */\r\nconst getObjectAndProperty = (config, schemaPath, index = 0) => {\r\n\tif (!schemaPath) return { value: config };\r\n\tconst parts = schemaPath.split(\".\");\r\n\tlet property = parts.pop();\r\n\tlet current = config;\r\n\tlet i = 0;\r\n\tfor (const part of parts) {\r\n\t\tconst isArray = part.endsWith(\"[]\");\r\n\t\tconst name = isArray ? part.slice(0, -2) : part;\r\n\t\tlet value = current[name];\r\n\t\tif (isArray) {\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = {};\r\n\t\t\t\tcurrent[name] = [...Array.from({ length: index }), value];\r\n\t\t\t\tcliAddedItems.set(current[name], index + 1);\r\n\t\t\t} else if (!Array.isArray(value)) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproblem: {\r\n\t\t\t\t\t\ttype: \"unexpected-non-array-in-path\",\r\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\r\n\t\t\t\twhile (addedItems <= index) {\r\n\t\t\t\t\tvalue.push(undefined);\r\n\t\t\t\t\taddedItems++;\r\n\t\t\t\t}\r\n\t\t\t\tcliAddedItems.set(value, addedItems);\r\n\t\t\t\tconst x = value.length - addedItems + index;\r\n\t\t\t\tif (value[x] === undefined) {\r\n\t\t\t\t\tvalue[x] = {};\r\n\t\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tproblem: {\r\n\t\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\r\n\t\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tvalue = value[x];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = current[name] = {};\r\n\t\t\t} else if (value === null || typeof value !== \"object\") {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproblem: {\r\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\r\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tcurrent = value;\r\n\t\ti++;\r\n\t}\r\n\tlet value = current[property];\r\n\tif (property.endsWith(\"[]\")) {\r\n\t\tconst name = property.slice(0, -2);\r\n\t\tconst value = current[name];\r\n\t\tif (value === undefined) {\r\n\t\t\tcurrent[name] = [...Array.from({ length: index }), undefined];\r\n\t\t\tcliAddedItems.set(current[name], index + 1);\r\n\t\t\treturn { object: current[name], property: index, value: undefined };\r\n\t\t} else if (!Array.isArray(value)) {\r\n\t\t\tcurrent[name] = [value, ...Array.from({ length: index }), undefined];\r\n\t\t\tcliAddedItems.set(current[name], index + 1);\r\n\t\t\treturn { object: current[name], property: index + 1, value: undefined };\r\n\t\t} else {\r\n\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\r\n\t\t\twhile (addedItems <= index) {\r\n\t\t\t\tvalue.push(undefined);\r\n\t\t\t\taddedItems++;\r\n\t\t\t}\r\n\t\t\tcliAddedItems.set(value, addedItems);\r\n\t\t\tconst x = value.length - addedItems + index;\r\n\t\t\tif (value[x] === undefined) {\r\n\t\t\t\tvalue[x] = {};\r\n\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproblem: {\r\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\r\n\t\t\t\t\t\tpath: schemaPath\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tobject: value,\r\n\t\t\t\tproperty: x,\r\n\t\t\t\tvalue: value[x]\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\treturn { object: current, property, value };\r\n};\r\n\r\n/**\r\n * @param {any} config configuration\r\n * @param {string} schemaPath path in the config\r\n * @param {any} value parsed value\r\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\r\n * @returns {LocalProblem | null} problem or null for success\r\n */\r\nconst setValue = (config, schemaPath, value, index) => {\r\n\tconst { problem, object, property } = getObjectAndProperty(\r\n\t\tconfig,\r\n\t\tschemaPath,\r\n\t\tindex\r\n\t);\r\n\tif (problem) return problem;\r\n\tobject[property] = value;\r\n\treturn null;\r\n};\r\n\r\n/**\r\n * @param {ArgumentConfig} argConfig processing instructions\r\n * @param {any} config configuration\r\n * @param {any} value the value\r\n * @param {number | undefined} index the index if multiple values provided\r\n * @returns {LocalProblem | null} a problem if any\r\n */\r\nconst processArgumentConfig = (argConfig, config, value, index) => {\r\n\tif (index !== undefined && !argConfig.multiple) {\r\n\t\treturn {\r\n\t\t\ttype: \"multiple-values-unexpected\",\r\n\t\t\tpath: argConfig.path\r\n\t\t};\r\n\t}\r\n\tconst parsed = parseValueForArgumentConfig(argConfig, value);\r\n\tif (parsed === undefined) {\r\n\t\treturn {\r\n\t\t\ttype: \"invalid-value\",\r\n\t\t\tpath: argConfig.path,\r\n\t\t\texpected: getExpectedValue(argConfig)\r\n\t\t};\r\n\t}\r\n\tconst problem = setValue(config, argConfig.path, parsed, index);\r\n\tif (problem) return problem;\r\n\treturn null;\r\n};\r\n\r\n/**\r\n * @param {ArgumentConfig} argConfig processing instructions\r\n * @returns {string | undefined} expected message\r\n */\r\nconst getExpectedValue = argConfig => {\r\n\tswitch (argConfig.type) {\r\n\t\tdefault:\r\n\t\t\treturn argConfig.type;\r\n\t\tcase \"boolean\":\r\n\t\t\treturn \"true | false\";\r\n\t\tcase \"RegExp\":\r\n\t\t\treturn \"regular expression (example: /ab?c*/)\";\r\n\t\tcase \"enum\":\r\n\t\t\treturn argConfig.values.map(v => `${v}`).join(\" | \");\r\n\t\tcase \"reset\":\r\n\t\t\treturn \"true (will reset the previous value to an empty array)\";\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {ArgumentConfig} argConfig processing instructions\r\n * @param {any} value the value\r\n * @returns {any | undefined} parsed value\r\n */\r\nconst parseValueForArgumentConfig = (argConfig, value) => {\r\n\tswitch (argConfig.type) {\r\n\t\tcase \"string\":\r\n\t\t\tif (typeof value === \"string\") {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"path\":\r\n\t\t\tif (typeof value === \"string\") {\r\n\t\t\t\treturn path.resolve(value);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"number\":\r\n\t\t\tif (typeof value === \"number\") return value;\r\n\t\t\tif (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\r\n\t\t\t\tconst n = +value;\r\n\t\t\t\tif (!isNaN(n)) return n;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"boolean\":\r\n\t\t\tif (typeof value === \"boolean\") return value;\r\n\t\t\tif (value === \"true\") return true;\r\n\t\t\tif (value === \"false\") return false;\r\n\t\t\tbreak;\r\n\t\tcase \"RegExp\":\r\n\t\t\tif (value instanceof RegExp) return value;\r\n\t\t\tif (typeof value === \"string\") {\r\n\t\t\t\t// cspell:word yugi\r\n\t\t\t\tconst match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\r\n\t\t\t\tif (match && !/[^\\\\]\\//.test(match[1]))\r\n\t\t\t\t\treturn new RegExp(match[1], match[2]);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"enum\":\r\n\t\t\tif (argConfig.values.includes(value)) return value;\r\n\t\t\tfor (const item of argConfig.values) {\r\n\t\t\t\tif (`${item}` === value) return item;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"reset\":\r\n\t\t\tif (value === true) return [];\r\n\t\t\tbreak;\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {Record<string, Argument>} args object of arguments\r\n * @param {any} config configuration\r\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\r\n * @returns {Problem[] | null} problems or null for success\r\n */\r\nconst processArguments = (args, config, values) => {\r\n\t/** @type {Problem[]} */\r\n\tconst problems = [];\r\n\tfor (const key of Object.keys(values)) {\r\n\t\tconst arg = args[key];\r\n\t\tif (!arg) {\r\n\t\t\tproblems.push({\r\n\t\t\t\ttype: \"unknown-argument\",\r\n\t\t\t\tpath: \"\",\r\n\t\t\t\targument: key\r\n\t\t\t});\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tconst processValue = (value, i) => {\r\n\t\t\tconst currentProblems = [];\r\n\t\t\tfor (const argConfig of arg.configs) {\r\n\t\t\t\tconst problem = processArgumentConfig(argConfig, config, value, i);\r\n\t\t\t\tif (!problem) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tcurrentProblems.push({\r\n\t\t\t\t\t...problem,\r\n\t\t\t\t\targument: key,\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tindex: i\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tproblems.push(...currentProblems);\r\n\t\t};\r\n\t\tlet value = values[key];\r\n\t\tif (Array.isArray(value)) {\r\n\t\t\tfor (let i = 0; i < value.length; i++) {\r\n\t\t\t\tprocessValue(value[i], i);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tprocessValue(value, undefined);\r\n\t\t}\r\n\t}\r\n\tif (problems.length === 0) return null;\r\n\treturn problems;\r\n};\r\n\r\nexports.getArguments = getArguments;\r\nexports.processArguments = processArguments;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}