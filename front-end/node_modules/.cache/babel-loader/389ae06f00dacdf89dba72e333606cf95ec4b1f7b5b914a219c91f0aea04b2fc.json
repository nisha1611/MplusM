{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UUID = exports.Binary = void 0;\nvar buffer_1 = require(\"buffer\");\nvar ensure_buffer_1 = require(\"./ensure_buffer\");\nvar uuid_utils_1 = require(\"./uuid_utils\");\nvar utils_1 = require(\"./parser/utils\");\nvar error_1 = require(\"./error\");\nvar constants_1 = require(\"./constants\");\n/**\r\n * A class representation of the BSON Binary type.\r\n * @public\r\n * @category BSONType\r\n */\nvar Binary = /** @class */function () {\n  /**\r\n   * Create a new Binary instance.\r\n   *\r\n   * This constructor can accept a string as its first argument. In this case,\r\n   * this string will be encoded using ISO-8859-1, **not** using UTF-8.\r\n   * This is almost certainly not what you want. Use `new Binary(Buffer.from(string))`\r\n   * instead to convert the string to a Buffer using UTF-8 first.\r\n   *\r\n   * @param buffer - a buffer object containing the binary data.\r\n   * @param subType - the option binary type.\r\n   */\n  function Binary(buffer, subType) {\n    if (!(this instanceof Binary)) return new Binary(buffer, subType);\n    if (!(buffer == null) && !(typeof buffer === 'string') && !ArrayBuffer.isView(buffer) && !(buffer instanceof ArrayBuffer) && !Array.isArray(buffer)) {\n      throw new error_1.BSONTypeError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>');\n    }\n    this.sub_type = subType !== null && subType !== void 0 ? subType : Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n    if (buffer == null) {\n      // create an empty binary buffer\n      this.buffer = buffer_1.Buffer.alloc(Binary.BUFFER_SIZE);\n      this.position = 0;\n    } else {\n      if (typeof buffer === 'string') {\n        // string\n        this.buffer = buffer_1.Buffer.from(buffer, 'binary');\n      } else if (Array.isArray(buffer)) {\n        // number[]\n        this.buffer = buffer_1.Buffer.from(buffer);\n      } else {\n        // Buffer | TypedArray | ArrayBuffer\n        this.buffer = (0, ensure_buffer_1.ensureBuffer)(buffer);\n      }\n      this.position = this.buffer.byteLength;\n    }\n  }\n  /**\r\n   * Updates this binary with byte_value.\r\n   *\r\n   * @param byteValue - a single byte we wish to write.\r\n   */\n  Binary.prototype.put = function (byteValue) {\n    // If it's a string and a has more than one character throw an error\n    if (typeof byteValue === 'string' && byteValue.length !== 1) {\n      throw new error_1.BSONTypeError('only accepts single character String');\n    } else if (typeof byteValue !== 'number' && byteValue.length !== 1) throw new error_1.BSONTypeError('only accepts single character Uint8Array or Array');\n    // Decode the byte value once\n    var decodedByte;\n    if (typeof byteValue === 'string') {\n      decodedByte = byteValue.charCodeAt(0);\n    } else if (typeof byteValue === 'number') {\n      decodedByte = byteValue;\n    } else {\n      decodedByte = byteValue[0];\n    }\n    if (decodedByte < 0 || decodedByte > 255) {\n      throw new error_1.BSONTypeError('only accepts number in a valid unsigned byte range 0-255');\n    }\n    if (this.buffer.length > this.position) {\n      this.buffer[this.position++] = decodedByte;\n    } else {\n      var buffer = buffer_1.Buffer.alloc(Binary.BUFFER_SIZE + this.buffer.length);\n      // Combine the two buffers together\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      this.buffer = buffer;\n      this.buffer[this.position++] = decodedByte;\n    }\n  };\n  /**\r\n   * Writes a buffer or string to the binary.\r\n   *\r\n   * @param sequence - a string or buffer to be written to the Binary BSON object.\r\n   * @param offset - specify the binary of where to write the content.\r\n   */\n  Binary.prototype.write = function (sequence, offset) {\n    offset = typeof offset === 'number' ? offset : this.position;\n    // If the buffer is to small let's extend the buffer\n    if (this.buffer.length < offset + sequence.length) {\n      var buffer = buffer_1.Buffer.alloc(this.buffer.length + sequence.length);\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      // Assign the new buffer\n      this.buffer = buffer;\n    }\n    if (ArrayBuffer.isView(sequence)) {\n      this.buffer.set((0, ensure_buffer_1.ensureBuffer)(sequence), offset);\n      this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n    } else if (typeof sequence === 'string') {\n      this.buffer.write(sequence, offset, sequence.length, 'binary');\n      this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;\n    }\n  };\n  /**\r\n   * Reads **length** bytes starting at **position**.\r\n   *\r\n   * @param position - read from the given position in the Binary.\r\n   * @param length - the number of bytes to read.\r\n   */\n  Binary.prototype.read = function (position, length) {\n    length = length && length > 0 ? length : this.position;\n    // Let's return the data based on the type we have\n    return this.buffer.slice(position, position + length);\n  };\n  /**\r\n   * Returns the value of this binary as a string.\r\n   * @param asRaw - Will skip converting to a string\r\n   * @remarks\r\n   * This is handy when calling this function conditionally for some key value pairs and not others\r\n   */\n  Binary.prototype.value = function (asRaw) {\n    asRaw = !!asRaw;\n    // Optimize to serialize for the situation where the data == size of buffer\n    if (asRaw && this.buffer.length === this.position) {\n      return this.buffer;\n    }\n    // If it's a node.js buffer object\n    if (asRaw) {\n      return this.buffer.slice(0, this.position);\n    }\n    return this.buffer.toString('binary', 0, this.position);\n  };\n  /** the length of the binary sequence */\n  Binary.prototype.length = function () {\n    return this.position;\n  };\n  Binary.prototype.toJSON = function () {\n    return this.buffer.toString('base64');\n  };\n  Binary.prototype.toString = function (format) {\n    return this.buffer.toString(format);\n  };\n  /** @internal */\n  Binary.prototype.toExtendedJSON = function (options) {\n    options = options || {};\n    var base64String = this.buffer.toString('base64');\n    var subType = Number(this.sub_type).toString(16);\n    if (options.legacy) {\n      return {\n        $binary: base64String,\n        $type: subType.length === 1 ? '0' + subType : subType\n      };\n    }\n    return {\n      $binary: {\n        base64: base64String,\n        subType: subType.length === 1 ? '0' + subType : subType\n      }\n    };\n  };\n  Binary.prototype.toUUID = function () {\n    if (this.sub_type === Binary.SUBTYPE_UUID) {\n      return new UUID(this.buffer.slice(0, this.position));\n    }\n    throw new error_1.BSONError(\"Binary sub_type \\\"\".concat(this.sub_type, \"\\\" is not supported for converting to UUID. Only \\\"\").concat(Binary.SUBTYPE_UUID, \"\\\" is currently supported.\"));\n  };\n  /** @internal */\n  Binary.fromExtendedJSON = function (doc, options) {\n    options = options || {};\n    var data;\n    var type;\n    if ('$binary' in doc) {\n      if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n        type = doc.$type ? parseInt(doc.$type, 16) : 0;\n        data = buffer_1.Buffer.from(doc.$binary, 'base64');\n      } else {\n        if (typeof doc.$binary !== 'string') {\n          type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n          data = buffer_1.Buffer.from(doc.$binary.base64, 'base64');\n        }\n      }\n    } else if ('$uuid' in doc) {\n      type = 4;\n      data = (0, uuid_utils_1.uuidHexStringToBuffer)(doc.$uuid);\n    }\n    if (!data) {\n      throw new error_1.BSONTypeError(\"Unexpected Binary Extended JSON format \".concat(JSON.stringify(doc)));\n    }\n    return type === constants_1.BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n  };\n  /** @internal */\n  Binary.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {\n    return this.inspect();\n  };\n  Binary.prototype.inspect = function () {\n    var asBuffer = this.value(true);\n    return \"new Binary(Buffer.from(\\\"\".concat(asBuffer.toString('hex'), \"\\\", \\\"hex\\\"), \").concat(this.sub_type, \")\");\n  };\n  /**\r\n   * Binary default subtype\r\n   * @internal\r\n   */\n  Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n  /** Initial buffer default size */\n  Binary.BUFFER_SIZE = 256;\n  /** Default BSON type */\n  Binary.SUBTYPE_DEFAULT = 0;\n  /** Function BSON type */\n  Binary.SUBTYPE_FUNCTION = 1;\n  /** Byte Array BSON type */\n  Binary.SUBTYPE_BYTE_ARRAY = 2;\n  /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */\n  Binary.SUBTYPE_UUID_OLD = 3;\n  /** UUID BSON type */\n  Binary.SUBTYPE_UUID = 4;\n  /** MD5 BSON type */\n  Binary.SUBTYPE_MD5 = 5;\n  /** Encrypted BSON type */\n  Binary.SUBTYPE_ENCRYPTED = 6;\n  /** Column BSON type */\n  Binary.SUBTYPE_COLUMN = 7;\n  /** User BSON type */\n  Binary.SUBTYPE_USER_DEFINED = 128;\n  return Binary;\n}();\nexports.Binary = Binary;\nObject.defineProperty(Binary.prototype, '_bsontype', {\n  value: 'Binary'\n});\nvar UUID_BYTE_LENGTH = 16;\n/**\r\n * A class representation of the BSON UUID type.\r\n * @public\r\n */\nvar UUID = /** @class */function (_super) {\n  __extends(UUID, _super);\n  /**\r\n   * Create an UUID type\r\n   *\r\n   * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.\r\n   */\n  function UUID(input) {\n    var _this = this;\n    var bytes;\n    var hexStr;\n    if (input == null) {\n      bytes = UUID.generate();\n    } else if (input instanceof UUID) {\n      bytes = buffer_1.Buffer.from(input.buffer);\n      hexStr = input.__id;\n    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n      bytes = (0, ensure_buffer_1.ensureBuffer)(input);\n    } else if (typeof input === 'string') {\n      bytes = (0, uuid_utils_1.uuidHexStringToBuffer)(input);\n    } else {\n      throw new error_1.BSONTypeError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');\n    }\n    _this = _super.call(this, bytes, constants_1.BSON_BINARY_SUBTYPE_UUID_NEW) || this;\n    _this.__id = hexStr;\n    return _this;\n  }\n  Object.defineProperty(UUID.prototype, \"id\", {\n    /**\r\n     * The UUID bytes\r\n     * @readonly\r\n     */\n    get: function () {\n      return this.buffer;\n    },\n    set: function (value) {\n      this.buffer = value;\n      if (UUID.cacheHexString) {\n        this.__id = (0, uuid_utils_1.bufferToUuidHexString)(value);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)\r\n   * @param includeDashes - should the string exclude dash-separators.\r\n   * */\n  UUID.prototype.toHexString = function (includeDashes) {\n    if (includeDashes === void 0) {\n      includeDashes = true;\n    }\n    if (UUID.cacheHexString && this.__id) {\n      return this.__id;\n    }\n    var uuidHexString = (0, uuid_utils_1.bufferToUuidHexString)(this.id, includeDashes);\n    if (UUID.cacheHexString) {\n      this.__id = uuidHexString;\n    }\n    return uuidHexString;\n  };\n  /**\r\n   * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.\r\n   */\n  UUID.prototype.toString = function (encoding) {\n    return encoding ? this.id.toString(encoding) : this.toHexString();\n  };\n  /**\r\n   * Converts the id into its JSON string representation.\r\n   * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\r\n   */\n  UUID.prototype.toJSON = function () {\n    return this.toHexString();\n  };\n  /**\r\n   * Compares the equality of this UUID with `otherID`.\r\n   *\r\n   * @param otherId - UUID instance to compare against.\r\n   */\n  UUID.prototype.equals = function (otherId) {\n    if (!otherId) {\n      return false;\n    }\n    if (otherId instanceof UUID) {\n      return otherId.id.equals(this.id);\n    }\n    try {\n      return new UUID(otherId).id.equals(this.id);\n    } catch (_a) {\n      return false;\n    }\n  };\n  /**\r\n   * Creates a Binary instance from the current UUID.\r\n   */\n  UUID.prototype.toBinary = function () {\n    return new Binary(this.id, Binary.SUBTYPE_UUID);\n  };\n  /**\r\n   * Generates a populated buffer containing a v4 uuid\r\n   */\n  UUID.generate = function () {\n    var bytes = (0, utils_1.randomBytes)(UUID_BYTE_LENGTH);\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    // Kindly borrowed from https://github.com/uuidjs/uuid/blob/master/src/v4.js\n    bytes[6] = bytes[6] & 0x0f | 0x40;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    return buffer_1.Buffer.from(bytes);\n  };\n  /**\r\n   * Checks if a value is a valid bson UUID\r\n   * @param input - UUID, string or Buffer to validate.\r\n   */\n  UUID.isValid = function (input) {\n    if (!input) {\n      return false;\n    }\n    if (input instanceof UUID) {\n      return true;\n    }\n    if (typeof input === 'string') {\n      return (0, uuid_utils_1.uuidValidateString)(input);\n    }\n    if ((0, utils_1.isUint8Array)(input)) {\n      // check for length & uuid version (https://tools.ietf.org/html/rfc4122#section-4.1.3)\n      if (input.length !== UUID_BYTE_LENGTH) {\n        return false;\n      }\n      return (input[6] & 0xf0) === 0x40 && (input[8] & 0x80) === 0x80;\n    }\n    return false;\n  };\n  /**\r\n   * Creates an UUID from a hex string representation of an UUID.\r\n   * @param hexString - 32 or 36 character hex string (dashes excluded/included).\r\n   */\n  UUID.createFromHexString = function (hexString) {\n    var buffer = (0, uuid_utils_1.uuidHexStringToBuffer)(hexString);\n    return new UUID(buffer);\n  };\n  /**\r\n   * Converts to a string representation of this Id.\r\n   *\r\n   * @returns return the 36 character hex string representation.\r\n   * @internal\r\n   */\n  UUID.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {\n    return this.inspect();\n  };\n  UUID.prototype.inspect = function () {\n    return \"new UUID(\\\"\".concat(this.toHexString(), \"\\\")\");\n  };\n  return UUID;\n}(Binary);\nexports.UUID = UUID;","map":{"version":3,"mappings":"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","names":["buffer","subType","Binary","ArrayBuffer","isView","Array","isArray","error_1","sub_type","BSON_BINARY_SUBTYPE_DEFAULT","buffer_1","alloc","BUFFER_SIZE","position","from","byteLength","byteValue","length","decodedByte","charCodeAt","copy","sequence","offset","set","write","slice","asRaw","toString","format","options","base64String","Number","legacy","$binary","$type","base64","SUBTYPE_UUID","UUID","doc","data","type","parseInt","$uuid","JSON","stringify","constants_1","Symbol","for","inspect","asBuffer","value","exports","Object","defineProperty","prototype","UUID_BYTE_LENGTH","__extends","input","bytes","hexStr","generate","__id","_super","_this","cacheHexString","includeDashes","uuidHexString","id","encoding","toHexString","otherId","equals","hexString"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\binary.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport { ensureBuffer } from './ensure_buffer';\r\nimport { bufferToUuidHexString, uuidHexStringToBuffer, uuidValidateString } from './uuid_utils';\r\nimport { isUint8Array, randomBytes } from './parser/utils';\r\nimport type { EJSONOptions } from './extended_json';\r\nimport { BSONError, BSONTypeError } from './error';\r\nimport { BSON_BINARY_SUBTYPE_UUID_NEW } from './constants';\r\n\r\n/** @public */\r\nexport type BinarySequence = Uint8Array | Buffer | number[];\r\n\r\n/** @public */\r\nexport interface BinaryExtendedLegacy {\r\n  $type: string;\r\n  $binary: string;\r\n}\r\n\r\n/** @public */\r\nexport interface BinaryExtended {\r\n  $binary: {\r\n    subType: string;\r\n    base64: string;\r\n  };\r\n}\r\n\r\n/**\r\n * A class representation of the BSON Binary type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport class Binary {\r\n  _bsontype!: 'Binary';\r\n\r\n  /**\r\n   * Binary default subtype\r\n   * @internal\r\n   */\r\n  private static readonly BSON_BINARY_SUBTYPE_DEFAULT = 0;\r\n\r\n  /** Initial buffer default size */\r\n  static readonly BUFFER_SIZE = 256;\r\n  /** Default BSON type */\r\n  static readonly SUBTYPE_DEFAULT = 0;\r\n  /** Function BSON type */\r\n  static readonly SUBTYPE_FUNCTION = 1;\r\n  /** Byte Array BSON type */\r\n  static readonly SUBTYPE_BYTE_ARRAY = 2;\r\n  /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */\r\n  static readonly SUBTYPE_UUID_OLD = 3;\r\n  /** UUID BSON type */\r\n  static readonly SUBTYPE_UUID = 4;\r\n  /** MD5 BSON type */\r\n  static readonly SUBTYPE_MD5 = 5;\r\n  /** Encrypted BSON type */\r\n  static readonly SUBTYPE_ENCRYPTED = 6;\r\n  /** Column BSON type */\r\n  static readonly SUBTYPE_COLUMN = 7;\r\n  /** User BSON type */\r\n  static readonly SUBTYPE_USER_DEFINED = 128;\r\n\r\n  buffer!: Buffer;\r\n  sub_type!: number;\r\n  position!: number;\r\n\r\n  /**\r\n   * Create a new Binary instance.\r\n   *\r\n   * This constructor can accept a string as its first argument. In this case,\r\n   * this string will be encoded using ISO-8859-1, **not** using UTF-8.\r\n   * This is almost certainly not what you want. Use `new Binary(Buffer.from(string))`\r\n   * instead to convert the string to a Buffer using UTF-8 first.\r\n   *\r\n   * @param buffer - a buffer object containing the binary data.\r\n   * @param subType - the option binary type.\r\n   */\r\n  constructor(buffer?: string | BinarySequence, subType?: number) {\r\n    if (!(this instanceof Binary)) return new Binary(buffer, subType);\r\n\r\n    if (\r\n      !(buffer == null) &&\r\n      !(typeof buffer === 'string') &&\r\n      !ArrayBuffer.isView(buffer) &&\r\n      !(buffer instanceof ArrayBuffer) &&\r\n      !Array.isArray(buffer)\r\n    ) {\r\n      throw new BSONTypeError(\r\n        'Binary can only be constructed from string, Buffer, TypedArray, or Array<number>'\r\n      );\r\n    }\r\n\r\n    this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\r\n\r\n    if (buffer == null) {\r\n      // create an empty binary buffer\r\n      this.buffer = Buffer.alloc(Binary.BUFFER_SIZE);\r\n      this.position = 0;\r\n    } else {\r\n      if (typeof buffer === 'string') {\r\n        // string\r\n        this.buffer = Buffer.from(buffer, 'binary');\r\n      } else if (Array.isArray(buffer)) {\r\n        // number[]\r\n        this.buffer = Buffer.from(buffer);\r\n      } else {\r\n        // Buffer | TypedArray | ArrayBuffer\r\n        this.buffer = ensureBuffer(buffer);\r\n      }\r\n\r\n      this.position = this.buffer.byteLength;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates this binary with byte_value.\r\n   *\r\n   * @param byteValue - a single byte we wish to write.\r\n   */\r\n  put(byteValue: string | number | Uint8Array | Buffer | number[]): void {\r\n    // If it's a string and a has more than one character throw an error\r\n    if (typeof byteValue === 'string' && byteValue.length !== 1) {\r\n      throw new BSONTypeError('only accepts single character String');\r\n    } else if (typeof byteValue !== 'number' && byteValue.length !== 1)\r\n      throw new BSONTypeError('only accepts single character Uint8Array or Array');\r\n\r\n    // Decode the byte value once\r\n    let decodedByte: number;\r\n    if (typeof byteValue === 'string') {\r\n      decodedByte = byteValue.charCodeAt(0);\r\n    } else if (typeof byteValue === 'number') {\r\n      decodedByte = byteValue;\r\n    } else {\r\n      decodedByte = byteValue[0];\r\n    }\r\n\r\n    if (decodedByte < 0 || decodedByte > 255) {\r\n      throw new BSONTypeError('only accepts number in a valid unsigned byte range 0-255');\r\n    }\r\n\r\n    if (this.buffer.length > this.position) {\r\n      this.buffer[this.position++] = decodedByte;\r\n    } else {\r\n      const buffer = Buffer.alloc(Binary.BUFFER_SIZE + this.buffer.length);\r\n      // Combine the two buffers together\r\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\r\n      this.buffer = buffer;\r\n      this.buffer[this.position++] = decodedByte;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a buffer or string to the binary.\r\n   *\r\n   * @param sequence - a string or buffer to be written to the Binary BSON object.\r\n   * @param offset - specify the binary of where to write the content.\r\n   */\r\n  write(sequence: string | BinarySequence, offset: number): void {\r\n    offset = typeof offset === 'number' ? offset : this.position;\r\n\r\n    // If the buffer is to small let's extend the buffer\r\n    if (this.buffer.length < offset + sequence.length) {\r\n      const buffer = Buffer.alloc(this.buffer.length + sequence.length);\r\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\r\n\r\n      // Assign the new buffer\r\n      this.buffer = buffer;\r\n    }\r\n\r\n    if (ArrayBuffer.isView(sequence)) {\r\n      this.buffer.set(ensureBuffer(sequence), offset);\r\n      this.position =\r\n        offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\r\n    } else if (typeof sequence === 'string') {\r\n      this.buffer.write(sequence, offset, sequence.length, 'binary');\r\n      this.position =\r\n        offset + sequence.length > this.position ? offset + sequence.length : this.position;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads **length** bytes starting at **position**.\r\n   *\r\n   * @param position - read from the given position in the Binary.\r\n   * @param length - the number of bytes to read.\r\n   */\r\n  read(position: number, length: number): BinarySequence {\r\n    length = length && length > 0 ? length : this.position;\r\n\r\n    // Let's return the data based on the type we have\r\n    return this.buffer.slice(position, position + length);\r\n  }\r\n\r\n  /**\r\n   * Returns the value of this binary as a string.\r\n   * @param asRaw - Will skip converting to a string\r\n   * @remarks\r\n   * This is handy when calling this function conditionally for some key value pairs and not others\r\n   */\r\n  value(asRaw?: boolean): string | BinarySequence {\r\n    asRaw = !!asRaw;\r\n\r\n    // Optimize to serialize for the situation where the data == size of buffer\r\n    if (asRaw && this.buffer.length === this.position) {\r\n      return this.buffer;\r\n    }\r\n\r\n    // If it's a node.js buffer object\r\n    if (asRaw) {\r\n      return this.buffer.slice(0, this.position);\r\n    }\r\n    return this.buffer.toString('binary', 0, this.position);\r\n  }\r\n\r\n  /** the length of the binary sequence */\r\n  length(): number {\r\n    return this.position;\r\n  }\r\n\r\n  toJSON(): string {\r\n    return this.buffer.toString('base64');\r\n  }\r\n\r\n  toString(format?: string): string {\r\n    return this.buffer.toString(format);\r\n  }\r\n\r\n  /** @internal */\r\n  toExtendedJSON(options?: EJSONOptions): BinaryExtendedLegacy | BinaryExtended {\r\n    options = options || {};\r\n    const base64String = this.buffer.toString('base64');\r\n\r\n    const subType = Number(this.sub_type).toString(16);\r\n    if (options.legacy) {\r\n      return {\r\n        $binary: base64String,\r\n        $type: subType.length === 1 ? '0' + subType : subType\r\n      };\r\n    }\r\n    return {\r\n      $binary: {\r\n        base64: base64String,\r\n        subType: subType.length === 1 ? '0' + subType : subType\r\n      }\r\n    };\r\n  }\r\n\r\n  toUUID(): UUID {\r\n    if (this.sub_type === Binary.SUBTYPE_UUID) {\r\n      return new UUID(this.buffer.slice(0, this.position));\r\n    }\r\n\r\n    throw new BSONError(\r\n      `Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`\r\n    );\r\n  }\r\n\r\n  /** @internal */\r\n  static fromExtendedJSON(\r\n    doc: BinaryExtendedLegacy | BinaryExtended | UUIDExtended,\r\n    options?: EJSONOptions\r\n  ): Binary {\r\n    options = options || {};\r\n    let data: Buffer | undefined;\r\n    let type;\r\n    if ('$binary' in doc) {\r\n      if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\r\n        type = doc.$type ? parseInt(doc.$type, 16) : 0;\r\n        data = Buffer.from(doc.$binary, 'base64');\r\n      } else {\r\n        if (typeof doc.$binary !== 'string') {\r\n          type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\r\n          data = Buffer.from(doc.$binary.base64, 'base64');\r\n        }\r\n      }\r\n    } else if ('$uuid' in doc) {\r\n      type = 4;\r\n      data = uuidHexStringToBuffer(doc.$uuid);\r\n    }\r\n    if (!data) {\r\n      throw new BSONTypeError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\r\n    }\r\n    return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\r\n  }\r\n\r\n  /** @internal */\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    const asBuffer = this.value(true);\r\n    return `new Binary(Buffer.from(\"${asBuffer.toString('hex')}\", \"hex\"), ${this.sub_type})`;\r\n  }\r\n}\r\n\r\nObject.defineProperty(Binary.prototype, '_bsontype', { value: 'Binary' });\r\n\r\n/** @public */\r\nexport type UUIDExtended = {\r\n  $uuid: string;\r\n};\r\nconst UUID_BYTE_LENGTH = 16;\r\n\r\n/**\r\n * A class representation of the BSON UUID type.\r\n * @public\r\n */\r\nexport class UUID extends Binary {\r\n  static cacheHexString: boolean;\r\n\r\n  /** UUID hexString cache @internal */\r\n  private __id?: string;\r\n\r\n  /**\r\n   * Create an UUID type\r\n   *\r\n   * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.\r\n   */\r\n  constructor(input?: string | Buffer | UUID) {\r\n    let bytes;\r\n    let hexStr;\r\n    if (input == null) {\r\n      bytes = UUID.generate();\r\n    } else if (input instanceof UUID) {\r\n      bytes = Buffer.from(input.buffer);\r\n      hexStr = input.__id;\r\n    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\r\n      bytes = ensureBuffer(input);\r\n    } else if (typeof input === 'string') {\r\n      bytes = uuidHexStringToBuffer(input);\r\n    } else {\r\n      throw new BSONTypeError(\r\n        'Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).'\r\n      );\r\n    }\r\n    super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\r\n    this.__id = hexStr;\r\n  }\r\n\r\n  /**\r\n   * The UUID bytes\r\n   * @readonly\r\n   */\r\n  get id(): Buffer {\r\n    return this.buffer;\r\n  }\r\n\r\n  set id(value: Buffer) {\r\n    this.buffer = value;\r\n\r\n    if (UUID.cacheHexString) {\r\n      this.__id = bufferToUuidHexString(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)\r\n   * @param includeDashes - should the string exclude dash-separators.\r\n   * */\r\n  toHexString(includeDashes = true): string {\r\n    if (UUID.cacheHexString && this.__id) {\r\n      return this.__id;\r\n    }\r\n\r\n    const uuidHexString = bufferToUuidHexString(this.id, includeDashes);\r\n\r\n    if (UUID.cacheHexString) {\r\n      this.__id = uuidHexString;\r\n    }\r\n\r\n    return uuidHexString;\r\n  }\r\n\r\n  /**\r\n   * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.\r\n   */\r\n  toString(encoding?: string): string {\r\n    return encoding ? this.id.toString(encoding) : this.toHexString();\r\n  }\r\n\r\n  /**\r\n   * Converts the id into its JSON string representation.\r\n   * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\r\n   */\r\n  toJSON(): string {\r\n    return this.toHexString();\r\n  }\r\n\r\n  /**\r\n   * Compares the equality of this UUID with `otherID`.\r\n   *\r\n   * @param otherId - UUID instance to compare against.\r\n   */\r\n  equals(otherId: string | Buffer | UUID): boolean {\r\n    if (!otherId) {\r\n      return false;\r\n    }\r\n\r\n    if (otherId instanceof UUID) {\r\n      return otherId.id.equals(this.id);\r\n    }\r\n\r\n    try {\r\n      return new UUID(otherId).id.equals(this.id);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a Binary instance from the current UUID.\r\n   */\r\n  toBinary(): Binary {\r\n    return new Binary(this.id, Binary.SUBTYPE_UUID);\r\n  }\r\n\r\n  /**\r\n   * Generates a populated buffer containing a v4 uuid\r\n   */\r\n  static generate(): Buffer {\r\n    const bytes = randomBytes(UUID_BYTE_LENGTH);\r\n\r\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\r\n    // Kindly borrowed from https://github.com/uuidjs/uuid/blob/master/src/v4.js\r\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n\r\n    return Buffer.from(bytes);\r\n  }\r\n\r\n  /**\r\n   * Checks if a value is a valid bson UUID\r\n   * @param input - UUID, string or Buffer to validate.\r\n   */\r\n  static isValid(input: string | Buffer | UUID): boolean {\r\n    if (!input) {\r\n      return false;\r\n    }\r\n\r\n    if (input instanceof UUID) {\r\n      return true;\r\n    }\r\n\r\n    if (typeof input === 'string') {\r\n      return uuidValidateString(input);\r\n    }\r\n\r\n    if (isUint8Array(input)) {\r\n      // check for length & uuid version (https://tools.ietf.org/html/rfc4122#section-4.1.3)\r\n      if (input.length !== UUID_BYTE_LENGTH) {\r\n        return false;\r\n      }\r\n\r\n      return (input[6] & 0xf0) === 0x40 && (input[8] & 0x80) === 0x80;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Creates an UUID from a hex string representation of an UUID.\r\n   * @param hexString - 32 or 36 character hex string (dashes excluded/included).\r\n   */\r\n  static createFromHexString(hexString: string): UUID {\r\n    const buffer = uuidHexStringToBuffer(hexString);\r\n    return new UUID(buffer);\r\n  }\r\n\r\n  /**\r\n   * Converts to a string representation of this Id.\r\n   *\r\n   * @returns return the 36 character hex string representation.\r\n   * @internal\r\n   */\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    return `new UUID(\"${this.toHexString()}\")`;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}