{"ast":null,"code":"'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([`--${boundary}`, `content-disposition: form-data; name=\"file${i + 1}\"; ` + `filename=\"random${i + 1}.bin\"`, 'content-type: application/octet-stream', '', '0'.repeat(mb), ''].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([`--${boundary}--`, ''].join('\\r\\n')));\n  return bufs;\n}\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, new Array(100).fill(1));\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0\n};\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy':\n    {\n      const busboy = require('busboy');\n      const parser = busboy({\n        limits: {\n          fieldSizeLimit: Infinity\n        },\n        headers: {\n          'content-type': `multipart/form-data; boundary=${boundary}`\n        }\n      });\n      parser.on('file', (name, stream, info) => {\n        ++calls.partBegin;\n        stream.on('data', chunk => {\n          ++calls.partData;\n        }).on('end', () => {\n          ++calls.partEnd;\n        });\n      }).on('close', () => {\n        ++calls.end;\n        console.timeEnd(moduleName);\n      });\n      console.time(moduleName);\n      for (const buf of buffers) parser.write(buf);\n      break;\n    }\n  case 'formidable':\n    {\n      const {\n        MultipartParser\n      } = require('formidable');\n      const parser = new MultipartParser();\n      parser.initWithBoundary(boundary);\n      parser.on('data', _ref => {\n        let {\n          name\n        } = _ref;\n        ++calls[name];\n        if (name === 'end') console.timeEnd(moduleName);\n      });\n      console.time(moduleName);\n      for (const buf of buffers) parser.write(buf);\n      break;\n    }\n  case 'multiparty':\n    {\n      const {\n        Readable\n      } = require('stream');\n      const {\n        Form\n      } = require('multiparty');\n      const form = new Form({\n        maxFieldsSize: Infinity,\n        maxFields: Infinity,\n        maxFilesSize: Infinity,\n        autoFields: false,\n        autoFiles: false\n      });\n      const req = new Readable({\n        read: () => {}\n      });\n      req.headers = {\n        'content-type': `multipart/form-data; boundary=${boundary}`\n      };\n      function hijack(name, fn) {\n        const oldFn = form[name];\n        form[name] = function () {\n          fn();\n          return oldFn.apply(this, arguments);\n        };\n      }\n      hijack('onParseHeaderField', () => {\n        ++calls.headerField;\n      });\n      hijack('onParseHeaderValue', () => {\n        ++calls.headerValue;\n      });\n      hijack('onParsePartBegin', () => {\n        ++calls.partBegin;\n      });\n      hijack('onParsePartData', () => {\n        ++calls.partData;\n      });\n      hijack('onParsePartEnd', () => {\n        ++calls.partEnd;\n      });\n      form.on('close', () => {\n        ++calls.end;\n        console.timeEnd(moduleName);\n      }).on('part', p => p.resume());\n      console.time(moduleName);\n      form.parse(req);\n      for (const buf of buffers) req.push(buf);\n      req.push(null);\n      break;\n    }\n  default:\n    if (moduleName === undefined) console.error('Missing parser module name');else console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}","map":{"version":3,"names":["createMultipartBuffers","boundary","sizes","bufs","i","length","mb","push","Buffer","from","repeat","join","buffers","Array","fill","calls","partBegin","headerField","headerValue","headerEnd","headersEnd","partData","partEnd","end","moduleName","process","argv","busboy","require","parser","limits","fieldSizeLimit","Infinity","headers","on","name","stream","info","chunk","console","timeEnd","time","buf","write","MultipartParser","initWithBoundary","Readable","Form","form","maxFieldsSize","maxFields","maxFilesSize","autoFields","autoFiles","req","read","hijack","fn","oldFn","apply","arguments","p","resume","parse","undefined","error","exit"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/busboy/bench/bench-multipart-files-100mb-small.js"],"sourcesContent":["'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([\n      `--${boundary}`,\n      `content-disposition: form-data; name=\"file${i + 1}\"; `\n        + `filename=\"random${i + 1}.bin\"`,\n      'content-type: application/octet-stream',\n      '',\n      '0'.repeat(mb),\n      '',\n    ].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([\n    `--${boundary}--`,\n    '',\n  ].join('\\r\\n')));\n  return bufs;\n}\n\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, (new Array(100)).fill(1));\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': `multipart/form-data; boundary=${boundary}`,\n      },\n    });\n    parser.on('file', (name, stream, info) => {\n      ++calls.partBegin;\n      stream.on('data', (chunk) => {\n        ++calls.partData;\n      }).on('end', () => {\n        ++calls.partEnd;\n      });\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n    break;\n  }\n\n  case 'formidable': {\n    const { MultipartParser } = require('formidable');\n\n    const parser = new MultipartParser();\n    parser.initWithBoundary(boundary);\n    parser.on('data', ({ name }) => {\n      ++calls[name];\n      if (name === 'end')\n        console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n\n    break;\n  }\n\n  case 'multiparty': {\n    const { Readable } = require('stream');\n\n    const { Form } = require('multiparty');\n\n    const form = new Form({\n      maxFieldsSize: Infinity,\n      maxFields: Infinity,\n      maxFilesSize: Infinity,\n      autoFields: false,\n      autoFiles: false,\n    });\n\n    const req = new Readable({ read: () => {} });\n    req.headers = {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    };\n\n    function hijack(name, fn) {\n      const oldFn = form[name];\n      form[name] = function() {\n        fn();\n        return oldFn.apply(this, arguments);\n      };\n    }\n\n    hijack('onParseHeaderField', () => {\n      ++calls.headerField;\n    });\n    hijack('onParseHeaderValue', () => {\n      ++calls.headerValue;\n    });\n    hijack('onParsePartBegin', () => {\n      ++calls.partBegin;\n    });\n    hijack('onParsePartData', () => {\n      ++calls.partData;\n    });\n    hijack('onParsePartEnd', () => {\n      ++calls.partEnd;\n    });\n\n    form.on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    }).on('part', (p) => p.resume());\n\n    console.time(moduleName);\n    form.parse(req);\n    for (const buf of buffers)\n      req.push(buf);\n    req.push(null);\n\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}