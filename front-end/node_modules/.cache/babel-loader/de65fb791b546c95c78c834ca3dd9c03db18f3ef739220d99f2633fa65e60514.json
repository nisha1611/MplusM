{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\r\n * Array SchemaType constructor\r\n *\r\n * @param {String} key\r\n * @param {SchemaType} cast\r\n * @param {Object} options\r\n * @param {Object} schemaOptions\r\n * @inherits SchemaType\r\n * @api public\r\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n  if (cast) {\n    let castOptions = {};\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n    this.$embeddedSchemaType = this.caster;\n  }\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      // Leave it up to `cast()` to convert the array\n      return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\r\n * This schema type's name, to defend against minifiers that mangle\r\n * function names.\r\n *\r\n * @api public\r\n */\nSchemaArray.schemaName = 'Array';\n\n/**\r\n * Options for all arrays.\r\n *\r\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\r\n *\r\n * @static\r\n * @api public\r\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n\n/*!\r\n * ignore\r\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\r\n * Sets a default option for all Array instances.\r\n *\r\n * #### Example:\r\n *\r\n *     // Make all Array instances have `required` of true by default.\r\n *     mongoose.Schema.Array.set('required', true);\r\n *\r\n *     const User = mongoose.model('User', new Schema({ test: Array }));\r\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\r\n *\r\n * @param {String} option The option you'd like to set the value for\r\n * @param {Any} value value for option\r\n * @return {undefined}\r\n * @function set\r\n * @api public\r\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\r\n * Inherits from SchemaType.\r\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\r\n * ignore\r\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\r\n * Override the function the required validator uses to check whether an array\r\n * passes the `required` check.\r\n *\r\n * #### Example:\r\n *\r\n *     // Require non-empty array to pass `required` check\r\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\r\n *\r\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\r\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\r\n *\r\n * @param {Function} fn\r\n * @return {Function}\r\n * @function checkRequired\r\n * @api public\r\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\r\n * Check if the given value satisfies the `required` validator.\r\n *\r\n * @param {Any} value\r\n * @param {Document} doc\r\n * @return {Boolean}\r\n * @api public\r\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\r\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\r\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\r\n *\r\n * @param {...String|Object} [args] enumeration values\r\n * @return {SchemaArray} this\r\n */\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n  while (true) {\n    const instance = arr && arr.caster && arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n    break;\n  }\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\r\n * Overrides the getters application for the population special-case\r\n *\r\n * @param {Object} value\r\n * @param {Object} scope\r\n * @api private\r\n */\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;\n    const len = rawValue.length;\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n  return ret;\n};\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\r\n * Casts values for set().\r\n *\r\n * @param {Object} value\r\n * @param {Document} doc document that triggers the casting\r\n * @param {Boolean} init whether this is an initialization cast\r\n * @api private\r\n */\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n    options = options || emptyOpts;\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\r\n * ignore\r\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\r\n * ignore\r\n */\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\r\n * ignore\r\n */\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\r\n * Casts values for queries.\r\n *\r\n * @param {String} $conditional\r\n * @param {any} [value]\r\n * @api private\r\n */\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n  return val;\n};\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n  val = val.map(function (v) {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return {\n        $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch)\n      };\n    }\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o)[this.path];\n  }, this);\n  return this.castForQuery(val);\n}\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n  return cast(this.casterConstructor.schema, val);\n}\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n    return ret;\n  };\n}\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$not = handle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\r\n * Module exports.\r\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","ref","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$embeddedSchemaType","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","arr","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","$populated","ret","rawValue","isMongooseArray","__array","len","length","i","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","valueDepth","min","max","containsNonArrayItem","prev","l","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substring","lastIndexOf","_arrayPath","opts","arrayPathIndex","_arrayParentPath","applySetters","e","kind","inspect","castNonArraysOption","markModified","_castForPopulate","$toObject","toObject","discriminator","assign","schematype","validators","slice","requiredValidator","undefined","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$not","$regex","$nin","$in","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst $exists = require('./operators/exists');\r\nconst $type = require('./operators/type');\r\nconst MongooseError = require('../error/mongooseError');\r\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\r\nconst SchemaType = require('../schematype');\r\nconst CastError = SchemaType.CastError;\r\nconst Mixed = require('./mixed');\r\nconst arrayDepth = require('../helpers/arrayDepth');\r\nconst cast = require('../cast');\r\nconst isOperator = require('../helpers/query/isOperator');\r\nconst util = require('util');\r\nconst utils = require('../utils');\r\nconst castToNumber = require('./operators/helpers').castToNumber;\r\nconst geospatial = require('./operators/geospatial');\r\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\r\n\r\nlet MongooseArray;\r\nlet EmbeddedDoc;\r\n\r\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\r\nconst emptyOpts = Object.freeze({});\r\n\r\n/**\r\n * Array SchemaType constructor\r\n *\r\n * @param {String} key\r\n * @param {SchemaType} cast\r\n * @param {Object} options\r\n * @param {Object} schemaOptions\r\n * @inherits SchemaType\r\n * @api public\r\n */\r\n\r\nfunction SchemaArray(key, cast, options, schemaOptions) {\r\n  // lazy load\r\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\r\n\r\n  let typeKey = 'type';\r\n  if (schemaOptions && schemaOptions.typeKey) {\r\n    typeKey = schemaOptions.typeKey;\r\n  }\r\n  this.schemaOptions = schemaOptions;\r\n\r\n  if (cast) {\r\n    let castOptions = {};\r\n\r\n    if (utils.isPOJO(cast)) {\r\n      if (cast[typeKey]) {\r\n        // support { type: Woot }\r\n        castOptions = utils.clone(cast); // do not alter user arguments\r\n        delete castOptions[typeKey];\r\n        cast = cast[typeKey];\r\n      } else {\r\n        cast = Mixed;\r\n      }\r\n    }\r\n\r\n    if (options != null && options.ref != null && castOptions.ref == null) {\r\n      castOptions.ref = options.ref;\r\n    }\r\n\r\n    if (cast === Object) {\r\n      cast = Mixed;\r\n    }\r\n\r\n    // support { type: 'String' }\r\n    const name = typeof cast === 'string'\r\n      ? cast\r\n      : utils.getFunctionName(cast);\r\n\r\n    const Types = require('./index.js');\r\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\r\n\r\n    this.casterConstructor = caster;\r\n\r\n    if (this.casterConstructor instanceof SchemaArray) {\r\n      this.casterConstructor[isNestedArraySymbol] = true;\r\n    }\r\n\r\n    if (typeof caster === 'function' &&\r\n        !caster.$isArraySubdocument &&\r\n        !caster.$isSchemaMap) {\r\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\r\n      this.caster = new caster(path, castOptions);\r\n    } else {\r\n      this.caster = caster;\r\n      if (!(this.caster instanceof EmbeddedDoc)) {\r\n        this.caster.path = key;\r\n      }\r\n    }\r\n\r\n    this.$embeddedSchemaType = this.caster;\r\n  }\r\n\r\n  this.$isMongooseArray = true;\r\n\r\n  SchemaType.call(this, key, options, 'Array');\r\n\r\n  let defaultArr;\r\n  let fn;\r\n\r\n  if (this.defaultValue != null) {\r\n    defaultArr = this.defaultValue;\r\n    fn = typeof defaultArr === 'function';\r\n  }\r\n\r\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\r\n    const defaultFn = function() {\r\n      // Leave it up to `cast()` to convert the array\r\n      return fn\r\n        ? defaultArr.call(this)\r\n        : defaultArr != null\r\n          ? [].concat(defaultArr)\r\n          : [];\r\n    };\r\n    defaultFn.$runBeforeSetters = !fn;\r\n    this.default(defaultFn);\r\n  }\r\n}\r\n\r\n/**\r\n * This schema type's name, to defend against minifiers that mangle\r\n * function names.\r\n *\r\n * @api public\r\n */\r\nSchemaArray.schemaName = 'Array';\r\n\r\n\r\n/**\r\n * Options for all arrays.\r\n *\r\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\r\n *\r\n * @static\r\n * @api public\r\n */\r\n\r\nSchemaArray.options = { castNonArrays: true };\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchemaArray.defaultOptions = {};\r\n\r\n/**\r\n * Sets a default option for all Array instances.\r\n *\r\n * #### Example:\r\n *\r\n *     // Make all Array instances have `required` of true by default.\r\n *     mongoose.Schema.Array.set('required', true);\r\n *\r\n *     const User = mongoose.model('User', new Schema({ test: Array }));\r\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\r\n *\r\n * @param {String} option The option you'd like to set the value for\r\n * @param {Any} value value for option\r\n * @return {undefined}\r\n * @function set\r\n * @api public\r\n */\r\nSchemaArray.set = SchemaType.set;\r\n\r\n/*!\r\n * Inherits from SchemaType.\r\n */\r\nSchemaArray.prototype = Object.create(SchemaType.prototype);\r\nSchemaArray.prototype.constructor = SchemaArray;\r\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\r\n\r\n/**\r\n * Override the function the required validator uses to check whether an array\r\n * passes the `required` check.\r\n *\r\n * #### Example:\r\n *\r\n *     // Require non-empty array to pass `required` check\r\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\r\n *\r\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\r\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\r\n *\r\n * @param {Function} fn\r\n * @return {Function}\r\n * @function checkRequired\r\n * @api public\r\n */\r\n\r\nSchemaArray.checkRequired = SchemaType.checkRequired;\r\n\r\n/**\r\n * Check if the given value satisfies the `required` validator.\r\n *\r\n * @param {Any} value\r\n * @param {Document} doc\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\r\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\r\n    return !!value;\r\n  }\r\n\r\n  // `require('util').inherits()` does **not** copy static properties, and\r\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\r\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\r\n    this.constructor.checkRequired() :\r\n    SchemaArray.checkRequired();\r\n\r\n  return _checkRequired(value);\r\n};\r\n\r\n/**\r\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\r\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\r\n *\r\n * @param {...String|Object} [args] enumeration values\r\n * @return {SchemaArray} this\r\n */\r\n\r\nSchemaArray.prototype.enum = function() {\r\n  let arr = this;\r\n  while (true) {\r\n    const instance = arr &&\r\n    arr.caster &&\r\n    arr.caster.instance;\r\n    if (instance === 'Array') {\r\n      arr = arr.caster;\r\n      continue;\r\n    }\r\n    if (instance !== 'String' && instance !== 'Number') {\r\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\r\n        ', not ' + instance);\r\n    }\r\n    break;\r\n  }\r\n\r\n  let enumArray = arguments;\r\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\r\n    enumArray = utils.object.vals(enumArray);\r\n  }\r\n\r\n  arr.caster.enum.apply(arr.caster, enumArray);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Overrides the getters application for the population special-case\r\n *\r\n * @param {Object} value\r\n * @param {Object} scope\r\n * @api private\r\n */\r\n\r\nSchemaArray.prototype.applyGetters = function(value, scope) {\r\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\r\n    // means the object id was populated\r\n    return value;\r\n  }\r\n\r\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\r\n  if (Array.isArray(ret)) {\r\n    const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;\r\n    const len = rawValue.length;\r\n    for (let i = 0; i < len; ++i) {\r\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\r\n    }\r\n  }\r\n  return ret;\r\n};\r\n\r\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\r\n  if (this.casterConstructor.$isMongooseArray &&\r\n      SchemaArray.options.castNonArrays &&\r\n      !this[isNestedArraySymbol]) {\r\n    // Check nesting levels and wrap in array if necessary\r\n    let depth = 0;\r\n    let arr = this;\r\n    while (arr != null &&\r\n      arr.$isMongooseArray &&\r\n      !arr.$isMongooseDocumentArray) {\r\n      ++depth;\r\n      arr = arr.casterConstructor;\r\n    }\r\n\r\n    // No need to wrap empty arrays\r\n    if (value != null && value.length !== 0) {\r\n      const valueDepth = arrayDepth(value);\r\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\r\n        for (let i = valueDepth.max; i < depth; ++i) {\r\n          value = [value];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\r\n};\r\n\r\n/**\r\n * Casts values for set().\r\n *\r\n * @param {Object} value\r\n * @param {Document} doc document that triggers the casting\r\n * @param {Boolean} init whether this is an initialization cast\r\n * @api private\r\n */\r\n\r\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\r\n  // lazy load\r\n  MongooseArray || (MongooseArray = require('../types').Array);\r\n\r\n  let i;\r\n  let l;\r\n\r\n  if (Array.isArray(value)) {\r\n    const len = value.length;\r\n    if (!len && doc) {\r\n      const indexes = doc.schema.indexedPaths();\r\n\r\n      const arrayPath = this.path;\r\n      for (i = 0, l = indexes.length; i < l; ++i) {\r\n        const pathIndex = indexes[i][0][arrayPath];\r\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Special case: if this index is on the parent of what looks like\r\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\r\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\r\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\r\n      if (arrayGeojsonPath != null) {\r\n        for (i = 0, l = indexes.length; i < l; ++i) {\r\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\r\n          if (pathIndex === '2dsphere') {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    options = options || emptyOpts;\r\n\r\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\r\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\r\n    rawValue = value.__array;\r\n\r\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\r\n      return value;\r\n    }\r\n\r\n    const caster = this.caster;\r\n    const isMongooseArray = caster.$isMongooseArray;\r\n    if (caster && this.casterConstructor !== Mixed) {\r\n      try {\r\n        const len = rawValue.length;\r\n        for (i = 0; i < len; i++) {\r\n          const opts = {};\r\n          // Perf: creating `arrayPath` is expensive for large arrays.\r\n          // We only need `arrayPath` if this is a nested array, so\r\n          // skip if possible.\r\n          if (isMongooseArray) {\r\n            if (options.arrayPath != null) {\r\n              opts.arrayPathIndex = i;\r\n            } else if (caster._arrayParentPath != null) {\r\n              opts.arrayPathIndex = i;\r\n            }\r\n          }\r\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\r\n        }\r\n      } catch (e) {\r\n        // rethrow\r\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\r\n      }\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\r\n  if (init || castNonArraysOption) {\r\n    // gh-2442: if we're loading this from the db and its not an array, mark\r\n    // the whole array as modified.\r\n    if (!!doc && !!init) {\r\n      doc.markModified(this.path);\r\n    }\r\n    return this.cast([value], doc, init);\r\n  }\r\n\r\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\r\n  // lazy load\r\n  MongooseArray || (MongooseArray = require('../types').Array);\r\n\r\n  if (Array.isArray(value)) {\r\n    let i;\r\n    const rawValue = value.__array ? value.__array : value;\r\n    const len = rawValue.length;\r\n\r\n    const caster = this.caster;\r\n    if (caster && this.casterConstructor !== Mixed) {\r\n      try {\r\n        for (i = 0; i < len; i++) {\r\n          const opts = {};\r\n          // Perf: creating `arrayPath` is expensive for large arrays.\r\n          // We only need `arrayPath` if this is a nested array, so\r\n          // skip if possible.\r\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\r\n            opts.arrayPathIndex = i;\r\n          }\r\n\r\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\r\n        }\r\n      } catch (e) {\r\n        // rethrow\r\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\r\n      }\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\r\n};\r\n\r\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchemaArray.prototype.discriminator = function(name, schema) {\r\n  let arr = this;\r\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\r\n    arr = arr.casterConstructor;\r\n    if (arr == null || typeof arr === 'function') {\r\n      throw new MongooseError('You can only add an embedded discriminator on ' +\r\n        'a document array, ' + this.path + ' is a plain array');\r\n    }\r\n  }\r\n  return arr.discriminator(name, schema);\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nSchemaArray.prototype.clone = function() {\r\n  const options = Object.assign({}, this.options);\r\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\r\n  schematype.validators = this.validators.slice();\r\n  if (this.requiredValidator !== undefined) {\r\n    schematype.requiredValidator = this.requiredValidator;\r\n  }\r\n  return schematype;\r\n};\r\n\r\n/**\r\n * Casts values for queries.\r\n *\r\n * @param {String} $conditional\r\n * @param {any} [value]\r\n * @api private\r\n */\r\n\r\nSchemaArray.prototype.castForQuery = function($conditional, value) {\r\n  let handler;\r\n  let val;\r\n\r\n  if (arguments.length === 2) {\r\n    handler = this.$conditionalHandlers[$conditional];\r\n\r\n    if (!handler) {\r\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\r\n    }\r\n\r\n    val = handler.call(this, value);\r\n  } else {\r\n    val = $conditional;\r\n    let Constructor = this.casterConstructor;\r\n\r\n    if (val &&\r\n        Constructor.discriminators &&\r\n        Constructor.schema &&\r\n        Constructor.schema.options &&\r\n        Constructor.schema.options.discriminatorKey) {\r\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\r\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\r\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\r\n      } else {\r\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\r\n        if (constructorByValue) {\r\n          Constructor = constructorByValue;\r\n        }\r\n      }\r\n    }\r\n\r\n    const proto = this.casterConstructor.prototype;\r\n    let method = proto && (proto.castForQuery || proto.cast);\r\n    if (!method && Constructor.castForQuery) {\r\n      method = Constructor.castForQuery;\r\n    }\r\n    const caster = this.caster;\r\n\r\n    if (Array.isArray(val)) {\r\n      this.setters.reverse().forEach(setter => {\r\n        val = setter.call(this, val, this);\r\n      });\r\n      val = val.map(function(v) {\r\n        if (utils.isObject(v) && v.$elemMatch) {\r\n          return v;\r\n        }\r\n        if (method) {\r\n          v = method.call(caster, v);\r\n          return v;\r\n        }\r\n        if (v != null) {\r\n          v = new Constructor(v);\r\n          return v;\r\n        }\r\n        return v;\r\n      });\r\n    } else if (method) {\r\n      val = method.call(caster, val);\r\n    } else if (val != null) {\r\n      val = new Constructor(val);\r\n    }\r\n  }\r\n\r\n  return val;\r\n};\r\n\r\nfunction cast$all(val) {\r\n  if (!Array.isArray(val)) {\r\n    val = [val];\r\n  }\r\n\r\n  val = val.map(function(v) {\r\n    if (!utils.isObject(v)) {\r\n      return v;\r\n    }\r\n    if (v.$elemMatch != null) {\r\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch) };\r\n    }\r\n\r\n    const o = {};\r\n    o[this.path] = v;\r\n    return cast(this.casterConstructor.schema, o)[this.path];\r\n  }, this);\r\n\r\n  return this.castForQuery(val);\r\n}\r\n\r\nfunction cast$elemMatch(val) {\r\n  const keys = Object.keys(val);\r\n  const numKeys = keys.length;\r\n  for (let i = 0; i < numKeys; ++i) {\r\n    const key = keys[i];\r\n    const value = val[key];\r\n    if (isOperator(key) && value != null) {\r\n      val[key] = this.castForQuery(key, value);\r\n    }\r\n  }\r\n\r\n  // Is this an embedded discriminator and is the discriminator key set?\r\n  // If so, use the discriminator schema. See gh-7449\r\n  const discriminatorKey = this &&\r\n    this.casterConstructor &&\r\n    this.casterConstructor.schema &&\r\n    this.casterConstructor.schema.options &&\r\n    this.casterConstructor.schema.options.discriminatorKey;\r\n  const discriminators = this &&\r\n  this.casterConstructor &&\r\n  this.casterConstructor.schema &&\r\n  this.casterConstructor.schema.discriminators || {};\r\n  if (discriminatorKey != null &&\r\n      val[discriminatorKey] != null &&\r\n      discriminators[val[discriminatorKey]] != null) {\r\n    return cast(discriminators[val[discriminatorKey]], val);\r\n  }\r\n\r\n  return cast(this.casterConstructor.schema, val);\r\n}\r\n\r\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\r\n\r\nhandle.$all = cast$all;\r\nhandle.$options = String;\r\nhandle.$elemMatch = cast$elemMatch;\r\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\r\nhandle.$or = createLogicalQueryOperatorHandler('$or');\r\nhandle.$and = createLogicalQueryOperatorHandler('$and');\r\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\r\n\r\nfunction createLogicalQueryOperatorHandler(op) {\r\n  return function logicalQueryOperatorHandler(val) {\r\n    if (!Array.isArray(val)) {\r\n      throw new TypeError('conditional ' + op + ' requires an array');\r\n    }\r\n\r\n    const ret = [];\r\n    for (const obj of val) {\r\n      ret.push(cast(this.casterConstructor.schema, obj));\r\n    }\r\n\r\n    return ret;\r\n  };\r\n}\r\n\r\nhandle.$near =\r\nhandle.$nearSphere = geospatial.cast$near;\r\n\r\nhandle.$within =\r\nhandle.$geoWithin = geospatial.cast$within;\r\n\r\nhandle.$size =\r\nhandle.$minDistance =\r\nhandle.$maxDistance = castToNumber;\r\n\r\nhandle.$exists = $exists;\r\nhandle.$type = $type;\r\n\r\nhandle.$eq =\r\nhandle.$gt =\r\nhandle.$gte =\r\nhandle.$lt =\r\nhandle.$lte =\r\nhandle.$ne =\r\nhandle.$not =\r\nhandle.$regex = SchemaArray.prototype.castForQuery;\r\n\r\n// `$in` is special because you can also include an empty array in the query\r\n// like `$in: [1, []]`, see gh-5913\r\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\r\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\r\n\r\n/*!\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = SchemaArray;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}