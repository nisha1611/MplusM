{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst makeSerializable = require(\"./makeSerializable.js\");\n\n/**\r\n * @template T\r\n * @param {Set<T>} targetSet set where items should be added\r\n * @param {Set<Iterable<T>>} toMerge iterables to be merged\r\n * @returns {void}\r\n */\nconst merge = (targetSet, toMerge) => {\n  for (const set of toMerge) {\n    for (const item of set) {\n      targetSet.add(item);\n    }\n  }\n};\n\n/**\r\n * @template T\r\n * @param {Set<Iterable<T>>} targetSet set where iterables should be added\r\n * @param {Array<LazySet<T>>} toDeepMerge lazy sets to be flattened\r\n * @returns {void}\r\n */\nconst flatten = (targetSet, toDeepMerge) => {\n  for (const set of toDeepMerge) {\n    if (set._set.size > 0) targetSet.add(set._set);\n    if (set._needMerge) {\n      for (const mergedSet of set._toMerge) {\n        targetSet.add(mergedSet);\n      }\n      flatten(targetSet, set._toDeepMerge);\n    }\n  }\n};\n\n/**\r\n * Like Set but with an addAll method to eventually add items from another iterable.\r\n * Access methods make sure that all delayed operations are executed.\r\n * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).\r\n * @template T\r\n */\nclass LazySet {\n  /**\r\n   * @param {Iterable<T>=} iterable init iterable\r\n   */\n  constructor(iterable) {\n    /** @type {Set<T>} */\n    this._set = new Set(iterable);\n    /** @type {Set<Iterable<T>>} */\n    this._toMerge = new Set();\n    /** @type {Array<LazySet<T>>} */\n    this._toDeepMerge = [];\n    this._needMerge = false;\n    this._deopt = false;\n  }\n  _flatten() {\n    flatten(this._toMerge, this._toDeepMerge);\n    this._toDeepMerge.length = 0;\n  }\n  _merge() {\n    this._flatten();\n    merge(this._set, this._toMerge);\n    this._toMerge.clear();\n    this._needMerge = false;\n  }\n  _isEmpty() {\n    return this._set.size === 0 && this._toMerge.size === 0 && this._toDeepMerge.length === 0;\n  }\n  get size() {\n    if (this._needMerge) this._merge();\n    return this._set.size;\n  }\n\n  /**\r\n   * @param {T} item an item\r\n   * @returns {this} itself\r\n   */\n  add(item) {\n    this._set.add(item);\n    return this;\n  }\n\n  /**\r\n   * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set\r\n   * @returns {this} itself\r\n   */\n  addAll(iterable) {\n    if (this._deopt) {\n      const _set = this._set;\n      for (const item of iterable) {\n        _set.add(item);\n      }\n    } else {\n      if (iterable instanceof LazySet) {\n        if (iterable._isEmpty()) return this;\n        this._toDeepMerge.push(iterable);\n        this._needMerge = true;\n        if (this._toDeepMerge.length > 100000) {\n          this._flatten();\n        }\n      } else {\n        this._toMerge.add(iterable);\n        this._needMerge = true;\n      }\n      if (this._toMerge.size > 100000) this._merge();\n    }\n    return this;\n  }\n  clear() {\n    this._set.clear();\n    this._toMerge.clear();\n    this._toDeepMerge.length = 0;\n    this._needMerge = false;\n    this._deopt = false;\n  }\n\n  /**\r\n   * @param {T} value an item\r\n   * @returns {boolean} true, if the value was in the Set before\r\n   */\n  delete(value) {\n    if (this._needMerge) this._merge();\n    return this._set.delete(value);\n  }\n  entries() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.entries();\n  }\n\n  /**\r\n   * @param {function(T, T, Set<T>): void} callbackFn function called for each entry\r\n   * @param {any} thisArg this argument for the callbackFn\r\n   * @returns {void}\r\n   */\n  forEach(callbackFn, thisArg) {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    this._set.forEach(callbackFn, thisArg);\n  }\n\n  /**\r\n   * @param {T} item an item\r\n   * @returns {boolean} true, when the item is in the Set\r\n   */\n  has(item) {\n    if (this._needMerge) this._merge();\n    return this._set.has(item);\n  }\n  keys() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.keys();\n  }\n  values() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.values();\n  }\n  [Symbol.iterator]() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set[Symbol.iterator]();\n  }\n\n  /* istanbul ignore next */\n  get [Symbol.toStringTag]() {\n    return \"LazySet\";\n  }\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    if (this._needMerge) this._merge();\n    write(this._set.size);\n    for (const item of this._set) write(item);\n  }\n  static deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    const count = read();\n    const items = [];\n    for (let i = 0; i < count; i++) {\n      items.push(read());\n    }\n    return new LazySet(items);\n  }\n}\nmakeSerializable(LazySet, \"webpack/lib/util/LazySet\");\nmodule.exports = LazySet;","map":{"version":3,"names":["makeSerializable","require","merge","targetSet","toMerge","set","item","add","flatten","toDeepMerge","_set","size","_needMerge","mergedSet","_toMerge","_toDeepMerge","LazySet","constructor","iterable","Set","_deopt","_flatten","length","_merge","clear","_isEmpty","addAll","push","delete","value","entries","forEach","callbackFn","thisArg","has","keys","values","Symbol","iterator","toStringTag","serialize","write","deserialize","read","count","items","i","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/util/LazySet.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst makeSerializable = require(\"./makeSerializable.js\");\r\n\r\n/**\r\n * @template T\r\n * @param {Set<T>} targetSet set where items should be added\r\n * @param {Set<Iterable<T>>} toMerge iterables to be merged\r\n * @returns {void}\r\n */\r\nconst merge = (targetSet, toMerge) => {\r\n\tfor (const set of toMerge) {\r\n\t\tfor (const item of set) {\r\n\t\t\ttargetSet.add(item);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * @template T\r\n * @param {Set<Iterable<T>>} targetSet set where iterables should be added\r\n * @param {Array<LazySet<T>>} toDeepMerge lazy sets to be flattened\r\n * @returns {void}\r\n */\r\nconst flatten = (targetSet, toDeepMerge) => {\r\n\tfor (const set of toDeepMerge) {\r\n\t\tif (set._set.size > 0) targetSet.add(set._set);\r\n\t\tif (set._needMerge) {\r\n\t\t\tfor (const mergedSet of set._toMerge) {\r\n\t\t\t\ttargetSet.add(mergedSet);\r\n\t\t\t}\r\n\t\t\tflatten(targetSet, set._toDeepMerge);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * Like Set but with an addAll method to eventually add items from another iterable.\r\n * Access methods make sure that all delayed operations are executed.\r\n * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).\r\n * @template T\r\n */\r\nclass LazySet {\r\n\t/**\r\n\t * @param {Iterable<T>=} iterable init iterable\r\n\t */\r\n\tconstructor(iterable) {\r\n\t\t/** @type {Set<T>} */\r\n\t\tthis._set = new Set(iterable);\r\n\t\t/** @type {Set<Iterable<T>>} */\r\n\t\tthis._toMerge = new Set();\r\n\t\t/** @type {Array<LazySet<T>>} */\r\n\t\tthis._toDeepMerge = [];\r\n\t\tthis._needMerge = false;\r\n\t\tthis._deopt = false;\r\n\t}\r\n\r\n\t_flatten() {\r\n\t\tflatten(this._toMerge, this._toDeepMerge);\r\n\t\tthis._toDeepMerge.length = 0;\r\n\t}\r\n\r\n\t_merge() {\r\n\t\tthis._flatten();\r\n\t\tmerge(this._set, this._toMerge);\r\n\t\tthis._toMerge.clear();\r\n\t\tthis._needMerge = false;\r\n\t}\r\n\r\n\t_isEmpty() {\r\n\t\treturn (\r\n\t\t\tthis._set.size === 0 &&\r\n\t\t\tthis._toMerge.size === 0 &&\r\n\t\t\tthis._toDeepMerge.length === 0\r\n\t\t);\r\n\t}\r\n\r\n\tget size() {\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set.size;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {T} item an item\r\n\t * @returns {this} itself\r\n\t */\r\n\tadd(item) {\r\n\t\tthis._set.add(item);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set\r\n\t * @returns {this} itself\r\n\t */\r\n\taddAll(iterable) {\r\n\t\tif (this._deopt) {\r\n\t\t\tconst _set = this._set;\r\n\t\t\tfor (const item of iterable) {\r\n\t\t\t\t_set.add(item);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (iterable instanceof LazySet) {\r\n\t\t\t\tif (iterable._isEmpty()) return this;\r\n\t\t\t\tthis._toDeepMerge.push(iterable);\r\n\t\t\t\tthis._needMerge = true;\r\n\t\t\t\tif (this._toDeepMerge.length > 100000) {\r\n\t\t\t\t\tthis._flatten();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis._toMerge.add(iterable);\r\n\t\t\t\tthis._needMerge = true;\r\n\t\t\t}\r\n\t\t\tif (this._toMerge.size > 100000) this._merge();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tclear() {\r\n\t\tthis._set.clear();\r\n\t\tthis._toMerge.clear();\r\n\t\tthis._toDeepMerge.length = 0;\r\n\t\tthis._needMerge = false;\r\n\t\tthis._deopt = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {T} value an item\r\n\t * @returns {boolean} true, if the value was in the Set before\r\n\t */\r\n\tdelete(value) {\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set.delete(value);\r\n\t}\r\n\r\n\tentries() {\r\n\t\tthis._deopt = true;\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {function(T, T, Set<T>): void} callbackFn function called for each entry\r\n\t * @param {any} thisArg this argument for the callbackFn\r\n\t * @returns {void}\r\n\t */\r\n\tforEach(callbackFn, thisArg) {\r\n\t\tthis._deopt = true;\r\n\t\tif (this._needMerge) this._merge();\r\n\t\tthis._set.forEach(callbackFn, thisArg);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {T} item an item\r\n\t * @returns {boolean} true, when the item is in the Set\r\n\t */\r\n\thas(item) {\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set.has(item);\r\n\t}\r\n\r\n\tkeys() {\r\n\t\tthis._deopt = true;\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set.keys();\r\n\t}\r\n\r\n\tvalues() {\r\n\t\tthis._deopt = true;\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set.values();\r\n\t}\r\n\r\n\t[Symbol.iterator]() {\r\n\t\tthis._deopt = true;\r\n\t\tif (this._needMerge) this._merge();\r\n\t\treturn this._set[Symbol.iterator]();\r\n\t}\r\n\r\n\t/* istanbul ignore next */\r\n\tget [Symbol.toStringTag]() {\r\n\t\treturn \"LazySet\";\r\n\t}\r\n\r\n\tserialize({ write }) {\r\n\t\tif (this._needMerge) this._merge();\r\n\t\twrite(this._set.size);\r\n\t\tfor (const item of this._set) write(item);\r\n\t}\r\n\r\n\tstatic deserialize({ read }) {\r\n\t\tconst count = read();\r\n\t\tconst items = [];\r\n\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\titems.push(read());\r\n\t\t}\r\n\t\treturn new LazySet(items);\r\n\t}\r\n}\r\n\r\nmakeSerializable(LazySet, \"webpack/lib/util/LazySet\");\r\n\r\nmodule.exports = LazySet;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}