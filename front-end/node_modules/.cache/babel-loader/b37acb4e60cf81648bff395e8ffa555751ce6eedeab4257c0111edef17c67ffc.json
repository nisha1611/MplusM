{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies.\r\n */\nconst Binary = require('../driver').get().Binary;\nconst isBsonType = require('./isBsonType');\nconst isMongooseObject = require('./isMongooseObject');\nconst MongooseError = require('../error');\nconst util = require('util');\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\r\n * ignore\r\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({\n      transform: false,\n      virtuals: false\n    }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction modifiedPaths(update, path, result) {\n  let recursion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n  if (recursion == null) {\n    recursion = {\n      raw: {\n        update,\n        path\n      },\n      trace: new WeakSet()\n    };\n  }\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, {\n      showHidden: false,\n      depth: 1\n    })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({\n        transform: false,\n        virtuals: false\n      });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n  return result;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction shouldFlatten(val) {\n  return val && typeof val === 'object' && !(val instanceof Date) && !isBsonType(val, 'ObjectID') && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, 'Decimal128') && !(val instanceof Binary);\n}","map":{"version":3,"names":["Binary","require","get","isBsonType","isMongooseObject","MongooseError","util","exports","flatten","modifiedPaths","update","path","options","schema","keys","Buffer","isBuffer","Object","toObject","transform","virtuals","numKeys","length","result","i","key","val","keySchema","isNested","nested","instance","shouldFlatten","skipArrays","Array","isArray","flat","k","paths","p","startsWith","hasOwnProperty","recursion","raw","trace","WeakSet","has","inspect","showHidden","depth","add","_path","delete","Date"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/common.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\nconst Binary = require('../driver').get().Binary;\r\nconst isBsonType = require('./isBsonType');\r\nconst isMongooseObject = require('./isMongooseObject');\r\nconst MongooseError = require('../error');\r\nconst util = require('util');\r\n\r\nexports.flatten = flatten;\r\nexports.modifiedPaths = modifiedPaths;\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction flatten(update, path, options, schema) {\r\n  let keys;\r\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\r\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\r\n  } else {\r\n    keys = Object.keys(update || {});\r\n  }\r\n\r\n  const numKeys = keys.length;\r\n  const result = {};\r\n  path = path ? path + '.' : '';\r\n\r\n  for (let i = 0; i < numKeys; ++i) {\r\n    const key = keys[i];\r\n    const val = update[key];\r\n    result[path + key] = val;\r\n\r\n    // Avoid going into mixed paths if schema is specified\r\n    const keySchema = schema && schema.path && schema.path(path + key);\r\n    const isNested = schema && schema.nested && schema.nested[path + key];\r\n    if (keySchema && keySchema.instance === 'Mixed') continue;\r\n\r\n    if (shouldFlatten(val)) {\r\n      if (options && options.skipArrays && Array.isArray(val)) {\r\n        continue;\r\n      }\r\n      const flat = flatten(val, path + key, options, schema);\r\n      for (const k in flat) {\r\n        result[k] = flat[k];\r\n      }\r\n      if (Array.isArray(val)) {\r\n        result[path + key] = val;\r\n      }\r\n    }\r\n\r\n    if (isNested) {\r\n      const paths = Object.keys(schema.paths);\r\n      for (const p of paths) {\r\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\r\n          result[p] = void 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction modifiedPaths(update, path, result, recursion = null) {\r\n  if (update == null || typeof update !== 'object') {\r\n    return;\r\n  }\r\n\r\n  if (recursion == null) {\r\n    recursion = {\r\n      raw: { update, path },\r\n      trace: new WeakSet()\r\n    };\r\n  }\r\n\r\n  if (recursion.trace.has(update)) {\r\n    throw new MongooseError(`a circular reference in the update value, updateValue:\r\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\r\nupdatePath: '${recursion.raw.path}'`);\r\n  }\r\n  recursion.trace.add(update);\r\n\r\n  const keys = Object.keys(update || {});\r\n  const numKeys = keys.length;\r\n  result = result || {};\r\n  path = path ? path + '.' : '';\r\n\r\n  for (let i = 0; i < numKeys; ++i) {\r\n    const key = keys[i];\r\n    let val = update[key];\r\n\r\n    const _path = path + key;\r\n    result[_path] = true;\r\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\r\n      val = val.toObject({ transform: false, virtuals: false });\r\n    }\r\n    if (shouldFlatten(val)) {\r\n      modifiedPaths(val, path + key, result, recursion);\r\n    }\r\n  }\r\n  recursion.trace.delete(update);\r\n\r\n  return result;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction shouldFlatten(val) {\r\n  return val &&\r\n      typeof val === 'object' &&\r\n      !(val instanceof Date) &&\r\n      !isBsonType(val, 'ObjectID') &&\r\n      (!Array.isArray(val) || val.length !== 0) &&\r\n      !(val instanceof Buffer) &&\r\n      !isBsonType(val, 'Decimal128') &&\r\n      !(val instanceof Binary);\r\n}\r\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAW,CAAC,CAACC,GAAG,EAAE,CAACF,MAAM;AAChD,MAAMG,UAAU,GAAGF,OAAO,CAAC,cAAc,CAAC;AAC1C,MAAMG,gBAAgB,GAAGH,OAAO,CAAC,oBAAoB,CAAC;AACtD,MAAMI,aAAa,GAAGJ,OAAO,CAAC,UAAU,CAAC;AACzC,MAAMK,IAAI,GAAGL,OAAO,CAAC,MAAM,CAAC;AAE5BM,OAAO,CAACC,OAAO,GAAGA,OAAO;AACzBD,OAAO,CAACE,aAAa,GAAGA,aAAa;;AAErC;AACA;AACA;;AAEA,SAASD,OAAO,CAACE,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAEC,MAAM,EAAE;EAC9C,IAAIC,IAAI;EACR,IAAIJ,MAAM,IAAIN,gBAAgB,CAACM,MAAM,CAAC,IAAI,CAACK,MAAM,CAACC,QAAQ,CAACN,MAAM,CAAC,EAAE;IAClEI,IAAI,GAAGG,MAAM,CAACH,IAAI,CAACJ,MAAM,CAACQ,QAAQ,CAAC;MAAEC,SAAS,EAAE,KAAK;MAAEC,QAAQ,EAAE;IAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;EAClF,CAAC,MAAM;IACLN,IAAI,GAAGG,MAAM,CAACH,IAAI,CAACJ,MAAM,IAAI,CAAC,CAAC,CAAC;EAClC;EAEA,MAAMW,OAAO,GAAGP,IAAI,CAACQ,MAAM;EAC3B,MAAMC,MAAM,GAAG,CAAC,CAAC;EACjBZ,IAAI,GAAGA,IAAI,GAAGA,IAAI,GAAG,GAAG,GAAG,EAAE;EAE7B,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,OAAO,EAAE,EAAEG,CAAC,EAAE;IAChC,MAAMC,GAAG,GAAGX,IAAI,CAACU,CAAC,CAAC;IACnB,MAAME,GAAG,GAAGhB,MAAM,CAACe,GAAG,CAAC;IACvBF,MAAM,CAACZ,IAAI,GAAGc,GAAG,CAAC,GAAGC,GAAG;;IAExB;IACA,MAAMC,SAAS,GAAGd,MAAM,IAAIA,MAAM,CAACF,IAAI,IAAIE,MAAM,CAACF,IAAI,CAACA,IAAI,GAAGc,GAAG,CAAC;IAClE,MAAMG,QAAQ,GAAGf,MAAM,IAAIA,MAAM,CAACgB,MAAM,IAAIhB,MAAM,CAACgB,MAAM,CAAClB,IAAI,GAAGc,GAAG,CAAC;IACrE,IAAIE,SAAS,IAAIA,SAAS,CAACG,QAAQ,KAAK,OAAO,EAAE;IAEjD,IAAIC,aAAa,CAACL,GAAG,CAAC,EAAE;MACtB,IAAId,OAAO,IAAIA,OAAO,CAACoB,UAAU,IAAIC,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC,EAAE;QACvD;MACF;MACA,MAAMS,IAAI,GAAG3B,OAAO,CAACkB,GAAG,EAAEf,IAAI,GAAGc,GAAG,EAAEb,OAAO,EAAEC,MAAM,CAAC;MACtD,KAAK,MAAMuB,CAAC,IAAID,IAAI,EAAE;QACpBZ,MAAM,CAACa,CAAC,CAAC,GAAGD,IAAI,CAACC,CAAC,CAAC;MACrB;MACA,IAAIH,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC,EAAE;QACtBH,MAAM,CAACZ,IAAI,GAAGc,GAAG,CAAC,GAAGC,GAAG;MAC1B;IACF;IAEA,IAAIE,QAAQ,EAAE;MACZ,MAAMS,KAAK,GAAGpB,MAAM,CAACH,IAAI,CAACD,MAAM,CAACwB,KAAK,CAAC;MACvC,KAAK,MAAMC,CAAC,IAAID,KAAK,EAAE;QACrB,IAAIC,CAAC,CAACC,UAAU,CAAC5B,IAAI,GAAGc,GAAG,GAAG,GAAG,CAAC,IAAI,CAACF,MAAM,CAACiB,cAAc,CAACF,CAAC,CAAC,EAAE;UAC/Df,MAAM,CAACe,CAAC,CAAC,GAAG,KAAK,CAAC;QACpB;MACF;IACF;EACF;EAEA,OAAOf,MAAM;AACf;;AAEA;AACA;AACA;;AAEA,SAASd,aAAa,CAACC,MAAM,EAAEC,IAAI,EAAEY,MAAM,EAAoB;EAAA,IAAlBkB,SAAS,uEAAG,IAAI;EAC3D,IAAI/B,MAAM,IAAI,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAChD;EACF;EAEA,IAAI+B,SAAS,IAAI,IAAI,EAAE;IACrBA,SAAS,GAAG;MACVC,GAAG,EAAE;QAAEhC,MAAM;QAAEC;MAAK,CAAC;MACrBgC,KAAK,EAAE,IAAIC,OAAO;IACpB,CAAC;EACH;EAEA,IAAIH,SAAS,CAACE,KAAK,CAACE,GAAG,CAACnC,MAAM,CAAC,EAAE;IAC/B,MAAM,IAAIL,aAAa,CAAE;AAC7B,EAAEC,IAAI,CAACwC,OAAO,CAACL,SAAS,CAACC,GAAG,CAAChC,MAAM,EAAE;MAAEqC,UAAU,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAE,CAAC,CAAE;AACtE,eAAeP,SAAS,CAACC,GAAG,CAAC/B,IAAK,GAAE,CAAC;EACnC;EACA8B,SAAS,CAACE,KAAK,CAACM,GAAG,CAACvC,MAAM,CAAC;EAE3B,MAAMI,IAAI,GAAGG,MAAM,CAACH,IAAI,CAACJ,MAAM,IAAI,CAAC,CAAC,CAAC;EACtC,MAAMW,OAAO,GAAGP,IAAI,CAACQ,MAAM;EAC3BC,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;EACrBZ,IAAI,GAAGA,IAAI,GAAGA,IAAI,GAAG,GAAG,GAAG,EAAE;EAE7B,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,OAAO,EAAE,EAAEG,CAAC,EAAE;IAChC,MAAMC,GAAG,GAAGX,IAAI,CAACU,CAAC,CAAC;IACnB,IAAIE,GAAG,GAAGhB,MAAM,CAACe,GAAG,CAAC;IAErB,MAAMyB,KAAK,GAAGvC,IAAI,GAAGc,GAAG;IACxBF,MAAM,CAAC2B,KAAK,CAAC,GAAG,IAAI;IACpB,IAAI,CAACnC,MAAM,CAACC,QAAQ,CAACU,GAAG,CAAC,IAAItB,gBAAgB,CAACsB,GAAG,CAAC,EAAE;MAClDA,GAAG,GAAGA,GAAG,CAACR,QAAQ,CAAC;QAAEC,SAAS,EAAE,KAAK;QAAEC,QAAQ,EAAE;MAAM,CAAC,CAAC;IAC3D;IACA,IAAIW,aAAa,CAACL,GAAG,CAAC,EAAE;MACtBjB,aAAa,CAACiB,GAAG,EAAEf,IAAI,GAAGc,GAAG,EAAEF,MAAM,EAAEkB,SAAS,CAAC;IACnD;EACF;EACAA,SAAS,CAACE,KAAK,CAACQ,MAAM,CAACzC,MAAM,CAAC;EAE9B,OAAOa,MAAM;AACf;;AAEA;AACA;AACA;;AAEA,SAASQ,aAAa,CAACL,GAAG,EAAE;EAC1B,OAAOA,GAAG,IACN,OAAOA,GAAG,KAAK,QAAQ,IACvB,EAAEA,GAAG,YAAY0B,IAAI,CAAC,IACtB,CAACjD,UAAU,CAACuB,GAAG,EAAE,UAAU,CAAC,KAC3B,CAACO,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC,IAAIA,GAAG,CAACJ,MAAM,KAAK,CAAC,CAAC,IACzC,EAAEI,GAAG,YAAYX,MAAM,CAAC,IACxB,CAACZ,UAAU,CAACuB,GAAG,EAAE,YAAY,CAAC,IAC9B,EAAEA,GAAG,YAAY1B,MAAM,CAAC;AAC9B"},"metadata":{},"sourceType":"script","externalDependencies":[]}