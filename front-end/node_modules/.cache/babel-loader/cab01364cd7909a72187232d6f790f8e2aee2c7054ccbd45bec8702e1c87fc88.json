{"ast":null,"code":"/*!\r\n * Module dependencies.\r\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst Readable = require('stream').Readable;\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst immediate = require('../helpers/immediate');\nconst util = require('util');\n\n/**\r\n * An AggregationCursor is a concurrency primitive for processing aggregation\r\n * results one document at a time. It is analogous to QueryCursor.\r\n *\r\n * An AggregationCursor fulfills the Node.js streams3 API,\r\n * in addition to several other mechanisms for loading documents from MongoDB\r\n * one at a time.\r\n *\r\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\r\n * but **not** the model's post aggregate hooks.\r\n *\r\n * Unless you're an advanced user, do **not** instantiate this class directly.\r\n * Use [`Aggregate#cursor()`](/docs/api/aggregate.html#aggregate_Aggregate-cursor) instead.\r\n *\r\n * @param {Aggregate} agg\r\n * @inherits Readable\r\n * @event `cursor`: Emitted when the cursor is created\r\n * @event `error`: Emitted when an error occurred\r\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\r\n * @event `end`: Emitted when the stream is exhausted\r\n * @api public\r\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, {\n    autoDestroy: true,\n    objectMode: true\n  });\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n  _init(model, this, agg);\n}\nutil.inherits(AggregationCursor, Readable);\n\n/*!\r\n * ignore\r\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function () {\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function () {\n      model.hooks.execPre('aggregate', agg, function () {\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/**\r\n * Necessary to satisfy the Readable API\r\n * @method _read\r\n * @memberOf AggregationCursor\r\n * @instance\r\n * @api private\r\n */\n\nAggregationCursor.prototype._read = function () {\n  const _this = this;\n  _next(this, function (error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function (error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' + 'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n  AggregationCursor.prototype[Symbol.asyncIterator] = function () {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\r\n * Registers a transform function which subsequently maps documents retrieved\r\n * via the streams interface or `.next()`\r\n *\r\n * #### Example:\r\n *\r\n *     // Map documents returned by `data` events\r\n *     Thing.\r\n *       find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *        doc.foo = \"bar\";\r\n *        return doc;\r\n *       })\r\n *       on('data', function(doc) { console.log(doc.foo); });\r\n *\r\n *     // Or map documents returned by `.next()`\r\n *     const cursor = Thing.find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *         doc.foo = \"bar\";\r\n *         return doc;\r\n *       });\r\n *     cursor.next(function(error, doc) {\r\n *       console.log(doc.foo);\r\n *     });\r\n *\r\n * @param {Function} fn\r\n * @return {AggregationCursor}\r\n * @memberOf AggregationCursor\r\n * @api public\r\n * @method map\r\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function (fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\r\n * Marks this cursor as errored\r\n * @method _markError\r\n * @instance\r\n * @memberOf AggregationCursor\r\n * @api private\r\n */\n\nAggregationCursor.prototype._markError = function (error) {\n  this._error = error;\n  return this;\n};\n\n/**\r\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\r\n * `next()` will error.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method close\r\n * @emits close\r\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\r\n */\n\nAggregationCursor.prototype.close = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n      this.emit('close');\n      cb(null);\n    });\n  });\n};\n\n/**\r\n * Get the next document from this cursor. Will return `null` when there are\r\n * no documents left.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method next\r\n */\n\nAggregationCursor.prototype.next = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    _next(this, cb);\n  });\n};\n\n/**\r\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\r\n * will wait for the promise to resolve before iterating on to the next one.\r\n * Returns a promise that resolves when done.\r\n *\r\n * @param {Function} fn\r\n * @param {Object} [options]\r\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\r\n * @param {Function} [callback] executed when all docs have been processed\r\n * @return {Promise}\r\n * @api public\r\n * @method eachAsync\r\n */\n\nAggregationCursor.prototype.eachAsync = function (fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n  return eachAsync(function (cb) {\n    return _next(_this, cb);\n  }, fn, opts, callback);\n};\n\n/**\r\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\r\n * You do not need to call this function explicitly, the JavaScript runtime\r\n * will call it for you.\r\n *\r\n * #### Example:\r\n *\r\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\r\n *     // creates an AggregationCursor instance internally.\r\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\r\n *     for await (const doc of agg) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n *     // You can also use an AggregationCursor instance for async iteration\r\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\r\n *     for await (const doc of cursor) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n * Node.js 10.x supports async iterators natively without any flags. You can\r\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\r\n *\r\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\r\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\r\n * support async iterators.\r\n *\r\n * @method Symbol.asyncIterator\r\n * @memberOf AggregationCursor\r\n * @instance\r\n * @api public\r\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function () {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\r\n * ignore\r\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function () {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nAggregationCursor.prototype.transformNull = function (val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? {\n    done: true\n  } : {\n    value: doc,\n    done: false\n  };\n}\n\n/**\r\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\r\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\r\n *\r\n * @param {String} flag\r\n * @param {Boolean} value\r\n * @return {AggregationCursor} this\r\n * @api public\r\n * @method addCursorFlag\r\n */\n\nAggregationCursor.prototype.addCursorFlag = function (flag, value) {\n  const _this = this;\n  _waitForCursor(this, function () {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function () {\n    cb();\n  });\n}\n\n/**\r\n * Get the next doc from the underlying cursor and mongooseify it\r\n * (populate, etc.)\r\n * @param {Any} ctx\r\n * @param {Function} cb\r\n * @api private\r\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function (err, doc) {\n      if (err || doc === null && !ctx._mongooseOptions.transformNull) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function (doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n  if (ctx._error) {\n    return immediate(function () {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.cursor) {\n    return ctx.cursor.next(function (error, doc) {\n      if (error) {\n        return callback(error);\n      }\n      if (!doc) {\n        return callback(null, null);\n      }\n      callback(null, doc);\n    });\n  } else {\n    ctx.once('cursor', function () {\n      _next(ctx, cb);\n    });\n  }\n}\nmodule.exports = AggregationCursor;","map":{"version":3,"names":["MongooseError","require","Readable","promiseOrCallback","eachAsync","immediate","util","AggregationCursor","agg","call","autoDestroy","objectMode","cursor","_transforms","model","_model","options","useMongooseAggCursor","_mongooseOptions","_init","inherits","c","collection","buffer","hooks","execPre","aggregate","_pipeline","emit","emitter","once","prototype","_read","_this","_next","error","doc","push","close","Symbol","asyncIterator","msg","Object","defineProperty","value","fn","enumerable","configurable","writable","_markError","_error","callback","cb","listeners","length","next","opts","transformNull","_transformForAsyncIterator","indexOf","map","val","arguments","done","addCursorFlag","flag","_waitForCursor","ctx","err","reduce","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/cursor/AggregationCursor.js"],"sourcesContent":["/*!\r\n * Module dependencies.\r\n */\r\n\r\n'use strict';\r\n\r\nconst MongooseError = require('../error/mongooseError');\r\nconst Readable = require('stream').Readable;\r\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\r\nconst eachAsync = require('../helpers/cursor/eachAsync');\r\nconst immediate = require('../helpers/immediate');\r\nconst util = require('util');\r\n\r\n/**\r\n * An AggregationCursor is a concurrency primitive for processing aggregation\r\n * results one document at a time. It is analogous to QueryCursor.\r\n *\r\n * An AggregationCursor fulfills the Node.js streams3 API,\r\n * in addition to several other mechanisms for loading documents from MongoDB\r\n * one at a time.\r\n *\r\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\r\n * but **not** the model's post aggregate hooks.\r\n *\r\n * Unless you're an advanced user, do **not** instantiate this class directly.\r\n * Use [`Aggregate#cursor()`](/docs/api/aggregate.html#aggregate_Aggregate-cursor) instead.\r\n *\r\n * @param {Aggregate} agg\r\n * @inherits Readable\r\n * @event `cursor`: Emitted when the cursor is created\r\n * @event `error`: Emitted when an error occurred\r\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\r\n * @event `end`: Emitted when the stream is exhausted\r\n * @api public\r\n */\r\n\r\nfunction AggregationCursor(agg) {\r\n  // set autoDestroy=true because on node 12 it's by default false\r\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\r\n  Readable.call(this, { autoDestroy: true, objectMode: true });\r\n\r\n  this.cursor = null;\r\n  this.agg = agg;\r\n  this._transforms = [];\r\n  const model = agg._model;\r\n  delete agg.options.cursor.useMongooseAggCursor;\r\n  this._mongooseOptions = {};\r\n\r\n  _init(model, this, agg);\r\n}\r\n\r\nutil.inherits(AggregationCursor, Readable);\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _init(model, c, agg) {\r\n  if (!model.collection.buffer) {\r\n    model.hooks.execPre('aggregate', agg, function() {\r\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\r\n      c.emit('cursor', c.cursor);\r\n    });\r\n  } else {\r\n    model.collection.emitter.once('queue', function() {\r\n      model.hooks.execPre('aggregate', agg, function() {\r\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\r\n        c.emit('cursor', c.cursor);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Necessary to satisfy the Readable API\r\n * @method _read\r\n * @memberOf AggregationCursor\r\n * @instance\r\n * @api private\r\n */\r\n\r\nAggregationCursor.prototype._read = function() {\r\n  const _this = this;\r\n  _next(this, function(error, doc) {\r\n    if (error) {\r\n      return _this.emit('error', error);\r\n    }\r\n    if (!doc) {\r\n      _this.push(null);\r\n      _this.cursor.close(function(error) {\r\n        if (error) {\r\n          return _this.emit('error', error);\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    _this.push(doc);\r\n  });\r\n};\r\n\r\nif (Symbol.asyncIterator != null) {\r\n  const msg = 'Mongoose does not support using async iterators with an ' +\r\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\r\n\r\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\r\n    throw new MongooseError(msg);\r\n  };\r\n}\r\n\r\n/**\r\n * Registers a transform function which subsequently maps documents retrieved\r\n * via the streams interface or `.next()`\r\n *\r\n * #### Example:\r\n *\r\n *     // Map documents returned by `data` events\r\n *     Thing.\r\n *       find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *        doc.foo = \"bar\";\r\n *        return doc;\r\n *       })\r\n *       on('data', function(doc) { console.log(doc.foo); });\r\n *\r\n *     // Or map documents returned by `.next()`\r\n *     const cursor = Thing.find({ name: /^hello/ }).\r\n *       cursor().\r\n *       map(function (doc) {\r\n *         doc.foo = \"bar\";\r\n *         return doc;\r\n *       });\r\n *     cursor.next(function(error, doc) {\r\n *       console.log(doc.foo);\r\n *     });\r\n *\r\n * @param {Function} fn\r\n * @return {AggregationCursor}\r\n * @memberOf AggregationCursor\r\n * @api public\r\n * @method map\r\n */\r\n\r\nObject.defineProperty(AggregationCursor.prototype, 'map', {\r\n  value: function(fn) {\r\n    this._transforms.push(fn);\r\n    return this;\r\n  },\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true\r\n});\r\n\r\n/**\r\n * Marks this cursor as errored\r\n * @method _markError\r\n * @instance\r\n * @memberOf AggregationCursor\r\n * @api private\r\n */\r\n\r\nAggregationCursor.prototype._markError = function(error) {\r\n  this._error = error;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\r\n * `next()` will error.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method close\r\n * @emits close\r\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\r\n */\r\n\r\nAggregationCursor.prototype.close = function(callback) {\r\n  return promiseOrCallback(callback, cb => {\r\n    this.cursor.close(error => {\r\n      if (error) {\r\n        cb(error);\r\n        return this.listeners('error').length > 0 && this.emit('error', error);\r\n      }\r\n      this.emit('close');\r\n      cb(null);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Get the next document from this cursor. Will return `null` when there are\r\n * no documents left.\r\n *\r\n * @param {Function} callback\r\n * @return {Promise}\r\n * @api public\r\n * @method next\r\n */\r\n\r\nAggregationCursor.prototype.next = function(callback) {\r\n  return promiseOrCallback(callback, cb => {\r\n    _next(this, cb);\r\n  });\r\n};\r\n\r\n/**\r\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\r\n * will wait for the promise to resolve before iterating on to the next one.\r\n * Returns a promise that resolves when done.\r\n *\r\n * @param {Function} fn\r\n * @param {Object} [options]\r\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\r\n * @param {Function} [callback] executed when all docs have been processed\r\n * @return {Promise}\r\n * @api public\r\n * @method eachAsync\r\n */\r\n\r\nAggregationCursor.prototype.eachAsync = function(fn, opts, callback) {\r\n  const _this = this;\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n  opts = opts || {};\r\n\r\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\r\n};\r\n\r\n/**\r\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\r\n * You do not need to call this function explicitly, the JavaScript runtime\r\n * will call it for you.\r\n *\r\n * #### Example:\r\n *\r\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\r\n *     // creates an AggregationCursor instance internally.\r\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\r\n *     for await (const doc of agg) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n *     // You can also use an AggregationCursor instance for async iteration\r\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\r\n *     for await (const doc of cursor) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n * Node.js 10.x supports async iterators natively without any flags. You can\r\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\r\n *\r\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\r\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\r\n * support async iterators.\r\n *\r\n * @method Symbol.asyncIterator\r\n * @memberOf AggregationCursor\r\n * @instance\r\n * @api public\r\n */\r\n\r\nif (Symbol.asyncIterator != null) {\r\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\r\n    return this.transformNull()._transformForAsyncIterator();\r\n  };\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nAggregationCursor.prototype._transformForAsyncIterator = function() {\r\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\r\n    this.map(_transformForAsyncIterator);\r\n  }\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nAggregationCursor.prototype.transformNull = function(val) {\r\n  if (arguments.length === 0) {\r\n    val = true;\r\n  }\r\n  this._mongooseOptions.transformNull = val;\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _transformForAsyncIterator(doc) {\r\n  return doc == null ? { done: true } : { value: doc, done: false };\r\n}\r\n\r\n/**\r\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\r\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\r\n *\r\n * @param {String} flag\r\n * @param {Boolean} value\r\n * @return {AggregationCursor} this\r\n * @api public\r\n * @method addCursorFlag\r\n */\r\n\r\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\r\n  const _this = this;\r\n  _waitForCursor(this, function() {\r\n    _this.cursor.addCursorFlag(flag, value);\r\n  });\r\n  return this;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _waitForCursor(ctx, cb) {\r\n  if (ctx.cursor) {\r\n    return cb();\r\n  }\r\n  ctx.once('cursor', function() {\r\n    cb();\r\n  });\r\n}\r\n\r\n/**\r\n * Get the next doc from the underlying cursor and mongooseify it\r\n * (populate, etc.)\r\n * @param {Any} ctx\r\n * @param {Function} cb\r\n * @api private\r\n */\r\n\r\nfunction _next(ctx, cb) {\r\n  let callback = cb;\r\n  if (ctx._transforms.length) {\r\n    callback = function(err, doc) {\r\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\r\n        return cb(err, doc);\r\n      }\r\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\r\n        return fn(doc);\r\n      }, doc));\r\n    };\r\n  }\r\n\r\n  if (ctx._error) {\r\n    return immediate(function() {\r\n      callback(ctx._error);\r\n    });\r\n  }\r\n\r\n  if (ctx.cursor) {\r\n    return ctx.cursor.next(function(error, doc) {\r\n      if (error) {\r\n        return callback(error);\r\n      }\r\n      if (!doc) {\r\n        return callback(null, null);\r\n      }\r\n\r\n      callback(null, doc);\r\n    });\r\n  } else {\r\n    ctx.once('cursor', function() {\r\n      _next(ctx, cb);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = AggregationCursor;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}