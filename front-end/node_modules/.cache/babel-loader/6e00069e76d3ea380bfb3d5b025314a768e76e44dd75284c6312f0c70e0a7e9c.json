{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoDBAWS = void 0;\nconst crypto = require(\"crypto\");\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst BSON = require(\"../../bson\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst mongo_credentials_1 = require(\"./mongo_credentials\");\nconst providers_1 = require(\"./providers\");\nconst ASCII_N = 110;\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\nconst AWS_EC2_URI = 'http://169.254.169.254';\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\nconst bsonOptions = {\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\nclass MongoDBAWS extends auth_provider_1.AuthProvider {\n  auth(authContext, callback) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if ('kModuleError' in deps_1.aws4) {\n      return callback(deps_1.aws4['kModuleError']);\n    }\n    const {\n      sign\n    } = deps_1.aws4;\n    if ((0, utils_1.maxWireVersion)(connection) < 9) {\n      callback(new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later'));\n      return;\n    }\n    if (!credentials.username) {\n      makeTempCredentials(credentials, (err, tempCredentials) => {\n        if (err || !tempCredentials) return callback(err);\n        authContext.credentials = tempCredentials;\n        this.auth(authContext, callback);\n      });\n      return;\n    }\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\n    const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? {\n      accessKeyId,\n      secretAccessKey,\n      sessionToken\n    } : accessKeyId && secretAccessKey ? {\n      accessKeyId,\n      secretAccessKey\n    } : undefined;\n    const db = credentials.source;\n    crypto.randomBytes(32, (err, nonce) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const saslStart = {\n        saslStart: 1,\n        mechanism: 'MONGODB-AWS',\n        payload: BSON.serialize({\n          r: nonce,\n          p: ASCII_N\n        }, bsonOptions)\n      };\n      connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, undefined, (err, res) => {\n        if (err) return callback(err);\n        const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions);\n        const host = serverResponse.h;\n        const serverNonce = serverResponse.s.buffer;\n        if (serverNonce.length !== 64) {\n          callback(\n          // TODO(NODE-3483)\n          new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`));\n          return;\n        }\n        if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {\n          // TODO(NODE-3483)\n          callback(new error_1.MongoRuntimeError('Server nonce does not begin with client nonce'));\n          return;\n        }\n        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n          // TODO(NODE-3483)\n          callback(new error_1.MongoRuntimeError(`Server returned an invalid host: \"${host}\"`));\n          return;\n        }\n        const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n        const options = sign({\n          method: 'POST',\n          host,\n          region: deriveRegion(serverResponse.h),\n          service: 'sts',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Content-Length': body.length,\n            'X-MongoDB-Server-Nonce': serverNonce.toString('base64'),\n            'X-MongoDB-GS2-CB-Flag': 'n'\n          },\n          path: '/',\n          body\n        }, awsCredentials);\n        const payload = {\n          a: options.headers.Authorization,\n          d: options.headers['X-Amz-Date']\n        };\n        if (sessionToken) {\n          payload.t = sessionToken;\n        }\n        const saslContinue = {\n          saslContinue: 1,\n          conversationId: 1,\n          payload: BSON.serialize(payload, bsonOptions)\n        };\n        connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, undefined, callback);\n      });\n    });\n  }\n}\nexports.MongoDBAWS = MongoDBAWS;\nfunction makeTempCredentials(credentials, callback) {\n  function done(creds) {\n    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {\n      callback(new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials'));\n      return;\n    }\n    callback(undefined, new mongo_credentials_1.MongoCredentials({\n      username: creds.AccessKeyId,\n      password: creds.SecretAccessKey,\n      source: credentials.source,\n      mechanism: providers_1.AuthMechanism.MONGODB_AWS,\n      mechanismProperties: {\n        AWS_SESSION_TOKEN: creds.Token\n      }\n    }));\n  }\n  const credentialProvider = (0, deps_1.getAwsCredentialProvider)();\n  // Check if the AWS credential provider from the SDK is present. If not,\n  // use the old method.\n  if ('kModuleError' in credentialProvider) {\n    // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\n    // is set then drivers MUST assume that it was set by an AWS ECS agent\n    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\n      request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, undefined, (err, res) => {\n        if (err) return callback(err);\n        done(res);\n      });\n      return;\n    }\n    // Otherwise assume we are on an EC2 instance\n    // get a token\n    request(`${AWS_EC2_URI}/latest/api/token`, {\n      method: 'PUT',\n      json: false,\n      headers: {\n        'X-aws-ec2-metadata-token-ttl-seconds': 30\n      }\n    }, (err, token) => {\n      if (err) return callback(err);\n      // get role name\n      request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {\n        json: false,\n        headers: {\n          'X-aws-ec2-metadata-token': token\n        }\n      }, (err, roleName) => {\n        if (err) return callback(err);\n        // get temp credentials\n        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {\n          headers: {\n            'X-aws-ec2-metadata-token': token\n          }\n        }, (err, creds) => {\n          if (err) return callback(err);\n          done(creds);\n        });\n      });\n    });\n  } else {\n    /*\r\n     * Creates a credential provider that will attempt to find credentials from the\r\n     * following sources (listed in order of precedence):\r\n     *\r\n     * - Environment variables exposed via process.env\r\n     * - SSO credentials from token cache\r\n     * - Web identity token credentials\r\n     * - Shared credentials and config ini files\r\n     * - The EC2/ECS Instance Metadata Service\r\n     */\n    const {\n      fromNodeProviderChain\n    } = credentialProvider;\n    const provider = fromNodeProviderChain();\n    provider().then(creds => {\n      done({\n        AccessKeyId: creds.accessKeyId,\n        SecretAccessKey: creds.secretAccessKey,\n        Token: creds.sessionToken,\n        Expiration: creds.expiration\n      });\n    }).catch(error => {\n      callback(new error_1.MongoAWSError(error.message));\n    });\n  }\n}\nfunction deriveRegion(host) {\n  const parts = host.split('.');\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n  return parts[1];\n}\nfunction request(uri, _options, callback) {\n  const options = Object.assign({\n    method: 'GET',\n    timeout: 10000,\n    json: true\n  }, url.parse(uri), _options);\n  const req = http.request(options, res => {\n    res.setEncoding('utf8');\n    let data = '';\n    res.on('data', d => data += d);\n    res.on('end', () => {\n      if (options.json === false) {\n        callback(undefined, data);\n        return;\n      }\n      try {\n        const parsed = JSON.parse(data);\n        callback(undefined, parsed);\n      } catch (err) {\n        // TODO(NODE-3483)\n        callback(new error_1.MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\n      }\n    });\n  });\n  req.on('timeout', () => {\n    req.destroy(new error_1.MongoAWSError(`AWS request to ${uri} timed out after ${options.timeout} ms`));\n  });\n  req.on('error', err => callback(err));\n  req.end();\n}","map":{"version":3,"mappings":"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","names":["ASCII_N","AWS_RELATIVE_URI","AWS_EC2_URI","AWS_EC2_PATH","bsonOptions","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","MongoDBAWS","auth_provider_1","auth","authContext","callback","connection","credentials","error_1","deps_1","sign","username","makeTempCredentials","err","tempCredentials","accessKeyId","secretAccessKey","password","sessionToken","mechanismProperties","AWS_SESSION_TOKEN","awsCredentials","undefined","db","source","crypto","randomBytes","nonce","saslStart","mechanism","payload","BSON","serialize","r","p","command","res","serverResponse","deserialize","buffer","host","h","serverNonce","s","length","compare","indexOf","body","options","method","region","deriveRegion","service","headers","toString","path","a","Authorization","d","t","saslContinue","conversationId","exports","done","creds","AccessKeyId","SecretAccessKey","Token","mongo_credentials_1","providers_1","MONGODB_AWS","credentialProvider","process","env","AWS_CONTAINER_CREDENTIALS_RELATIVE_URI","request","json","token","roleName","fromNodeProviderChain","provider","then","Expiration","expiration","catch","error","message","parts","split","uri","_options","Object","assign","timeout","url","parse","req","http","setEncoding","data","on","parsed","JSON","destroy","end"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_aws.ts"],"sourcesContent":["import * as crypto from 'crypto';\r\nimport * as http from 'http';\r\nimport * as url from 'url';\r\n\r\nimport type { Binary, BSONSerializeOptions } from '../../bson';\r\nimport * as BSON from '../../bson';\r\nimport { aws4, getAwsCredentialProvider } from '../../deps';\r\nimport {\r\n  MongoAWSError,\r\n  MongoCompatibilityError,\r\n  MongoMissingCredentialsError,\r\n  MongoRuntimeError\r\n} from '../../error';\r\nimport { Callback, maxWireVersion, ns } from '../../utils';\r\nimport { AuthContext, AuthProvider } from './auth_provider';\r\nimport { MongoCredentials } from './mongo_credentials';\r\nimport { AuthMechanism } from './providers';\r\n\r\nconst ASCII_N = 110;\r\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\r\nconst AWS_EC2_URI = 'http://169.254.169.254';\r\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\r\nconst bsonOptions: BSONSerializeOptions = {\r\n  promoteLongs: true,\r\n  promoteValues: true,\r\n  promoteBuffers: false,\r\n  bsonRegExp: false\r\n};\r\n\r\ninterface AWSSaslContinuePayload {\r\n  a: string;\r\n  d: string;\r\n  t?: string;\r\n}\r\n\r\nexport class MongoDBAWS extends AuthProvider {\r\n  override auth(authContext: AuthContext, callback: Callback): void {\r\n    const { connection, credentials } = authContext;\r\n    if (!credentials) {\r\n      return callback(new MongoMissingCredentialsError('AuthContext must provide credentials.'));\r\n    }\r\n\r\n    if ('kModuleError' in aws4) {\r\n      return callback(aws4['kModuleError']);\r\n    }\r\n    const { sign } = aws4;\r\n\r\n    if (maxWireVersion(connection) < 9) {\r\n      callback(\r\n        new MongoCompatibilityError(\r\n          'MONGODB-AWS authentication requires MongoDB version 4.4 or later'\r\n        )\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (!credentials.username) {\r\n      makeTempCredentials(credentials, (err, tempCredentials) => {\r\n        if (err || !tempCredentials) return callback(err);\r\n\r\n        authContext.credentials = tempCredentials;\r\n        this.auth(authContext, callback);\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const accessKeyId = credentials.username;\r\n    const secretAccessKey = credentials.password;\r\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\r\n\r\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\r\n    const awsCredentials =\r\n      accessKeyId && secretAccessKey && sessionToken\r\n        ? { accessKeyId, secretAccessKey, sessionToken }\r\n        : accessKeyId && secretAccessKey\r\n        ? { accessKeyId, secretAccessKey }\r\n        : undefined;\r\n\r\n    const db = credentials.source;\r\n    crypto.randomBytes(32, (err, nonce) => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const saslStart = {\r\n        saslStart: 1,\r\n        mechanism: 'MONGODB-AWS',\r\n        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)\r\n      };\r\n\r\n      connection.command(ns(`${db}.$cmd`), saslStart, undefined, (err, res) => {\r\n        if (err) return callback(err);\r\n\r\n        const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions) as {\r\n          s: Binary;\r\n          h: string;\r\n        };\r\n        const host = serverResponse.h;\r\n        const serverNonce = serverResponse.s.buffer;\r\n        if (serverNonce.length !== 64) {\r\n          callback(\r\n            // TODO(NODE-3483)\r\n            new MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`)\r\n          );\r\n\r\n          return;\r\n        }\r\n\r\n        if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {\r\n          // TODO(NODE-3483)\r\n          callback(new MongoRuntimeError('Server nonce does not begin with client nonce'));\r\n          return;\r\n        }\r\n\r\n        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\r\n          // TODO(NODE-3483)\r\n          callback(new MongoRuntimeError(`Server returned an invalid host: \"${host}\"`));\r\n          return;\r\n        }\r\n\r\n        const body = 'Action=GetCallerIdentity&Version=2011-06-15';\r\n        const options = sign(\r\n          {\r\n            method: 'POST',\r\n            host,\r\n            region: deriveRegion(serverResponse.h),\r\n            service: 'sts',\r\n            headers: {\r\n              'Content-Type': 'application/x-www-form-urlencoded',\r\n              'Content-Length': body.length,\r\n              'X-MongoDB-Server-Nonce': serverNonce.toString('base64'),\r\n              'X-MongoDB-GS2-CB-Flag': 'n'\r\n            },\r\n            path: '/',\r\n            body\r\n          },\r\n          awsCredentials\r\n        );\r\n\r\n        const payload: AWSSaslContinuePayload = {\r\n          a: options.headers.Authorization,\r\n          d: options.headers['X-Amz-Date']\r\n        };\r\n        if (sessionToken) {\r\n          payload.t = sessionToken;\r\n        }\r\n\r\n        const saslContinue = {\r\n          saslContinue: 1,\r\n          conversationId: 1,\r\n          payload: BSON.serialize(payload, bsonOptions)\r\n        };\r\n\r\n        connection.command(ns(`${db}.$cmd`), saslContinue, undefined, callback);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\ninterface AWSTempCredentials {\r\n  AccessKeyId?: string;\r\n  SecretAccessKey?: string;\r\n  Token?: string;\r\n  RoleArn?: string;\r\n  Expiration?: Date;\r\n}\r\n\r\n/* @internal */\r\nexport interface AWSCredentials {\r\n  accessKeyId?: string;\r\n  secretAccessKey?: string;\r\n  sessionToken?: string;\r\n  expiration?: Date;\r\n}\r\n\r\nfunction makeTempCredentials(credentials: MongoCredentials, callback: Callback<MongoCredentials>) {\r\n  function done(creds: AWSTempCredentials) {\r\n    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {\r\n      callback(\r\n        new MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials')\r\n      );\r\n      return;\r\n    }\r\n\r\n    callback(\r\n      undefined,\r\n      new MongoCredentials({\r\n        username: creds.AccessKeyId,\r\n        password: creds.SecretAccessKey,\r\n        source: credentials.source,\r\n        mechanism: AuthMechanism.MONGODB_AWS,\r\n        mechanismProperties: {\r\n          AWS_SESSION_TOKEN: creds.Token\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  const credentialProvider = getAwsCredentialProvider();\r\n\r\n  // Check if the AWS credential provider from the SDK is present. If not,\r\n  // use the old method.\r\n  if ('kModuleError' in credentialProvider) {\r\n    // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\r\n    // is set then drivers MUST assume that it was set by an AWS ECS agent\r\n    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\r\n      request(\r\n        `${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`,\r\n        undefined,\r\n        (err, res) => {\r\n          if (err) return callback(err);\r\n          done(res);\r\n        }\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    // Otherwise assume we are on an EC2 instance\r\n\r\n    // get a token\r\n    request(\r\n      `${AWS_EC2_URI}/latest/api/token`,\r\n      { method: 'PUT', json: false, headers: { 'X-aws-ec2-metadata-token-ttl-seconds': 30 } },\r\n      (err, token) => {\r\n        if (err) return callback(err);\r\n\r\n        // get role name\r\n        request(\r\n          `${AWS_EC2_URI}/${AWS_EC2_PATH}`,\r\n          { json: false, headers: { 'X-aws-ec2-metadata-token': token } },\r\n          (err, roleName) => {\r\n            if (err) return callback(err);\r\n\r\n            // get temp credentials\r\n            request(\r\n              `${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`,\r\n              { headers: { 'X-aws-ec2-metadata-token': token } },\r\n              (err, creds) => {\r\n                if (err) return callback(err);\r\n                done(creds);\r\n              }\r\n            );\r\n          }\r\n        );\r\n      }\r\n    );\r\n  } else {\r\n    /*\r\n     * Creates a credential provider that will attempt to find credentials from the\r\n     * following sources (listed in order of precedence):\r\n     *\r\n     * - Environment variables exposed via process.env\r\n     * - SSO credentials from token cache\r\n     * - Web identity token credentials\r\n     * - Shared credentials and config ini files\r\n     * - The EC2/ECS Instance Metadata Service\r\n     */\r\n    const { fromNodeProviderChain } = credentialProvider;\r\n    const provider = fromNodeProviderChain();\r\n    provider()\r\n      .then((creds: AWSCredentials) => {\r\n        done({\r\n          AccessKeyId: creds.accessKeyId,\r\n          SecretAccessKey: creds.secretAccessKey,\r\n          Token: creds.sessionToken,\r\n          Expiration: creds.expiration\r\n        });\r\n      })\r\n      .catch((error: Error) => {\r\n        callback(new MongoAWSError(error.message));\r\n      });\r\n  }\r\n}\r\n\r\nfunction deriveRegion(host: string) {\r\n  const parts = host.split('.');\r\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\r\n    return 'us-east-1';\r\n  }\r\n\r\n  return parts[1];\r\n}\r\n\r\ninterface RequestOptions {\r\n  json?: boolean;\r\n  method?: string;\r\n  timeout?: number;\r\n  headers?: http.OutgoingHttpHeaders;\r\n}\r\n\r\nfunction request(uri: string, _options: RequestOptions | undefined, callback: Callback) {\r\n  const options = Object.assign(\r\n    {\r\n      method: 'GET',\r\n      timeout: 10000,\r\n      json: true\r\n    },\r\n    url.parse(uri),\r\n    _options\r\n  );\r\n\r\n  const req = http.request(options, res => {\r\n    res.setEncoding('utf8');\r\n\r\n    let data = '';\r\n    res.on('data', d => (data += d));\r\n    res.on('end', () => {\r\n      if (options.json === false) {\r\n        callback(undefined, data);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const parsed = JSON.parse(data);\r\n        callback(undefined, parsed);\r\n      } catch (err) {\r\n        // TODO(NODE-3483)\r\n        callback(new MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\r\n      }\r\n    });\r\n  });\r\n\r\n  req.on('timeout', () => {\r\n    req.destroy(new MongoAWSError(`AWS request to ${uri} timed out after ${options.timeout} ms`));\r\n  });\r\n\r\n  req.on('error', err => callback(err));\r\n  req.end();\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}