{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\nconst getSchemaDiscriminatorByValue = require('../discriminator/getSchemaDiscriminatorByValue');\n\n/**\r\n * Like `schema.path()`, except with a document, because impossible to\r\n * determine path type without knowing the embedded discriminator key.\r\n * @param {Document} doc\r\n * @param {String} path\r\n * @param {Object} [options]\r\n * @api private\r\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' + get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};","map":{"version":3,"names":["get","require","getSchemaDiscriminatorByValue","module","exports","getEmbeddedDiscriminatorPath","doc","path","options","typeOnly","parts","indexOf","split","schemaType","type","schema","discriminatorKey","i","length","subpath","slice","join","instance","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","rest"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\r\n\r\nconst get = require('../get');\r\nconst getSchemaDiscriminatorByValue = require('../discriminator/getSchemaDiscriminatorByValue');\r\n\r\n/**\r\n * Like `schema.path()`, except with a document, because impossible to\r\n * determine path type without knowing the embedded discriminator key.\r\n * @param {Document} doc\r\n * @param {String} path\r\n * @param {Object} [options]\r\n * @api private\r\n */\r\n\r\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\r\n  options = options || {};\r\n  const typeOnly = options.typeOnly;\r\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\r\n  let schemaType = null;\r\n  let type = 'adhocOrUndefined';\r\n\r\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\r\n\r\n  for (let i = 0; i < parts.length; ++i) {\r\n    const subpath = parts.slice(0, i + 1).join('.');\r\n    schemaType = schema.path(subpath);\r\n    if (schemaType == null) {\r\n      type = 'adhocOrUndefined';\r\n      continue;\r\n    }\r\n    if (schemaType.instance === 'Mixed') {\r\n      return typeOnly ? 'real' : schemaType;\r\n    }\r\n    type = schema.pathType(subpath);\r\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\r\n    schemaType.schema.discriminators != null) {\r\n      const discriminators = schemaType.schema.discriminators;\r\n      const discriminatorKey = doc.get(subpath + '.' +\r\n        get(schemaType, 'schema.options.discriminatorKey'));\r\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\r\n        continue;\r\n      }\r\n      const rest = parts.slice(i + 1).join('.');\r\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\r\n    }\r\n  }\r\n\r\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\r\n  return typeOnly ? type : schemaType;\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC7B,MAAMC,6BAA6B,GAAGD,OAAO,CAAC,gDAAgD,CAAC;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAE,MAAM,CAACC,OAAO,GAAG,SAASC,4BAA4B,CAACC,GAAG,EAAEC,IAAI,EAAEC,OAAO,EAAE;EACzEA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMC,QAAQ,GAAGD,OAAO,CAACC,QAAQ;EACjC,MAAMC,KAAK,GAAGH,IAAI,CAACI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,CAACJ,IAAI,CAAC,GAAGA,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC;EACjE,IAAIC,UAAU,GAAG,IAAI;EACrB,IAAIC,IAAI,GAAG,kBAAkB;EAE7B,MAAMC,MAAM,GAAGb,6BAA6B,CAACI,GAAG,CAACS,MAAM,EAAET,GAAG,CAACN,GAAG,CAACM,GAAG,CAACS,MAAM,CAACP,OAAO,CAACQ,gBAAgB,CAAC,CAAC,IAAIV,GAAG,CAACS,MAAM;EAEpH,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACQ,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,MAAME,OAAO,GAAGT,KAAK,CAACU,KAAK,CAAC,CAAC,EAAEH,CAAC,GAAG,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;IAC/CR,UAAU,GAAGE,MAAM,CAACR,IAAI,CAACY,OAAO,CAAC;IACjC,IAAIN,UAAU,IAAI,IAAI,EAAE;MACtBC,IAAI,GAAG,kBAAkB;MACzB;IACF;IACA,IAAID,UAAU,CAACS,QAAQ,KAAK,OAAO,EAAE;MACnC,OAAOb,QAAQ,GAAG,MAAM,GAAGI,UAAU;IACvC;IACAC,IAAI,GAAGC,MAAM,CAACQ,QAAQ,CAACJ,OAAO,CAAC;IAC/B,IAAI,CAACN,UAAU,CAACW,eAAe,IAAIX,UAAU,CAACY,+BAA+B,KAC7EZ,UAAU,CAACE,MAAM,CAACW,cAAc,IAAI,IAAI,EAAE;MACxC,MAAMA,cAAc,GAAGb,UAAU,CAACE,MAAM,CAACW,cAAc;MACvD,MAAMV,gBAAgB,GAAGV,GAAG,CAACN,GAAG,CAACmB,OAAO,GAAG,GAAG,GAC5CnB,GAAG,CAACa,UAAU,EAAE,iCAAiC,CAAC,CAAC;MACrD,IAAIG,gBAAgB,IAAI,IAAI,IAAIU,cAAc,CAACV,gBAAgB,CAAC,IAAI,IAAI,EAAE;QACxE;MACF;MACA,MAAMW,IAAI,GAAGjB,KAAK,CAACU,KAAK,CAACH,CAAC,GAAG,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;MACzC,OAAOhB,4BAA4B,CAACC,GAAG,CAACN,GAAG,CAACmB,OAAO,CAAC,EAAEQ,IAAI,EAAEnB,OAAO,CAAC;IACtE;EACF;;EAEA;EACA,OAAOC,QAAQ,GAAGK,IAAI,GAAGD,UAAU;AACrC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}