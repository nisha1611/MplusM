{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\nconst {\n  RawSource,\n  CachedSource,\n  CompatSource\n} = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst {\n  compareSelect,\n  compareStrings\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst EMPTY_SET = new Set();\nconst addToList = (itemOrItems, list) => {\n  if (Array.isArray(itemOrItems)) {\n    for (const item of itemOrItems) {\n      list.add(item);\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n\n/**\r\n * @template T\r\n * @param {T[]} input list\r\n * @param {function(T): Buffer} fn map function\r\n * @returns {Buffer[]} buffers without duplicates\r\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  const result = [];\n  outer: for (const value of input) {\n    const buf = fn(value);\n    for (const other of result) {\n      if (buf.equals(other)) continue outer;\n    }\n    result.push(buf);\n  }\n  return result;\n};\n\n/**\r\n * Escapes regular expression metacharacters\r\n * @param {string} str String to quote\r\n * @returns {string} Escaped string\r\n */\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\nconst cachedSourceMap = new WeakMap();\nconst toCachedSource = source => {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n  const entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  const newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n\n/**\r\n * @typedef {Object} AssetInfoForRealContentHash\r\n * @property {string} name\r\n * @property {AssetInfo} info\r\n * @property {Source} source\r\n * @property {RawSource | undefined} newSource\r\n * @property {RawSource | undefined} newSourceWithoutOwn\r\n * @property {string} content\r\n * @property {Set<string>} ownHashes\r\n * @property {Promise} contentComputePromise\r\n * @property {Promise} contentComputeWithoutOwnPromise\r\n * @property {Set<string>} referencedHashes\r\n * @property {Set<string>} hashes\r\n */\n\n/**\r\n * @typedef {Object} CompilationHooks\r\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\r\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\nclass RealContentHashPlugin {\n  /**\r\n   * @param {Compilation} compilation the compilation\r\n   * @returns {CompilationHooks} the attached hooks\r\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n    let hooks = compilationHooksMap.get(compilation);\n    if (hooks === undefined) {\n      hooks = {\n        updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n    return hooks;\n  }\n  constructor(_ref) {\n    let {\n      hashFunction,\n      hashDigest\n    } = _ref;\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler the compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n      const cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n      const cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n      const hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n      compilation.hooks.processAssets.tapPromise({\n        name: \"RealContentHashPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n      }, async () => {\n        const assets = compilation.getAssets();\n        /** @type {AssetInfoForRealContentHash[]} */\n        const assetsWithInfo = [];\n        const hashToAssets = new Map();\n        for (const {\n          source,\n          info,\n          name\n        } of assets) {\n          const cachedSource = toCachedSource(source);\n          const content = cachedSource.source();\n          /** @type {Set<string>} */\n          const hashes = new Set();\n          addToList(info.contenthash, hashes);\n          const data = {\n            name,\n            info,\n            source: cachedSource,\n            /** @type {RawSource | undefined} */\n            newSource: undefined,\n            /** @type {RawSource | undefined} */\n            newSourceWithoutOwn: undefined,\n            content,\n            /** @type {Set<string>} */\n            ownHashes: undefined,\n            contentComputePromise: undefined,\n            contentComputeWithoutOwnPromise: undefined,\n            /** @type {Set<string>} */\n            referencedHashes: undefined,\n            hashes\n          };\n          assetsWithInfo.push(data);\n          for (const hash of hashes) {\n            const list = hashToAssets.get(hash);\n            if (list === undefined) {\n              hashToAssets.set(hash, [data]);\n            } else {\n              list.push(data);\n            }\n          }\n        }\n        if (hashToAssets.size === 0) return;\n        const hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n        await Promise.all(assetsWithInfo.map(async asset => {\n          const {\n            name,\n            source,\n            content,\n            hashes\n          } = asset;\n          if (Buffer.isBuffer(content)) {\n            asset.referencedHashes = EMPTY_SET;\n            asset.ownHashes = EMPTY_SET;\n            return;\n          }\n          const etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n          [asset.referencedHashes, asset.ownHashes] = await cacheAnalyse.providePromise(name, etag, () => {\n            const referencedHashes = new Set();\n            let ownHashes = new Set();\n            const inContent = content.match(hashRegExp);\n            if (inContent) {\n              for (const hash of inContent) {\n                if (hashes.has(hash)) {\n                  ownHashes.add(hash);\n                  continue;\n                }\n                referencedHashes.add(hash);\n              }\n            }\n            return [referencedHashes, ownHashes];\n          });\n        }));\n        const getDependencies = hash => {\n          const assets = hashToAssets.get(hash);\n          if (!assets) {\n            const referencingAssets = assetsWithInfo.filter(asset => asset.referencedHashes.has(hash));\n            const err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets.map(a => {\n              const match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(a.content);\n              return ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n            }).join(\"\\n\")}`);\n            compilation.errors.push(err);\n            return undefined;\n          }\n          const hashes = new Set();\n          for (const {\n            referencedHashes,\n            ownHashes\n          } of assets) {\n            if (!ownHashes.has(hash)) {\n              for (const hash of ownHashes) {\n                hashes.add(hash);\n              }\n            }\n            for (const hash of referencedHashes) {\n              hashes.add(hash);\n            }\n          }\n          return hashes;\n        };\n        const hashInfo = hash => {\n          const assets = hashToAssets.get(hash);\n          return `${hash} (${Array.from(assets, a => a.name)})`;\n        };\n        const hashesInOrder = new Set();\n        for (const hash of hashToAssets.keys()) {\n          const add = (hash, stack) => {\n            const deps = getDependencies(hash);\n            if (!deps) return;\n            stack.add(hash);\n            for (const dep of deps) {\n              if (hashesInOrder.has(dep)) continue;\n              if (stack.has(dep)) {\n                throw new Error(`Circular hash dependency ${Array.from(stack, hashInfo).join(\" -> \")} -> ${hashInfo(dep)}`);\n              }\n              add(dep, stack);\n            }\n            hashesInOrder.add(hash);\n            stack.delete(hash);\n          };\n          if (hashesInOrder.has(hash)) continue;\n          add(hash, new Set());\n        }\n        const hashToNewHash = new Map();\n        const getEtag = asset => cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, hash => hashToNewHash.get(hash)).join(\"|\"));\n        const computeNewContent = asset => {\n          if (asset.contentComputePromise) return asset.contentComputePromise;\n          return asset.contentComputePromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name;\n              const etag = getEtag(asset);\n              asset.newSource = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => hashToNewHash.get(hash));\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n        const computeNewContentWithoutOwn = asset => {\n          if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n          return asset.contentComputeWithoutOwnPromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name + \"|without-own\";\n              const etag = getEtag(asset);\n              asset.newSourceWithoutOwn = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => {\n                  if (asset.ownHashes.has(hash)) {\n                    return \"\";\n                  }\n                  return hashToNewHash.get(hash);\n                });\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n        const comparator = compareSelect(a => a.name, compareStrings);\n        for (const oldHash of hashesInOrder) {\n          const assets = hashToAssets.get(oldHash);\n          assets.sort(comparator);\n          const hash = createHash(this._hashFunction);\n          await Promise.all(assets.map(asset => asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset)));\n          const assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n            if (asset.ownHashes.has(oldHash)) {\n              return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n            } else {\n              return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n            }\n          });\n          let newHash = hooks.updateHash.call(assetsContent, oldHash);\n          if (!newHash) {\n            for (const content of assetsContent) {\n              hash.update(content);\n            }\n            const digest = hash.digest(this._hashDigest);\n            newHash = /** @type {string} */digest.slice(0, oldHash.length);\n          }\n          hashToNewHash.set(oldHash, newHash);\n        }\n        await Promise.all(assetsWithInfo.map(async asset => {\n          await computeNewContent(asset);\n          const newName = asset.name.replace(hashRegExp, hash => hashToNewHash.get(hash));\n          const infoUpdate = {};\n          const hash = asset.info.contenthash;\n          infoUpdate.contenthash = Array.isArray(hash) ? hash.map(hash => hashToNewHash.get(hash)) : hashToNewHash.get(hash);\n          if (asset.newSource !== undefined) {\n            compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n          } else {\n            compilation.updateAsset(asset.name, asset.source, infoUpdate);\n          }\n          if (asset.name !== newName) {\n            compilation.renameAsset(asset.name, newName);\n          }\n        }));\n      });\n    });\n  }\n}\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"names":["SyncBailHook","require","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","getCompilationHooks","compilation","TypeError","hooks","updateHash","constructor","hashFunction","hashDigest","_hashFunction","_hashDigest","apply","compiler","tap","cacheAnalyse","getCache","cacheGenerate","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","call","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { SyncBailHook } = require(\"tapable\");\r\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\r\nconst Compilation = require(\"../Compilation\");\r\nconst WebpackError = require(\"../WebpackError\");\r\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\r\nconst createHash = require(\"../util/createHash\");\r\n\r\n/** @typedef {import(\"webpack-sources\").Source} Source */\r\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\r\n/** @typedef {import(\"../Compiler\")} Compiler */\r\n\r\nconst EMPTY_SET = new Set();\r\n\r\nconst addToList = (itemOrItems, list) => {\r\n\tif (Array.isArray(itemOrItems)) {\r\n\t\tfor (const item of itemOrItems) {\r\n\t\t\tlist.add(item);\r\n\t\t}\r\n\t} else if (itemOrItems) {\r\n\t\tlist.add(itemOrItems);\r\n\t}\r\n};\r\n\r\n/**\r\n * @template T\r\n * @param {T[]} input list\r\n * @param {function(T): Buffer} fn map function\r\n * @returns {Buffer[]} buffers without duplicates\r\n */\r\nconst mapAndDeduplicateBuffers = (input, fn) => {\r\n\t// Buffer.equals compares size first so this should be efficient enough\r\n\t// If it becomes a performance problem we can use a map and group by size\r\n\t// instead of looping over all assets.\r\n\tconst result = [];\r\n\touter: for (const value of input) {\r\n\t\tconst buf = fn(value);\r\n\t\tfor (const other of result) {\r\n\t\t\tif (buf.equals(other)) continue outer;\r\n\t\t}\r\n\t\tresult.push(buf);\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Escapes regular expression metacharacters\r\n * @param {string} str String to quote\r\n * @returns {string} Escaped string\r\n */\r\nconst quoteMeta = str => {\r\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\r\n};\r\n\r\nconst cachedSourceMap = new WeakMap();\r\n\r\nconst toCachedSource = source => {\r\n\tif (source instanceof CachedSource) {\r\n\t\treturn source;\r\n\t}\r\n\tconst entry = cachedSourceMap.get(source);\r\n\tif (entry !== undefined) return entry;\r\n\tconst newSource = new CachedSource(CompatSource.from(source));\r\n\tcachedSourceMap.set(source, newSource);\r\n\treturn newSource;\r\n};\r\n\r\n/**\r\n * @typedef {Object} AssetInfoForRealContentHash\r\n * @property {string} name\r\n * @property {AssetInfo} info\r\n * @property {Source} source\r\n * @property {RawSource | undefined} newSource\r\n * @property {RawSource | undefined} newSourceWithoutOwn\r\n * @property {string} content\r\n * @property {Set<string>} ownHashes\r\n * @property {Promise} contentComputePromise\r\n * @property {Promise} contentComputeWithoutOwnPromise\r\n * @property {Set<string>} referencedHashes\r\n * @property {Set<string>} hashes\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationHooks\r\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\r\n */\r\n\r\n/** @type {WeakMap<Compilation, CompilationHooks>} */\r\nconst compilationHooksMap = new WeakMap();\r\n\r\nclass RealContentHashPlugin {\r\n\t/**\r\n\t * @param {Compilation} compilation the compilation\r\n\t * @returns {CompilationHooks} the attached hooks\r\n\t */\r\n\tstatic getCompilationHooks(compilation) {\r\n\t\tif (!(compilation instanceof Compilation)) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\r\n\t\t\t);\r\n\t\t}\r\n\t\tlet hooks = compilationHooksMap.get(compilation);\r\n\t\tif (hooks === undefined) {\r\n\t\t\thooks = {\r\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\r\n\t\t\t};\r\n\t\t\tcompilationHooksMap.set(compilation, hooks);\r\n\t\t}\r\n\t\treturn hooks;\r\n\t}\r\n\r\n\tconstructor({ hashFunction, hashDigest }) {\r\n\t\tthis._hashFunction = hashFunction;\r\n\t\tthis._hashDigest = hashDigest;\r\n\t}\r\n\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler the compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\r\n\t\t\tconst cacheAnalyse = compilation.getCache(\r\n\t\t\t\t\"RealContentHashPlugin|analyse\"\r\n\t\t\t);\r\n\t\t\tconst cacheGenerate = compilation.getCache(\r\n\t\t\t\t\"RealContentHashPlugin|generate\"\r\n\t\t\t);\r\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\r\n\t\t\tcompilation.hooks.processAssets.tapPromise(\r\n\t\t\t\t{\r\n\t\t\t\t\tname: \"RealContentHashPlugin\",\r\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\r\n\t\t\t\t},\r\n\t\t\t\tasync () => {\r\n\t\t\t\t\tconst assets = compilation.getAssets();\r\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\r\n\t\t\t\t\tconst assetsWithInfo = [];\r\n\t\t\t\t\tconst hashToAssets = new Map();\r\n\t\t\t\t\tfor (const { source, info, name } of assets) {\r\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\r\n\t\t\t\t\t\tconst content = cachedSource.source();\r\n\t\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\t\tconst hashes = new Set();\r\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\r\n\t\t\t\t\t\tconst data = {\r\n\t\t\t\t\t\t\tname,\r\n\t\t\t\t\t\t\tinfo,\r\n\t\t\t\t\t\t\tsource: cachedSource,\r\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\r\n\t\t\t\t\t\t\tnewSource: undefined,\r\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\r\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\r\n\t\t\t\t\t\t\tcontent,\r\n\t\t\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\t\t\townHashes: undefined,\r\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\r\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\r\n\t\t\t\t\t\t\t/** @type {Set<string>} */\r\n\t\t\t\t\t\t\treferencedHashes: undefined,\r\n\t\t\t\t\t\t\thashes\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tassetsWithInfo.push(data);\r\n\t\t\t\t\t\tfor (const hash of hashes) {\r\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\r\n\t\t\t\t\t\t\tif (list === undefined) {\r\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlist.push(data);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hashToAssets.size === 0) return;\r\n\t\t\t\t\tconst hashRegExp = new RegExp(\r\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\r\n\t\t\t\t\t\t\"g\"\r\n\t\t\t\t\t);\r\n\t\t\t\t\tawait Promise.all(\r\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\r\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\r\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\r\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\r\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\r\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\r\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\r\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\r\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\r\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\r\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\r\n\t\t\t\t\t\t\t\t\tif (inContent) {\r\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t);\r\n\t\t\t\t\tconst getDependencies = hash => {\r\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\r\n\t\t\t\t\t\tif (!assets) {\r\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\r\n\t\t\t\t\t\t\t\tasset.referencedHashes.has(hash)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\r\nSome kind of unexpected caching problem occurred.\r\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\r\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\r\nReferenced by:\r\n${referencingAssets\r\n\t.map(a => {\r\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\r\n\t\t\ta.content\r\n\t\t);\r\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\r\n\t})\r\n\t.join(\"\\n\")}`);\r\n\t\t\t\t\t\t\tcompilation.errors.push(err);\r\n\t\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst hashes = new Set();\r\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\r\n\t\t\t\t\t\t\tif (!ownHashes.has(hash)) {\r\n\t\t\t\t\t\t\t\tfor (const hash of ownHashes) {\r\n\t\t\t\t\t\t\t\t\thashes.add(hash);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (const hash of referencedHashes) {\r\n\t\t\t\t\t\t\t\thashes.add(hash);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn hashes;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst hashInfo = hash => {\r\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\r\n\t\t\t\t\t\treturn `${hash} (${Array.from(assets, a => a.name)})`;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst hashesInOrder = new Set();\r\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\r\n\t\t\t\t\t\tconst add = (hash, stack) => {\r\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\r\n\t\t\t\t\t\t\tif (!deps) return;\r\n\t\t\t\t\t\t\tstack.add(hash);\r\n\t\t\t\t\t\t\tfor (const dep of deps) {\r\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\r\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\r\n\t\t\t\t\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\r\n\t\t\t\t\t\t\t\t\t\t\tstack,\r\n\t\t\t\t\t\t\t\t\t\t\thashInfo\r\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tadd(dep, stack);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\thashesInOrder.add(hash);\r\n\t\t\t\t\t\t\tstack.delete(hash);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\r\n\t\t\t\t\t\tadd(hash, new Set());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst hashToNewHash = new Map();\r\n\t\t\t\t\tconst getEtag = asset =>\r\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\r\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\r\n\t\t\t\t\t\t\tArray.from(asset.referencedHashes, hash =>\r\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\r\n\t\t\t\t\t\t\t).join(\"|\")\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tconst computeNewContent = asset => {\r\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\r\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\r\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\r\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\r\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\r\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\r\n\t\t\t\t\t\t\t\t\tidentifier,\r\n\t\t\t\t\t\t\t\t\tetag,\r\n\t\t\t\t\t\t\t\t\t() => {\r\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\r\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})());\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\r\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\r\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\r\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\r\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\r\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\r\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\r\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\r\n\t\t\t\t\t\t\t\t\tidentifier,\r\n\t\t\t\t\t\t\t\t\tetag,\r\n\t\t\t\t\t\t\t\t\t() => {\r\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\r\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\r\n\t\t\t\t\t\t\t\t\t\t\thash => {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (asset.ownHashes.has(hash)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})());\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\r\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\r\n\t\t\t\t\t\tconst assets = hashToAssets.get(oldHash);\r\n\t\t\t\t\t\tassets.sort(comparator);\r\n\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\r\n\t\t\t\t\t\tawait Promise.all(\r\n\t\t\t\t\t\t\tassets.map(asset =>\r\n\t\t\t\t\t\t\t\tasset.ownHashes.has(oldHash)\r\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\r\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\r\n\t\t\t\t\t\t\tif (asset.ownHashes.has(oldHash)) {\r\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\r\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\r\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn asset.newSource\r\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\r\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\r\n\t\t\t\t\t\tif (!newHash) {\r\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\r\n\t\t\t\t\t\t\t\thash.update(content);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\r\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait Promise.all(\r\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\r\n\t\t\t\t\t\t\tawait computeNewContent(asset);\r\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\r\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tconst infoUpdate = {};\r\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\r\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\r\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\r\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\r\n\r\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\r\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\r\n\t\t\t\t\t\t\t\t\tasset.name,\r\n\t\t\t\t\t\t\t\t\tasset.newSource,\r\n\t\t\t\t\t\t\t\t\tinfoUpdate\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (asset.name !== newName) {\r\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = RealContentHashPlugin;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}