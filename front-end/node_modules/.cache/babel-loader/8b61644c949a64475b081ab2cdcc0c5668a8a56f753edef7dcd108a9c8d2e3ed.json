{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;\nexports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = void 0;\nconst crypto = require(\"crypto\");\nconst os = require(\"os\");\nconst url_1 = require(\"url\");\nconst bson_1 = require(\"./bson\");\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\nconst constants_2 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst write_concern_1 = require(\"./write_concern\");\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\r\n * Throws if collectionName is not a valid mongodb collection namespace.\r\n * @internal\r\n */\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  }\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\nexports.checkCollectionName = checkCollectionName;\n/**\r\n * Ensure Hint field is in a shape we expect:\r\n * - object of index names mapping to 1 or -1\r\n * - just an index name\r\n * @internal\r\n */\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n  return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\nconst TO_STRING = object => Object.prototype.toString.call(object);\n/**\r\n * Checks if arg is an Object:\r\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\r\n * @internal\r\n */\nfunction isObject(arg) {\n  return '[object Object]' === TO_STRING(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction mergeOptions(target, source) {\n  return {\n    ...target,\n    ...source\n  };\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  }\n  // Filtered options\n  return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\r\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\r\n * @internal\r\n *\r\n * @param target - The target command to which we will apply retryWrites.\r\n * @param db - The database from which we can inherit a retryWrites value.\r\n */\nfunction applyRetryableWrites(target, db) {\n  var _a;\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n  return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\r\n * Applies a write concern to a command based on well defined inheritance rules, optionally\r\n * detecting support for the write concern in the first place.\r\n * @internal\r\n *\r\n * @param target - the target command we will be applying the write concern to\r\n * @param sources - sources where we can inherit default write concerns from\r\n * @param options - optional settings passed into a command for write concern overrides\r\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const db = sources.db;\n  const coll = sources.collection;\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n    return target;\n  }\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n  return target;\n}\nexports.applyWriteConcern = applyWriteConcern;\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @typeParam T - The resolution type of the possible promise\r\n * @param value - An object that could be a promise\r\n * @returns true if the provided value is a Promise\r\n */\nfunction isPromiseLike(value) {\n  return !!value && typeof value.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\r\n * Applies collation to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply collation\r\n * @param target - target of command\r\n * @param options - options containing collation settings\r\n */\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\r\n * Applies a read concern to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply the read concern\r\n * @param coll - the parent collection of the operation calling this method\r\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  const readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\r\n * Applies an explain to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply the explain\r\n * @param options - the options containing the explain verbosity\r\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\r\n * A helper function to get the topology from a given provider. Throws\r\n * if the topology cannot be found.\r\n * @throws MongoNotConnectedError\r\n * @internal\r\n */\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/**\r\n * Default message handler for generating deprecation warnings.\r\n * @internal\r\n *\r\n * @param name - function name\r\n * @param option - option name\r\n * @returns warning message\r\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\r\n * Deprecates a given function's options.\r\n * @internal\r\n *\r\n * @param this - the bound class if this is a method\r\n * @param config - configuration for deprecation\r\n * @param fn - the target function of deprecation\r\n * @returns modified function that warns once per deprecated option, and executes original function\r\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n  function deprecated() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const options = args[config.optionsIndex];\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    }\n    // interrupt the function call with a warning\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n    return fn.bind(this)(...args);\n  }\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n  return deprecated;\n}\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nclass MongoDBNamespace {\n  /**\r\n   * Create a namespace object\r\n   *\r\n   * @param db - database name\r\n   * @param collection - collection name\r\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection === '' ? undefined : collection;\n  }\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n  static fromString(namespace) {\n    if (typeof namespace !== 'string' || namespace === '') {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n    const [db, ...collectionParts] = namespace.split('.');\n    const collection = collectionParts.join('.');\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n  }\n}\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\nfunction makeCounter() {\n  let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return function* () {\n    let count = seed;\n    while (true) {\n      const newCount = count;\n      count += 1;\n      yield newCount;\n    }\n  }();\n}\nexports.makeCounter = makeCounter;\nfunction maybeCallback(promiseFn, callback) {\n  const PromiseConstructor = promise_provider_1.PromiseProvider.get();\n  const promise = promiseFn();\n  if (callback == null) {\n    if (PromiseConstructor == null) {\n      return promise;\n    } else {\n      return new PromiseConstructor((resolve, reject) => {\n        promise.then(resolve, reject);\n      });\n    }\n  }\n  promise.then(result => callback(undefined, result), error => callback(error));\n  return;\n}\nexports.maybeCallback = maybeCallback;\n/** @internal */\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\nexports.databaseNamespace = databaseNamespace;\n/**\r\n * Synchronously Generate a UUIDv4\r\n * @internal\r\n */\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\nexports.uuidV4 = uuidV4;\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\r\n * @internal\r\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is available that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n  return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n * @internal\r\n *\r\n * @param arr - An array of items to asynchronously iterate over\r\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param callback - The callback called after every item has been iterated\r\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n    eachFn(arr[idx], eachCallback);\n  }\n  eachFn(arr[idx], eachCallback);\n}\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n  return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\nexports.makeStateMachine = makeStateMachine;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  };\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n  return metadata;\n}\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\r\n * Merge inherited properties from parent into options, prioritizing values from options,\r\n * then values from parent.\r\n * @internal\r\n */\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n  const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\n  const session = options === null || options === void 0 ? void 0 : options.session;\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n    const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n  const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n  return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.isSuperset = isSuperset;\n/**\r\n * Checks if the document is a Hello request\r\n * @internal\r\n */\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n  return difference;\n}\nexports.setDifference = setDifference;\nconst HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\nfunction isRecord(value) {\n  let requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (!isObject(value)) {\n    return false;\n  }\n  const ctor = value.constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n    // Check to see if some method exists from the Object exists\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n  return true;\n}\nexports.isRecord = isRecord;\n/**\r\n * Make a deep copy of an object\r\n *\r\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\r\n * but instead something that is good enough for the purposes of\r\n * command monitoring.\r\n */\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n  const ctor = value.constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value);\n      case 'set':\n        return new Set(value);\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n  return value;\n}\nexports.deepCopy = deepCopy;\n/**\r\n * A sequential list of items in a circularly linked list\r\n * @remarks\r\n * The head node is special, it is always defined and has a value of null.\r\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\r\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\r\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\r\n * @internal\r\n */\nclass List {\n  constructor() {\n    this.count = 0;\n    // this is carefully crafted:\n    // declaring a complete and consistently key ordered\n    // object is beneficial to the runtime optimizations\n    this.head = {\n      next: null,\n      prev: null,\n      value: null\n    };\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n  get length() {\n    return this.count;\n  }\n  get [Symbol.toStringTag]() {\n    return 'List';\n  }\n  toArray() {\n    return Array.from(this);\n  }\n  toString() {\n    return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\n  }\n  *[Symbol.iterator]() {\n    for (const node of this.nodes()) {\n      yield node.value;\n    }\n  }\n  *nodes() {\n    let ptr = this.head.next;\n    while (ptr !== this.head) {\n      // Save next before yielding so that we make removing within iteration safe\n      const {\n        next\n      } = ptr;\n      yield ptr;\n      ptr = next;\n    }\n  }\n  /** Insert at end of list */\n  push(value) {\n    this.count += 1;\n    const newNode = {\n      next: this.head,\n      prev: this.head.prev,\n      value\n    };\n    this.head.prev.next = newNode;\n    this.head.prev = newNode;\n  }\n  /** Inserts every item inside an iterable instead of the iterable itself */\n  pushMany(iterable) {\n    for (const value of iterable) {\n      this.push(value);\n    }\n  }\n  /** Insert at front of list */\n  unshift(value) {\n    this.count += 1;\n    const newNode = {\n      next: this.head.next,\n      prev: this.head,\n      value\n    };\n    this.head.next.prev = newNode;\n    this.head.next = newNode;\n  }\n  remove(node) {\n    if (node === this.head || this.length === 0) {\n      return null;\n    }\n    this.count -= 1;\n    const prevNode = node.prev;\n    const nextNode = node.next;\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n    return node.value;\n  }\n  /** Removes the first node at the front of the list */\n  shift() {\n    return this.remove(this.head.next);\n  }\n  /** Removes the last node at the end of the list */\n  pop() {\n    return this.remove(this.head.prev);\n  }\n  /** Iterates through the list and removes nodes where filter returns true */\n  prune(filter) {\n    for (const node of this.nodes()) {\n      if (filter(node.value)) {\n        this.remove(node);\n      }\n    }\n  }\n  clear() {\n    this.count = 0;\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n  /** Returns the first item in the list, does not remove */\n  first() {\n    // If the list is empty, value will be the head's null\n    return this.head.next.value;\n  }\n  /** Returns the last item in the list, does not remove */\n  last() {\n    // If the list is empty, value will be the head's null\n    return this.head.prev.value;\n  }\n}\nexports.List = List;\n/**\r\n * A pool of Buffers which allow you to read them as if they were one\r\n * @internal\r\n */\nclass BufferPool {\n  constructor() {\n    this.buffers = new List();\n    this.totalByteLength = 0;\n  }\n  get length() {\n    return this.totalByteLength;\n  }\n  /** Adds a buffer to the internal buffer pool list */\n  append(buffer) {\n    this.buffers.push(buffer);\n    this.totalByteLength += buffer.length;\n  }\n  /**\r\n   * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\r\n   * otherwise return null. Size can be negative, caller should error check.\r\n   */\n  getInt32() {\n    if (this.totalByteLength < 4) {\n      return null;\n    }\n    const firstBuffer = this.buffers.first();\n    if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n      return firstBuffer.readInt32LE(0);\n    }\n    // Unlikely case: an int32 is split across buffers.\n    // Use read and put the returned buffer back on top\n    const top4Bytes = this.read(4);\n    const value = top4Bytes.readInt32LE(0);\n    // Put it back.\n    this.totalByteLength += 4;\n    this.buffers.unshift(top4Bytes);\n    return value;\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n  read(size) {\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n    // oversized request returns empty buffer\n    if (size > this.totalByteLength) {\n      return Buffer.alloc(0);\n    }\n    // We know we have enough, we just don't know how it is spread across chunks\n    // TODO(NODE-4732): alloc API should change based on raw option\n    const result = Buffer.allocUnsafe(size);\n    for (let bytesRead = 0; bytesRead < size;) {\n      const buffer = this.buffers.shift();\n      if (buffer == null) {\n        break;\n      }\n      const bytesRemaining = size - bytesRead;\n      const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n      const bytes = buffer.subarray(0, bytesReadable);\n      result.set(bytes, bytesRead);\n      bytesRead += bytesReadable;\n      this.totalByteLength -= bytesReadable;\n      if (bytesReadable < buffer.byteLength) {\n        this.buffers.unshift(buffer.subarray(bytesReadable));\n      }\n    }\n    return result;\n  }\n}\nexports.BufferPool = BufferPool;\n/** @public */\nclass HostAddress {\n  constructor(hostString) {\n    this.host = undefined;\n    this.port = undefined;\n    this.socketPath = undefined;\n    this.isIPv6 = false;\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n    if (escapedHost.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(escapedHost);\n      return;\n    }\n    const urlString = `iLoveJS://${escapedHost}`;\n    let url;\n    try {\n      url = new url_1.URL(urlString);\n    } catch (urlError) {\n      const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\n      runtimeError.cause = urlError;\n      throw runtimeError;\n    }\n    const hostname = url.hostname;\n    const port = url.port;\n    let normalized = decodeURIComponent(hostname).toLowerCase();\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\n      this.isIPv6 = true;\n      normalized = normalized.substring(1, hostname.length - 1);\n    }\n    this.host = normalized.toLowerCase();\n    if (typeof port === 'number') {\n      this.port = port;\n    } else if (typeof port === 'string' && port !== '') {\n      this.port = Number.parseInt(port, 10);\n    } else {\n      this.port = 27017;\n    }\n    if (this.port === 0) {\n      throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n    }\n    Object.freeze(this);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new HostAddress('${this.toString()}')`;\n  }\n  toString() {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6) {\n        return `[${this.host}]:${this.port}`;\n      }\n      return `${this.host}:${this.port}`;\n    }\n    return `${this.socketPath}`;\n  }\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n  static fromHostPort(host, port) {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n  static fromSrvRecord(_ref) {\n    let {\n      name,\n      port\n    } = _ref;\n    return HostAddress.fromHostPort(name, port);\n  }\n}\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n};\n/**\r\n * When the driver used emitWarning the code will be equal to this.\r\n * @public\r\n *\r\n * @example\r\n * ```ts\r\n * process.on('warning', (warning) => {\r\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\r\n * })\r\n * ```\r\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\r\n * Will emit a warning once for the duration of the application.\r\n * Uses the message to identify if it has already been emitted\r\n * so using string interpolation can cause multiple emits\r\n * @internal\r\n */\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\r\n * Takes a JS object and joins the values into a string separated by ', '\r\n */\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\r\n * Determine if a server supports retryable writes.\r\n *\r\n * @internal\r\n */\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n  return false;\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\nfunction parsePackageVersion(_ref2) {\n  let {\n    version\n  } = _ref2;\n  const [major, minor, patch] = version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major,\n    minor,\n    patch\n  };\n}\nexports.parsePackageVersion = parsePackageVersion;\n/**\r\n * Fisherâ€“Yates Shuffle\r\n *\r\n * Reference: https://bost.ocks.org/mike/shuffle/\r\n * @param sequence - items to be shuffled\r\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\r\n */\nfunction shuffle(sequence) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1;\n    // And swap it with the current element\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\nexports.shuffle = shuffle;\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n  return false;\n}\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\nfunction getMongoDBClientEncryption() {\n  let mongodbClientEncryption = null;\n  // NOTE(NODE-4254): This is to get around the circular dependency between\n  // mongodb-client-encryption and the driver in the test scenarios.\n  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n    } catch {\n      // ignore\n    }\n  } else {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require('mongodb-client-encryption');\n    } catch {\n      // ignore\n    }\n  }\n  return mongodbClientEncryption;\n}\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;\n/**\r\n * Compare objectIds. `null` is always less\r\n * - `+1 = oid1 is greater than oid2`\r\n * - `-1 = oid1 is less than oid2`\r\n * - `+0 = oid1 is equal oid2`\r\n */\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null && oid2 == null) {\n    return 0;\n  }\n  if (oid1 == null) {\n    return -1;\n  }\n  if (oid2 == null) {\n    return 1;\n  }\n  return oid1.id.compare(oid2.id);\n}\nexports.compareObjectId = compareObjectId;\nfunction parseInteger(value) {\n  if (typeof value === 'number') return Math.trunc(value);\n  const parsedValue = Number.parseInt(String(value), 10);\n  return Number.isNaN(parsedValue) ? null : parsedValue;\n}\nexports.parseInteger = parseInteger;\nfunction parseUnsignedInteger(value) {\n  const parsedInt = parseInteger(value);\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\nexports.parseUnsignedInteger = parseUnsignedInteger;","map":{"version":3,"mappings":"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","names":["exports","Number","MAX_SAFE_INTEGER","checkCollectionName","collectionName","error_1","indexOf","match","normalizeHintField","hint","finalHint","undefined","Array","isArray","forEach","param","name","TO_STRING","object","Object","prototype","toString","call","isObject","arg","mergeOptions","target","source","filterOptions","options","names","includes","applyRetryableWrites","db","s","retryWrites","applyWriteConcern","sources","coll","collection","session","inTransaction","writeConcern","write_concern_1","fromOptions","assign","isPromiseLike","value","then","decorateWithCollation","command","capabilities","getTopology","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","keys","length","decorateWithExplain","explain","verbosity","provider","topology","client","defaultMsgHandler","option","deprecateOptions","config","fn","process","noDeprecation","msgHandler","optionsWarned","Set","deprecated","args","optionsIndex","bind","deprecatedOption","deprecatedOptions","has","add","msg","emitWarning","logger","getLogger","warn","setPrototypeOf","ns","MongoDBNamespace","fromString","constructor","withCollection","namespace","collectionParts","split","join","makeCounter","seed","count","newCount","maybeCallback","promiseFn","callback","PromiseConstructor","promise_provider_1","get","promise","resolve","reject","result","error","databaseNamespace","uuidV4","crypto","randomBytes","maxWireVersion","topologyOrServer","loadBalanced","constants_1","hello","lastHello","description","eachAsync","arr","eachFn","idx","awaiting","eachCallback","err","eachAsyncSeries","arrayStrictEqual","arr2","every","elt","errorStrictEqual","lhs","rhs","message","makeStateMachine","stateTable","stateTransition","newState","legalStates","state","emit","NODE_DRIVER_VERSION","require","version","makeClientMetadata","metadata","driver","os","type","platform","architecture","arch","release","endianness","driverInfo","appName","buffer","Buffer","from","application","byteLength","slice","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","hasAtomicOperators","doc","document","resolveOptions","parent","readPreference","isSuperset","set","subset","elem","isHello","constants_2","setDifference","setA","setB","difference","delete","HAS_OWN","prop","hasOwnProperty","isRecord","requiredKeys","ctor","deepCopy","map","item","res","key","toLowerCase","Map","List","head","next","prev","Symbol","toStringTag","toArray","iterator","node","nodes","ptr","push","newNode","pushMany","iterable","unshift","remove","prevNode","nextNode","shift","pop","prune","filter","clear","first","last","BufferPool","buffers","totalByteLength","append","getInt32","firstBuffer","readInt32LE","top4Bytes","read","size","alloc","allocUnsafe","bytesRead","bytesRemaining","bytesReadable","min","bytes","subarray","HostAddress","hostString","escapedHost","endsWith","socketPath","decodeURIComponent","urlString","url","url_1","urlError","runtimeError","cause","hostname","port","normalized","startsWith","isIPv6","substring","host","parseInt","freeze","for","inspect","fromHostPort","fromSrvRecord","createPk","bson_1","code","emittedWarnings","emitWarningOnce","enumToString","en","values","supportsRetryableWrites","server","logicalSessionTimeoutMinutes","common_1","Standalone","parsePackageVersion","major","minor","patch","n","shuffle","sequence","limit","items","remainingItemsToShuffle","lowerBound","randomIndex","random","swapHold","commandSupportsReadConcern","aggregate","distinct","find","geoNear","mapReduce","out","inline","getMongoDBClientEncryption","mongodbClientEncryption","env","MONGODB_CLIENT_ENCRYPTION_OVERRIDE","compareObjectId","oid1","oid2","id","compare","parseInteger","trunc","parsedValue","String","isNaN","parseUnsignedInteger","parsedInt"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\utils.ts"],"sourcesContent":["import * as crypto from 'crypto';\r\nimport type { SrvRecord } from 'dns';\r\nimport * as os from 'os';\r\nimport { URL } from 'url';\r\n\r\nimport { Document, ObjectId, resolveBSONOptions } from './bson';\r\nimport type { Connection } from './cmap/connection';\r\nimport { MAX_SUPPORTED_WIRE_VERSION } from './cmap/wire_protocol/constants';\r\nimport type { Collection } from './collection';\r\nimport { LEGACY_HELLO_COMMAND } from './constants';\r\nimport type { AbstractCursor } from './cursor/abstract_cursor';\r\nimport type { FindCursor } from './cursor/find_cursor';\r\nimport type { Db } from './db';\r\nimport {\r\n  AnyError,\r\n  MongoCompatibilityError,\r\n  MongoInvalidArgumentError,\r\n  MongoNotConnectedError,\r\n  MongoParseError,\r\n  MongoRuntimeError\r\n} from './error';\r\nimport type { Explain } from './explain';\r\nimport type { MongoClient } from './mongo_client';\r\nimport type { CommandOperationOptions, OperationParent } from './operations/command';\r\nimport type { Hint, OperationOptions } from './operations/operation';\r\nimport { PromiseProvider } from './promise_provider';\r\nimport { ReadConcern } from './read_concern';\r\nimport { ReadPreference } from './read_preference';\r\nimport { ServerType } from './sdam/common';\r\nimport type { Server } from './sdam/server';\r\nimport type { Topology } from './sdam/topology';\r\nimport type { ClientSession } from './sessions';\r\nimport { W, WriteConcern, WriteConcernOptions } from './write_concern';\r\n\r\n/**\r\n * MongoDB Driver style callback\r\n * @public\r\n */\r\nexport type Callback<T = any> = (error?: AnyError, result?: T) => void;\r\n\r\nexport const MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\r\n\r\nexport type AnyOptions = Document;\r\n\r\n/**\r\n * Throws if collectionName is not a valid mongodb collection namespace.\r\n * @internal\r\n */\r\nexport function checkCollectionName(collectionName: string): void {\r\n  if ('string' !== typeof collectionName) {\r\n    throw new MongoInvalidArgumentError('Collection name must be a String');\r\n  }\r\n\r\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\r\n    throw new MongoInvalidArgumentError('Collection names cannot be empty');\r\n  }\r\n\r\n  if (\r\n    collectionName.indexOf('$') !== -1 &&\r\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\r\n  ) {\r\n    // TODO(NODE-3483): Use MongoNamespace static method\r\n    throw new MongoInvalidArgumentError(\"Collection names must not contain '$'\");\r\n  }\r\n\r\n  if (collectionName.match(/^\\.|\\.$/) != null) {\r\n    // TODO(NODE-3483): Use MongoNamespace static method\r\n    throw new MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\r\n  }\r\n\r\n  // Validate that we are not passing 0x00 in the collection name\r\n  if (collectionName.indexOf('\\x00') !== -1) {\r\n    // TODO(NODE-3483): Use MongoNamespace static method\r\n    throw new MongoInvalidArgumentError('Collection names cannot contain a null character');\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure Hint field is in a shape we expect:\r\n * - object of index names mapping to 1 or -1\r\n * - just an index name\r\n * @internal\r\n */\r\nexport function normalizeHintField(hint?: Hint): Hint | undefined {\r\n  let finalHint = undefined;\r\n\r\n  if (typeof hint === 'string') {\r\n    finalHint = hint;\r\n  } else if (Array.isArray(hint)) {\r\n    finalHint = {};\r\n\r\n    hint.forEach(param => {\r\n      finalHint[param] = 1;\r\n    });\r\n  } else if (hint != null && typeof hint === 'object') {\r\n    finalHint = {} as Document;\r\n    for (const name in hint) {\r\n      finalHint[name] = hint[name];\r\n    }\r\n  }\r\n\r\n  return finalHint;\r\n}\r\n\r\nconst TO_STRING = (object: unknown) => Object.prototype.toString.call(object);\r\n/**\r\n * Checks if arg is an Object:\r\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\r\n * @internal\r\n */\r\n\r\nexport function isObject(arg: unknown): arg is object {\r\n  return '[object Object]' === TO_STRING(arg);\r\n}\r\n\r\n/** @internal */\r\nexport function mergeOptions<T, S>(target: T, source: S): T & S {\r\n  return { ...target, ...source };\r\n}\r\n\r\n/** @internal */\r\nexport function filterOptions(options: AnyOptions, names: ReadonlyArray<string>): AnyOptions {\r\n  const filterOptions: AnyOptions = {};\r\n\r\n  for (const name in options) {\r\n    if (names.includes(name)) {\r\n      filterOptions[name] = options[name];\r\n    }\r\n  }\r\n\r\n  // Filtered options\r\n  return filterOptions;\r\n}\r\n\r\ninterface HasRetryableWrites {\r\n  retryWrites?: boolean;\r\n}\r\n/**\r\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\r\n * @internal\r\n *\r\n * @param target - The target command to which we will apply retryWrites.\r\n * @param db - The database from which we can inherit a retryWrites value.\r\n */\r\nexport function applyRetryableWrites<T extends HasRetryableWrites>(target: T, db?: Db): T {\r\n  if (db && db.s.options?.retryWrites) {\r\n    target.retryWrites = true;\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\ninterface HasWriteConcern {\r\n  writeConcern?: WriteConcernOptions | WriteConcern | W;\r\n}\r\n/**\r\n * Applies a write concern to a command based on well defined inheritance rules, optionally\r\n * detecting support for the write concern in the first place.\r\n * @internal\r\n *\r\n * @param target - the target command we will be applying the write concern to\r\n * @param sources - sources where we can inherit default write concerns from\r\n * @param options - optional settings passed into a command for write concern overrides\r\n */\r\nexport function applyWriteConcern<T extends HasWriteConcern>(\r\n  target: T,\r\n  sources: { db?: Db; collection?: Collection },\r\n  options?: OperationOptions & WriteConcernOptions\r\n): T {\r\n  options = options ?? {};\r\n  const db = sources.db;\r\n  const coll = sources.collection;\r\n\r\n  if (options.session && options.session.inTransaction()) {\r\n    // writeConcern is not allowed within a multi-statement transaction\r\n    if (target.writeConcern) {\r\n      delete target.writeConcern;\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  const writeConcern = WriteConcern.fromOptions(options);\r\n  if (writeConcern) {\r\n    return Object.assign(target, { writeConcern });\r\n  }\r\n\r\n  if (coll && coll.writeConcern) {\r\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\r\n  }\r\n\r\n  if (db && db.writeConcern) {\r\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @typeParam T - The resolution type of the possible promise\r\n * @param value - An object that could be a promise\r\n * @returns true if the provided value is a Promise\r\n */\r\nexport function isPromiseLike<T = any>(value?: PromiseLike<T> | void): value is Promise<T> {\r\n  return !!value && typeof value.then === 'function';\r\n}\r\n\r\n/**\r\n * Applies collation to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply collation\r\n * @param target - target of command\r\n * @param options - options containing collation settings\r\n */\r\nexport function decorateWithCollation(\r\n  command: Document,\r\n  target: MongoClient | Db | Collection,\r\n  options: AnyOptions\r\n): void {\r\n  const capabilities = getTopology(target).capabilities;\r\n  if (options.collation && typeof options.collation === 'object') {\r\n    if (capabilities && capabilities.commandsTakeCollation) {\r\n      command.collation = options.collation;\r\n    } else {\r\n      throw new MongoCompatibilityError(`Current topology does not support collation`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Applies a read concern to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply the read concern\r\n * @param coll - the parent collection of the operation calling this method\r\n */\r\nexport function decorateWithReadConcern(\r\n  command: Document,\r\n  coll: { s: { readConcern?: ReadConcern } },\r\n  options?: OperationOptions\r\n): void {\r\n  if (options && options.session && options.session.inTransaction()) {\r\n    return;\r\n  }\r\n  const readConcern = Object.assign({}, command.readConcern || {});\r\n  if (coll.s.readConcern) {\r\n    Object.assign(readConcern, coll.s.readConcern);\r\n  }\r\n\r\n  if (Object.keys(readConcern).length > 0) {\r\n    Object.assign(command, { readConcern: readConcern });\r\n  }\r\n}\r\n\r\n/**\r\n * Applies an explain to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply the explain\r\n * @param options - the options containing the explain verbosity\r\n */\r\nexport function decorateWithExplain(command: Document, explain: Explain): Document {\r\n  if (command.explain) {\r\n    return command;\r\n  }\r\n\r\n  return { explain: command, verbosity: explain.verbosity };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type TopologyProvider =\r\n  | MongoClient\r\n  | ClientSession\r\n  | FindCursor\r\n  | AbstractCursor\r\n  | Collection<any>\r\n  | Db;\r\n\r\n/**\r\n * A helper function to get the topology from a given provider. Throws\r\n * if the topology cannot be found.\r\n * @throws MongoNotConnectedError\r\n * @internal\r\n */\r\nexport function getTopology(provider: TopologyProvider): Topology {\r\n  // MongoClient or ClientSession or AbstractCursor\r\n  if ('topology' in provider && provider.topology) {\r\n    return provider.topology;\r\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\r\n    return provider.s.client.topology;\r\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\r\n    return provider.s.db.s.client.topology;\r\n  }\r\n\r\n  throw new MongoNotConnectedError('MongoClient must be connected to perform this operation');\r\n}\r\n\r\n/**\r\n * Default message handler for generating deprecation warnings.\r\n * @internal\r\n *\r\n * @param name - function name\r\n * @param option - option name\r\n * @returns warning message\r\n */\r\nexport function defaultMsgHandler(name: string, option: string): string {\r\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\r\n}\r\n\r\nexport interface DeprecateOptionsConfig {\r\n  /** function name */\r\n  name: string;\r\n  /** options to deprecate */\r\n  deprecatedOptions: string[];\r\n  /** index of options object in function arguments array */\r\n  optionsIndex: number;\r\n  /** optional custom message handler to generate warnings */\r\n  msgHandler?(this: void, name: string, option: string): string;\r\n}\r\n\r\n/**\r\n * Deprecates a given function's options.\r\n * @internal\r\n *\r\n * @param this - the bound class if this is a method\r\n * @param config - configuration for deprecation\r\n * @param fn - the target function of deprecation\r\n * @returns modified function that warns once per deprecated option, and executes original function\r\n */\r\nexport function deprecateOptions(\r\n  this: unknown,\r\n  config: DeprecateOptionsConfig,\r\n  fn: (...args: any[]) => any\r\n): any {\r\n  if ((process as any).noDeprecation === true) {\r\n    return fn;\r\n  }\r\n\r\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\r\n\r\n  const optionsWarned = new Set();\r\n  function deprecated(this: any, ...args: any[]) {\r\n    const options = args[config.optionsIndex] as AnyOptions;\r\n\r\n    // ensure options is a valid, non-empty object, otherwise short-circuit\r\n    if (!isObject(options) || Object.keys(options).length === 0) {\r\n      return fn.bind(this)(...args); // call the function, no change\r\n    }\r\n\r\n    // interrupt the function call with a warning\r\n    for (const deprecatedOption of config.deprecatedOptions) {\r\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\r\n        optionsWarned.add(deprecatedOption);\r\n        const msg = msgHandler(config.name, deprecatedOption);\r\n        emitWarning(msg);\r\n        if (this && 'getLogger' in this) {\r\n          const logger = this.getLogger();\r\n          if (logger) {\r\n            logger.warn(msg);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return fn.bind(this)(...args);\r\n  }\r\n\r\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\r\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\r\n  Object.setPrototypeOf(deprecated, fn);\r\n  if (fn.prototype) {\r\n    // Setting this (rather than using Object.setPrototype, as above) ensures\r\n    // that calling the unwrapped constructor gives an instanceof the wrapped\r\n    // constructor.\r\n    deprecated.prototype = fn.prototype;\r\n  }\r\n\r\n  return deprecated;\r\n}\r\n\r\n/** @internal */\r\nexport function ns(ns: string): MongoDBNamespace {\r\n  return MongoDBNamespace.fromString(ns);\r\n}\r\n\r\n/** @public */\r\nexport class MongoDBNamespace {\r\n  db: string;\r\n  collection: string | undefined;\r\n  /**\r\n   * Create a namespace object\r\n   *\r\n   * @param db - database name\r\n   * @param collection - collection name\r\n   */\r\n  constructor(db: string, collection?: string) {\r\n    this.db = db;\r\n    this.collection = collection === '' ? undefined : collection;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\r\n  }\r\n\r\n  withCollection(collection: string): MongoDBNamespace {\r\n    return new MongoDBNamespace(this.db, collection);\r\n  }\r\n\r\n  static fromString(namespace?: string): MongoDBNamespace {\r\n    if (typeof namespace !== 'string' || namespace === '') {\r\n      // TODO(NODE-3483): Replace with MongoNamespaceError\r\n      throw new MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\r\n    }\r\n\r\n    const [db, ...collectionParts] = namespace.split('.');\r\n    const collection = collectionParts.join('.');\r\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport function* makeCounter(seed = 0): Generator<number> {\r\n  let count = seed;\r\n  while (true) {\r\n    const newCount = count;\r\n    count += 1;\r\n    yield newCount;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper for handling legacy callback support.\r\n */\r\nexport function maybeCallback<T>(promiseFn: () => Promise<T>, callback: null): Promise<T>;\r\nexport function maybeCallback<T>(\r\n  promiseFn: () => Promise<T>,\r\n  callback?: Callback<T>\r\n): Promise<T> | void;\r\nexport function maybeCallback<T>(\r\n  promiseFn: () => Promise<T>,\r\n  callback?: Callback<T> | null\r\n): Promise<T> | void {\r\n  const PromiseConstructor = PromiseProvider.get();\r\n\r\n  const promise = promiseFn();\r\n  if (callback == null) {\r\n    if (PromiseConstructor == null) {\r\n      return promise;\r\n    } else {\r\n      return new PromiseConstructor((resolve, reject) => {\r\n        promise.then(resolve, reject);\r\n      });\r\n    }\r\n  }\r\n\r\n  promise.then(\r\n    result => callback(undefined, result),\r\n    error => callback(error)\r\n  );\r\n  return;\r\n}\r\n\r\n/** @internal */\r\nexport function databaseNamespace(ns: string): string {\r\n  return ns.split('.')[0];\r\n}\r\n\r\n/**\r\n * Synchronously Generate a UUIDv4\r\n * @internal\r\n */\r\nexport function uuidV4(): Buffer {\r\n  const result = crypto.randomBytes(16);\r\n  result[6] = (result[6] & 0x0f) | 0x40;\r\n  result[8] = (result[8] & 0x3f) | 0x80;\r\n  return result;\r\n}\r\n\r\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\r\n * @internal\r\n */\r\nexport function maxWireVersion(topologyOrServer?: Connection | Topology | Server): number {\r\n  if (topologyOrServer) {\r\n    if (topologyOrServer.loadBalanced) {\r\n      // Since we do not have a monitor, we assume the load balanced server is always\r\n      // pointed at the latest mongodb version. There is a risk that for on-prem\r\n      // deployments that don't upgrade immediately that this could alert to the\r\n      // application that a feature is available that is actually not.\r\n      return MAX_SUPPORTED_WIRE_VERSION;\r\n    }\r\n    if (topologyOrServer.hello) {\r\n      return topologyOrServer.hello.maxWireVersion;\r\n    }\r\n\r\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\r\n      const lastHello = topologyOrServer.lastHello();\r\n      if (lastHello) {\r\n        return lastHello.maxWireVersion;\r\n      }\r\n    }\r\n\r\n    if (\r\n      topologyOrServer.description &&\r\n      'maxWireVersion' in topologyOrServer.description &&\r\n      topologyOrServer.description.maxWireVersion != null\r\n    ) {\r\n      return topologyOrServer.description.maxWireVersion;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n * @internal\r\n *\r\n * @param arr - An array of items to asynchronously iterate over\r\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param callback - The callback called after every item has been iterated\r\n */\r\nexport function eachAsync<T = Document>(\r\n  arr: T[],\r\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\r\n  callback: Callback\r\n): void {\r\n  arr = arr || [];\r\n\r\n  let idx = 0;\r\n  let awaiting = 0;\r\n  for (idx = 0; idx < arr.length; ++idx) {\r\n    awaiting++;\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n\r\n  if (awaiting === 0) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  function eachCallback(err?: AnyError) {\r\n    awaiting--;\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (idx === arr.length && awaiting <= 0) {\r\n      callback();\r\n    }\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport function eachAsyncSeries<T = any>(\r\n  arr: T[],\r\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\r\n  callback: Callback\r\n): void {\r\n  arr = arr || [];\r\n\r\n  let idx = 0;\r\n  let awaiting = arr.length;\r\n  if (awaiting === 0) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  function eachCallback(err?: AnyError) {\r\n    idx++;\r\n    awaiting--;\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (idx === arr.length && awaiting <= 0) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n\r\n  eachFn(arr[idx], eachCallback);\r\n}\r\n\r\n/** @internal */\r\nexport function arrayStrictEqual(arr: unknown[], arr2: unknown[]): boolean {\r\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\r\n    return false;\r\n  }\r\n\r\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\r\n}\r\n\r\n/** @internal */\r\nexport function errorStrictEqual(lhs?: AnyError | null, rhs?: AnyError | null): boolean {\r\n  if (lhs === rhs) {\r\n    return true;\r\n  }\r\n\r\n  if (!lhs || !rhs) {\r\n    return lhs === rhs;\r\n  }\r\n\r\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\r\n    return false;\r\n  }\r\n\r\n  if (lhs.constructor.name !== rhs.constructor.name) {\r\n    return false;\r\n  }\r\n\r\n  if (lhs.message !== rhs.message) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\ninterface StateTable {\r\n  [key: string]: string[];\r\n}\r\ninterface ObjectWithState {\r\n  s: { state: string };\r\n  emit(event: 'stateChanged', state: string, newState: string): void;\r\n}\r\ninterface StateTransitionFunction {\r\n  (target: ObjectWithState, newState: string): void;\r\n}\r\n\r\n/** @public */\r\nexport type EventEmitterWithState = {\r\n  /** @internal */\r\n  stateChanged(previous: string, current: string): void;\r\n};\r\n\r\n/** @internal */\r\nexport function makeStateMachine(stateTable: StateTable): StateTransitionFunction {\r\n  return function stateTransition(target, newState) {\r\n    const legalStates = stateTable[target.s.state];\r\n    if (legalStates && legalStates.indexOf(newState) < 0) {\r\n      throw new MongoRuntimeError(\r\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\r\n      );\r\n    }\r\n\r\n    target.emit('stateChanged', target.s.state, newState);\r\n    target.s.state = newState;\r\n  };\r\n}\r\n\r\n/** @public */\r\nexport interface ClientMetadata {\r\n  driver: {\r\n    name: string;\r\n    version: string;\r\n  };\r\n  os: {\r\n    type: string;\r\n    name: NodeJS.Platform;\r\n    architecture: string;\r\n    version: string;\r\n  };\r\n  platform: string;\r\n  version?: string;\r\n  application?: {\r\n    name: string;\r\n  };\r\n}\r\n\r\n/** @public */\r\nexport interface ClientMetadataOptions {\r\n  driverInfo?: {\r\n    name?: string;\r\n    version?: string;\r\n    platform?: string;\r\n  };\r\n  appName?: string;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst NODE_DRIVER_VERSION = require('../package.json').version;\r\n\r\nexport function makeClientMetadata(options?: ClientMetadataOptions): ClientMetadata {\r\n  options = options ?? {};\r\n\r\n  const metadata: ClientMetadata = {\r\n    driver: {\r\n      name: 'nodejs',\r\n      version: NODE_DRIVER_VERSION\r\n    },\r\n    os: {\r\n      type: os.type(),\r\n      name: process.platform,\r\n      architecture: process.arch,\r\n      version: os.release()\r\n    },\r\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\r\n  };\r\n\r\n  // support optionally provided wrapping driver info\r\n  if (options.driverInfo) {\r\n    if (options.driverInfo.name) {\r\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\r\n    }\r\n\r\n    if (options.driverInfo.version) {\r\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\r\n    }\r\n\r\n    if (options.driverInfo.platform) {\r\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\r\n    }\r\n  }\r\n\r\n  if (options.appName) {\r\n    // MongoDB requires the appName not exceed a byte length of 128\r\n    const buffer = Buffer.from(options.appName);\r\n    metadata.application = {\r\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\r\n    };\r\n  }\r\n\r\n  return metadata;\r\n}\r\n\r\n/** @internal */\r\nexport function now(): number {\r\n  const hrtime = process.hrtime();\r\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\r\n}\r\n\r\n/** @internal */\r\nexport function calculateDurationInMs(started: number): number {\r\n  if (typeof started !== 'number') {\r\n    throw new MongoInvalidArgumentError('Numeric value required to calculate duration');\r\n  }\r\n\r\n  const elapsed = now() - started;\r\n  return elapsed < 0 ? 0 : elapsed;\r\n}\r\n\r\n/** @internal */\r\nexport function hasAtomicOperators(doc: Document | Document[]): boolean {\r\n  if (Array.isArray(doc)) {\r\n    for (const document of doc) {\r\n      if (hasAtomicOperators(document)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  const keys = Object.keys(doc);\r\n  return keys.length > 0 && keys[0][0] === '$';\r\n}\r\n\r\n/**\r\n * Merge inherited properties from parent into options, prioritizing values from options,\r\n * then values from parent.\r\n * @internal\r\n */\r\nexport function resolveOptions<T extends CommandOperationOptions>(\r\n  parent: OperationParent | undefined,\r\n  options?: T\r\n): T {\r\n  const result: T = Object.assign({}, options, resolveBSONOptions(options, parent));\r\n\r\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\r\n  const session = options?.session;\r\n  if (!session?.inTransaction()) {\r\n    const readConcern = ReadConcern.fromOptions(options) ?? parent?.readConcern;\r\n    if (readConcern) {\r\n      result.readConcern = readConcern;\r\n    }\r\n\r\n    const writeConcern = WriteConcern.fromOptions(options) ?? parent?.writeConcern;\r\n    if (writeConcern) {\r\n      result.writeConcern = writeConcern;\r\n    }\r\n  }\r\n\r\n  const readPreference = ReadPreference.fromOptions(options) ?? parent?.readPreference;\r\n  if (readPreference) {\r\n    result.readPreference = readPreference;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function isSuperset(set: Set<any> | any[], subset: Set<any> | any[]): boolean {\r\n  set = Array.isArray(set) ? new Set(set) : set;\r\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\r\n  for (const elem of subset) {\r\n    if (!set.has(elem)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Checks if the document is a Hello request\r\n * @internal\r\n */\r\nexport function isHello(doc: Document): boolean {\r\n  return doc[LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\r\n}\r\n\r\n/** Returns the items that are uniquely in setA */\r\nexport function setDifference<T>(setA: Iterable<T>, setB: Iterable<T>): Set<T> {\r\n  const difference = new Set<T>(setA);\r\n  for (const elem of setB) {\r\n    difference.delete(elem);\r\n  }\r\n  return difference;\r\n}\r\n\r\nconst HAS_OWN = (object: unknown, prop: string) =>\r\n  Object.prototype.hasOwnProperty.call(object, prop);\r\n\r\nexport function isRecord<T extends readonly string[]>(\r\n  value: unknown,\r\n  requiredKeys: T\r\n): value is Record<T[number], any>;\r\nexport function isRecord(value: unknown): value is Record<string, any>;\r\nexport function isRecord(\r\n  value: unknown,\r\n  requiredKeys: string[] | undefined = undefined\r\n): value is Record<string, any> {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n\r\n  const ctor = (value as any).constructor;\r\n  if (ctor && ctor.prototype) {\r\n    if (!isObject(ctor.prototype)) {\r\n      return false;\r\n    }\r\n\r\n    // Check to see if some method exists from the Object exists\r\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (requiredKeys) {\r\n    const keys = Object.keys(value as Record<string, any>);\r\n    return isSuperset(keys, requiredKeys);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Make a deep copy of an object\r\n *\r\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\r\n * but instead something that is good enough for the purposes of\r\n * command monitoring.\r\n */\r\nexport function deepCopy<T>(value: T): T {\r\n  if (value == null) {\r\n    return value;\r\n  } else if (Array.isArray(value)) {\r\n    return value.map(item => deepCopy(item)) as unknown as T;\r\n  } else if (isRecord(value)) {\r\n    const res = {} as any;\r\n    for (const key in value) {\r\n      res[key] = deepCopy(value[key]);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  const ctor = (value as any).constructor;\r\n  if (ctor) {\r\n    switch (ctor.name.toLowerCase()) {\r\n      case 'date':\r\n        return new ctor(Number(value));\r\n      case 'map':\r\n        return new Map(value as any) as unknown as T;\r\n      case 'set':\r\n        return new Set(value as any) as unknown as T;\r\n      case 'buffer':\r\n        return Buffer.from(value as unknown as Buffer) as unknown as T;\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\ntype ListNode<T> = {\r\n  value: T;\r\n  next: ListNode<T> | HeadNode<T>;\r\n  prev: ListNode<T> | HeadNode<T>;\r\n};\r\n\r\ntype HeadNode<T> = {\r\n  value: null;\r\n  next: ListNode<T>;\r\n  prev: ListNode<T>;\r\n};\r\n\r\n/**\r\n * When a list is empty the head is a reference with pointers to itself\r\n * So this type represents that self referential state\r\n */\r\ntype EmptyNode = {\r\n  value: null;\r\n  next: EmptyNode;\r\n  prev: EmptyNode;\r\n};\r\n\r\n/**\r\n * A sequential list of items in a circularly linked list\r\n * @remarks\r\n * The head node is special, it is always defined and has a value of null.\r\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\r\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\r\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\r\n * @internal\r\n */\r\nexport class List<T = unknown> {\r\n  private readonly head: HeadNode<T> | EmptyNode;\r\n  private count: number;\r\n\r\n  get length() {\r\n    return this.count;\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'List' as const;\r\n  }\r\n\r\n  constructor() {\r\n    this.count = 0;\r\n\r\n    // this is carefully crafted:\r\n    // declaring a complete and consistently key ordered\r\n    // object is beneficial to the runtime optimizations\r\n    this.head = {\r\n      next: null,\r\n      prev: null,\r\n      value: null\r\n    } as unknown as EmptyNode;\r\n    this.head.next = this.head;\r\n    this.head.prev = this.head;\r\n  }\r\n\r\n  toArray() {\r\n    return Array.from(this);\r\n  }\r\n\r\n  toString() {\r\n    return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\r\n  }\r\n\r\n  *[Symbol.iterator](): Generator<T, void, void> {\r\n    for (const node of this.nodes()) {\r\n      yield node.value;\r\n    }\r\n  }\r\n\r\n  private *nodes(): Generator<ListNode<T>, void, void> {\r\n    let ptr: HeadNode<T> | ListNode<T> | EmptyNode = this.head.next;\r\n    while (ptr !== this.head) {\r\n      // Save next before yielding so that we make removing within iteration safe\r\n      const { next } = ptr as ListNode<T>;\r\n      yield ptr as ListNode<T>;\r\n      ptr = next;\r\n    }\r\n  }\r\n\r\n  /** Insert at end of list */\r\n  push(value: T) {\r\n    this.count += 1;\r\n    const newNode: ListNode<T> = {\r\n      next: this.head as HeadNode<T>,\r\n      prev: this.head.prev as ListNode<T>,\r\n      value\r\n    };\r\n    this.head.prev.next = newNode;\r\n    this.head.prev = newNode;\r\n  }\r\n\r\n  /** Inserts every item inside an iterable instead of the iterable itself */\r\n  pushMany(iterable: Iterable<T>) {\r\n    for (const value of iterable) {\r\n      this.push(value);\r\n    }\r\n  }\r\n\r\n  /** Insert at front of list */\r\n  unshift(value: T) {\r\n    this.count += 1;\r\n    const newNode: ListNode<T> = {\r\n      next: this.head.next as ListNode<T>,\r\n      prev: this.head as HeadNode<T>,\r\n      value\r\n    };\r\n    this.head.next.prev = newNode;\r\n    this.head.next = newNode;\r\n  }\r\n\r\n  private remove(node: ListNode<T> | EmptyNode): T | null {\r\n    if (node === this.head || this.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    this.count -= 1;\r\n\r\n    const prevNode = node.prev;\r\n    const nextNode = node.next;\r\n    prevNode.next = nextNode;\r\n    nextNode.prev = prevNode;\r\n\r\n    return node.value;\r\n  }\r\n\r\n  /** Removes the first node at the front of the list */\r\n  shift(): T | null {\r\n    return this.remove(this.head.next);\r\n  }\r\n\r\n  /** Removes the last node at the end of the list */\r\n  pop(): T | null {\r\n    return this.remove(this.head.prev);\r\n  }\r\n\r\n  /** Iterates through the list and removes nodes where filter returns true */\r\n  prune(filter: (value: T) => boolean) {\r\n    for (const node of this.nodes()) {\r\n      if (filter(node.value)) {\r\n        this.remove(node);\r\n      }\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.count = 0;\r\n    this.head.next = this.head as EmptyNode;\r\n    this.head.prev = this.head as EmptyNode;\r\n  }\r\n\r\n  /** Returns the first item in the list, does not remove */\r\n  first(): T | null {\r\n    // If the list is empty, value will be the head's null\r\n    return this.head.next.value;\r\n  }\r\n\r\n  /** Returns the last item in the list, does not remove */\r\n  last(): T | null {\r\n    // If the list is empty, value will be the head's null\r\n    return this.head.prev.value;\r\n  }\r\n}\r\n\r\n/**\r\n * A pool of Buffers which allow you to read them as if they were one\r\n * @internal\r\n */\r\nexport class BufferPool {\r\n  private buffers: List<Buffer>;\r\n  private totalByteLength: number;\r\n\r\n  constructor() {\r\n    this.buffers = new List();\r\n    this.totalByteLength = 0;\r\n  }\r\n\r\n  get length(): number {\r\n    return this.totalByteLength;\r\n  }\r\n\r\n  /** Adds a buffer to the internal buffer pool list */\r\n  append(buffer: Buffer): void {\r\n    this.buffers.push(buffer);\r\n    this.totalByteLength += buffer.length;\r\n  }\r\n\r\n  /**\r\n   * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\r\n   * otherwise return null. Size can be negative, caller should error check.\r\n   */\r\n  getInt32(): number | null {\r\n    if (this.totalByteLength < 4) {\r\n      return null;\r\n    }\r\n    const firstBuffer = this.buffers.first();\r\n    if (firstBuffer != null && firstBuffer.byteLength >= 4) {\r\n      return firstBuffer.readInt32LE(0);\r\n    }\r\n\r\n    // Unlikely case: an int32 is split across buffers.\r\n    // Use read and put the returned buffer back on top\r\n    const top4Bytes = this.read(4);\r\n    const value = top4Bytes.readInt32LE(0);\r\n\r\n    // Put it back.\r\n    this.totalByteLength += 4;\r\n    this.buffers.unshift(top4Bytes);\r\n\r\n    return value;\r\n  }\r\n\r\n  /** Reads the requested number of bytes, optionally consuming them */\r\n  read(size: number): Buffer {\r\n    if (typeof size !== 'number' || size < 0) {\r\n      throw new MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\r\n    }\r\n\r\n    // oversized request returns empty buffer\r\n    if (size > this.totalByteLength) {\r\n      return Buffer.alloc(0);\r\n    }\r\n\r\n    // We know we have enough, we just don't know how it is spread across chunks\r\n    // TODO(NODE-4732): alloc API should change based on raw option\r\n    const result = Buffer.allocUnsafe(size);\r\n\r\n    for (let bytesRead = 0; bytesRead < size; ) {\r\n      const buffer = this.buffers.shift();\r\n      if (buffer == null) {\r\n        break;\r\n      }\r\n      const bytesRemaining = size - bytesRead;\r\n      const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\r\n      const bytes = buffer.subarray(0, bytesReadable);\r\n\r\n      result.set(bytes, bytesRead);\r\n\r\n      bytesRead += bytesReadable;\r\n      this.totalByteLength -= bytesReadable;\r\n      if (bytesReadable < buffer.byteLength) {\r\n        this.buffers.unshift(buffer.subarray(bytesReadable));\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport class HostAddress {\r\n  host: string | undefined = undefined;\r\n  port: number | undefined = undefined;\r\n  socketPath: string | undefined = undefined;\r\n  isIPv6 = false;\r\n\r\n  constructor(hostString: string) {\r\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\r\n\r\n    if (escapedHost.endsWith('.sock')) {\r\n      // heuristically determine if we're working with a domain socket\r\n      this.socketPath = decodeURIComponent(escapedHost);\r\n      return;\r\n    }\r\n\r\n    const urlString = `iLoveJS://${escapedHost}`;\r\n    let url;\r\n    try {\r\n      url = new URL(urlString);\r\n    } catch (urlError) {\r\n      const runtimeError = new MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\r\n      runtimeError.cause = urlError;\r\n      throw runtimeError;\r\n    }\r\n\r\n    const hostname = url.hostname;\r\n    const port = url.port;\r\n\r\n    let normalized = decodeURIComponent(hostname).toLowerCase();\r\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\r\n      this.isIPv6 = true;\r\n      normalized = normalized.substring(1, hostname.length - 1);\r\n    }\r\n\r\n    this.host = normalized.toLowerCase();\r\n\r\n    if (typeof port === 'number') {\r\n      this.port = port;\r\n    } else if (typeof port === 'string' && port !== '') {\r\n      this.port = Number.parseInt(port, 10);\r\n    } else {\r\n      this.port = 27017;\r\n    }\r\n\r\n    if (this.port === 0) {\r\n      throw new MongoParseError('Invalid port (zero) with hostname');\r\n    }\r\n    Object.freeze(this);\r\n  }\r\n\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    return `new HostAddress('${this.toString()}')`;\r\n  }\r\n\r\n  toString(): string {\r\n    if (typeof this.host === 'string') {\r\n      if (this.isIPv6) {\r\n        return `[${this.host}]:${this.port}`;\r\n      }\r\n      return `${this.host}:${this.port}`;\r\n    }\r\n    return `${this.socketPath}`;\r\n  }\r\n\r\n  static fromString(this: void, s: string): HostAddress {\r\n    return new HostAddress(s);\r\n  }\r\n\r\n  static fromHostPort(host: string, port: number): HostAddress {\r\n    if (host.includes(':')) {\r\n      host = `[${host}]`; // IPv6 address\r\n    }\r\n    return HostAddress.fromString(`${host}:${port}`);\r\n  }\r\n\r\n  static fromSrvRecord({ name, port }: SrvRecord): HostAddress {\r\n    return HostAddress.fromHostPort(name, port);\r\n  }\r\n}\r\n\r\nexport const DEFAULT_PK_FACTORY = {\r\n  // We prefer not to rely on ObjectId having a createPk method\r\n  createPk(): ObjectId {\r\n    return new ObjectId();\r\n  }\r\n};\r\n\r\n/**\r\n * When the driver used emitWarning the code will be equal to this.\r\n * @public\r\n *\r\n * @example\r\n * ```ts\r\n * process.on('warning', (warning) => {\r\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\r\n * })\r\n * ```\r\n */\r\nexport const MONGODB_WARNING_CODE = 'MONGODB DRIVER' as const;\r\n\r\n/** @internal */\r\nexport function emitWarning(message: string): void {\r\n  return process.emitWarning(message, { code: MONGODB_WARNING_CODE } as any);\r\n}\r\n\r\nconst emittedWarnings = new Set();\r\n/**\r\n * Will emit a warning once for the duration of the application.\r\n * Uses the message to identify if it has already been emitted\r\n * so using string interpolation can cause multiple emits\r\n * @internal\r\n */\r\nexport function emitWarningOnce(message: string): void {\r\n  if (!emittedWarnings.has(message)) {\r\n    emittedWarnings.add(message);\r\n    return emitWarning(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Takes a JS object and joins the values into a string separated by ', '\r\n */\r\nexport function enumToString(en: Record<string, unknown>): string {\r\n  return Object.values(en).join(', ');\r\n}\r\n\r\n/**\r\n * Determine if a server supports retryable writes.\r\n *\r\n * @internal\r\n */\r\nexport function supportsRetryableWrites(server?: Server): boolean {\r\n  if (!server) {\r\n    return false;\r\n  }\r\n\r\n  if (server.loadBalanced) {\r\n    // Loadbalanced topologies will always support retry writes\r\n    return true;\r\n  }\r\n\r\n  if (server.description.logicalSessionTimeoutMinutes != null) {\r\n    // that supports sessions\r\n    if (server.description.type !== ServerType.Standalone) {\r\n      // and that is not a standalone\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function parsePackageVersion({ version }: { version: string }): {\r\n  major: number;\r\n  minor: number;\r\n  patch: number;\r\n} {\r\n  const [major, minor, patch] = version.split('.').map((n: string) => Number.parseInt(n, 10));\r\n  return { major, minor, patch };\r\n}\r\n\r\n/**\r\n * Fisherâ€“Yates Shuffle\r\n *\r\n * Reference: https://bost.ocks.org/mike/shuffle/\r\n * @param sequence - items to be shuffled\r\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\r\n */\r\nexport function shuffle<T>(sequence: Iterable<T>, limit = 0): Array<T> {\r\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\r\n\r\n  if (limit > items.length) {\r\n    throw new MongoRuntimeError('Limit must be less than the number of items');\r\n  }\r\n\r\n  let remainingItemsToShuffle = items.length;\r\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\r\n  while (remainingItemsToShuffle > lowerBound) {\r\n    // Pick a remaining element\r\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\r\n    remainingItemsToShuffle -= 1;\r\n\r\n    // And swap it with the current element\r\n    const swapHold = items[remainingItemsToShuffle];\r\n    items[remainingItemsToShuffle] = items[randomIndex];\r\n    items[randomIndex] = swapHold;\r\n  }\r\n\r\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\r\n}\r\n\r\n// TODO: this should be codified in command construction\r\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\r\nexport function commandSupportsReadConcern(command: Document, options?: Document): boolean {\r\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\r\n    return true;\r\n  }\r\n\r\n  if (\r\n    command.mapReduce &&\r\n    options &&\r\n    options.out &&\r\n    (options.out.inline === 1 || options.out === 'inline')\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\r\nexport function getMongoDBClientEncryption(): {\r\n  extension: (mdb: unknown) => {\r\n    AutoEncrypter: any;\r\n    ClientEncryption: any;\r\n  };\r\n} | null {\r\n  let mongodbClientEncryption = null;\r\n\r\n  // NOTE(NODE-4254): This is to get around the circular dependency between\r\n  // mongodb-client-encryption and the driver in the test scenarios.\r\n  if (\r\n    typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' &&\r\n    process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0\r\n  ) {\r\n    try {\r\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\r\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\r\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\r\n      mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\r\n    } catch {\r\n      // ignore\r\n    }\r\n  } else {\r\n    try {\r\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\r\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\r\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\r\n      mongodbClientEncryption = require('mongodb-client-encryption');\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  return mongodbClientEncryption;\r\n}\r\n\r\n/**\r\n * Compare objectIds. `null` is always less\r\n * - `+1 = oid1 is greater than oid2`\r\n * - `-1 = oid1 is less than oid2`\r\n * - `+0 = oid1 is equal oid2`\r\n */\r\nexport function compareObjectId(oid1?: ObjectId | null, oid2?: ObjectId | null): 0 | 1 | -1 {\r\n  if (oid1 == null && oid2 == null) {\r\n    return 0;\r\n  }\r\n\r\n  if (oid1 == null) {\r\n    return -1;\r\n  }\r\n\r\n  if (oid2 == null) {\r\n    return 1;\r\n  }\r\n\r\n  return oid1.id.compare(oid2.id);\r\n}\r\n\r\nexport function parseInteger(value: unknown): number | null {\r\n  if (typeof value === 'number') return Math.trunc(value);\r\n  const parsedValue = Number.parseInt(String(value), 10);\r\n\r\n  return Number.isNaN(parsedValue) ? null : parsedValue;\r\n}\r\n\r\nexport function parseUnsignedInteger(value: unknown): number | null {\r\n  const parsedInt = parseInteger(value);\r\n\r\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}