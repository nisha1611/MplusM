{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst arraySum = array => {\n  let sum = 0;\n  for (const item of array) sum += item;\n  return sum;\n};\n\n/**\r\n * @param {any[]} args items to be truncated\r\n * @param {number} maxLength maximum length of args including spaces between\r\n * @returns {string[]} truncated args\r\n */\nconst truncateArgs = (args, maxLength) => {\n  const lengths = args.map(a => `${a}`.length);\n  const availableLength = maxLength - lengths.length + 1;\n  if (availableLength > 0 && args.length === 1) {\n    if (availableLength >= args[0].length) {\n      return args;\n    } else if (availableLength > 3) {\n      return [\"...\" + args[0].slice(-availableLength + 3)];\n    } else {\n      return [args[0].slice(-availableLength)];\n    }\n  }\n\n  // Check if there is space for at least 4 chars per arg\n  if (availableLength < arraySum(lengths.map(i => Math.min(i, 6)))) {\n    // remove args\n    if (args.length > 1) return truncateArgs(args.slice(0, args.length - 1), maxLength);\n    return [];\n  }\n  let currentLength = arraySum(lengths);\n\n  // Check if all fits into maxLength\n  if (currentLength <= availableLength) return args;\n\n  // Try to remove chars from the longest items until it fits\n  while (currentLength > availableLength) {\n    const maxLength = Math.max(...lengths);\n    const shorterItems = lengths.filter(l => l !== maxLength);\n    const nextToMaxLength = shorterItems.length > 0 ? Math.max(...shorterItems) : 0;\n    const maxReduce = maxLength - nextToMaxLength;\n    let maxItems = lengths.length - shorterItems.length;\n    let overrun = currentLength - availableLength;\n    for (let i = 0; i < lengths.length; i++) {\n      if (lengths[i] === maxLength) {\n        const reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\n        lengths[i] -= reduce;\n        currentLength -= reduce;\n        overrun -= reduce;\n        maxItems--;\n      }\n    }\n  }\n\n  // Return args reduced to length in lengths\n  return args.map((a, i) => {\n    const str = `${a}`;\n    const length = lengths[i];\n    if (str.length === length) {\n      return str;\n    } else if (length > 5) {\n      return \"...\" + str.slice(-length + 3);\n    } else if (length > 0) {\n      return str.slice(-length);\n    } else {\n      return \"\";\n    }\n  });\n};\nmodule.exports = truncateArgs;","map":{"version":3,"names":["arraySum","array","sum","item","truncateArgs","args","maxLength","lengths","map","a","length","availableLength","slice","i","Math","min","currentLength","max","shorterItems","filter","l","nextToMaxLength","maxReduce","maxItems","overrun","reduce","floor","str","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/logging/truncateArgs.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst arraySum = array => {\r\n\tlet sum = 0;\r\n\tfor (const item of array) sum += item;\r\n\treturn sum;\r\n};\r\n\r\n/**\r\n * @param {any[]} args items to be truncated\r\n * @param {number} maxLength maximum length of args including spaces between\r\n * @returns {string[]} truncated args\r\n */\r\nconst truncateArgs = (args, maxLength) => {\r\n\tconst lengths = args.map(a => `${a}`.length);\r\n\tconst availableLength = maxLength - lengths.length + 1;\r\n\r\n\tif (availableLength > 0 && args.length === 1) {\r\n\t\tif (availableLength >= args[0].length) {\r\n\t\t\treturn args;\r\n\t\t} else if (availableLength > 3) {\r\n\t\t\treturn [\"...\" + args[0].slice(-availableLength + 3)];\r\n\t\t} else {\r\n\t\t\treturn [args[0].slice(-availableLength)];\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if there is space for at least 4 chars per arg\r\n\tif (availableLength < arraySum(lengths.map(i => Math.min(i, 6)))) {\r\n\t\t// remove args\r\n\t\tif (args.length > 1)\r\n\t\t\treturn truncateArgs(args.slice(0, args.length - 1), maxLength);\r\n\t\treturn [];\r\n\t}\r\n\r\n\tlet currentLength = arraySum(lengths);\r\n\r\n\t// Check if all fits into maxLength\r\n\tif (currentLength <= availableLength) return args;\r\n\r\n\t// Try to remove chars from the longest items until it fits\r\n\twhile (currentLength > availableLength) {\r\n\t\tconst maxLength = Math.max(...lengths);\r\n\t\tconst shorterItems = lengths.filter(l => l !== maxLength);\r\n\t\tconst nextToMaxLength =\r\n\t\t\tshorterItems.length > 0 ? Math.max(...shorterItems) : 0;\r\n\t\tconst maxReduce = maxLength - nextToMaxLength;\r\n\t\tlet maxItems = lengths.length - shorterItems.length;\r\n\t\tlet overrun = currentLength - availableLength;\r\n\t\tfor (let i = 0; i < lengths.length; i++) {\r\n\t\t\tif (lengths[i] === maxLength) {\r\n\t\t\t\tconst reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\r\n\t\t\t\tlengths[i] -= reduce;\r\n\t\t\t\tcurrentLength -= reduce;\r\n\t\t\t\toverrun -= reduce;\r\n\t\t\t\tmaxItems--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return args reduced to length in lengths\r\n\treturn args.map((a, i) => {\r\n\t\tconst str = `${a}`;\r\n\t\tconst length = lengths[i];\r\n\t\tif (str.length === length) {\r\n\t\t\treturn str;\r\n\t\t} else if (length > 5) {\r\n\t\t\treturn \"...\" + str.slice(-length + 3);\r\n\t\t} else if (length > 0) {\r\n\t\t\treturn str.slice(-length);\r\n\t\t} else {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t});\r\n};\r\n\r\nmodule.exports = truncateArgs;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}