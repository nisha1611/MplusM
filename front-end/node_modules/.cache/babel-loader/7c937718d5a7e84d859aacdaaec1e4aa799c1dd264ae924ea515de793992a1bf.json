{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\r\n * A class representing a client session on the server\r\n *\r\n * NOTE: not meant to be instantiated directly.\r\n * @public\r\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\r\n   * Create a client session.\r\n   * @internal\r\n   * @param client - The current client\r\n   * @param sessionPool - The server session pool (Internal Class)\r\n   * @param options - Optional settings\r\n   * @param clientOptions - Optional settings provided when creating a MongoClient\r\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    var _b;\n    super();\n    /** @internal */\n    this[_a] = false;\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n    options = options !== null && options !== void 0 ? options : {};\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: (_b = options.causalConsistency) !== null && _b !== void 0 ? _b : defaultCausalConsistencyValue\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n  get id() {\n    var _b;\n    return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;\n  }\n  get serverSession() {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n  get loadBalanced() {\n    var _b;\n    return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n    this.transaction.unpinServer();\n  }\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const finalOptions = {\n      force: true,\n      ...options\n    };\n    return (0, utils_1.maybeCallback)(async () => {\n      try {\n        if (this.inTransaction()) {\n          await this.abortTransaction();\n        }\n        if (!this.hasEnded) {\n          const serverSession = this[kServerSession];\n          if (serverSession != null) {\n            // release the server session back to the pool\n            this.sessionPool.release(serverSession);\n            // Make sure a new serverSession never makes it onto this ClientSession\n            Object.defineProperty(this, kServerSession, {\n              value: ServerSession.clone(serverSession),\n              writable: false\n            });\n          }\n          // mark the session as ended, and emit a signal\n          this.hasEnded = true;\n          this.emit('ended', this);\n        }\n      } catch {\n        // spec indicates that we should ignore all errors for `endSessions`\n      } finally {\n        maybeClearPinnedConnection(this, finalOptions);\n      }\n    }, callback);\n  }\n  /**\r\n   * Advances the operationTime for a ClientSession.\r\n   *\r\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\r\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\r\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\r\n   *\r\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\r\n   */\n  advanceClusterTime(clusterTime) {\n    var _b, _c;\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n    if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\r\n   * Used to determine if this session equals another\r\n   *\r\n   * @param session - The session to compare to\r\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /**\r\n   * Increment the transaction number on the internal ServerSession\r\n   *\r\n   * @privateRemarks\r\n   * This helper increments a value stored on the client session that will be\r\n   * added to the serverSession's txnNumber upon applying it to a command.\r\n   * This is because the serverSession is lazily acquired after a connection is obtained\r\n   */\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\r\n   * Starts a new transaction with the given options.\r\n   *\r\n   * @param options - Options for the transaction\r\n   */\n  startTransaction(options) {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n      writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n      readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n      maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n  commitTransaction(callback) {\n    return (0, utils_1.maybeCallback)(async () => endTransactionAsync(this, 'commitTransaction'), callback);\n  }\n  abortTransaction(callback) {\n    return (0, utils_1.maybeCallback)(async () => endTransactionAsync(this, 'abortTransaction'), callback);\n  }\n  /**\r\n   * This is here to ensure that ClientSession is never serialized to BSON.\r\n   */\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\r\n   * Runs a provided callback within a transaction, retrying either the commitTransaction operation\r\n   * or entire transaction as needed (and when the error permits) to better ensure that\r\n   * the transaction can complete successfully.\r\n   *\r\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\r\n   * Any callbacks that do not return a Promise will result in undefined behavior.\r\n   *\r\n   * @remarks\r\n   * This function:\r\n   * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\r\n   * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\r\n   * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\r\n   *\r\n   * Checkout a descriptive example here:\r\n   * @see https://www.mongodb.com/developer/quickstart/node-transactions/\r\n   *\r\n   * @param fn - callback to run within a transaction\r\n   * @param options - optional settings for the transaction\r\n   * @returns A raw command response or undefined\r\n   */\n  withTransaction(fn, options) {\n    const startTime = (0, utils_1.now)();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n      if (options === null || options === void 0 ? void 0 : options.forceClear) {\n        loadBalancer.s.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n    session[kPinnedConnection] = undefined;\n  }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw err;\n  });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options) {\n  var _b;\n  session.startTransaction(options);\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    const PromiseConstructor = (_b = promise_provider_1.PromiseProvider.get()) !== null && _b !== void 0 ? _b : Promise;\n    promise = PromiseConstructor.reject(err);\n  }\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(() => null);\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n      throw err;\n    }\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n    return maybeRetryOrThrow(err);\n  });\n}\nconst endTransactionAsync = (0, util_1.promisify)(endTransaction);\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n  // construct and send the command\n  const command = {\n    [commandName]: 1\n  };\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  function commandHandler(error, result) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      }\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    if (error instanceof error_1.MongoError) {\n      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n          // per txns spec, must unpin session in this case\n          session.unpin({\n            error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error\n        });\n      }\n    }\n    callback(error, result);\n  }\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n  // send the command\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), (error, result) => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n    commandHandler(error, result);\n  });\n}\n/**\r\n * Reflects the existence of a session on the server. Can be reused by the session pool.\r\n * WARNING: not meant to be instantiated directly. For internal use only.\r\n * @public\r\n */\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\r\n   * Determines if the server session has timed out.\r\n   *\r\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\r\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\r\n   * @internal\r\n   * Cloning meant to keep a readable reference to the server session data\r\n   * after ClientSession has ended\r\n   */\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n}\nexports.ServerSession = ServerSession;\n/**\r\n * Maintains a pool of Server Sessions.\r\n * For internal use only\r\n * @internal\r\n */\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\r\n   * Acquire a Server Session from the pool.\r\n   * Iterates through each session in the pool, removing any stale sessions\r\n   * along the way. The first non-stale session found is removed from the\r\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\r\n   */\n  acquire() {\n    var _b, _c, _d;\n    const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n    let session = null;\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (potentialSession != null && (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    }\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n    return session;\n  }\n  /**\r\n   * Release a session to the session pool\r\n   * Adds the session back to the session pool if the session has not timed out yet.\r\n   * This method also removes any stale sessions from the pool.\r\n   *\r\n   * @param session - The session to release to the pool\r\n   */\n  release(session) {\n    var _b, _c, _d;\n    const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n    if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\r\n * Optionally decorate a command with sessions specific keys\r\n *\r\n * @param session - the session tracking transaction state\r\n * @param command - the command to decorate\r\n * @param options - Optional settings passed to calling operation\r\n *\r\n * @internal\r\n */\nfunction applySession(session, command, options) {\n  var _b, _c;\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n  if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n  return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"mappings":"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","names":["minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","ClientSession","mongo_types_1","constructor","client","sessionPool","options","clientOptions","error_1","ServerSessionPool","snapshot","causalConsistency","hasEnded","explicit","acquire","defaultCausalConsistencyValue","supports","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","Object","assign","transaction","transactions_1","id","serverSession","snapshotEnabled","loadBalanced","topology","description","type","common_1","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","constants_1","inTransaction","metrics_1","TXN","CURSOR","unpin","maybeClearPinnedConnection","unpinServer","isPinned","endSession","callback","finalOptions","force","abortTransaction","release","defineProperty","value","ServerSession","clone","writable","advanceOperationTime","greaterThan","advanceClusterTime","_bsontype","signature","hash","keyId","equals","session","buffer","incrementTransactionNumber","isActive","startTransaction","isCommitted","topologyMaxWireVersion","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","STARTING_TRANSACTION","commitTransaction","endTransactionAsync","toBSON","withTransaction","fn","startTime","attemptTransaction","exports","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","isUnknownTransactionCommitResult","err","isNonDeterministicWriteConcernError","codeName","has","isMaxTimeMSExpiredError","code","UnsatisfiableWriteConcern","UnknownReplWriteConcern","error","hasErrorLabel","TransientTransactionError","servers","Array","from","s","values","loadBalancer","pool","checkIn","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","catch","UnknownTransactionCommitResult","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","promise","PromiseConstructor","get","Promise","reject","then","maybeRetryOrThrow","addErrorLabel","endTransaction","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeout","maxTimeMS","commandHandler","result","RetryableWriteError","recoveryToken","run_command_1","read_preference_1","primary","bypassPinningCheck","bson_1","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","prototype","sessions","utils_1","logicalSessionTimeoutMinutes","length","potentialSession","shift","unshift","prune","applySession","lsid","inTxnOrTxnCommand","isRetryableWrite","willRetryWrite","fromNumber","afterClusterTime","level","read_concern_1","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","cursor"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongodb\\src\\sessions.ts"],"sourcesContent":["import { promisify } from 'util';\r\n\r\nimport { Binary, Document, Long, Timestamp } from './bson';\r\nimport type { CommandOptions, Connection } from './cmap/connection';\r\nimport { ConnectionPoolMetrics } from './cmap/metrics';\r\nimport { isSharded } from './cmap/wire_protocol/shared';\r\nimport { PINNED, UNPINNED } from './constants';\r\nimport type { AbstractCursor } from './cursor/abstract_cursor';\r\nimport {\r\n  AnyError,\r\n  MongoAPIError,\r\n  MongoCompatibilityError,\r\n  MONGODB_ERROR_CODES,\r\n  MongoDriverError,\r\n  MongoError,\r\n  MongoErrorLabel,\r\n  MongoExpiredSessionError,\r\n  MongoInvalidArgumentError,\r\n  MongoRuntimeError,\r\n  MongoServerError,\r\n  MongoTransactionError,\r\n  MongoWriteConcernError\r\n} from './error';\r\nimport type { MongoClient, MongoOptions } from './mongo_client';\r\nimport { TypedEventEmitter } from './mongo_types';\r\nimport { executeOperation } from './operations/execute_operation';\r\nimport { RunAdminCommandOperation } from './operations/run_command';\r\nimport { PromiseProvider } from './promise_provider';\r\nimport { ReadConcernLevel } from './read_concern';\r\nimport { ReadPreference } from './read_preference';\r\nimport { _advanceClusterTime, ClusterTime, TopologyType } from './sdam/common';\r\nimport { isTransactionCommand, Transaction, TransactionOptions, TxnState } from './transactions';\r\nimport {\r\n  calculateDurationInMs,\r\n  Callback,\r\n  commandSupportsReadConcern,\r\n  isPromiseLike,\r\n  List,\r\n  maxWireVersion,\r\n  maybeCallback,\r\n  now,\r\n  uuidV4\r\n} from './utils';\r\n\r\nconst minWireVersionForShardedTransactions = 8;\r\n\r\n/** @public */\r\nexport interface ClientSessionOptions {\r\n  /** Whether causal consistency should be enabled on this session */\r\n  causalConsistency?: boolean;\r\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\r\n  snapshot?: boolean;\r\n  /** The default TransactionOptions to use for transactions started on this session. */\r\n  defaultTransactionOptions?: TransactionOptions;\r\n\r\n  /** @internal */\r\n  owner?: symbol | AbstractCursor;\r\n  /** @internal */\r\n  explicit?: boolean;\r\n  /** @internal */\r\n  initialClusterTime?: ClusterTime;\r\n}\r\n\r\n/** @public */\r\nexport type WithTransactionCallback<T = void> = (session: ClientSession) => Promise<T>;\r\n\r\n/** @public */\r\nexport type ClientSessionEvents = {\r\n  ended(session: ClientSession): void;\r\n};\r\n\r\n/** @internal */\r\nconst kServerSession = Symbol('serverSession');\r\n/** @internal */\r\nconst kSnapshotTime = Symbol('snapshotTime');\r\n/** @internal */\r\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\r\n/** @internal */\r\nconst kPinnedConnection = Symbol('pinnedConnection');\r\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\r\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\r\n\r\n/** @public */\r\nexport interface EndSessionOptions {\r\n  /**\r\n   * An optional error which caused the call to end this session\r\n   * @internal\r\n   */\r\n  error?: AnyError;\r\n  force?: boolean;\r\n  forceClear?: boolean;\r\n}\r\n\r\n/**\r\n * A class representing a client session on the server\r\n *\r\n * NOTE: not meant to be instantiated directly.\r\n * @public\r\n */\r\nexport class ClientSession extends TypedEventEmitter<ClientSessionEvents> {\r\n  /** @internal */\r\n  client: MongoClient;\r\n  /** @internal */\r\n  sessionPool: ServerSessionPool;\r\n  hasEnded: boolean;\r\n  clientOptions?: MongoOptions;\r\n  supports: { causalConsistency: boolean };\r\n  clusterTime?: ClusterTime;\r\n  operationTime?: Timestamp;\r\n  explicit: boolean;\r\n  /** @internal */\r\n  owner?: symbol | AbstractCursor;\r\n  defaultTransactionOptions: TransactionOptions;\r\n  transaction: Transaction;\r\n  /** @internal */\r\n  [kServerSession]: ServerSession | null;\r\n  /** @internal */\r\n  [kSnapshotTime]?: Timestamp;\r\n  /** @internal */\r\n  [kSnapshotEnabled] = false;\r\n  /** @internal */\r\n  [kPinnedConnection]?: Connection;\r\n  /** @internal */\r\n  [kTxnNumberIncrement]: number;\r\n\r\n  /**\r\n   * Create a client session.\r\n   * @internal\r\n   * @param client - The current client\r\n   * @param sessionPool - The server session pool (Internal Class)\r\n   * @param options - Optional settings\r\n   * @param clientOptions - Optional settings provided when creating a MongoClient\r\n   */\r\n  constructor(\r\n    client: MongoClient,\r\n    sessionPool: ServerSessionPool,\r\n    options: ClientSessionOptions,\r\n    clientOptions?: MongoOptions\r\n  ) {\r\n    super();\r\n\r\n    if (client == null) {\r\n      // TODO(NODE-3483)\r\n      throw new MongoRuntimeError('ClientSession requires a MongoClient');\r\n    }\r\n\r\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\r\n      // TODO(NODE-3483)\r\n      throw new MongoRuntimeError('ClientSession requires a ServerSessionPool');\r\n    }\r\n\r\n    options = options ?? {};\r\n\r\n    if (options.snapshot === true) {\r\n      this[kSnapshotEnabled] = true;\r\n      if (options.causalConsistency === true) {\r\n        throw new MongoInvalidArgumentError(\r\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\r\n        );\r\n      }\r\n    }\r\n\r\n    this.client = client;\r\n    this.sessionPool = sessionPool;\r\n    this.hasEnded = false;\r\n    this.clientOptions = clientOptions;\r\n\r\n    this.explicit = !!options.explicit;\r\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\r\n    this[kTxnNumberIncrement] = 0;\r\n\r\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\r\n    this.supports = {\r\n      // if we can enable causal consistency, do so by default\r\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\r\n    };\r\n\r\n    this.clusterTime = options.initialClusterTime;\r\n\r\n    this.operationTime = undefined;\r\n    this.owner = options.owner;\r\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\r\n    this.transaction = new Transaction();\r\n  }\r\n\r\n  /** The server id associated with this session */\r\n  get id(): ServerSessionId | undefined {\r\n    return this[kServerSession]?.id;\r\n  }\r\n\r\n  get serverSession(): ServerSession {\r\n    let serverSession = this[kServerSession];\r\n    if (serverSession == null) {\r\n      if (this.explicit) {\r\n        throw new MongoRuntimeError('Unexpected null serverSession for an explicit session');\r\n      }\r\n      if (this.hasEnded) {\r\n        throw new MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\r\n      }\r\n      serverSession = this.sessionPool.acquire();\r\n      this[kServerSession] = serverSession;\r\n    }\r\n    return serverSession;\r\n  }\r\n\r\n  /** Whether or not this session is configured for snapshot reads */\r\n  get snapshotEnabled(): boolean {\r\n    return this[kSnapshotEnabled];\r\n  }\r\n\r\n  get loadBalanced(): boolean {\r\n    return this.client.topology?.description.type === TopologyType.LoadBalanced;\r\n  }\r\n\r\n  /** @internal */\r\n  get pinnedConnection(): Connection | undefined {\r\n    return this[kPinnedConnection];\r\n  }\r\n\r\n  /** @internal */\r\n  pin(conn: Connection): void {\r\n    if (this[kPinnedConnection]) {\r\n      throw TypeError('Cannot pin multiple connections to the same session');\r\n    }\r\n\r\n    this[kPinnedConnection] = conn;\r\n    conn.emit(\r\n      PINNED,\r\n      this.inTransaction() ? ConnectionPoolMetrics.TXN : ConnectionPoolMetrics.CURSOR\r\n    );\r\n  }\r\n\r\n  /** @internal */\r\n  unpin(options?: { force?: boolean; forceClear?: boolean; error?: AnyError }): void {\r\n    if (this.loadBalanced) {\r\n      return maybeClearPinnedConnection(this, options);\r\n    }\r\n\r\n    this.transaction.unpinServer();\r\n  }\r\n\r\n  get isPinned(): boolean {\r\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\r\n  }\r\n\r\n  /**\r\n   * Ends this session on the server\r\n   *\r\n   * @param options - Optional settings. Currently reserved for future use\r\n   * @param callback - Optional callback for completion of this operation\r\n   */\r\n  endSession(): Promise<void>;\r\n  endSession(options: EndSessionOptions): Promise<void>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  endSession(callback: Callback<void>): void;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  endSession(options: EndSessionOptions, callback: Callback<void>): void;\r\n  endSession(\r\n    options?: EndSessionOptions | Callback<void>,\r\n    callback?: Callback<void>\r\n  ): void | Promise<void> {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    const finalOptions = { force: true, ...options };\r\n\r\n    return maybeCallback(async () => {\r\n      try {\r\n        if (this.inTransaction()) {\r\n          await this.abortTransaction();\r\n        }\r\n        if (!this.hasEnded) {\r\n          const serverSession = this[kServerSession];\r\n          if (serverSession != null) {\r\n            // release the server session back to the pool\r\n            this.sessionPool.release(serverSession);\r\n            // Make sure a new serverSession never makes it onto this ClientSession\r\n            Object.defineProperty(this, kServerSession, {\r\n              value: ServerSession.clone(serverSession),\r\n              writable: false\r\n            });\r\n          }\r\n          // mark the session as ended, and emit a signal\r\n          this.hasEnded = true;\r\n          this.emit('ended', this);\r\n        }\r\n      } catch {\r\n        // spec indicates that we should ignore all errors for `endSessions`\r\n      } finally {\r\n        maybeClearPinnedConnection(this, finalOptions);\r\n      }\r\n    }, callback);\r\n  }\r\n\r\n  /**\r\n   * Advances the operationTime for a ClientSession.\r\n   *\r\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\r\n   */\r\n  advanceOperationTime(operationTime: Timestamp): void {\r\n    if (this.operationTime == null) {\r\n      this.operationTime = operationTime;\r\n      return;\r\n    }\r\n\r\n    if (operationTime.greaterThan(this.operationTime)) {\r\n      this.operationTime = operationTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\r\n   *\r\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\r\n   */\r\n  advanceClusterTime(clusterTime: ClusterTime): void {\r\n    if (!clusterTime || typeof clusterTime !== 'object') {\r\n      throw new MongoInvalidArgumentError('input cluster time must be an object');\r\n    }\r\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\r\n      throw new MongoInvalidArgumentError(\r\n        'input cluster time \"clusterTime\" property must be a valid BSON Timestamp'\r\n      );\r\n    }\r\n    if (\r\n      !clusterTime.signature ||\r\n      clusterTime.signature.hash?._bsontype !== 'Binary' ||\r\n      (typeof clusterTime.signature.keyId !== 'number' &&\r\n        clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\r\n    ) {\r\n      throw new MongoInvalidArgumentError(\r\n        'input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId'\r\n      );\r\n    }\r\n\r\n    _advanceClusterTime(this, clusterTime);\r\n  }\r\n\r\n  /**\r\n   * Used to determine if this session equals another\r\n   *\r\n   * @param session - The session to compare to\r\n   */\r\n  equals(session: ClientSession): boolean {\r\n    if (!(session instanceof ClientSession)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.id == null || session.id == null) {\r\n      return false;\r\n    }\r\n\r\n    return this.id.id.buffer.equals(session.id.id.buffer);\r\n  }\r\n\r\n  /**\r\n   * Increment the transaction number on the internal ServerSession\r\n   *\r\n   * @privateRemarks\r\n   * This helper increments a value stored on the client session that will be\r\n   * added to the serverSession's txnNumber upon applying it to a command.\r\n   * This is because the serverSession is lazily acquired after a connection is obtained\r\n   */\r\n  incrementTransactionNumber(): void {\r\n    this[kTxnNumberIncrement] += 1;\r\n  }\r\n\r\n  /** @returns whether this session is currently in a transaction or not */\r\n  inTransaction(): boolean {\r\n    return this.transaction.isActive;\r\n  }\r\n\r\n  /**\r\n   * Starts a new transaction with the given options.\r\n   *\r\n   * @param options - Options for the transaction\r\n   */\r\n  startTransaction(options?: TransactionOptions): void {\r\n    if (this[kSnapshotEnabled]) {\r\n      throw new MongoCompatibilityError('Transactions are not supported in snapshot sessions');\r\n    }\r\n\r\n    if (this.inTransaction()) {\r\n      throw new MongoTransactionError('Transaction already in progress');\r\n    }\r\n\r\n    if (this.isPinned && this.transaction.isCommitted) {\r\n      this.unpin();\r\n    }\r\n\r\n    const topologyMaxWireVersion = maxWireVersion(this.client.topology);\r\n    if (\r\n      isSharded(this.client.topology) &&\r\n      topologyMaxWireVersion != null &&\r\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\r\n    ) {\r\n      throw new MongoCompatibilityError(\r\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\r\n      );\r\n    }\r\n\r\n    // increment txnNumber\r\n    this.incrementTransactionNumber();\r\n    // create transaction state\r\n    this.transaction = new Transaction({\r\n      readConcern:\r\n        options?.readConcern ??\r\n        this.defaultTransactionOptions.readConcern ??\r\n        this.clientOptions?.readConcern,\r\n      writeConcern:\r\n        options?.writeConcern ??\r\n        this.defaultTransactionOptions.writeConcern ??\r\n        this.clientOptions?.writeConcern,\r\n      readPreference:\r\n        options?.readPreference ??\r\n        this.defaultTransactionOptions.readPreference ??\r\n        this.clientOptions?.readPreference,\r\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\r\n    });\r\n\r\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\r\n  }\r\n\r\n  /**\r\n   * Commits the currently active transaction in this session.\r\n   *\r\n   * @param callback - An optional callback, a Promise will be returned if none is provided\r\n   */\r\n  commitTransaction(): Promise<Document>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  commitTransaction(callback: Callback<Document>): void;\r\n  commitTransaction(callback?: Callback<Document>): Promise<Document> | void {\r\n    return maybeCallback(async () => endTransactionAsync(this, 'commitTransaction'), callback);\r\n  }\r\n\r\n  /**\r\n   * Aborts the currently active transaction in this session.\r\n   *\r\n   * @param callback - An optional callback, a Promise will be returned if none is provided\r\n   */\r\n  abortTransaction(): Promise<Document>;\r\n  /** @deprecated Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance */\r\n  abortTransaction(callback: Callback<Document>): void;\r\n  abortTransaction(callback?: Callback<Document>): Promise<Document> | void {\r\n    return maybeCallback(async () => endTransactionAsync(this, 'abortTransaction'), callback);\r\n  }\r\n\r\n  /**\r\n   * This is here to ensure that ClientSession is never serialized to BSON.\r\n   */\r\n  toBSON(): never {\r\n    throw new MongoRuntimeError('ClientSession cannot be serialized to BSON.');\r\n  }\r\n\r\n  /**\r\n   * Runs a provided callback within a transaction, retrying either the commitTransaction operation\r\n   * or entire transaction as needed (and when the error permits) to better ensure that\r\n   * the transaction can complete successfully.\r\n   *\r\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\r\n   * Any callbacks that do not return a Promise will result in undefined behavior.\r\n   *\r\n   * @remarks\r\n   * This function:\r\n   * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\r\n   * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\r\n   * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\r\n   *\r\n   * Checkout a descriptive example here:\r\n   * @see https://www.mongodb.com/developer/quickstart/node-transactions/\r\n   *\r\n   * @param fn - callback to run within a transaction\r\n   * @param options - optional settings for the transaction\r\n   * @returns A raw command response or undefined\r\n   */\r\n  withTransaction<T = void>(\r\n    fn: WithTransactionCallback<T>,\r\n    options?: TransactionOptions\r\n  ): Promise<Document | undefined> {\r\n    const startTime = now();\r\n    return attemptTransaction(this, startTime, fn, options);\r\n  }\r\n}\r\n\r\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\r\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\r\n  'CannotSatisfyWriteConcern',\r\n  'UnknownReplWriteConcern',\r\n  'UnsatisfiableWriteConcern'\r\n]);\r\n\r\nfunction hasNotTimedOut(startTime: number, max: number) {\r\n  return calculateDurationInMs(startTime) < max;\r\n}\r\n\r\nfunction isUnknownTransactionCommitResult(err: MongoError) {\r\n  const isNonDeterministicWriteConcernError =\r\n    err instanceof MongoServerError &&\r\n    err.codeName &&\r\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\r\n\r\n  return (\r\n    isMaxTimeMSExpiredError(err) ||\r\n    (!isNonDeterministicWriteConcernError &&\r\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\r\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\r\n  );\r\n}\r\n\r\nexport function maybeClearPinnedConnection(\r\n  session: ClientSession,\r\n  options?: EndSessionOptions\r\n): void {\r\n  // unpin a connection if it has been pinned\r\n  const conn = session[kPinnedConnection];\r\n  const error = options?.error;\r\n\r\n  if (\r\n    session.inTransaction() &&\r\n    error &&\r\n    error instanceof MongoError &&\r\n    error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const topology = session.client.topology;\r\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\r\n  //       to validate that we don't unpin on _all_ errors?\r\n  if (conn && topology != null) {\r\n    const servers = Array.from(topology.s.servers.values());\r\n    const loadBalancer = servers[0];\r\n\r\n    if (options?.error == null || options?.force) {\r\n      loadBalancer.s.pool.checkIn(conn);\r\n      conn.emit(\r\n        UNPINNED,\r\n        session.transaction.state !== TxnState.NO_TRANSACTION\r\n          ? ConnectionPoolMetrics.TXN\r\n          : ConnectionPoolMetrics.CURSOR\r\n      );\r\n\r\n      if (options?.forceClear) {\r\n        loadBalancer.s.pool.clear({ serviceId: conn.serviceId });\r\n      }\r\n    }\r\n\r\n    session[kPinnedConnection] = undefined;\r\n  }\r\n}\r\n\r\nfunction isMaxTimeMSExpiredError(err: MongoError) {\r\n  if (err == null || !(err instanceof MongoServerError)) {\r\n    return false;\r\n  }\r\n\r\n  return (\r\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\r\n    (err.writeConcernError && err.writeConcernError.code === MONGODB_ERROR_CODES.MaxTimeMSExpired)\r\n  );\r\n}\r\n\r\nfunction attemptTransactionCommit<T>(\r\n  session: ClientSession,\r\n  startTime: number,\r\n  fn: WithTransactionCallback<T>,\r\n  options?: TransactionOptions\r\n): Promise<T> {\r\n  return session.commitTransaction().catch((err: MongoError) => {\r\n    if (\r\n      err instanceof MongoError &&\r\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\r\n      !isMaxTimeMSExpiredError(err)\r\n    ) {\r\n      if (err.hasErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult)) {\r\n        return attemptTransactionCommit(session, startTime, fn, options);\r\n      }\r\n\r\n      if (err.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\r\n        return attemptTransaction(session, startTime, fn, options);\r\n      }\r\n    }\r\n\r\n    throw err;\r\n  });\r\n}\r\n\r\nconst USER_EXPLICIT_TXN_END_STATES = new Set<TxnState>([\r\n  TxnState.NO_TRANSACTION,\r\n  TxnState.TRANSACTION_COMMITTED,\r\n  TxnState.TRANSACTION_ABORTED\r\n]);\r\n\r\nfunction userExplicitlyEndedTransaction(session: ClientSession) {\r\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\r\n}\r\n\r\nfunction attemptTransaction<TSchema>(\r\n  session: ClientSession,\r\n  startTime: number,\r\n  fn: WithTransactionCallback<TSchema>,\r\n  options?: TransactionOptions\r\n): Promise<any> {\r\n  session.startTransaction(options);\r\n\r\n  let promise;\r\n  try {\r\n    promise = fn(session);\r\n  } catch (err) {\r\n    const PromiseConstructor = PromiseProvider.get() ?? Promise;\r\n    promise = PromiseConstructor.reject(err);\r\n  }\r\n\r\n  if (!isPromiseLike(promise)) {\r\n    session.abortTransaction().catch(() => null);\r\n    throw new MongoInvalidArgumentError(\r\n      'Function provided to `withTransaction` must return a Promise'\r\n    );\r\n  }\r\n\r\n  return promise.then(\r\n    () => {\r\n      if (userExplicitlyEndedTransaction(session)) {\r\n        return;\r\n      }\r\n\r\n      return attemptTransactionCommit(session, startTime, fn, options);\r\n    },\r\n    err => {\r\n      function maybeRetryOrThrow(err: MongoError): Promise<any> {\r\n        if (\r\n          err instanceof MongoError &&\r\n          err.hasErrorLabel(MongoErrorLabel.TransientTransactionError) &&\r\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\r\n        ) {\r\n          return attemptTransaction(session, startTime, fn, options);\r\n        }\r\n\r\n        if (isMaxTimeMSExpiredError(err)) {\r\n          err.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\r\n        }\r\n\r\n        throw err;\r\n      }\r\n\r\n      if (session.inTransaction()) {\r\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\r\n      }\r\n\r\n      return maybeRetryOrThrow(err);\r\n    }\r\n  );\r\n}\r\n\r\nconst endTransactionAsync = promisify(\r\n  endTransaction as (\r\n    session: ClientSession,\r\n    commandName: 'abortTransaction' | 'commitTransaction',\r\n    callback: (error: Error, result: Document) => void\r\n  ) => void\r\n);\r\n\r\nfunction endTransaction(\r\n  session: ClientSession,\r\n  commandName: 'abortTransaction' | 'commitTransaction',\r\n  callback: Callback<Document>\r\n) {\r\n  // handle any initial problematic cases\r\n  const txnState = session.transaction.state;\r\n\r\n  if (txnState === TxnState.NO_TRANSACTION) {\r\n    callback(new MongoTransactionError('No transaction started'));\r\n    return;\r\n  }\r\n\r\n  if (commandName === 'commitTransaction') {\r\n    if (\r\n      txnState === TxnState.STARTING_TRANSACTION ||\r\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\r\n    ) {\r\n      // the transaction was never started, we can safely exit here\r\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\r\n      callback(\r\n        new MongoTransactionError('Cannot call commitTransaction after calling abortTransaction')\r\n      );\r\n      return;\r\n    }\r\n  } else {\r\n    if (txnState === TxnState.STARTING_TRANSACTION) {\r\n      // the transaction was never started, we can safely exit here\r\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\r\n      callback(new MongoTransactionError('Cannot call abortTransaction twice'));\r\n      return;\r\n    }\r\n\r\n    if (\r\n      txnState === TxnState.TRANSACTION_COMMITTED ||\r\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\r\n    ) {\r\n      callback(\r\n        new MongoTransactionError('Cannot call abortTransaction after calling commitTransaction')\r\n      );\r\n      return;\r\n    }\r\n  }\r\n\r\n  // construct and send the command\r\n  const command: Document = { [commandName]: 1 };\r\n\r\n  // apply a writeConcern if specified\r\n  let writeConcern;\r\n  if (session.transaction.options.writeConcern) {\r\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\r\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\r\n    writeConcern = { w: session.clientOptions.writeConcern.w };\r\n  }\r\n\r\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\r\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\r\n  }\r\n\r\n  if (writeConcern) {\r\n    Object.assign(command, { writeConcern });\r\n  }\r\n\r\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\r\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\r\n  }\r\n\r\n  function commandHandler(error?: Error, result?: Document) {\r\n    if (commandName !== 'commitTransaction') {\r\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\r\n      if (session.loadBalanced) {\r\n        maybeClearPinnedConnection(session, { force: false });\r\n      }\r\n\r\n      // The spec indicates that we should ignore all errors on `abortTransaction`\r\n      return callback();\r\n    }\r\n\r\n    session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\r\n    if (error instanceof MongoError) {\r\n      if (\r\n        error.hasErrorLabel(MongoErrorLabel.RetryableWriteError) ||\r\n        error instanceof MongoWriteConcernError ||\r\n        isMaxTimeMSExpiredError(error)\r\n      ) {\r\n        if (isUnknownTransactionCommitResult(error)) {\r\n          error.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\r\n\r\n          // per txns spec, must unpin session in this case\r\n          session.unpin({ error });\r\n        }\r\n      } else if (error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\r\n        session.unpin({ error });\r\n      }\r\n    }\r\n\r\n    callback(error, result);\r\n  }\r\n\r\n  if (session.transaction.recoveryToken) {\r\n    command.recoveryToken = session.transaction.recoveryToken;\r\n  }\r\n\r\n  // send the command\r\n  executeOperation(\r\n    session.client,\r\n    new RunAdminCommandOperation(undefined, command, {\r\n      session,\r\n      readPreference: ReadPreference.primary,\r\n      bypassPinningCheck: true\r\n    }),\r\n    (error, result) => {\r\n      if (command.abortTransaction) {\r\n        // always unpin on abort regardless of command outcome\r\n        session.unpin();\r\n      }\r\n\r\n      if (error instanceof MongoError && error.hasErrorLabel(MongoErrorLabel.RetryableWriteError)) {\r\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\r\n        if (command.commitTransaction) {\r\n          // per txns spec, must unpin session in this case\r\n          session.unpin({ force: true });\r\n\r\n          command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\r\n            w: 'majority'\r\n          });\r\n        }\r\n\r\n        return executeOperation(\r\n          session.client,\r\n          new RunAdminCommandOperation(undefined, command, {\r\n            session,\r\n            readPreference: ReadPreference.primary,\r\n            bypassPinningCheck: true\r\n          }),\r\n          commandHandler\r\n        );\r\n      }\r\n\r\n      commandHandler(error, result);\r\n    }\r\n  );\r\n}\r\n\r\n/** @public */\r\nexport type ServerSessionId = { id: Binary };\r\n\r\n/**\r\n * Reflects the existence of a session on the server. Can be reused by the session pool.\r\n * WARNING: not meant to be instantiated directly. For internal use only.\r\n * @public\r\n */\r\nexport class ServerSession {\r\n  id: ServerSessionId;\r\n  lastUse: number;\r\n  txnNumber: number;\r\n  isDirty: boolean;\r\n\r\n  /** @internal */\r\n  constructor() {\r\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\r\n    this.lastUse = now();\r\n    this.txnNumber = 0;\r\n    this.isDirty = false;\r\n  }\r\n\r\n  /**\r\n   * Determines if the server session has timed out.\r\n   *\r\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\r\n   */\r\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\r\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\r\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\r\n    const idleTimeMinutes = Math.round(\r\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\r\n    );\r\n\r\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * Cloning meant to keep a readable reference to the server session data\r\n   * after ClientSession has ended\r\n   */\r\n  static clone(serverSession: ServerSession): Readonly<ServerSession> {\r\n    const arrayBuffer = new ArrayBuffer(16);\r\n    const idBytes = Buffer.from(arrayBuffer);\r\n    idBytes.set(serverSession.id.id.buffer);\r\n\r\n    const id = new Binary(idBytes, serverSession.id.id.sub_type);\r\n\r\n    // Manual prototype construction to avoid modifying the constructor of this class\r\n    return Object.setPrototypeOf(\r\n      {\r\n        id: { id },\r\n        lastUse: serverSession.lastUse,\r\n        txnNumber: serverSession.txnNumber,\r\n        isDirty: serverSession.isDirty\r\n      },\r\n      ServerSession.prototype\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Maintains a pool of Server Sessions.\r\n * For internal use only\r\n * @internal\r\n */\r\nexport class ServerSessionPool {\r\n  client: MongoClient;\r\n  sessions: List<ServerSession>;\r\n\r\n  constructor(client: MongoClient) {\r\n    if (client == null) {\r\n      throw new MongoRuntimeError('ServerSessionPool requires a MongoClient');\r\n    }\r\n\r\n    this.client = client;\r\n    this.sessions = new List<ServerSession>();\r\n  }\r\n\r\n  /**\r\n   * Acquire a Server Session from the pool.\r\n   * Iterates through each session in the pool, removing any stale sessions\r\n   * along the way. The first non-stale session found is removed from the\r\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\r\n   */\r\n  acquire(): ServerSession {\r\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\r\n\r\n    let session: ServerSession | null = null;\r\n\r\n    // Try to obtain from session pool\r\n    while (this.sessions.length > 0) {\r\n      const potentialSession = this.sessions.shift();\r\n      if (\r\n        potentialSession != null &&\r\n        (!!this.client.topology?.loadBalanced ||\r\n          !potentialSession.hasTimedOut(sessionTimeoutMinutes))\r\n      ) {\r\n        session = potentialSession;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If nothing valid came from the pool make a new one\r\n    if (session == null) {\r\n      session = new ServerSession();\r\n    }\r\n\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * Release a session to the session pool\r\n   * Adds the session back to the session pool if the session has not timed out yet.\r\n   * This method also removes any stale sessions from the pool.\r\n   *\r\n   * @param session - The session to release to the pool\r\n   */\r\n  release(session: ServerSession): void {\r\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\r\n\r\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\r\n      this.sessions.unshift(session);\r\n    }\r\n\r\n    if (!sessionTimeoutMinutes) {\r\n      return;\r\n    }\r\n\r\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\r\n\r\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\r\n      if (session.isDirty) {\r\n        return;\r\n      }\r\n\r\n      // otherwise, readd this session to the session pool\r\n      this.sessions.unshift(session);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Optionally decorate a command with sessions specific keys\r\n *\r\n * @param session - the session tracking transaction state\r\n * @param command - the command to decorate\r\n * @param options - Optional settings passed to calling operation\r\n *\r\n * @internal\r\n */\r\nexport function applySession(\r\n  session: ClientSession,\r\n  command: Document,\r\n  options: CommandOptions\r\n): MongoDriverError | undefined {\r\n  if (session.hasEnded) {\r\n    return new MongoExpiredSessionError();\r\n  }\r\n\r\n  // May acquire serverSession here\r\n  const serverSession = session.serverSession;\r\n  if (serverSession == null) {\r\n    return new MongoRuntimeError('Unable to acquire server session');\r\n  }\r\n\r\n  if (options.writeConcern?.w === 0) {\r\n    if (session && session.explicit) {\r\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\r\n      return new MongoAPIError('Cannot have explicit session with unacknowledged writes');\r\n    }\r\n    return;\r\n  }\r\n\r\n  // mark the last use of this session, and apply the `lsid`\r\n  serverSession.lastUse = now();\r\n  command.lsid = serverSession.id;\r\n\r\n  const inTxnOrTxnCommand = session.inTransaction() || isTransactionCommand(command);\r\n  const isRetryableWrite = !!options.willRetryWrite;\r\n\r\n  if (isRetryableWrite || inTxnOrTxnCommand) {\r\n    serverSession.txnNumber += session[kTxnNumberIncrement];\r\n    session[kTxnNumberIncrement] = 0;\r\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\r\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\r\n  }\r\n\r\n  if (!inTxnOrTxnCommand) {\r\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\r\n      session.transaction.transition(TxnState.NO_TRANSACTION);\r\n    }\r\n\r\n    if (\r\n      session.supports.causalConsistency &&\r\n      session.operationTime &&\r\n      commandSupportsReadConcern(command, options)\r\n    ) {\r\n      command.readConcern = command.readConcern || {};\r\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\r\n    } else if (session[kSnapshotEnabled]) {\r\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\r\n      if (session[kSnapshotTime] != null) {\r\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  // now attempt to apply transaction-specific sessions data\r\n\r\n  // `autocommit` must always be false to differentiate from retryable writes\r\n  command.autocommit = false;\r\n\r\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\r\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\r\n    command.startTransaction = true;\r\n\r\n    const readConcern =\r\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\r\n    if (readConcern) {\r\n      command.readConcern = readConcern;\r\n    }\r\n\r\n    if (session.supports.causalConsistency && session.operationTime) {\r\n      command.readConcern = command.readConcern || {};\r\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\r\n    }\r\n  }\r\n  return;\r\n}\r\n\r\nexport function updateSessionFromResponse(session: ClientSession, document: Document): void {\r\n  if (document.$clusterTime) {\r\n    _advanceClusterTime(session, document.$clusterTime);\r\n  }\r\n\r\n  if (document.operationTime && session && session.supports.causalConsistency) {\r\n    session.advanceOperationTime(document.operationTime);\r\n  }\r\n\r\n  if (document.recoveryToken && session && session.inTransaction()) {\r\n    session.transaction._recoveryToken = document.recoveryToken;\r\n  }\r\n\r\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\r\n    // find and aggregate commands return atClusterTime on the cursor\r\n    // distinct includes it in the response body\r\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\r\n    if (atClusterTime) {\r\n      session[kSnapshotTime] = atClusterTime;\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}