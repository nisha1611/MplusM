{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StandardRetryStrategy = void 0;\nconst protocol_http_1 = require(\"@aws-sdk/protocol-http\");\nconst service_error_classification_1 = require(\"@aws-sdk/service-error-classification\");\nconst util_retry_1 = require(\"@aws-sdk/util-retry\");\nconst uuid_1 = require(\"uuid\");\nconst defaultRetryQuota_1 = require(\"./defaultRetryQuota\");\nconst delayDecider_1 = require(\"./delayDecider\");\nconst retryDecider_1 = require(\"./retryDecider\");\nconst util_1 = require(\"./util\");\nclass StandardRetryStrategy {\n  constructor(maxAttemptsProvider, options) {\n    var _a, _b, _c;\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = util_retry_1.RETRY_MODES.STANDARD;\n    this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;\n    this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;\n    this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);\n  }\n  shouldRetry(error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      maxAttempts = await this.maxAttemptsProvider();\n    } catch (error) {\n      maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;\n    }\n    return maxAttempts;\n  }\n  async retry(next, args, options) {\n    let retryTokenAmount;\n    let attempts = 0;\n    let totalDelay = 0;\n    const maxAttempts = await this.getMaxAttempts();\n    const {\n      request\n    } = args;\n    if (protocol_http_1.HttpRequest.isInstance(request)) {\n      request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();\n    }\n    while (true) {\n      try {\n        if (protocol_http_1.HttpRequest.isInstance(request)) {\n          request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        if (options === null || options === void 0 ? void 0 : options.beforeRequest) {\n          await options.beforeRequest();\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        if (options === null || options === void 0 ? void 0 : options.afterRequest) {\n          options.afterRequest(response);\n        }\n        this.retryQuota.releaseRetryTokens(retryTokenAmount);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const err = (0, util_1.asSdkError)(e);\n        attempts++;\n        if (this.shouldRetry(err, attempts, maxAttempts)) {\n          retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n          const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);\n          const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n          const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n          totalDelay += delay;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n        err.$metadata.attempts = attempts;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\nexports.StandardRetryStrategy = StandardRetryStrategy;\nconst getDelayFromRetryAfterHeader = response => {\n  if (!protocol_http_1.HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate.getTime() - Date.now();\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","StandardRetryStrategy","protocol_http_1","require","service_error_classification_1","util_retry_1","uuid_1","defaultRetryQuota_1","delayDecider_1","retryDecider_1","util_1","constructor","maxAttemptsProvider","options","_a","_b","_c","mode","RETRY_MODES","STANDARD","retryDecider","defaultRetryDecider","delayDecider","defaultDelayDecider","retryQuota","getDefaultRetryQuota","INITIAL_RETRY_TOKENS","shouldRetry","error","attempts","maxAttempts","hasRetryTokens","getMaxAttempts","DEFAULT_MAX_ATTEMPTS","retry","next","args","retryTokenAmount","totalDelay","request","HttpRequest","isInstance","headers","INVOCATION_ID_HEADER","v4","REQUEST_HEADER","beforeRequest","response","output","afterRequest","releaseRetryTokens","$metadata","totalRetryDelay","e","err","asSdkError","retrieveRetryTokens","delayFromDecider","isThrottlingError","THROTTLING_RETRY_DELAY_BASE","DEFAULT_RETRY_DELAY_BASE","delayFromResponse","getDelayFromRetryAfterHeader","$response","delay","Math","max","Promise","resolve","setTimeout","HttpResponse","retryAfterHeaderName","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","retryAfterDate","Date","getTime","now"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/middleware-retry/dist-cjs/StandardRetryStrategy.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StandardRetryStrategy = void 0;\r\nconst protocol_http_1 = require(\"@aws-sdk/protocol-http\");\r\nconst service_error_classification_1 = require(\"@aws-sdk/service-error-classification\");\r\nconst util_retry_1 = require(\"@aws-sdk/util-retry\");\r\nconst uuid_1 = require(\"uuid\");\r\nconst defaultRetryQuota_1 = require(\"./defaultRetryQuota\");\r\nconst delayDecider_1 = require(\"./delayDecider\");\r\nconst retryDecider_1 = require(\"./retryDecider\");\r\nconst util_1 = require(\"./util\");\r\nclass StandardRetryStrategy {\r\n    constructor(maxAttemptsProvider, options) {\r\n        var _a, _b, _c;\r\n        this.maxAttemptsProvider = maxAttemptsProvider;\r\n        this.mode = util_retry_1.RETRY_MODES.STANDARD;\r\n        this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;\r\n        this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;\r\n        this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);\r\n    }\r\n    shouldRetry(error, attempts, maxAttempts) {\r\n        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\r\n    }\r\n    async getMaxAttempts() {\r\n        let maxAttempts;\r\n        try {\r\n            maxAttempts = await this.maxAttemptsProvider();\r\n        }\r\n        catch (error) {\r\n            maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;\r\n        }\r\n        return maxAttempts;\r\n    }\r\n    async retry(next, args, options) {\r\n        let retryTokenAmount;\r\n        let attempts = 0;\r\n        let totalDelay = 0;\r\n        const maxAttempts = await this.getMaxAttempts();\r\n        const { request } = args;\r\n        if (protocol_http_1.HttpRequest.isInstance(request)) {\r\n            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();\r\n        }\r\n        while (true) {\r\n            try {\r\n                if (protocol_http_1.HttpRequest.isInstance(request)) {\r\n                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\r\n                }\r\n                if (options === null || options === void 0 ? void 0 : options.beforeRequest) {\r\n                    await options.beforeRequest();\r\n                }\r\n                const { response, output } = await next(args);\r\n                if (options === null || options === void 0 ? void 0 : options.afterRequest) {\r\n                    options.afterRequest(response);\r\n                }\r\n                this.retryQuota.releaseRetryTokens(retryTokenAmount);\r\n                output.$metadata.attempts = attempts + 1;\r\n                output.$metadata.totalRetryDelay = totalDelay;\r\n                return { response, output };\r\n            }\r\n            catch (e) {\r\n                const err = (0, util_1.asSdkError)(e);\r\n                attempts++;\r\n                if (this.shouldRetry(err, attempts, maxAttempts)) {\r\n                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\r\n                    const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);\r\n                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\r\n                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);\r\n                    totalDelay += delay;\r\n                    await new Promise((resolve) => setTimeout(resolve, delay));\r\n                    continue;\r\n                }\r\n                if (!err.$metadata) {\r\n                    err.$metadata = {};\r\n                }\r\n                err.$metadata.attempts = attempts;\r\n                err.$metadata.totalRetryDelay = totalDelay;\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.StandardRetryStrategy = StandardRetryStrategy;\r\nconst getDelayFromRetryAfterHeader = (response) => {\r\n    if (!protocol_http_1.HttpResponse.isInstance(response))\r\n        return;\r\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\r\n    if (!retryAfterHeaderName)\r\n        return;\r\n    const retryAfter = response.headers[retryAfterHeaderName];\r\n    const retryAfterSeconds = Number(retryAfter);\r\n    if (!Number.isNaN(retryAfterSeconds))\r\n        return retryAfterSeconds * 1000;\r\n    const retryAfterDate = new Date(retryAfter);\r\n    return retryAfterDate.getTime() - Date.now();\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}