{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Decimal128 = void 0;\nvar buffer_1 = require(\"buffer\");\nvar error_1 = require(\"./error\");\nvar long_1 = require(\"./long\");\nvar utils_1 = require(\"./parser/utils\");\nvar PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nvar PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nvar PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nvar EXPONENT_MAX = 6111;\nvar EXPONENT_MIN = -6176;\nvar EXPONENT_BIAS = 6176;\nvar MAX_DIGITS = 34;\n// Nan value bits as 32 bit values (due to lack of longs)\nvar NAN_BUFFER = [0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();\n// Infinity value bits 32 bit values (due to lack of longs)\nvar INF_NEGATIVE_BUFFER = [0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();\nvar INF_POSITIVE_BUFFER = [0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();\nvar EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\n// Extract least significant 5 bits\nvar COMBINATION_MASK = 0x1f;\n// Extract least significant 14 bits\nvar EXPONENT_MASK = 0x3fff;\n// Value of combination field for Inf\nvar COMBINATION_INFINITY = 30;\n// Value of combination field for NaN\nvar COMBINATION_NAN = 31;\n// Detect if the value is a digit\nfunction isDigit(value) {\n  return !isNaN(parseInt(value, 10));\n}\n// Divide two uint128 values\nfunction divideu128(value) {\n  var DIVISOR = long_1.Long.fromNumber(1000 * 1000 * 1000);\n  var _rem = long_1.Long.fromNumber(0);\n  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n    return {\n      quotient: value,\n      rem: _rem\n    };\n  }\n  for (var i = 0; i <= 3; i++) {\n    // Adjust remainder to match value of next dividend\n    _rem = _rem.shiftLeft(32);\n    // Add the divided to _rem\n    _rem = _rem.add(new long_1.Long(value.parts[i], 0));\n    value.parts[i] = _rem.div(DIVISOR).low;\n    _rem = _rem.modulo(DIVISOR);\n  }\n  return {\n    quotient: value,\n    rem: _rem\n  };\n}\n// Multiply two Long values and return the 128 bit value\nfunction multiply64x2(left, right) {\n  if (!left && !right) {\n    return {\n      high: long_1.Long.fromNumber(0),\n      low: long_1.Long.fromNumber(0)\n    };\n  }\n  var leftHigh = left.shiftRightUnsigned(32);\n  var leftLow = new long_1.Long(left.getLowBits(), 0);\n  var rightHigh = right.shiftRightUnsigned(32);\n  var rightLow = new long_1.Long(right.getLowBits(), 0);\n  var productHigh = leftHigh.multiply(rightHigh);\n  var productMid = leftHigh.multiply(rightLow);\n  var productMid2 = leftLow.multiply(rightHigh);\n  var productLow = leftLow.multiply(rightLow);\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productMid = new long_1.Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productLow = productMid.shiftLeft(32).add(new long_1.Long(productLow.getLowBits(), 0));\n  // Return the 128 bit result\n  return {\n    high: productHigh,\n    low: productLow\n  };\n}\nfunction lessThan(left, right) {\n  // Make values unsigned\n  var uhleft = left.high >>> 0;\n  var uhright = right.high >>> 0;\n  // Compare high bits first\n  if (uhleft < uhright) {\n    return true;\n  } else if (uhleft === uhright) {\n    var ulleft = left.low >>> 0;\n    var ulright = right.low >>> 0;\n    if (ulleft < ulright) return true;\n  }\n  return false;\n}\nfunction invalidErr(string, message) {\n  throw new error_1.BSONTypeError(\"\\\"\".concat(string, \"\\\" is not a valid Decimal128 string - \").concat(message));\n}\n/**\r\n * A class representation of the BSON Decimal128 type.\r\n * @public\r\n * @category BSONType\r\n */\nvar Decimal128 = /** @class */function () {\n  /**\r\n   * @param bytes - a buffer containing the raw Decimal128 bytes in little endian order,\r\n   *                or a string representation as returned by .toString()\r\n   */\n  function Decimal128(bytes) {\n    if (!(this instanceof Decimal128)) return new Decimal128(bytes);\n    if (typeof bytes === 'string') {\n      this.bytes = Decimal128.fromString(bytes).bytes;\n    } else if ((0, utils_1.isUint8Array)(bytes)) {\n      if (bytes.byteLength !== 16) {\n        throw new error_1.BSONTypeError('Decimal128 must take a Buffer of 16 bytes');\n      }\n      this.bytes = bytes;\n    } else {\n      throw new error_1.BSONTypeError('Decimal128 must take a Buffer or string');\n    }\n  }\n  /**\r\n   * Create a Decimal128 instance from a string representation\r\n   *\r\n   * @param representation - a numeric string representation.\r\n   */\n  Decimal128.fromString = function (representation) {\n    // Parse state tracking\n    var isNegative = false;\n    var sawRadix = false;\n    var foundNonZero = false;\n    // Total number of significant digits (no leading or trailing zero)\n    var significantDigits = 0;\n    // Total number of significand digits read\n    var nDigitsRead = 0;\n    // Total number of digits (no leading zeros)\n    var nDigits = 0;\n    // The number of the digits after radix\n    var radixPosition = 0;\n    // The index of the first non-zero in *str*\n    var firstNonZero = 0;\n    // Digits Array\n    var digits = [0];\n    // The number of digits in digits\n    var nDigitsStored = 0;\n    // Insertion pointer for digits\n    var digitsInsert = 0;\n    // The index of the first non-zero digit\n    var firstDigit = 0;\n    // The index of the last digit\n    var lastDigit = 0;\n    // Exponent\n    var exponent = 0;\n    // loop index over array\n    var i = 0;\n    // The high 17 digits of the significand\n    var significandHigh = new long_1.Long(0, 0);\n    // The low 17 digits of the significand\n    var significandLow = new long_1.Long(0, 0);\n    // The biased exponent\n    var biasedExponent = 0;\n    // Read index\n    var index = 0;\n    // Naively prevent against REDOS attacks.\n    // TODO: implementing a custom parsing for this, or refactoring the regex would yield\n    //       further gains.\n    if (representation.length >= 7000) {\n      throw new error_1.BSONTypeError('' + representation + ' not a valid Decimal128 string');\n    }\n    // Results\n    var stringMatch = representation.match(PARSE_STRING_REGEXP);\n    var infMatch = representation.match(PARSE_INF_REGEXP);\n    var nanMatch = representation.match(PARSE_NAN_REGEXP);\n    // Validate the string\n    if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n      throw new error_1.BSONTypeError('' + representation + ' not a valid Decimal128 string');\n    }\n    if (stringMatch) {\n      // full_match = stringMatch[0]\n      // sign = stringMatch[1]\n      var unsignedNumber = stringMatch[2];\n      // stringMatch[3] is undefined if a whole number (ex \"1\", 12\")\n      // but defined if a number w/ decimal in it (ex \"1.0, 12.2\")\n      var e = stringMatch[4];\n      var expSign = stringMatch[5];\n      var expNumber = stringMatch[6];\n      // they provided e, but didn't give an exponent number. for ex \"1e\"\n      if (e && expNumber === undefined) invalidErr(representation, 'missing exponent power');\n      // they provided e, but didn't give a number before it. for ex \"e1\"\n      if (e && unsignedNumber === undefined) invalidErr(representation, 'missing exponent base');\n      if (e === undefined && (expSign || expNumber)) {\n        invalidErr(representation, 'missing e before exponent');\n      }\n    }\n    // Get the negative or positive sign\n    if (representation[index] === '+' || representation[index] === '-') {\n      isNegative = representation[index++] === '-';\n    }\n    // Check if user passed Infinity or NaN\n    if (!isDigit(representation[index]) && representation[index] !== '.') {\n      if (representation[index] === 'i' || representation[index] === 'I') {\n        return new Decimal128(buffer_1.Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\n      } else if (representation[index] === 'N') {\n        return new Decimal128(buffer_1.Buffer.from(NAN_BUFFER));\n      }\n    }\n    // Read all the digits\n    while (isDigit(representation[index]) || representation[index] === '.') {\n      if (representation[index] === '.') {\n        if (sawRadix) invalidErr(representation, 'contains multiple periods');\n        sawRadix = true;\n        index = index + 1;\n        continue;\n      }\n      if (nDigitsStored < 34) {\n        if (representation[index] !== '0' || foundNonZero) {\n          if (!foundNonZero) {\n            firstNonZero = nDigitsRead;\n          }\n          foundNonZero = true;\n          // Only store 34 digits\n          digits[digitsInsert++] = parseInt(representation[index], 10);\n          nDigitsStored = nDigitsStored + 1;\n        }\n      }\n      if (foundNonZero) nDigits = nDigits + 1;\n      if (sawRadix) radixPosition = radixPosition + 1;\n      nDigitsRead = nDigitsRead + 1;\n      index = index + 1;\n    }\n    if (sawRadix && !nDigitsRead) throw new error_1.BSONTypeError('' + representation + ' not a valid Decimal128 string');\n    // Read exponent if exists\n    if (representation[index] === 'e' || representation[index] === 'E') {\n      // Read exponent digits\n      var match = representation.substr(++index).match(EXPONENT_REGEX);\n      // No digits read\n      if (!match || !match[2]) return new Decimal128(buffer_1.Buffer.from(NAN_BUFFER));\n      // Get exponent\n      exponent = parseInt(match[0], 10);\n      // Adjust the index\n      index = index + match[0].length;\n    }\n    // Return not a number\n    if (representation[index]) return new Decimal128(buffer_1.Buffer.from(NAN_BUFFER));\n    // Done reading input\n    // Find first non-zero digit in digits\n    firstDigit = 0;\n    if (!nDigitsStored) {\n      firstDigit = 0;\n      lastDigit = 0;\n      digits[0] = 0;\n      nDigits = 1;\n      nDigitsStored = 1;\n      significantDigits = 0;\n    } else {\n      lastDigit = nDigitsStored - 1;\n      significantDigits = nDigits;\n      if (significantDigits !== 1) {\n        while (digits[firstNonZero + significantDigits - 1] === 0) {\n          significantDigits = significantDigits - 1;\n        }\n      }\n    }\n    // Normalization of exponent\n    // Correct exponent based on radix position, and shift significand as needed\n    // to represent user input\n    // Overflow prevention\n    if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {\n      exponent = EXPONENT_MIN;\n    } else {\n      exponent = exponent - radixPosition;\n    }\n    // Attempt to normalize the exponent\n    while (exponent > EXPONENT_MAX) {\n      // Shift exponent to significand and decrease\n      lastDigit = lastDigit + 1;\n      if (lastDigit - firstDigit > MAX_DIGITS) {\n        // Check if we have a zero then just hard clamp, otherwise fail\n        var digitsString = digits.join('');\n        if (digitsString.match(/^0+$/)) {\n          exponent = EXPONENT_MAX;\n          break;\n        }\n        invalidErr(representation, 'overflow');\n      }\n      exponent = exponent - 1;\n    }\n    while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n      // Shift last digit. can only do this if < significant digits than # stored.\n      if (lastDigit === 0 && significantDigits < nDigitsStored) {\n        exponent = EXPONENT_MIN;\n        significantDigits = 0;\n        break;\n      }\n      if (nDigitsStored < nDigits) {\n        // adjust to match digits not stored\n        nDigits = nDigits - 1;\n      } else {\n        // adjust to round\n        lastDigit = lastDigit - 1;\n      }\n      if (exponent < EXPONENT_MAX) {\n        exponent = exponent + 1;\n      } else {\n        // Check if we have a zero then just hard clamp, otherwise fail\n        var digitsString = digits.join('');\n        if (digitsString.match(/^0+$/)) {\n          exponent = EXPONENT_MAX;\n          break;\n        }\n        invalidErr(representation, 'overflow');\n      }\n    }\n    // Round\n    // We've normalized the exponent, but might still need to round.\n    if (lastDigit - firstDigit + 1 < significantDigits) {\n      var endOfString = nDigitsRead;\n      // If we have seen a radix point, 'string' is 1 longer than we have\n      // documented with ndigits_read, so inc the position of the first nonzero\n      // digit and the position that digits are read to.\n      if (sawRadix) {\n        firstNonZero = firstNonZero + 1;\n        endOfString = endOfString + 1;\n      }\n      // if negative, we need to increment again to account for - sign at start.\n      if (isNegative) {\n        firstNonZero = firstNonZero + 1;\n        endOfString = endOfString + 1;\n      }\n      var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n      var roundBit = 0;\n      if (roundDigit >= 5) {\n        roundBit = 1;\n        if (roundDigit === 5) {\n          roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n          for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n            if (parseInt(representation[i], 10)) {\n              roundBit = 1;\n              break;\n            }\n          }\n        }\n      }\n      if (roundBit) {\n        var dIdx = lastDigit;\n        for (; dIdx >= 0; dIdx--) {\n          if (++digits[dIdx] > 9) {\n            digits[dIdx] = 0;\n            // overflowed most significant digit\n            if (dIdx === 0) {\n              if (exponent < EXPONENT_MAX) {\n                exponent = exponent + 1;\n                digits[dIdx] = 1;\n              } else {\n                return new Decimal128(buffer_1.Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\n              }\n            }\n          }\n        }\n      }\n    }\n    // Encode significand\n    // The high 17 digits of the significand\n    significandHigh = long_1.Long.fromNumber(0);\n    // The low 17 digits of the significand\n    significandLow = long_1.Long.fromNumber(0);\n    // read a zero\n    if (significantDigits === 0) {\n      significandHigh = long_1.Long.fromNumber(0);\n      significandLow = long_1.Long.fromNumber(0);\n    } else if (lastDigit - firstDigit < 17) {\n      var dIdx = firstDigit;\n      significandLow = long_1.Long.fromNumber(digits[dIdx++]);\n      significandHigh = new long_1.Long(0, 0);\n      for (; dIdx <= lastDigit; dIdx++) {\n        significandLow = significandLow.multiply(long_1.Long.fromNumber(10));\n        significandLow = significandLow.add(long_1.Long.fromNumber(digits[dIdx]));\n      }\n    } else {\n      var dIdx = firstDigit;\n      significandHigh = long_1.Long.fromNumber(digits[dIdx++]);\n      for (; dIdx <= lastDigit - 17; dIdx++) {\n        significandHigh = significandHigh.multiply(long_1.Long.fromNumber(10));\n        significandHigh = significandHigh.add(long_1.Long.fromNumber(digits[dIdx]));\n      }\n      significandLow = long_1.Long.fromNumber(digits[dIdx++]);\n      for (; dIdx <= lastDigit; dIdx++) {\n        significandLow = significandLow.multiply(long_1.Long.fromNumber(10));\n        significandLow = significandLow.add(long_1.Long.fromNumber(digits[dIdx]));\n      }\n    }\n    var significand = multiply64x2(significandHigh, long_1.Long.fromString('100000000000000000'));\n    significand.low = significand.low.add(significandLow);\n    if (lessThan(significand.low, significandLow)) {\n      significand.high = significand.high.add(long_1.Long.fromNumber(1));\n    }\n    // Biased exponent\n    biasedExponent = exponent + EXPONENT_BIAS;\n    var dec = {\n      low: long_1.Long.fromNumber(0),\n      high: long_1.Long.fromNumber(0)\n    };\n    // Encode combination, exponent, and significand.\n    if (significand.high.shiftRightUnsigned(49).and(long_1.Long.fromNumber(1)).equals(long_1.Long.fromNumber(1))) {\n      // Encode '11' into bits 1 to 3\n      dec.high = dec.high.or(long_1.Long.fromNumber(0x3).shiftLeft(61));\n      dec.high = dec.high.or(long_1.Long.fromNumber(biasedExponent).and(long_1.Long.fromNumber(0x3fff).shiftLeft(47)));\n      dec.high = dec.high.or(significand.high.and(long_1.Long.fromNumber(0x7fffffffffff)));\n    } else {\n      dec.high = dec.high.or(long_1.Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n      dec.high = dec.high.or(significand.high.and(long_1.Long.fromNumber(0x1ffffffffffff)));\n    }\n    dec.low = significand.low;\n    // Encode sign\n    if (isNegative) {\n      dec.high = dec.high.or(long_1.Long.fromString('9223372036854775808'));\n    }\n    // Encode into a buffer\n    var buffer = buffer_1.Buffer.alloc(16);\n    index = 0;\n    // Encode the low 64 bits of the decimal\n    // Encode low bits\n    buffer[index++] = dec.low.low & 0xff;\n    buffer[index++] = dec.low.low >> 8 & 0xff;\n    buffer[index++] = dec.low.low >> 16 & 0xff;\n    buffer[index++] = dec.low.low >> 24 & 0xff;\n    // Encode high bits\n    buffer[index++] = dec.low.high & 0xff;\n    buffer[index++] = dec.low.high >> 8 & 0xff;\n    buffer[index++] = dec.low.high >> 16 & 0xff;\n    buffer[index++] = dec.low.high >> 24 & 0xff;\n    // Encode the high 64 bits of the decimal\n    // Encode low bits\n    buffer[index++] = dec.high.low & 0xff;\n    buffer[index++] = dec.high.low >> 8 & 0xff;\n    buffer[index++] = dec.high.low >> 16 & 0xff;\n    buffer[index++] = dec.high.low >> 24 & 0xff;\n    // Encode high bits\n    buffer[index++] = dec.high.high & 0xff;\n    buffer[index++] = dec.high.high >> 8 & 0xff;\n    buffer[index++] = dec.high.high >> 16 & 0xff;\n    buffer[index++] = dec.high.high >> 24 & 0xff;\n    // Return the new Decimal128\n    return new Decimal128(buffer);\n  };\n  /** Create a string representation of the raw Decimal128 value */\n  Decimal128.prototype.toString = function () {\n    // Note: bits in this routine are referred to starting at 0,\n    // from the sign bit, towards the coefficient.\n    // decoded biased exponent (14 bits)\n    var biased_exponent;\n    // the number of significand digits\n    var significand_digits = 0;\n    // the base-10 digits in the significand\n    var significand = new Array(36);\n    for (var i = 0; i < significand.length; i++) significand[i] = 0;\n    // read pointer into significand\n    var index = 0;\n    // true if the number is zero\n    var is_zero = false;\n    // the most significant significand bits (50-46)\n    var significand_msb;\n    // temporary storage for significand decoding\n    var significand128 = {\n      parts: [0, 0, 0, 0]\n    };\n    // indexing variables\n    var j, k;\n    // Output string\n    var string = [];\n    // Unpack index\n    index = 0;\n    // Buffer reference\n    var buffer = this.bytes;\n    // Unpack the low 64bits into a long\n    // bits 96 - 127\n    var low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    // bits 64 - 95\n    var midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    // Unpack the high 64bits into a long\n    // bits 32 - 63\n    var midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    // bits 0 - 31\n    var high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    // Unpack index\n    index = 0;\n    // Create the state of the decimal\n    var dec = {\n      low: new long_1.Long(low, midl),\n      high: new long_1.Long(midh, high)\n    };\n    if (dec.high.lessThan(long_1.Long.ZERO)) {\n      string.push('-');\n    }\n    // Decode combination field and exponent\n    // bits 1 - 5\n    var combination = high >> 26 & COMBINATION_MASK;\n    if (combination >> 3 === 3) {\n      // Check for 'special' values\n      if (combination === COMBINATION_INFINITY) {\n        return string.join('') + 'Infinity';\n      } else if (combination === COMBINATION_NAN) {\n        return 'NaN';\n      } else {\n        biased_exponent = high >> 15 & EXPONENT_MASK;\n        significand_msb = 0x08 + (high >> 14 & 0x01);\n      }\n    } else {\n      significand_msb = high >> 14 & 0x07;\n      biased_exponent = high >> 17 & EXPONENT_MASK;\n    }\n    // unbiased exponent\n    var exponent = biased_exponent - EXPONENT_BIAS;\n    // Create string of significand digits\n    // Convert the 114-bit binary number represented by\n    // (significand_high, significand_low) to at most 34 decimal\n    // digits through modulo and division.\n    significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n    significand128.parts[1] = midh;\n    significand128.parts[2] = midl;\n    significand128.parts[3] = low;\n    if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n      is_zero = true;\n    } else {\n      for (k = 3; k >= 0; k--) {\n        var least_digits = 0;\n        // Perform the divide\n        var result = divideu128(significand128);\n        significand128 = result.quotient;\n        least_digits = result.rem.low;\n        // We now have the 9 least significant digits (in base 2).\n        // Convert and output to string.\n        if (!least_digits) continue;\n        for (j = 8; j >= 0; j--) {\n          // significand[k * 9 + j] = Math.round(least_digits % 10);\n          significand[k * 9 + j] = least_digits % 10;\n          // least_digits = Math.round(least_digits / 10);\n          least_digits = Math.floor(least_digits / 10);\n        }\n      }\n    }\n    // Output format options:\n    // Scientific - [-]d.dddE(+/-)dd or [-]dE(+/-)dd\n    // Regular    - ddd.ddd\n    if (is_zero) {\n      significand_digits = 1;\n      significand[index] = 0;\n    } else {\n      significand_digits = 36;\n      while (!significand[index]) {\n        significand_digits = significand_digits - 1;\n        index = index + 1;\n      }\n    }\n    // the exponent if scientific notation is used\n    var scientific_exponent = significand_digits - 1 + exponent;\n    // The scientific exponent checks are dictated by the string conversion\n    // specification and are somewhat arbitrary cutoffs.\n    //\n    // We must check exponent > 0, because if this is the case, the number\n    // has trailing zeros.  However, we *cannot* output these trailing zeros,\n    // because doing so would change the precision of the value, and would\n    // change stored data if the string converted number is round tripped.\n    if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n      // Scientific format\n      // if there are too many significant digits, we should just be treating numbers\n      // as + or - 0 and using the non-scientific exponent (this is for the \"invalid\n      // representation should be treated as 0/-0\" spec cases in decimal128-1.json)\n      if (significand_digits > 34) {\n        string.push(\"\".concat(0));\n        if (exponent > 0) string.push(\"E+\".concat(exponent));else if (exponent < 0) string.push(\"E\".concat(exponent));\n        return string.join('');\n      }\n      string.push(\"\".concat(significand[index++]));\n      significand_digits = significand_digits - 1;\n      if (significand_digits) {\n        string.push('.');\n      }\n      for (var i = 0; i < significand_digits; i++) {\n        string.push(\"\".concat(significand[index++]));\n      }\n      // Exponent\n      string.push('E');\n      if (scientific_exponent > 0) {\n        string.push(\"+\".concat(scientific_exponent));\n      } else {\n        string.push(\"\".concat(scientific_exponent));\n      }\n    } else {\n      // Regular format with no decimal place\n      if (exponent >= 0) {\n        for (var i = 0; i < significand_digits; i++) {\n          string.push(\"\".concat(significand[index++]));\n        }\n      } else {\n        var radix_position = significand_digits + exponent;\n        // non-zero digits before radix\n        if (radix_position > 0) {\n          for (var i = 0; i < radix_position; i++) {\n            string.push(\"\".concat(significand[index++]));\n          }\n        } else {\n          string.push('0');\n        }\n        string.push('.');\n        // add leading zeros after radix\n        while (radix_position++ < 0) {\n          string.push('0');\n        }\n        for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n          string.push(\"\".concat(significand[index++]));\n        }\n      }\n    }\n    return string.join('');\n  };\n  Decimal128.prototype.toJSON = function () {\n    return {\n      $numberDecimal: this.toString()\n    };\n  };\n  /** @internal */\n  Decimal128.prototype.toExtendedJSON = function () {\n    return {\n      $numberDecimal: this.toString()\n    };\n  };\n  /** @internal */\n  Decimal128.fromExtendedJSON = function (doc) {\n    return Decimal128.fromString(doc.$numberDecimal);\n  };\n  /** @internal */\n  Decimal128.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {\n    return this.inspect();\n  };\n  Decimal128.prototype.inspect = function () {\n    return \"new Decimal128(\\\"\".concat(this.toString(), \"\\\")\");\n  };\n  return Decimal128;\n}();\nexports.Decimal128 = Decimal128;\nObject.defineProperty(Decimal128.prototype, '_bsontype', {\n  value: 'Decimal128'\n});","map":{"version":3,"mappings":"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","names":["PARSE_STRING_REGEXP","PARSE_INF_REGEXP","PARSE_NAN_REGEXP","EXPONENT_MAX","EXPONENT_MIN","EXPONENT_BIAS","MAX_DIGITS","NAN_BUFFER","reverse","INF_NEGATIVE_BUFFER","INF_POSITIVE_BUFFER","EXPONENT_REGEX","COMBINATION_MASK","EXPONENT_MASK","COMBINATION_INFINITY","COMBINATION_NAN","isDigit","value","isNaN","parseInt","divideu128","DIVISOR","long_1","fromNumber","_rem","parts","quotient","rem","i","shiftLeft","add","div","low","modulo","multiply64x2","left","right","high","leftHigh","shiftRightUnsigned","leftLow","getLowBits","rightHigh","rightLow","productHigh","multiply","productMid","productMid2","productLow","lessThan","uhleft","uhright","ulleft","ulright","invalidErr","string","message","error_1","bytes","Decimal128","fromString","byteLength","representation","isNegative","sawRadix","foundNonZero","significantDigits","nDigitsRead","nDigits","radixPosition","firstNonZero","digits","nDigitsStored","digitsInsert","firstDigit","lastDigit","exponent","significandHigh","significandLow","biasedExponent","index","length","stringMatch","match","infMatch","nanMatch","unsignedNumber","e","expSign","expNumber","undefined","buffer_1","from","substr","digitsString","join","endOfString","roundDigit","roundBit","dIdx","significand","dec","and","equals","or","buffer","alloc","biased_exponent","significand_digits","Array","is_zero","significand_msb","significand128","j","k","midl","midh","ZERO","push","combination","least_digits","result","Math","floor","scientific_exponent","radix_position","max","$numberDecimal","toString","doc","Symbol","for","inspect","exports","Object","defineProperty","prototype"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\decimal128.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport { BSONTypeError } from './error';\r\nimport { Long } from './long';\r\nimport { isUint8Array } from './parser/utils';\r\n\r\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\r\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\r\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\r\n\r\nconst EXPONENT_MAX = 6111;\r\nconst EXPONENT_MIN = -6176;\r\nconst EXPONENT_BIAS = 6176;\r\nconst MAX_DIGITS = 34;\r\n\r\n// Nan value bits as 32 bit values (due to lack of longs)\r\nconst NAN_BUFFER = [\r\n  0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n].reverse();\r\n// Infinity value bits 32 bit values (due to lack of longs)\r\nconst INF_NEGATIVE_BUFFER = [\r\n  0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n].reverse();\r\nconst INF_POSITIVE_BUFFER = [\r\n  0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n].reverse();\r\n\r\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\r\n\r\n// Extract least significant 5 bits\r\nconst COMBINATION_MASK = 0x1f;\r\n// Extract least significant 14 bits\r\nconst EXPONENT_MASK = 0x3fff;\r\n// Value of combination field for Inf\r\nconst COMBINATION_INFINITY = 30;\r\n// Value of combination field for NaN\r\nconst COMBINATION_NAN = 31;\r\n\r\n// Detect if the value is a digit\r\nfunction isDigit(value: string): boolean {\r\n  return !isNaN(parseInt(value, 10));\r\n}\r\n\r\n// Divide two uint128 values\r\nfunction divideu128(value: { parts: [number, number, number, number] }) {\r\n  const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\r\n  let _rem = Long.fromNumber(0);\r\n\r\n  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\r\n    return { quotient: value, rem: _rem };\r\n  }\r\n\r\n  for (let i = 0; i <= 3; i++) {\r\n    // Adjust remainder to match value of next dividend\r\n    _rem = _rem.shiftLeft(32);\r\n    // Add the divided to _rem\r\n    _rem = _rem.add(new Long(value.parts[i], 0));\r\n    value.parts[i] = _rem.div(DIVISOR).low;\r\n    _rem = _rem.modulo(DIVISOR);\r\n  }\r\n\r\n  return { quotient: value, rem: _rem };\r\n}\r\n\r\n// Multiply two Long values and return the 128 bit value\r\nfunction multiply64x2(left: Long, right: Long): { high: Long; low: Long } {\r\n  if (!left && !right) {\r\n    return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\r\n  }\r\n\r\n  const leftHigh = left.shiftRightUnsigned(32);\r\n  const leftLow = new Long(left.getLowBits(), 0);\r\n  const rightHigh = right.shiftRightUnsigned(32);\r\n  const rightLow = new Long(right.getLowBits(), 0);\r\n\r\n  let productHigh = leftHigh.multiply(rightHigh);\r\n  let productMid = leftHigh.multiply(rightLow);\r\n  const productMid2 = leftLow.multiply(rightHigh);\r\n  let productLow = leftLow.multiply(rightLow);\r\n\r\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\r\n  productMid = new Long(productMid.getLowBits(), 0)\r\n    .add(productMid2)\r\n    .add(productLow.shiftRightUnsigned(32));\r\n\r\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\r\n  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\r\n\r\n  // Return the 128 bit result\r\n  return { high: productHigh, low: productLow };\r\n}\r\n\r\nfunction lessThan(left: Long, right: Long): boolean {\r\n  // Make values unsigned\r\n  const uhleft = left.high >>> 0;\r\n  const uhright = right.high >>> 0;\r\n\r\n  // Compare high bits first\r\n  if (uhleft < uhright) {\r\n    return true;\r\n  } else if (uhleft === uhright) {\r\n    const ulleft = left.low >>> 0;\r\n    const ulright = right.low >>> 0;\r\n    if (ulleft < ulright) return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction invalidErr(string: string, message: string) {\r\n  throw new BSONTypeError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\r\n}\r\n\r\n/** @public */\r\nexport interface Decimal128Extended {\r\n  $numberDecimal: string;\r\n}\r\n\r\n/**\r\n * A class representation of the BSON Decimal128 type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport class Decimal128 {\r\n  _bsontype!: 'Decimal128';\r\n\r\n  readonly bytes!: Buffer;\r\n\r\n  /**\r\n   * @param bytes - a buffer containing the raw Decimal128 bytes in little endian order,\r\n   *                or a string representation as returned by .toString()\r\n   */\r\n  constructor(bytes: Buffer | string) {\r\n    if (!(this instanceof Decimal128)) return new Decimal128(bytes);\r\n\r\n    if (typeof bytes === 'string') {\r\n      this.bytes = Decimal128.fromString(bytes).bytes;\r\n    } else if (isUint8Array(bytes)) {\r\n      if (bytes.byteLength !== 16) {\r\n        throw new BSONTypeError('Decimal128 must take a Buffer of 16 bytes');\r\n      }\r\n      this.bytes = bytes;\r\n    } else {\r\n      throw new BSONTypeError('Decimal128 must take a Buffer or string');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a Decimal128 instance from a string representation\r\n   *\r\n   * @param representation - a numeric string representation.\r\n   */\r\n  static fromString(representation: string): Decimal128 {\r\n    // Parse state tracking\r\n    let isNegative = false;\r\n    let sawRadix = false;\r\n    let foundNonZero = false;\r\n\r\n    // Total number of significant digits (no leading or trailing zero)\r\n    let significantDigits = 0;\r\n    // Total number of significand digits read\r\n    let nDigitsRead = 0;\r\n    // Total number of digits (no leading zeros)\r\n    let nDigits = 0;\r\n    // The number of the digits after radix\r\n    let radixPosition = 0;\r\n    // The index of the first non-zero in *str*\r\n    let firstNonZero = 0;\r\n\r\n    // Digits Array\r\n    const digits = [0];\r\n    // The number of digits in digits\r\n    let nDigitsStored = 0;\r\n    // Insertion pointer for digits\r\n    let digitsInsert = 0;\r\n    // The index of the first non-zero digit\r\n    let firstDigit = 0;\r\n    // The index of the last digit\r\n    let lastDigit = 0;\r\n\r\n    // Exponent\r\n    let exponent = 0;\r\n    // loop index over array\r\n    let i = 0;\r\n    // The high 17 digits of the significand\r\n    let significandHigh = new Long(0, 0);\r\n    // The low 17 digits of the significand\r\n    let significandLow = new Long(0, 0);\r\n    // The biased exponent\r\n    let biasedExponent = 0;\r\n\r\n    // Read index\r\n    let index = 0;\r\n\r\n    // Naively prevent against REDOS attacks.\r\n    // TODO: implementing a custom parsing for this, or refactoring the regex would yield\r\n    //       further gains.\r\n    if (representation.length >= 7000) {\r\n      throw new BSONTypeError('' + representation + ' not a valid Decimal128 string');\r\n    }\r\n\r\n    // Results\r\n    const stringMatch = representation.match(PARSE_STRING_REGEXP);\r\n    const infMatch = representation.match(PARSE_INF_REGEXP);\r\n    const nanMatch = representation.match(PARSE_NAN_REGEXP);\r\n\r\n    // Validate the string\r\n    if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) {\r\n      throw new BSONTypeError('' + representation + ' not a valid Decimal128 string');\r\n    }\r\n\r\n    if (stringMatch) {\r\n      // full_match = stringMatch[0]\r\n      // sign = stringMatch[1]\r\n\r\n      const unsignedNumber = stringMatch[2];\r\n      // stringMatch[3] is undefined if a whole number (ex \"1\", 12\")\r\n      // but defined if a number w/ decimal in it (ex \"1.0, 12.2\")\r\n\r\n      const e = stringMatch[4];\r\n      const expSign = stringMatch[5];\r\n      const expNumber = stringMatch[6];\r\n\r\n      // they provided e, but didn't give an exponent number. for ex \"1e\"\r\n      if (e && expNumber === undefined) invalidErr(representation, 'missing exponent power');\r\n\r\n      // they provided e, but didn't give a number before it. for ex \"e1\"\r\n      if (e && unsignedNumber === undefined) invalidErr(representation, 'missing exponent base');\r\n\r\n      if (e === undefined && (expSign || expNumber)) {\r\n        invalidErr(representation, 'missing e before exponent');\r\n      }\r\n    }\r\n\r\n    // Get the negative or positive sign\r\n    if (representation[index] === '+' || representation[index] === '-') {\r\n      isNegative = representation[index++] === '-';\r\n    }\r\n\r\n    // Check if user passed Infinity or NaN\r\n    if (!isDigit(representation[index]) && representation[index] !== '.') {\r\n      if (representation[index] === 'i' || representation[index] === 'I') {\r\n        return new Decimal128(Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));\r\n      } else if (representation[index] === 'N') {\r\n        return new Decimal128(Buffer.from(NAN_BUFFER));\r\n      }\r\n    }\r\n\r\n    // Read all the digits\r\n    while (isDigit(representation[index]) || representation[index] === '.') {\r\n      if (representation[index] === '.') {\r\n        if (sawRadix) invalidErr(representation, 'contains multiple periods');\r\n\r\n        sawRadix = true;\r\n        index = index + 1;\r\n        continue;\r\n      }\r\n\r\n      if (nDigitsStored < 34) {\r\n        if (representation[index] !== '0' || foundNonZero) {\r\n          if (!foundNonZero) {\r\n            firstNonZero = nDigitsRead;\r\n          }\r\n\r\n          foundNonZero = true;\r\n\r\n          // Only store 34 digits\r\n          digits[digitsInsert++] = parseInt(representation[index], 10);\r\n          nDigitsStored = nDigitsStored + 1;\r\n        }\r\n      }\r\n\r\n      if (foundNonZero) nDigits = nDigits + 1;\r\n      if (sawRadix) radixPosition = radixPosition + 1;\r\n\r\n      nDigitsRead = nDigitsRead + 1;\r\n      index = index + 1;\r\n    }\r\n\r\n    if (sawRadix && !nDigitsRead)\r\n      throw new BSONTypeError('' + representation + ' not a valid Decimal128 string');\r\n\r\n    // Read exponent if exists\r\n    if (representation[index] === 'e' || representation[index] === 'E') {\r\n      // Read exponent digits\r\n      const match = representation.substr(++index).match(EXPONENT_REGEX);\r\n\r\n      // No digits read\r\n      if (!match || !match[2]) return new Decimal128(Buffer.from(NAN_BUFFER));\r\n\r\n      // Get exponent\r\n      exponent = parseInt(match[0], 10);\r\n\r\n      // Adjust the index\r\n      index = index + match[0].length;\r\n    }\r\n\r\n    // Return not a number\r\n    if (representation[index]) return new Decimal128(Buffer.from(NAN_BUFFER));\r\n\r\n    // Done reading input\r\n    // Find first non-zero digit in digits\r\n    firstDigit = 0;\r\n\r\n    if (!nDigitsStored) {\r\n      firstDigit = 0;\r\n      lastDigit = 0;\r\n      digits[0] = 0;\r\n      nDigits = 1;\r\n      nDigitsStored = 1;\r\n      significantDigits = 0;\r\n    } else {\r\n      lastDigit = nDigitsStored - 1;\r\n      significantDigits = nDigits;\r\n      if (significantDigits !== 1) {\r\n        while (digits[firstNonZero + significantDigits - 1] === 0) {\r\n          significantDigits = significantDigits - 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Normalization of exponent\r\n    // Correct exponent based on radix position, and shift significand as needed\r\n    // to represent user input\r\n\r\n    // Overflow prevention\r\n    if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {\r\n      exponent = EXPONENT_MIN;\r\n    } else {\r\n      exponent = exponent - radixPosition;\r\n    }\r\n\r\n    // Attempt to normalize the exponent\r\n    while (exponent > EXPONENT_MAX) {\r\n      // Shift exponent to significand and decrease\r\n      lastDigit = lastDigit + 1;\r\n\r\n      if (lastDigit - firstDigit > MAX_DIGITS) {\r\n        // Check if we have a zero then just hard clamp, otherwise fail\r\n        const digitsString = digits.join('');\r\n        if (digitsString.match(/^0+$/)) {\r\n          exponent = EXPONENT_MAX;\r\n          break;\r\n        }\r\n\r\n        invalidErr(representation, 'overflow');\r\n      }\r\n      exponent = exponent - 1;\r\n    }\r\n\r\n    while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\r\n      // Shift last digit. can only do this if < significant digits than # stored.\r\n      if (lastDigit === 0 && significantDigits < nDigitsStored) {\r\n        exponent = EXPONENT_MIN;\r\n        significantDigits = 0;\r\n        break;\r\n      }\r\n\r\n      if (nDigitsStored < nDigits) {\r\n        // adjust to match digits not stored\r\n        nDigits = nDigits - 1;\r\n      } else {\r\n        // adjust to round\r\n        lastDigit = lastDigit - 1;\r\n      }\r\n\r\n      if (exponent < EXPONENT_MAX) {\r\n        exponent = exponent + 1;\r\n      } else {\r\n        // Check if we have a zero then just hard clamp, otherwise fail\r\n        const digitsString = digits.join('');\r\n        if (digitsString.match(/^0+$/)) {\r\n          exponent = EXPONENT_MAX;\r\n          break;\r\n        }\r\n        invalidErr(representation, 'overflow');\r\n      }\r\n    }\r\n\r\n    // Round\r\n    // We've normalized the exponent, but might still need to round.\r\n    if (lastDigit - firstDigit + 1 < significantDigits) {\r\n      let endOfString = nDigitsRead;\r\n\r\n      // If we have seen a radix point, 'string' is 1 longer than we have\r\n      // documented with ndigits_read, so inc the position of the first nonzero\r\n      // digit and the position that digits are read to.\r\n      if (sawRadix) {\r\n        firstNonZero = firstNonZero + 1;\r\n        endOfString = endOfString + 1;\r\n      }\r\n      // if negative, we need to increment again to account for - sign at start.\r\n      if (isNegative) {\r\n        firstNonZero = firstNonZero + 1;\r\n        endOfString = endOfString + 1;\r\n      }\r\n\r\n      const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\r\n      let roundBit = 0;\r\n\r\n      if (roundDigit >= 5) {\r\n        roundBit = 1;\r\n        if (roundDigit === 5) {\r\n          roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\r\n          for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\r\n            if (parseInt(representation[i], 10)) {\r\n              roundBit = 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (roundBit) {\r\n        let dIdx = lastDigit;\r\n\r\n        for (; dIdx >= 0; dIdx--) {\r\n          if (++digits[dIdx] > 9) {\r\n            digits[dIdx] = 0;\r\n\r\n            // overflowed most significant digit\r\n            if (dIdx === 0) {\r\n              if (exponent < EXPONENT_MAX) {\r\n                exponent = exponent + 1;\r\n                digits[dIdx] = 1;\r\n              } else {\r\n                return new Decimal128(\r\n                  Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER)\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Encode significand\r\n    // The high 17 digits of the significand\r\n    significandHigh = Long.fromNumber(0);\r\n    // The low 17 digits of the significand\r\n    significandLow = Long.fromNumber(0);\r\n\r\n    // read a zero\r\n    if (significantDigits === 0) {\r\n      significandHigh = Long.fromNumber(0);\r\n      significandLow = Long.fromNumber(0);\r\n    } else if (lastDigit - firstDigit < 17) {\r\n      let dIdx = firstDigit;\r\n      significandLow = Long.fromNumber(digits[dIdx++]);\r\n      significandHigh = new Long(0, 0);\r\n\r\n      for (; dIdx <= lastDigit; dIdx++) {\r\n        significandLow = significandLow.multiply(Long.fromNumber(10));\r\n        significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\r\n      }\r\n    } else {\r\n      let dIdx = firstDigit;\r\n      significandHigh = Long.fromNumber(digits[dIdx++]);\r\n\r\n      for (; dIdx <= lastDigit - 17; dIdx++) {\r\n        significandHigh = significandHigh.multiply(Long.fromNumber(10));\r\n        significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\r\n      }\r\n\r\n      significandLow = Long.fromNumber(digits[dIdx++]);\r\n\r\n      for (; dIdx <= lastDigit; dIdx++) {\r\n        significandLow = significandLow.multiply(Long.fromNumber(10));\r\n        significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\r\n      }\r\n    }\r\n\r\n    const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));\r\n    significand.low = significand.low.add(significandLow);\r\n\r\n    if (lessThan(significand.low, significandLow)) {\r\n      significand.high = significand.high.add(Long.fromNumber(1));\r\n    }\r\n\r\n    // Biased exponent\r\n    biasedExponent = exponent + EXPONENT_BIAS;\r\n    const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\r\n\r\n    // Encode combination, exponent, and significand.\r\n    if (\r\n      significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))\r\n    ) {\r\n      // Encode '11' into bits 1 to 3\r\n      dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\r\n      dec.high = dec.high.or(\r\n        Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47))\r\n      );\r\n      dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\r\n    } else {\r\n      dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\r\n      dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\r\n    }\r\n\r\n    dec.low = significand.low;\r\n\r\n    // Encode sign\r\n    if (isNegative) {\r\n      dec.high = dec.high.or(Long.fromString('9223372036854775808'));\r\n    }\r\n\r\n    // Encode into a buffer\r\n    const buffer = Buffer.alloc(16);\r\n    index = 0;\r\n\r\n    // Encode the low 64 bits of the decimal\r\n    // Encode low bits\r\n    buffer[index++] = dec.low.low & 0xff;\r\n    buffer[index++] = (dec.low.low >> 8) & 0xff;\r\n    buffer[index++] = (dec.low.low >> 16) & 0xff;\r\n    buffer[index++] = (dec.low.low >> 24) & 0xff;\r\n    // Encode high bits\r\n    buffer[index++] = dec.low.high & 0xff;\r\n    buffer[index++] = (dec.low.high >> 8) & 0xff;\r\n    buffer[index++] = (dec.low.high >> 16) & 0xff;\r\n    buffer[index++] = (dec.low.high >> 24) & 0xff;\r\n\r\n    // Encode the high 64 bits of the decimal\r\n    // Encode low bits\r\n    buffer[index++] = dec.high.low & 0xff;\r\n    buffer[index++] = (dec.high.low >> 8) & 0xff;\r\n    buffer[index++] = (dec.high.low >> 16) & 0xff;\r\n    buffer[index++] = (dec.high.low >> 24) & 0xff;\r\n    // Encode high bits\r\n    buffer[index++] = dec.high.high & 0xff;\r\n    buffer[index++] = (dec.high.high >> 8) & 0xff;\r\n    buffer[index++] = (dec.high.high >> 16) & 0xff;\r\n    buffer[index++] = (dec.high.high >> 24) & 0xff;\r\n\r\n    // Return the new Decimal128\r\n    return new Decimal128(buffer);\r\n  }\r\n\r\n  /** Create a string representation of the raw Decimal128 value */\r\n  toString(): string {\r\n    // Note: bits in this routine are referred to starting at 0,\r\n    // from the sign bit, towards the coefficient.\r\n\r\n    // decoded biased exponent (14 bits)\r\n    let biased_exponent;\r\n    // the number of significand digits\r\n    let significand_digits = 0;\r\n    // the base-10 digits in the significand\r\n    const significand = new Array<number>(36);\r\n    for (let i = 0; i < significand.length; i++) significand[i] = 0;\r\n    // read pointer into significand\r\n    let index = 0;\r\n\r\n    // true if the number is zero\r\n    let is_zero = false;\r\n\r\n    // the most significant significand bits (50-46)\r\n    let significand_msb;\r\n    // temporary storage for significand decoding\r\n    let significand128: { parts: [number, number, number, number] } = { parts: [0, 0, 0, 0] };\r\n    // indexing variables\r\n    let j, k;\r\n\r\n    // Output string\r\n    const string: string[] = [];\r\n\r\n    // Unpack index\r\n    index = 0;\r\n\r\n    // Buffer reference\r\n    const buffer = this.bytes;\r\n\r\n    // Unpack the low 64bits into a long\r\n    // bits 96 - 127\r\n    const low =\r\n      buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\r\n    // bits 64 - 95\r\n    const midl =\r\n      buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\r\n\r\n    // Unpack the high 64bits into a long\r\n    // bits 32 - 63\r\n    const midh =\r\n      buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\r\n    // bits 0 - 31\r\n    const high =\r\n      buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\r\n\r\n    // Unpack index\r\n    index = 0;\r\n\r\n    // Create the state of the decimal\r\n    const dec = {\r\n      low: new Long(low, midl),\r\n      high: new Long(midh, high)\r\n    };\r\n\r\n    if (dec.high.lessThan(Long.ZERO)) {\r\n      string.push('-');\r\n    }\r\n\r\n    // Decode combination field and exponent\r\n    // bits 1 - 5\r\n    const combination = (high >> 26) & COMBINATION_MASK;\r\n\r\n    if (combination >> 3 === 3) {\r\n      // Check for 'special' values\r\n      if (combination === COMBINATION_INFINITY) {\r\n        return string.join('') + 'Infinity';\r\n      } else if (combination === COMBINATION_NAN) {\r\n        return 'NaN';\r\n      } else {\r\n        biased_exponent = (high >> 15) & EXPONENT_MASK;\r\n        significand_msb = 0x08 + ((high >> 14) & 0x01);\r\n      }\r\n    } else {\r\n      significand_msb = (high >> 14) & 0x07;\r\n      biased_exponent = (high >> 17) & EXPONENT_MASK;\r\n    }\r\n\r\n    // unbiased exponent\r\n    const exponent = biased_exponent - EXPONENT_BIAS;\r\n\r\n    // Create string of significand digits\r\n\r\n    // Convert the 114-bit binary number represented by\r\n    // (significand_high, significand_low) to at most 34 decimal\r\n    // digits through modulo and division.\r\n    significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\r\n    significand128.parts[1] = midh;\r\n    significand128.parts[2] = midl;\r\n    significand128.parts[3] = low;\r\n\r\n    if (\r\n      significand128.parts[0] === 0 &&\r\n      significand128.parts[1] === 0 &&\r\n      significand128.parts[2] === 0 &&\r\n      significand128.parts[3] === 0\r\n    ) {\r\n      is_zero = true;\r\n    } else {\r\n      for (k = 3; k >= 0; k--) {\r\n        let least_digits = 0;\r\n        // Perform the divide\r\n        const result = divideu128(significand128);\r\n        significand128 = result.quotient;\r\n        least_digits = result.rem.low;\r\n\r\n        // We now have the 9 least significant digits (in base 2).\r\n        // Convert and output to string.\r\n        if (!least_digits) continue;\r\n\r\n        for (j = 8; j >= 0; j--) {\r\n          // significand[k * 9 + j] = Math.round(least_digits % 10);\r\n          significand[k * 9 + j] = least_digits % 10;\r\n          // least_digits = Math.round(least_digits / 10);\r\n          least_digits = Math.floor(least_digits / 10);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Output format options:\r\n    // Scientific - [-]d.dddE(+/-)dd or [-]dE(+/-)dd\r\n    // Regular    - ddd.ddd\r\n\r\n    if (is_zero) {\r\n      significand_digits = 1;\r\n      significand[index] = 0;\r\n    } else {\r\n      significand_digits = 36;\r\n      while (!significand[index]) {\r\n        significand_digits = significand_digits - 1;\r\n        index = index + 1;\r\n      }\r\n    }\r\n\r\n    // the exponent if scientific notation is used\r\n    const scientific_exponent = significand_digits - 1 + exponent;\r\n\r\n    // The scientific exponent checks are dictated by the string conversion\r\n    // specification and are somewhat arbitrary cutoffs.\r\n    //\r\n    // We must check exponent > 0, because if this is the case, the number\r\n    // has trailing zeros.  However, we *cannot* output these trailing zeros,\r\n    // because doing so would change the precision of the value, and would\r\n    // change stored data if the string converted number is round tripped.\r\n    if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\r\n      // Scientific format\r\n\r\n      // if there are too many significant digits, we should just be treating numbers\r\n      // as + or - 0 and using the non-scientific exponent (this is for the \"invalid\r\n      // representation should be treated as 0/-0\" spec cases in decimal128-1.json)\r\n      if (significand_digits > 34) {\r\n        string.push(`${0}`);\r\n        if (exponent > 0) string.push(`E+${exponent}`);\r\n        else if (exponent < 0) string.push(`E${exponent}`);\r\n        return string.join('');\r\n      }\r\n\r\n      string.push(`${significand[index++]}`);\r\n      significand_digits = significand_digits - 1;\r\n\r\n      if (significand_digits) {\r\n        string.push('.');\r\n      }\r\n\r\n      for (let i = 0; i < significand_digits; i++) {\r\n        string.push(`${significand[index++]}`);\r\n      }\r\n\r\n      // Exponent\r\n      string.push('E');\r\n      if (scientific_exponent > 0) {\r\n        string.push(`+${scientific_exponent}`);\r\n      } else {\r\n        string.push(`${scientific_exponent}`);\r\n      }\r\n    } else {\r\n      // Regular format with no decimal place\r\n      if (exponent >= 0) {\r\n        for (let i = 0; i < significand_digits; i++) {\r\n          string.push(`${significand[index++]}`);\r\n        }\r\n      } else {\r\n        let radix_position = significand_digits + exponent;\r\n\r\n        // non-zero digits before radix\r\n        if (radix_position > 0) {\r\n          for (let i = 0; i < radix_position; i++) {\r\n            string.push(`${significand[index++]}`);\r\n          }\r\n        } else {\r\n          string.push('0');\r\n        }\r\n\r\n        string.push('.');\r\n        // add leading zeros after radix\r\n        while (radix_position++ < 0) {\r\n          string.push('0');\r\n        }\r\n\r\n        for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\r\n          string.push(`${significand[index++]}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return string.join('');\r\n  }\r\n\r\n  toJSON(): Decimal128Extended {\r\n    return { $numberDecimal: this.toString() };\r\n  }\r\n\r\n  /** @internal */\r\n  toExtendedJSON(): Decimal128Extended {\r\n    return { $numberDecimal: this.toString() };\r\n  }\r\n\r\n  /** @internal */\r\n  static fromExtendedJSON(doc: Decimal128Extended): Decimal128 {\r\n    return Decimal128.fromString(doc.$numberDecimal);\r\n  }\r\n\r\n  /** @internal */\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    return `new Decimal128(\"${this.toString()}\")`;\r\n  }\r\n}\r\n\r\nObject.defineProperty(Decimal128.prototype, '_bsontype', { value: 'Decimal128' });\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}