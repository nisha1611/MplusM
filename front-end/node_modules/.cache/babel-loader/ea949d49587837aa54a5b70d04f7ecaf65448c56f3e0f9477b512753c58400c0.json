{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n\nclass FlagDependencyExportsPlugin {\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler the compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyExportsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      const cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n      compilation.hooks.finishModules.tapAsync(\"FlagDependencyExportsPlugin\", (modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.FlagDependencyExportsPlugin\");\n        let statRestoredFromMemCache = 0;\n        let statRestoredFromCache = 0;\n        let statNoExports = 0;\n        let statFlaggedUncached = 0;\n        let statNotCached = 0;\n        let statQueueItemsProcessed = 0;\n        const {\n          moduleMemCaches\n        } = compilation;\n\n        /** @type {Queue<Module>} */\n        const queue = new Queue();\n\n        // Step 1: Try to restore cached provided export info from cache\n        logger.time(\"restore cached provided exports\");\n        asyncLib.each(modules, (module, callback) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          if (!module.buildMeta || !module.buildMeta.exportsType) {\n            if (exportsInfo.otherExportsInfo.provided !== null) {\n              // It's a module without declared exports\n              statNoExports++;\n              exportsInfo.setHasProvideInfo();\n              exportsInfo.setUnknownExportsProvided();\n              return callback();\n            }\n          }\n          if (typeof module.buildInfo.hash !== \"string\") {\n            statFlaggedUncached++;\n            // Enqueue uncacheable module for determining the exports\n            queue.enqueue(module);\n            exportsInfo.setHasProvideInfo();\n            return callback();\n          }\n          const memCache = moduleMemCaches && moduleMemCaches.get(module);\n          const memCacheValue = memCache && memCache.get(this);\n          if (memCacheValue !== undefined) {\n            statRestoredFromMemCache++;\n            exportsInfo.restoreProvided(memCacheValue);\n            return callback();\n          }\n          cache.get(module.identifier(), module.buildInfo.hash, (err, result) => {\n            if (err) return callback(err);\n            if (result !== undefined) {\n              statRestoredFromCache++;\n              exportsInfo.restoreProvided(result);\n            } else {\n              statNotCached++;\n              // Without cached info enqueue module for determining the exports\n              queue.enqueue(module);\n              exportsInfo.setHasProvideInfo();\n            }\n            callback();\n          });\n        }, err => {\n          logger.timeEnd(\"restore cached provided exports\");\n          if (err) return callback(err);\n\n          /** @type {Set<Module>} */\n          const modulesToStore = new Set();\n\n          /** @type {Map<Module, Set<Module>>} */\n          const dependencies = new Map();\n\n          /** @type {Module} */\n          let module;\n\n          /** @type {ExportsInfo} */\n          let exportsInfo;\n\n          /** @type {Map<Dependency, ExportsSpec>} */\n          const exportsSpecsFromDependencies = new Map();\n          let cacheable = true;\n          let changed = false;\n\n          /**\r\n           * @param {DependenciesBlock} depBlock the dependencies block\r\n           * @returns {void}\r\n           */\n          const processDependenciesBlock = depBlock => {\n            for (const dep of depBlock.dependencies) {\n              processDependency(dep);\n            }\n            for (const block of depBlock.blocks) {\n              processDependenciesBlock(block);\n            }\n          };\n\n          /**\r\n           * @param {Dependency} dep the dependency\r\n           * @returns {void}\r\n           */\n          const processDependency = dep => {\n            const exportDesc = dep.getExports(moduleGraph);\n            if (!exportDesc) return;\n            exportsSpecsFromDependencies.set(dep, exportDesc);\n          };\n\n          /**\r\n           * @param {Dependency} dep dependency\r\n           * @param {ExportsSpec} exportDesc info\r\n           * @returns {void}\r\n           */\n          const processExportsSpec = (dep, exportDesc) => {\n            const exports = exportDesc.exports;\n            const globalCanMangle = exportDesc.canMangle;\n            const globalFrom = exportDesc.from;\n            const globalPriority = exportDesc.priority;\n            const globalTerminalBinding = exportDesc.terminalBinding || false;\n            const exportDeps = exportDesc.dependencies;\n            if (exportDesc.hideExports) {\n              for (const name of exportDesc.hideExports) {\n                const exportInfo = exportsInfo.getExportInfo(name);\n                exportInfo.unsetTarget(dep);\n              }\n            }\n            if (exports === true) {\n              // unknown exports\n              if (exportsInfo.setUnknownExportsProvided(globalCanMangle, exportDesc.excludeExports, globalFrom && dep, globalFrom, globalPriority)) {\n                changed = true;\n              }\n            } else if (Array.isArray(exports)) {\n              /**\r\n               * merge in new exports\r\n               * @param {ExportsInfo} exportsInfo own exports info\r\n               * @param {(ExportSpec | string)[]} exports list of exports\r\n               */\n              const mergeExports = (exportsInfo, exports) => {\n                for (const exportNameOrSpec of exports) {\n                  let name;\n                  let canMangle = globalCanMangle;\n                  let terminalBinding = globalTerminalBinding;\n                  let exports = undefined;\n                  let from = globalFrom;\n                  let fromExport = undefined;\n                  let priority = globalPriority;\n                  let hidden = false;\n                  if (typeof exportNameOrSpec === \"string\") {\n                    name = exportNameOrSpec;\n                  } else {\n                    name = exportNameOrSpec.name;\n                    if (exportNameOrSpec.canMangle !== undefined) canMangle = exportNameOrSpec.canMangle;\n                    if (exportNameOrSpec.export !== undefined) fromExport = exportNameOrSpec.export;\n                    if (exportNameOrSpec.exports !== undefined) exports = exportNameOrSpec.exports;\n                    if (exportNameOrSpec.from !== undefined) from = exportNameOrSpec.from;\n                    if (exportNameOrSpec.priority !== undefined) priority = exportNameOrSpec.priority;\n                    if (exportNameOrSpec.terminalBinding !== undefined) terminalBinding = exportNameOrSpec.terminalBinding;\n                    if (exportNameOrSpec.hidden !== undefined) hidden = exportNameOrSpec.hidden;\n                  }\n                  const exportInfo = exportsInfo.getExportInfo(name);\n                  if (exportInfo.provided === false || exportInfo.provided === null) {\n                    exportInfo.provided = true;\n                    changed = true;\n                  }\n                  if (exportInfo.canMangleProvide !== false && canMangle === false) {\n                    exportInfo.canMangleProvide = false;\n                    changed = true;\n                  }\n                  if (terminalBinding && !exportInfo.terminalBinding) {\n                    exportInfo.terminalBinding = true;\n                    changed = true;\n                  }\n                  if (exports) {\n                    const nestedExportsInfo = exportInfo.createNestedExportsInfo();\n                    mergeExports(nestedExportsInfo, exports);\n                  }\n                  if (from && (hidden ? exportInfo.unsetTarget(dep) : exportInfo.setTarget(dep, from, fromExport === undefined ? [name] : fromExport, priority))) {\n                    changed = true;\n                  }\n\n                  // Recalculate target exportsInfo\n                  const target = exportInfo.getTarget(moduleGraph);\n                  let targetExportsInfo = undefined;\n                  if (target) {\n                    const targetModuleExportsInfo = moduleGraph.getExportsInfo(target.module);\n                    targetExportsInfo = targetModuleExportsInfo.getNestedExportsInfo(target.export);\n                    // add dependency for this module\n                    const set = dependencies.get(target.module);\n                    if (set === undefined) {\n                      dependencies.set(target.module, new Set([module]));\n                    } else {\n                      set.add(module);\n                    }\n                  }\n                  if (exportInfo.exportsInfoOwned) {\n                    if (exportInfo.exportsInfo.setRedirectNamedTo(targetExportsInfo)) {\n                      changed = true;\n                    }\n                  } else if (exportInfo.exportsInfo !== targetExportsInfo) {\n                    exportInfo.exportsInfo = targetExportsInfo;\n                    changed = true;\n                  }\n                }\n              };\n              mergeExports(exportsInfo, exports);\n            }\n            // store dependencies\n            if (exportDeps) {\n              cacheable = false;\n              for (const exportDependency of exportDeps) {\n                // add dependency for this module\n                const set = dependencies.get(exportDependency);\n                if (set === undefined) {\n                  dependencies.set(exportDependency, new Set([module]));\n                } else {\n                  set.add(module);\n                }\n              }\n            }\n          };\n          const notifyDependencies = () => {\n            const deps = dependencies.get(module);\n            if (deps !== undefined) {\n              for (const dep of deps) {\n                queue.enqueue(dep);\n              }\n            }\n          };\n          logger.time(\"figure out provided exports\");\n          while (queue.length > 0) {\n            module = queue.dequeue();\n            statQueueItemsProcessed++;\n            exportsInfo = moduleGraph.getExportsInfo(module);\n            cacheable = true;\n            changed = false;\n            exportsSpecsFromDependencies.clear();\n            moduleGraph.freeze();\n            processDependenciesBlock(module);\n            moduleGraph.unfreeze();\n            for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {\n              processExportsSpec(dep, exportsSpec);\n            }\n            if (cacheable) {\n              modulesToStore.add(module);\n            }\n            if (changed) {\n              notifyDependencies();\n            }\n          }\n          logger.timeEnd(\"figure out provided exports\");\n          logger.log(`${Math.round(100 * (statFlaggedUncached + statNotCached) / (statRestoredFromMemCache + statRestoredFromCache + statNotCached + statFlaggedUncached + statNoExports))}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${statQueueItemsProcessed - statNotCached - statFlaggedUncached} additional calculations due to dependencies)`);\n          logger.time(\"store provided exports into cache\");\n          asyncLib.each(modulesToStore, (module, callback) => {\n            if (typeof module.buildInfo.hash !== \"string\") {\n              // not cacheable\n              return callback();\n            }\n            const cachedData = moduleGraph.getExportsInfo(module).getRestoreProvidedData();\n            const memCache = moduleMemCaches && moduleMemCaches.get(module);\n            if (memCache) {\n              memCache.set(this, cachedData);\n            }\n            cache.store(module.identifier(), module.buildInfo.hash, cachedData, callback);\n          }, err => {\n            logger.timeEnd(\"store provided exports into cache\");\n            callback(err);\n          });\n        });\n      });\n\n      /** @type {WeakMap<Module, any>} */\n      const providedExportsCache = new WeakMap();\n      compilation.hooks.rebuildModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        providedExportsCache.set(module, moduleGraph.getExportsInfo(module).getRestoreProvidedData());\n      });\n      compilation.hooks.finishRebuildingModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        moduleGraph.getExportsInfo(module).restoreProvided(providedExportsCache.get(module));\n      });\n    });\n  }\n}\nmodule.exports = FlagDependencyExportsPlugin;","map":{"version":3,"names":["asyncLib","require","Queue","FlagDependencyExportsPlugin","apply","compiler","hooks","compilation","tap","moduleGraph","cache","getCache","finishModules","tapAsync","modules","callback","logger","getLogger","statRestoredFromMemCache","statRestoredFromCache","statNoExports","statFlaggedUncached","statNotCached","statQueueItemsProcessed","moduleMemCaches","queue","time","each","module","exportsInfo","getExportsInfo","buildMeta","exportsType","otherExportsInfo","provided","setHasProvideInfo","setUnknownExportsProvided","buildInfo","hash","enqueue","memCache","get","memCacheValue","undefined","restoreProvided","identifier","err","result","timeEnd","modulesToStore","Set","dependencies","Map","exportsSpecsFromDependencies","cacheable","changed","processDependenciesBlock","depBlock","dep","processDependency","block","blocks","exportDesc","getExports","set","processExportsSpec","exports","globalCanMangle","canMangle","globalFrom","from","globalPriority","priority","globalTerminalBinding","terminalBinding","exportDeps","hideExports","name","exportInfo","getExportInfo","unsetTarget","excludeExports","Array","isArray","mergeExports","exportNameOrSpec","fromExport","hidden","export","canMangleProvide","nestedExportsInfo","createNestedExportsInfo","setTarget","target","getTarget","targetExportsInfo","targetModuleExportsInfo","getNestedExportsInfo","add","exportsInfoOwned","setRedirectNamedTo","exportDependency","notifyDependencies","deps","length","dequeue","clear","freeze","unfreeze","exportsSpec","log","Math","round","cachedData","getRestoreProvidedData","store","providedExportsCache","WeakMap","rebuildModule","finishRebuildingModule"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/FlagDependencyExportsPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst asyncLib = require(\"neo-async\");\r\nconst Queue = require(\"./util/Queue\");\r\n\r\n/** @typedef {import(\"./Compiler\")} Compiler */\r\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\r\n/** @typedef {import(\"./Dependency\")} Dependency */\r\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\r\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\r\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\r\n/** @typedef {import(\"./Module\")} Module */\r\n\r\nclass FlagDependencyExportsPlugin {\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler the compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tcompiler.hooks.compilation.tap(\r\n\t\t\t\"FlagDependencyExportsPlugin\",\r\n\t\t\tcompilation => {\r\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\r\n\t\t\t\tconst cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\r\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\r\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\r\n\t\t\t\t\t(modules, callback) => {\r\n\t\t\t\t\t\tconst logger = compilation.getLogger(\r\n\t\t\t\t\t\t\t\"webpack.FlagDependencyExportsPlugin\"\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tlet statRestoredFromMemCache = 0;\r\n\t\t\t\t\t\tlet statRestoredFromCache = 0;\r\n\t\t\t\t\t\tlet statNoExports = 0;\r\n\t\t\t\t\t\tlet statFlaggedUncached = 0;\r\n\t\t\t\t\t\tlet statNotCached = 0;\r\n\t\t\t\t\t\tlet statQueueItemsProcessed = 0;\r\n\r\n\t\t\t\t\t\tconst { moduleMemCaches } = compilation;\r\n\r\n\t\t\t\t\t\t/** @type {Queue<Module>} */\r\n\t\t\t\t\t\tconst queue = new Queue();\r\n\r\n\t\t\t\t\t\t// Step 1: Try to restore cached provided export info from cache\r\n\t\t\t\t\t\tlogger.time(\"restore cached provided exports\");\r\n\t\t\t\t\t\tasyncLib.each(\r\n\t\t\t\t\t\t\tmodules,\r\n\t\t\t\t\t\t\t(module, callback) => {\r\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\r\n\t\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\r\n\t\t\t\t\t\t\t\t\tif (exportsInfo.otherExportsInfo.provided !== null) {\r\n\t\t\t\t\t\t\t\t\t\t// It's a module without declared exports\r\n\t\t\t\t\t\t\t\t\t\tstatNoExports++;\r\n\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\r\n\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided();\r\n\t\t\t\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\r\n\t\t\t\t\t\t\t\t\tstatFlaggedUncached++;\r\n\t\t\t\t\t\t\t\t\t// Enqueue uncacheable module for determining the exports\r\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\r\n\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\r\n\t\t\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\r\n\t\t\t\t\t\t\t\tconst memCacheValue = memCache && memCache.get(this);\r\n\t\t\t\t\t\t\t\tif (memCacheValue !== undefined) {\r\n\t\t\t\t\t\t\t\t\tstatRestoredFromMemCache++;\r\n\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(memCacheValue);\r\n\t\t\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcache.get(\r\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\r\n\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\r\n\t\t\t\t\t\t\t\t\t(err, result) => {\r\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (result !== undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache++;\r\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(result);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tstatNotCached++;\r\n\t\t\t\t\t\t\t\t\t\t\t// Without cached info enqueue module for determining the exports\r\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\r\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcallback();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\terr => {\r\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"restore cached provided exports\");\r\n\t\t\t\t\t\t\t\tif (err) return callback(err);\r\n\r\n\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\r\n\t\t\t\t\t\t\t\tconst modulesToStore = new Set();\r\n\r\n\t\t\t\t\t\t\t\t/** @type {Map<Module, Set<Module>>} */\r\n\t\t\t\t\t\t\t\tconst dependencies = new Map();\r\n\r\n\t\t\t\t\t\t\t\t/** @type {Module} */\r\n\t\t\t\t\t\t\t\tlet module;\r\n\r\n\t\t\t\t\t\t\t\t/** @type {ExportsInfo} */\r\n\t\t\t\t\t\t\t\tlet exportsInfo;\r\n\r\n\t\t\t\t\t\t\t\t/** @type {Map<Dependency, ExportsSpec>} */\r\n\t\t\t\t\t\t\t\tconst exportsSpecsFromDependencies = new Map();\r\n\r\n\t\t\t\t\t\t\t\tlet cacheable = true;\r\n\t\t\t\t\t\t\t\tlet changed = false;\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * @param {DependenciesBlock} depBlock the dependencies block\r\n\t\t\t\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\tconst processDependenciesBlock = depBlock => {\r\n\t\t\t\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\r\n\t\t\t\t\t\t\t\t\t\tprocessDependency(dep);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tfor (const block of depBlock.blocks) {\r\n\t\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(block);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * @param {Dependency} dep the dependency\r\n\t\t\t\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\tconst processDependency = dep => {\r\n\t\t\t\t\t\t\t\t\tconst exportDesc = dep.getExports(moduleGraph);\r\n\t\t\t\t\t\t\t\t\tif (!exportDesc) return;\r\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.set(dep, exportDesc);\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * @param {Dependency} dep dependency\r\n\t\t\t\t\t\t\t\t * @param {ExportsSpec} exportDesc info\r\n\t\t\t\t\t\t\t\t * @returns {void}\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\tconst processExportsSpec = (dep, exportDesc) => {\r\n\t\t\t\t\t\t\t\t\tconst exports = exportDesc.exports;\r\n\t\t\t\t\t\t\t\t\tconst globalCanMangle = exportDesc.canMangle;\r\n\t\t\t\t\t\t\t\t\tconst globalFrom = exportDesc.from;\r\n\t\t\t\t\t\t\t\t\tconst globalPriority = exportDesc.priority;\r\n\t\t\t\t\t\t\t\t\tconst globalTerminalBinding =\r\n\t\t\t\t\t\t\t\t\t\texportDesc.terminalBinding || false;\r\n\t\t\t\t\t\t\t\t\tconst exportDeps = exportDesc.dependencies;\r\n\t\t\t\t\t\t\t\t\tif (exportDesc.hideExports) {\r\n\t\t\t\t\t\t\t\t\t\tfor (const name of exportDesc.hideExports) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\r\n\t\t\t\t\t\t\t\t\t\t\texportInfo.unsetTarget(dep);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (exports === true) {\r\n\t\t\t\t\t\t\t\t\t\t// unknown exports\r\n\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided(\r\n\t\t\t\t\t\t\t\t\t\t\t\tglobalCanMangle,\r\n\t\t\t\t\t\t\t\t\t\t\t\texportDesc.excludeExports,\r\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom && dep,\r\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom,\r\n\t\t\t\t\t\t\t\t\t\t\t\tglobalPriority\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else if (Array.isArray(exports)) {\r\n\t\t\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t\t\t * merge in new exports\r\n\t\t\t\t\t\t\t\t\t\t * @param {ExportsInfo} exportsInfo own exports info\r\n\t\t\t\t\t\t\t\t\t\t * @param {(ExportSpec | string)[]} exports list of exports\r\n\t\t\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t\t\tconst mergeExports = (exportsInfo, exports) => {\r\n\t\t\t\t\t\t\t\t\t\t\tfor (const exportNameOrSpec of exports) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet name;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet canMangle = globalCanMangle;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet terminalBinding = globalTerminalBinding;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet exports = undefined;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet from = globalFrom;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet fromExport = undefined;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet priority = globalPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet hidden = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof exportNameOrSpec === \"string\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec;\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec.name;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.canMangle !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle = exportNameOrSpec.canMangle;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.export !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport = exportNameOrSpec.export;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.exports !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texports = exportNameOrSpec.exports;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.from !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom = exportNameOrSpec.from;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.priority !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority = exportNameOrSpec.priority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.terminalBinding !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tterminalBinding = exportNameOrSpec.terminalBinding;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.hidden !== undefined)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thidden = exportNameOrSpec.hidden;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === false ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === null\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide !== false &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle === false\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (terminalBinding && !exportInfo.terminalBinding) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.terminalBinding = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (exports) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst nestedExportsInfo =\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.createNestedExportsInfo();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmergeExports(nestedExportsInfo, exports);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfrom &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(hidden\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? exportInfo.unsetTarget(dep)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfo.setTarget(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport === undefined ? [name] : fromExport,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ))\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Recalculate target exportsInfo\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(moduleGraph);\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet targetExportsInfo = undefined;\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (target) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst targetModuleExportsInfo =\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(target.module);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo =\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModuleExportsInfo.getNestedExportsInfo(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(target.module);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(target.module, new Set([module]));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportInfo.exportsInfoOwned) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo.setRedirectNamedTo(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo !== targetExportsInfo\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo = targetExportsInfo;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\tmergeExports(exportsInfo, exports);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// store dependencies\r\n\t\t\t\t\t\t\t\t\tif (exportDeps) {\r\n\t\t\t\t\t\t\t\t\t\tcacheable = false;\r\n\t\t\t\t\t\t\t\t\t\tfor (const exportDependency of exportDeps) {\r\n\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\r\n\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(exportDependency);\r\n\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(exportDependency, new Set([module]));\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\tconst notifyDependencies = () => {\r\n\t\t\t\t\t\t\t\t\tconst deps = dependencies.get(module);\r\n\t\t\t\t\t\t\t\t\tif (deps !== undefined) {\r\n\t\t\t\t\t\t\t\t\t\tfor (const dep of deps) {\r\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\tlogger.time(\"figure out provided exports\");\r\n\t\t\t\t\t\t\t\twhile (queue.length > 0) {\r\n\t\t\t\t\t\t\t\t\tmodule = queue.dequeue();\r\n\r\n\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed++;\r\n\r\n\t\t\t\t\t\t\t\t\texportsInfo = moduleGraph.getExportsInfo(module);\r\n\r\n\t\t\t\t\t\t\t\t\tcacheable = true;\r\n\t\t\t\t\t\t\t\t\tchanged = false;\r\n\r\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.clear();\r\n\t\t\t\t\t\t\t\t\tmoduleGraph.freeze();\r\n\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(module);\r\n\t\t\t\t\t\t\t\t\tmoduleGraph.unfreeze();\r\n\t\t\t\t\t\t\t\t\tfor (const [\r\n\t\t\t\t\t\t\t\t\t\tdep,\r\n\t\t\t\t\t\t\t\t\t\texportsSpec\r\n\t\t\t\t\t\t\t\t\t] of exportsSpecsFromDependencies) {\r\n\t\t\t\t\t\t\t\t\t\tprocessExportsSpec(dep, exportsSpec);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif (cacheable) {\r\n\t\t\t\t\t\t\t\t\t\tmodulesToStore.add(module);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif (changed) {\r\n\t\t\t\t\t\t\t\t\t\tnotifyDependencies();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"figure out provided exports\");\r\n\r\n\t\t\t\t\t\t\t\tlogger.log(\r\n\t\t\t\t\t\t\t\t\t`${Math.round(\r\n\t\t\t\t\t\t\t\t\t\t(100 * (statFlaggedUncached + statNotCached)) /\r\n\t\t\t\t\t\t\t\t\t\t\t(statRestoredFromMemCache +\r\n\t\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache +\r\n\t\t\t\t\t\t\t\t\t\t\t\tstatNotCached +\r\n\t\t\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached +\r\n\t\t\t\t\t\t\t\t\t\t\t\tstatNoExports)\r\n\t\t\t\t\t\t\t\t\t)}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${\r\n\t\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed -\r\n\t\t\t\t\t\t\t\t\t\tstatNotCached -\r\n\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached\r\n\t\t\t\t\t\t\t\t\t} additional calculations due to dependencies)`\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tlogger.time(\"store provided exports into cache\");\r\n\t\t\t\t\t\t\t\tasyncLib.each(\r\n\t\t\t\t\t\t\t\t\tmodulesToStore,\r\n\t\t\t\t\t\t\t\t\t(module, callback) => {\r\n\t\t\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\r\n\t\t\t\t\t\t\t\t\t\t\t// not cacheable\r\n\t\t\t\t\t\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tconst cachedData = moduleGraph\r\n\t\t\t\t\t\t\t\t\t\t\t.getExportsInfo(module)\r\n\t\t\t\t\t\t\t\t\t\t\t.getRestoreProvidedData();\r\n\t\t\t\t\t\t\t\t\t\tconst memCache =\r\n\t\t\t\t\t\t\t\t\t\t\tmoduleMemCaches && moduleMemCaches.get(module);\r\n\t\t\t\t\t\t\t\t\t\tif (memCache) {\r\n\t\t\t\t\t\t\t\t\t\t\tmemCache.set(this, cachedData);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcache.store(\r\n\t\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\r\n\t\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\r\n\t\t\t\t\t\t\t\t\t\t\tcachedData,\r\n\t\t\t\t\t\t\t\t\t\t\tcallback\r\n\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\terr => {\r\n\t\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"store provided exports into cache\");\r\n\t\t\t\t\t\t\t\t\t\tcallback(err);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\r\n\t\t\t\t/** @type {WeakMap<Module, any>} */\r\n\t\t\t\tconst providedExportsCache = new WeakMap();\r\n\t\t\t\tcompilation.hooks.rebuildModule.tap(\r\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\r\n\t\t\t\t\tmodule => {\r\n\t\t\t\t\t\tprovidedExportsCache.set(\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(module).getRestoreProvidedData()\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\tcompilation.hooks.finishRebuildingModule.tap(\r\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\r\n\t\t\t\t\tmodule => {\r\n\t\t\t\t\t\tmoduleGraph\r\n\t\t\t\t\t\t\t.getExportsInfo(module)\r\n\t\t\t\t\t\t\t.restoreProvided(providedExportsCache.get(module));\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = FlagDependencyExportsPlugin;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AACrC,MAAMC,KAAK,GAAGD,OAAO,CAAC,cAAc,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,2BAA2B,CAAC;EACjC;AACD;AACA;AACA;AACA;EACCC,KAAK,CAACC,QAAQ,EAAE;IACfA,QAAQ,CAACC,KAAK,CAACC,WAAW,CAACC,GAAG,CAC7B,6BAA6B,EAC7BD,WAAW,IAAI;MACd,MAAME,WAAW,GAAGF,WAAW,CAACE,WAAW;MAC3C,MAAMC,KAAK,GAAGH,WAAW,CAACI,QAAQ,CAAC,6BAA6B,CAAC;MACjEJ,WAAW,CAACD,KAAK,CAACM,aAAa,CAACC,QAAQ,CACvC,6BAA6B,EAC7B,CAACC,OAAO,EAAEC,QAAQ,KAAK;QACtB,MAAMC,MAAM,GAAGT,WAAW,CAACU,SAAS,CACnC,qCAAqC,CACrC;QACD,IAAIC,wBAAwB,GAAG,CAAC;QAChC,IAAIC,qBAAqB,GAAG,CAAC;QAC7B,IAAIC,aAAa,GAAG,CAAC;QACrB,IAAIC,mBAAmB,GAAG,CAAC;QAC3B,IAAIC,aAAa,GAAG,CAAC;QACrB,IAAIC,uBAAuB,GAAG,CAAC;QAE/B,MAAM;UAAEC;QAAgB,CAAC,GAAGjB,WAAW;;QAEvC;QACA,MAAMkB,KAAK,GAAG,IAAIvB,KAAK,EAAE;;QAEzB;QACAc,MAAM,CAACU,IAAI,CAAC,iCAAiC,CAAC;QAC9C1B,QAAQ,CAAC2B,IAAI,CACZb,OAAO,EACP,CAACc,MAAM,EAAEb,QAAQ,KAAK;UACrB,MAAMc,WAAW,GAAGpB,WAAW,CAACqB,cAAc,CAACF,MAAM,CAAC;UACtD,IAAI,CAACA,MAAM,CAACG,SAAS,IAAI,CAACH,MAAM,CAACG,SAAS,CAACC,WAAW,EAAE;YACvD,IAAIH,WAAW,CAACI,gBAAgB,CAACC,QAAQ,KAAK,IAAI,EAAE;cACnD;cACAd,aAAa,EAAE;cACfS,WAAW,CAACM,iBAAiB,EAAE;cAC/BN,WAAW,CAACO,yBAAyB,EAAE;cACvC,OAAOrB,QAAQ,EAAE;YAClB;UACD;UACA,IAAI,OAAOa,MAAM,CAACS,SAAS,CAACC,IAAI,KAAK,QAAQ,EAAE;YAC9CjB,mBAAmB,EAAE;YACrB;YACAI,KAAK,CAACc,OAAO,CAACX,MAAM,CAAC;YACrBC,WAAW,CAACM,iBAAiB,EAAE;YAC/B,OAAOpB,QAAQ,EAAE;UAClB;UACA,MAAMyB,QAAQ,GAAGhB,eAAe,IAAIA,eAAe,CAACiB,GAAG,CAACb,MAAM,CAAC;UAC/D,MAAMc,aAAa,GAAGF,QAAQ,IAAIA,QAAQ,CAACC,GAAG,CAAC,IAAI,CAAC;UACpD,IAAIC,aAAa,KAAKC,SAAS,EAAE;YAChCzB,wBAAwB,EAAE;YAC1BW,WAAW,CAACe,eAAe,CAACF,aAAa,CAAC;YAC1C,OAAO3B,QAAQ,EAAE;UAClB;UACAL,KAAK,CAAC+B,GAAG,CACRb,MAAM,CAACiB,UAAU,EAAE,EACnBjB,MAAM,CAACS,SAAS,CAACC,IAAI,EACrB,CAACQ,GAAG,EAAEC,MAAM,KAAK;YAChB,IAAID,GAAG,EAAE,OAAO/B,QAAQ,CAAC+B,GAAG,CAAC;YAE7B,IAAIC,MAAM,KAAKJ,SAAS,EAAE;cACzBxB,qBAAqB,EAAE;cACvBU,WAAW,CAACe,eAAe,CAACG,MAAM,CAAC;YACpC,CAAC,MAAM;cACNzB,aAAa,EAAE;cACf;cACAG,KAAK,CAACc,OAAO,CAACX,MAAM,CAAC;cACrBC,WAAW,CAACM,iBAAiB,EAAE;YAChC;YACApB,QAAQ,EAAE;UACX,CAAC,CACD;QACF,CAAC,EACD+B,GAAG,IAAI;UACN9B,MAAM,CAACgC,OAAO,CAAC,iCAAiC,CAAC;UACjD,IAAIF,GAAG,EAAE,OAAO/B,QAAQ,CAAC+B,GAAG,CAAC;;UAE7B;UACA,MAAMG,cAAc,GAAG,IAAIC,GAAG,EAAE;;UAEhC;UACA,MAAMC,YAAY,GAAG,IAAIC,GAAG,EAAE;;UAE9B;UACA,IAAIxB,MAAM;;UAEV;UACA,IAAIC,WAAW;;UAEf;UACA,MAAMwB,4BAA4B,GAAG,IAAID,GAAG,EAAE;UAE9C,IAAIE,SAAS,GAAG,IAAI;UACpB,IAAIC,OAAO,GAAG,KAAK;;UAEnB;AACR;AACA;AACA;UACQ,MAAMC,wBAAwB,GAAGC,QAAQ,IAAI;YAC5C,KAAK,MAAMC,GAAG,IAAID,QAAQ,CAACN,YAAY,EAAE;cACxCQ,iBAAiB,CAACD,GAAG,CAAC;YACvB;YACA,KAAK,MAAME,KAAK,IAAIH,QAAQ,CAACI,MAAM,EAAE;cACpCL,wBAAwB,CAACI,KAAK,CAAC;YAChC;UACD,CAAC;;UAED;AACR;AACA;AACA;UACQ,MAAMD,iBAAiB,GAAGD,GAAG,IAAI;YAChC,MAAMI,UAAU,GAAGJ,GAAG,CAACK,UAAU,CAACtD,WAAW,CAAC;YAC9C,IAAI,CAACqD,UAAU,EAAE;YACjBT,4BAA4B,CAACW,GAAG,CAACN,GAAG,EAAEI,UAAU,CAAC;UAClD,CAAC;;UAED;AACR;AACA;AACA;AACA;UACQ,MAAMG,kBAAkB,GAAG,CAACP,GAAG,EAAEI,UAAU,KAAK;YAC/C,MAAMI,OAAO,GAAGJ,UAAU,CAACI,OAAO;YAClC,MAAMC,eAAe,GAAGL,UAAU,CAACM,SAAS;YAC5C,MAAMC,UAAU,GAAGP,UAAU,CAACQ,IAAI;YAClC,MAAMC,cAAc,GAAGT,UAAU,CAACU,QAAQ;YAC1C,MAAMC,qBAAqB,GAC1BX,UAAU,CAACY,eAAe,IAAI,KAAK;YACpC,MAAMC,UAAU,GAAGb,UAAU,CAACX,YAAY;YAC1C,IAAIW,UAAU,CAACc,WAAW,EAAE;cAC3B,KAAK,MAAMC,IAAI,IAAIf,UAAU,CAACc,WAAW,EAAE;gBAC1C,MAAME,UAAU,GAAGjD,WAAW,CAACkD,aAAa,CAACF,IAAI,CAAC;gBAClDC,UAAU,CAACE,WAAW,CAACtB,GAAG,CAAC;cAC5B;YACD;YACA,IAAIQ,OAAO,KAAK,IAAI,EAAE;cACrB;cACA,IACCrC,WAAW,CAACO,yBAAyB,CACpC+B,eAAe,EACfL,UAAU,CAACmB,cAAc,EACzBZ,UAAU,IAAIX,GAAG,EACjBW,UAAU,EACVE,cAAc,CACd,EACA;gBACDhB,OAAO,GAAG,IAAI;cACf;YACD,CAAC,MAAM,IAAI2B,KAAK,CAACC,OAAO,CAACjB,OAAO,CAAC,EAAE;cAClC;AACV;AACA;AACA;AACA;cACU,MAAMkB,YAAY,GAAG,CAACvD,WAAW,EAAEqC,OAAO,KAAK;gBAC9C,KAAK,MAAMmB,gBAAgB,IAAInB,OAAO,EAAE;kBACvC,IAAIW,IAAI;kBACR,IAAIT,SAAS,GAAGD,eAAe;kBAC/B,IAAIO,eAAe,GAAGD,qBAAqB;kBAC3C,IAAIP,OAAO,GAAGvB,SAAS;kBACvB,IAAI2B,IAAI,GAAGD,UAAU;kBACrB,IAAIiB,UAAU,GAAG3C,SAAS;kBAC1B,IAAI6B,QAAQ,GAAGD,cAAc;kBAC7B,IAAIgB,MAAM,GAAG,KAAK;kBAClB,IAAI,OAAOF,gBAAgB,KAAK,QAAQ,EAAE;oBACzCR,IAAI,GAAGQ,gBAAgB;kBACxB,CAAC,MAAM;oBACNR,IAAI,GAAGQ,gBAAgB,CAACR,IAAI;oBAC5B,IAAIQ,gBAAgB,CAACjB,SAAS,KAAKzB,SAAS,EAC3CyB,SAAS,GAAGiB,gBAAgB,CAACjB,SAAS;oBACvC,IAAIiB,gBAAgB,CAACG,MAAM,KAAK7C,SAAS,EACxC2C,UAAU,GAAGD,gBAAgB,CAACG,MAAM;oBACrC,IAAIH,gBAAgB,CAACnB,OAAO,KAAKvB,SAAS,EACzCuB,OAAO,GAAGmB,gBAAgB,CAACnB,OAAO;oBACnC,IAAImB,gBAAgB,CAACf,IAAI,KAAK3B,SAAS,EACtC2B,IAAI,GAAGe,gBAAgB,CAACf,IAAI;oBAC7B,IAAIe,gBAAgB,CAACb,QAAQ,KAAK7B,SAAS,EAC1C6B,QAAQ,GAAGa,gBAAgB,CAACb,QAAQ;oBACrC,IAAIa,gBAAgB,CAACX,eAAe,KAAK/B,SAAS,EACjD+B,eAAe,GAAGW,gBAAgB,CAACX,eAAe;oBACnD,IAAIW,gBAAgB,CAACE,MAAM,KAAK5C,SAAS,EACxC4C,MAAM,GAAGF,gBAAgB,CAACE,MAAM;kBAClC;kBACA,MAAMT,UAAU,GAAGjD,WAAW,CAACkD,aAAa,CAACF,IAAI,CAAC;kBAElD,IACCC,UAAU,CAAC5C,QAAQ,KAAK,KAAK,IAC7B4C,UAAU,CAAC5C,QAAQ,KAAK,IAAI,EAC3B;oBACD4C,UAAU,CAAC5C,QAAQ,GAAG,IAAI;oBAC1BqB,OAAO,GAAG,IAAI;kBACf;kBAEA,IACCuB,UAAU,CAACW,gBAAgB,KAAK,KAAK,IACrCrB,SAAS,KAAK,KAAK,EAClB;oBACDU,UAAU,CAACW,gBAAgB,GAAG,KAAK;oBACnClC,OAAO,GAAG,IAAI;kBACf;kBAEA,IAAImB,eAAe,IAAI,CAACI,UAAU,CAACJ,eAAe,EAAE;oBACnDI,UAAU,CAACJ,eAAe,GAAG,IAAI;oBACjCnB,OAAO,GAAG,IAAI;kBACf;kBAEA,IAAIW,OAAO,EAAE;oBACZ,MAAMwB,iBAAiB,GACtBZ,UAAU,CAACa,uBAAuB,EAAE;oBACrCP,YAAY,CAACM,iBAAiB,EAAExB,OAAO,CAAC;kBACzC;kBAEA,IACCI,IAAI,KACHiB,MAAM,GACJT,UAAU,CAACE,WAAW,CAACtB,GAAG,CAAC,GAC3BoB,UAAU,CAACc,SAAS,CACpBlC,GAAG,EACHY,IAAI,EACJgB,UAAU,KAAK3C,SAAS,GAAG,CAACkC,IAAI,CAAC,GAAGS,UAAU,EAC9Cd,QAAQ,CACP,CAAC,EACJ;oBACDjB,OAAO,GAAG,IAAI;kBACf;;kBAEA;kBACA,MAAMsC,MAAM,GAAGf,UAAU,CAACgB,SAAS,CAACrF,WAAW,CAAC;kBAChD,IAAIsF,iBAAiB,GAAGpD,SAAS;kBACjC,IAAIkD,MAAM,EAAE;oBACX,MAAMG,uBAAuB,GAC5BvF,WAAW,CAACqB,cAAc,CAAC+D,MAAM,CAACjE,MAAM,CAAC;oBAC1CmE,iBAAiB,GAChBC,uBAAuB,CAACC,oBAAoB,CAC3CJ,MAAM,CAACL,MAAM,CACb;oBACF;oBACA,MAAMxB,GAAG,GAAGb,YAAY,CAACV,GAAG,CAACoD,MAAM,CAACjE,MAAM,CAAC;oBAC3C,IAAIoC,GAAG,KAAKrB,SAAS,EAAE;sBACtBQ,YAAY,CAACa,GAAG,CAAC6B,MAAM,CAACjE,MAAM,EAAE,IAAIsB,GAAG,CAAC,CAACtB,MAAM,CAAC,CAAC,CAAC;oBACnD,CAAC,MAAM;sBACNoC,GAAG,CAACkC,GAAG,CAACtE,MAAM,CAAC;oBAChB;kBACD;kBAEA,IAAIkD,UAAU,CAACqB,gBAAgB,EAAE;oBAChC,IACCrB,UAAU,CAACjD,WAAW,CAACuE,kBAAkB,CACxCL,iBAAiB,CACjB,EACA;sBACDxC,OAAO,GAAG,IAAI;oBACf;kBACD,CAAC,MAAM,IACNuB,UAAU,CAACjD,WAAW,KAAKkE,iBAAiB,EAC3C;oBACDjB,UAAU,CAACjD,WAAW,GAAGkE,iBAAiB;oBAC1CxC,OAAO,GAAG,IAAI;kBACf;gBACD;cACD,CAAC;cACD6B,YAAY,CAACvD,WAAW,EAAEqC,OAAO,CAAC;YACnC;YACA;YACA,IAAIS,UAAU,EAAE;cACfrB,SAAS,GAAG,KAAK;cACjB,KAAK,MAAM+C,gBAAgB,IAAI1B,UAAU,EAAE;gBAC1C;gBACA,MAAMX,GAAG,GAAGb,YAAY,CAACV,GAAG,CAAC4D,gBAAgB,CAAC;gBAC9C,IAAIrC,GAAG,KAAKrB,SAAS,EAAE;kBACtBQ,YAAY,CAACa,GAAG,CAACqC,gBAAgB,EAAE,IAAInD,GAAG,CAAC,CAACtB,MAAM,CAAC,CAAC,CAAC;gBACtD,CAAC,MAAM;kBACNoC,GAAG,CAACkC,GAAG,CAACtE,MAAM,CAAC;gBAChB;cACD;YACD;UACD,CAAC;UAED,MAAM0E,kBAAkB,GAAG,MAAM;YAChC,MAAMC,IAAI,GAAGpD,YAAY,CAACV,GAAG,CAACb,MAAM,CAAC;YACrC,IAAI2E,IAAI,KAAK5D,SAAS,EAAE;cACvB,KAAK,MAAMe,GAAG,IAAI6C,IAAI,EAAE;gBACvB9E,KAAK,CAACc,OAAO,CAACmB,GAAG,CAAC;cACnB;YACD;UACD,CAAC;UAED1C,MAAM,CAACU,IAAI,CAAC,6BAA6B,CAAC;UAC1C,OAAOD,KAAK,CAAC+E,MAAM,GAAG,CAAC,EAAE;YACxB5E,MAAM,GAAGH,KAAK,CAACgF,OAAO,EAAE;YAExBlF,uBAAuB,EAAE;YAEzBM,WAAW,GAAGpB,WAAW,CAACqB,cAAc,CAACF,MAAM,CAAC;YAEhD0B,SAAS,GAAG,IAAI;YAChBC,OAAO,GAAG,KAAK;YAEfF,4BAA4B,CAACqD,KAAK,EAAE;YACpCjG,WAAW,CAACkG,MAAM,EAAE;YACpBnD,wBAAwB,CAAC5B,MAAM,CAAC;YAChCnB,WAAW,CAACmG,QAAQ,EAAE;YACtB,KAAK,MAAM,CACVlD,GAAG,EACHmD,WAAW,CACX,IAAIxD,4BAA4B,EAAE;cAClCY,kBAAkB,CAACP,GAAG,EAAEmD,WAAW,CAAC;YACrC;YAEA,IAAIvD,SAAS,EAAE;cACdL,cAAc,CAACiD,GAAG,CAACtE,MAAM,CAAC;YAC3B;YAEA,IAAI2B,OAAO,EAAE;cACZ+C,kBAAkB,EAAE;YACrB;UACD;UACAtF,MAAM,CAACgC,OAAO,CAAC,6BAA6B,CAAC;UAE7ChC,MAAM,CAAC8F,GAAG,CACR,GAAEC,IAAI,CAACC,KAAK,CACX,GAAG,IAAI3F,mBAAmB,GAAGC,aAAa,CAAC,IAC1CJ,wBAAwB,GACxBC,qBAAqB,GACrBG,aAAa,GACbD,mBAAmB,GACnBD,aAAa,CAAC,CACf,iDAAgDA,aAAc,yBAAwBE,aAAc,gBAAeD,mBAAoB,yBAAwBF,qBAAsB,gBAAeD,wBAAyB,oBAC9NK,uBAAuB,GACvBD,aAAa,GACbD,mBACA,+CAA8C,CAC/C;UAEDL,MAAM,CAACU,IAAI,CAAC,mCAAmC,CAAC;UAChD1B,QAAQ,CAAC2B,IAAI,CACZsB,cAAc,EACd,CAACrB,MAAM,EAAEb,QAAQ,KAAK;YACrB,IAAI,OAAOa,MAAM,CAACS,SAAS,CAACC,IAAI,KAAK,QAAQ,EAAE;cAC9C;cACA,OAAOvB,QAAQ,EAAE;YAClB;YACA,MAAMkG,UAAU,GAAGxG,WAAW,CAC5BqB,cAAc,CAACF,MAAM,CAAC,CACtBsF,sBAAsB,EAAE;YAC1B,MAAM1E,QAAQ,GACbhB,eAAe,IAAIA,eAAe,CAACiB,GAAG,CAACb,MAAM,CAAC;YAC/C,IAAIY,QAAQ,EAAE;cACbA,QAAQ,CAACwB,GAAG,CAAC,IAAI,EAAEiD,UAAU,CAAC;YAC/B;YACAvG,KAAK,CAACyG,KAAK,CACVvF,MAAM,CAACiB,UAAU,EAAE,EACnBjB,MAAM,CAACS,SAAS,CAACC,IAAI,EACrB2E,UAAU,EACVlG,QAAQ,CACR;UACF,CAAC,EACD+B,GAAG,IAAI;YACN9B,MAAM,CAACgC,OAAO,CAAC,mCAAmC,CAAC;YACnDjC,QAAQ,CAAC+B,GAAG,CAAC;UACd,CAAC,CACD;QACF,CAAC,CACD;MACF,CAAC,CACD;;MAED;MACA,MAAMsE,oBAAoB,GAAG,IAAIC,OAAO,EAAE;MAC1C9G,WAAW,CAACD,KAAK,CAACgH,aAAa,CAAC9G,GAAG,CAClC,6BAA6B,EAC7BoB,MAAM,IAAI;QACTwF,oBAAoB,CAACpD,GAAG,CACvBpC,MAAM,EACNnB,WAAW,CAACqB,cAAc,CAACF,MAAM,CAAC,CAACsF,sBAAsB,EAAE,CAC3D;MACF,CAAC,CACD;MACD3G,WAAW,CAACD,KAAK,CAACiH,sBAAsB,CAAC/G,GAAG,CAC3C,6BAA6B,EAC7BoB,MAAM,IAAI;QACTnB,WAAW,CACTqB,cAAc,CAACF,MAAM,CAAC,CACtBgB,eAAe,CAACwE,oBAAoB,CAAC3E,GAAG,CAACb,MAAM,CAAC,CAAC;MACpD,CAAC,CACD;IACF,CAAC,CACD;EACF;AACD;AAEAA,MAAM,CAACsC,OAAO,GAAG/D,2BAA2B"},"metadata":{},"sourceType":"script","externalDependencies":[]}