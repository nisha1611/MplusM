{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultRateLimiter = void 0;\nconst service_error_classification_1 = require(\"@aws-sdk/service-error-classification\");\nclass DefaultRateLimiter {\n  constructor(options) {\n    var _a, _b, _c, _d, _e;\n    this.currentCapacity = 0;\n    this.enabled = false;\n    this.lastMaxRate = 0;\n    this.measuredTxRate = 0;\n    this.requestCount = 0;\n    this.lastTimestamp = 0;\n    this.timeWindow = 0;\n    this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;\n    this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;\n    this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;\n    this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;\n    this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;\n    const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n  getCurrentTimeInSeconds() {\n    return Date.now() / 1000;\n  }\n  async getSendToken() {\n    return this.acquireTokenBucket(1);\n  }\n  async acquireTokenBucket(amount) {\n    if (!this.enabled) {\n      return;\n    }\n    this.refillTokenBucket();\n    if (amount > this.currentCapacity) {\n      const delay = (amount - this.currentCapacity) / this.fillRate * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    this.currentCapacity = this.currentCapacity - amount;\n  }\n  refillTokenBucket() {\n    const timestamp = this.getCurrentTimeInSeconds();\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  }\n  updateClientSendingRate(response) {\n    let calculatedRate;\n    this.updateMeasuredRate();\n    if ((0, service_error_classification_1.isThrottlingError)(response)) {\n      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  }\n  calculateTimeWindow() {\n    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n  }\n  cubicThrottle(rateToUse) {\n    return this.getPrecise(rateToUse * this.beta);\n  }\n  cubicSuccess(timestamp) {\n    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n  }\n  enableTokenBucket() {\n    this.enabled = true;\n  }\n  updateTokenBucketRate(newRate) {\n    this.refillTokenBucket();\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity);\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  }\n  updateMeasuredRate() {\n    const t = this.getCurrentTimeInSeconds();\n    const timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n    if (timeBucket > this.lastTxRateBucket) {\n      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  }\n  getPrecise(num) {\n    return parseFloat(num.toFixed(8));\n  }\n}\nexports.DefaultRateLimiter = DefaultRateLimiter;","map":{"version":3,"names":["Object","defineProperty","exports","value","DefaultRateLimiter","service_error_classification_1","require","constructor","options","_a","_b","_c","_d","_e","currentCapacity","enabled","lastMaxRate","measuredTxRate","requestCount","lastTimestamp","timeWindow","beta","minCapacity","minFillRate","scaleConstant","smooth","currentTimeInSeconds","getCurrentTimeInSeconds","lastThrottleTime","lastTxRateBucket","Math","floor","fillRate","maxCapacity","Date","now","getSendToken","acquireTokenBucket","amount","refillTokenBucket","delay","Promise","resolve","setTimeout","timestamp","fillAmount","min","updateClientSendingRate","response","calculatedRate","updateMeasuredRate","isThrottlingError","rateToUse","calculateTimeWindow","cubicThrottle","enableTokenBucket","cubicSuccess","newRate","updateTokenBucketRate","getPrecise","pow","max","t","timeBucket","currentRate","num","parseFloat","toFixed"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/@aws-sdk/util-retry/dist-cjs/DefaultRateLimiter.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DefaultRateLimiter = void 0;\r\nconst service_error_classification_1 = require(\"@aws-sdk/service-error-classification\");\r\nclass DefaultRateLimiter {\r\n    constructor(options) {\r\n        var _a, _b, _c, _d, _e;\r\n        this.currentCapacity = 0;\r\n        this.enabled = false;\r\n        this.lastMaxRate = 0;\r\n        this.measuredTxRate = 0;\r\n        this.requestCount = 0;\r\n        this.lastTimestamp = 0;\r\n        this.timeWindow = 0;\r\n        this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;\r\n        this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;\r\n        this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;\r\n        this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;\r\n        this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;\r\n        const currentTimeInSeconds = this.getCurrentTimeInSeconds();\r\n        this.lastThrottleTime = currentTimeInSeconds;\r\n        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\r\n        this.fillRate = this.minFillRate;\r\n        this.maxCapacity = this.minCapacity;\r\n    }\r\n    getCurrentTimeInSeconds() {\r\n        return Date.now() / 1000;\r\n    }\r\n    async getSendToken() {\r\n        return this.acquireTokenBucket(1);\r\n    }\r\n    async acquireTokenBucket(amount) {\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n        this.refillTokenBucket();\r\n        if (amount > this.currentCapacity) {\r\n            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\r\n            await new Promise((resolve) => setTimeout(resolve, delay));\r\n        }\r\n        this.currentCapacity = this.currentCapacity - amount;\r\n    }\r\n    refillTokenBucket() {\r\n        const timestamp = this.getCurrentTimeInSeconds();\r\n        if (!this.lastTimestamp) {\r\n            this.lastTimestamp = timestamp;\r\n            return;\r\n        }\r\n        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\r\n        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\r\n        this.lastTimestamp = timestamp;\r\n    }\r\n    updateClientSendingRate(response) {\r\n        let calculatedRate;\r\n        this.updateMeasuredRate();\r\n        if ((0, service_error_classification_1.isThrottlingError)(response)) {\r\n            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\r\n            this.lastMaxRate = rateToUse;\r\n            this.calculateTimeWindow();\r\n            this.lastThrottleTime = this.getCurrentTimeInSeconds();\r\n            calculatedRate = this.cubicThrottle(rateToUse);\r\n            this.enableTokenBucket();\r\n        }\r\n        else {\r\n            this.calculateTimeWindow();\r\n            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\r\n        }\r\n        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\r\n        this.updateTokenBucketRate(newRate);\r\n    }\r\n    calculateTimeWindow() {\r\n        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\r\n    }\r\n    cubicThrottle(rateToUse) {\r\n        return this.getPrecise(rateToUse * this.beta);\r\n    }\r\n    cubicSuccess(timestamp) {\r\n        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\r\n    }\r\n    enableTokenBucket() {\r\n        this.enabled = true;\r\n    }\r\n    updateTokenBucketRate(newRate) {\r\n        this.refillTokenBucket();\r\n        this.fillRate = Math.max(newRate, this.minFillRate);\r\n        this.maxCapacity = Math.max(newRate, this.minCapacity);\r\n        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\r\n    }\r\n    updateMeasuredRate() {\r\n        const t = this.getCurrentTimeInSeconds();\r\n        const timeBucket = Math.floor(t * 2) / 2;\r\n        this.requestCount++;\r\n        if (timeBucket > this.lastTxRateBucket) {\r\n            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\r\n            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\r\n            this.requestCount = 0;\r\n            this.lastTxRateBucket = timeBucket;\r\n        }\r\n    }\r\n    getPrecise(num) {\r\n        return parseFloat(num.toFixed(8));\r\n    }\r\n}\r\nexports.DefaultRateLimiter = DefaultRateLimiter;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}