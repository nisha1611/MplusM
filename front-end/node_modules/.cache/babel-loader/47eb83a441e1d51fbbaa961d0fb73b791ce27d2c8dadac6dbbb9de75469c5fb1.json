{"ast":null,"code":"'use strict';\n\n/*!\r\n * Module dependencies\r\n */\nconst AggregationCursor = require('./cursor/AggregationCursor');\nconst Query = require('./query');\nconst {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n} = require('./helpers/query/applyGlobalOption');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst stringifyFunctionOperators = require('./helpers/aggregate/stringifyFunctionOperators');\nconst utils = require('./utils');\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n\n/**\r\n * Aggregate constructor used for building aggregation pipelines. Do not\r\n * instantiate this class directly, use [Model.aggregate()](/docs/api/model.html#model_Model-aggregate) instead.\r\n *\r\n * #### Example:\r\n *\r\n *     const aggregate = Model.aggregate([\r\n *       { $project: { a: 1, b: 1 } },\r\n *       { $skip: 5 }\r\n *     ]);\r\n *\r\n *     Model.\r\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\r\n *       unwind('tags').\r\n *       exec(callback);\r\n *\r\n * #### Note:\r\n *\r\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\r\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\r\n *\r\n *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\r\n *     // Do this instead to cast to an ObjectId\r\n *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\r\n *\r\n * @see MongoDB https://docs.mongodb.org/manual/applications/aggregation/\r\n * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate\r\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\r\n * @param {Model} [model] the model to use with this aggregate.\r\n * @api public\r\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\r\n * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).\r\n * Supported options are:\r\n *\r\n * - [`allowDiskUse`](./api/aggregate.html#aggregate_Aggregate-allowDiskUse)\r\n * - `bypassDocumentValidation`\r\n * - [`collation`](./api/aggregate.html#aggregate_Aggregate-collation)\r\n * - `comment`\r\n * - [`cursor`](./api/aggregate.html#aggregate_Aggregate-cursor)\r\n * - [`explain`](./api/aggregate.html#aggregate_Aggregate-explain)\r\n * - `fieldsAsRaw`\r\n * - `hint`\r\n * - `let`\r\n * - `maxTimeMS`\r\n * - `raw`\r\n * - `readConcern`\r\n * - `readPreference`\r\n * - [`session`](./api/aggregate.html#aggregate_Aggregate-session)\r\n * - `writeConcern`\r\n *\r\n * @property options\r\n * @memberOf Aggregate\r\n * @api public\r\n */\n\nAggregate.prototype.options;\n\n/**\r\n * Get/set the model that this aggregation will execute on.\r\n *\r\n * #### Example:\r\n *\r\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\r\n *     aggregate.model() === MyModel; // true\r\n *\r\n *     // Change the model. There's rarely any reason to do this.\r\n *     aggregate.model(SomeOtherModel);\r\n *     aggregate.model() === SomeOtherModel; // true\r\n *\r\n * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\r\n * @return {Model}\r\n * @api public\r\n */\n\nAggregate.prototype.model = function (model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null && model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null && model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n  return model;\n};\n\n/**\r\n * Appends new operators to this aggregate pipeline\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\r\n *\r\n *     // or pass an array\r\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\r\n *     aggregate.append(pipeline);\r\n *\r\n * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.append = function () {\n  const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [...arguments];\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n  this._pipeline = this._pipeline.concat(args);\n  return this;\n};\n\n/**\r\n * Appends a new $addFields operator to this aggregate pipeline.\r\n * Requires MongoDB v3.4+ to work\r\n *\r\n * #### Example:\r\n *\r\n *     // adding new fields based on existing fields\r\n *     aggregate.addFields({\r\n *         newField: '$b.nested'\r\n *       , plusTen: { $add: ['$val', 10]}\r\n *       , sub: {\r\n *            name: '$a'\r\n *         }\r\n *     })\r\n *\r\n *     // etc\r\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\r\n *\r\n * @param {Object} arg field specification\r\n * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/\r\n * @return {Aggregate}\r\n * @api public\r\n */\nAggregate.prototype.addFields = function (arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({\n    $addFields: Object.assign({}, arg)\n  });\n};\n\n/**\r\n * Appends a new $project operator to this aggregate pipeline.\r\n *\r\n * Mongoose query [selection syntax](#query_Query-select) is also supported.\r\n *\r\n * #### Example:\r\n *\r\n *     // include a, include b, exclude _id\r\n *     aggregate.project(\"a b -_id\");\r\n *\r\n *     // or you may use object notation, useful when\r\n *     // you have keys already prefixed with a \"-\"\r\n *     aggregate.project({a: 1, b: 1, _id: 0});\r\n *\r\n *     // reshaping documents\r\n *     aggregate.project({\r\n *         newField: '$b.nested'\r\n *       , plusTen: { $add: ['$val', 10]}\r\n *       , sub: {\r\n *            name: '$a'\r\n *         }\r\n *     })\r\n *\r\n *     // etc\r\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\r\n *\r\n * @param {Object|String} arg field specification\r\n * @see projection https://docs.mongodb.org/manual/reference/aggregation/project/\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.project = function (arg) {\n  const fields = {};\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function (field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n  return this.append({\n    $project: fields\n  });\n};\n\n/**\r\n * Appends a new custom $group operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.group({ _id: \"$department\" });\r\n *\r\n * @see $group https://docs.mongodb.org/manual/reference/aggregation/group/\r\n * @method group\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $group operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\n/**\r\n * Appends a new custom $match operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\r\n *\r\n * @see $match https://docs.mongodb.org/manual/reference/aggregation/match/\r\n * @method match\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $match operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\n/**\r\n * Appends a new $skip operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.skip(10);\r\n *\r\n * @see $skip https://docs.mongodb.org/manual/reference/aggregation/skip/\r\n * @method skip\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Number} num number of records to skip before next stage\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\n/**\r\n * Appends a new $limit operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.limit(10);\r\n *\r\n * @see $limit https://docs.mongodb.org/manual/reference/aggregation/limit/\r\n * @method limit\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Number} num maximum number of records to pass to the next stage\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\n/**\r\n * Appends a new $densify operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *      aggregate.densify({\r\n *        field: 'timestamp',\r\n *        range: {\r\n *          step: 1,\r\n *          unit: 'hour',\r\n *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\r\n *        }\r\n *      });\r\n *\r\n * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/\r\n * @method densify\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $densify operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\n/**\r\n * Appends a new $fill operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *      aggregate.fill({\r\n *        output: {\r\n *          bootsSold: { value: 0 },\r\n *          sandalsSold: { value: 0 },\r\n *          sneakersSold: { value: 0 }\r\n *        }\r\n *      });\r\n *\r\n * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/\r\n * @method fill\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $fill operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\n/**\r\n * Appends a new $geoNear operator to this aggregate pipeline.\r\n *\r\n * #### Note:\r\n *\r\n * **MUST** be used as the first operator in the pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.near({\r\n *       near: [40.724, -73.997],\r\n *       distanceField: \"dist.calculated\", // required\r\n *       maxDistance: 0.008,\r\n *       query: { type: \"public\" },\r\n *       includeLocs: \"dist.location\",\r\n *       uniqueDocs: true,\r\n *       num: 5\r\n *     });\r\n *\r\n * @see $geoNear https://docs.mongodb.org/manual/reference/aggregation/geoNear/\r\n * @method near\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.near = function (arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\r\n * define methods\r\n */\n\n'group match skip limit out densify fill'.split(' ').forEach(function ($operator) {\n  Aggregate.prototype[$operator] = function (arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\r\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\r\n *\r\n * Note that the `$unwind` operator requires the path name to start with '$'.\r\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.unwind(\"tags\");\r\n *     aggregate.unwind(\"a\", \"b\", \"c\");\r\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\r\n *\r\n * @see $unwind https://docs.mongodb.org/manual/reference/aggregation/unwind/\r\n * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.unwind = function () {\n  const args = [...arguments];\n  const res = [];\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({\n        $unwind: arg\n      });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: arg[0] === '$' ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' + 'must be string or object');\n    }\n  }\n  return this.append.apply(this, res);\n};\n\n/**\r\n * Appends a new $replaceRoot operator to this aggregate pipeline.\r\n *\r\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\r\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\r\n * If you are passing in an object the strings in your expression will not be altered.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.replaceRoot(\"user\");\r\n *\r\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\r\n *\r\n * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot\r\n * @param {String|Object} newRoot the field or document which will become the new root document\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.replaceRoot = function (newRoot) {\n  let ret;\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\r\n * Appends a new $count operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.count(\"userCount\");\r\n *\r\n * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count\r\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.count = function (fieldName) {\n  return this.append({\n    $count: fieldName\n  });\n};\n\n/**\r\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\r\n * or a pipeline object.\r\n *\r\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\r\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.sortByCount('users');\r\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\r\n *\r\n * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\r\n * @param {Object|String} arg\r\n * @return {Aggregate} this\r\n * @api public\r\n */\n\nAggregate.prototype.sortByCount = function (arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({\n      $sortByCount: arg\n    });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: arg[0] === '$' ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' + 'must be string or object');\n  }\n};\n\n/**\r\n * Appends new custom $lookup operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\r\n *\r\n * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\r\n * @param {Object} options to $lookup as described in the above link\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.lookup = function (options) {\n  return this.append({\n    $lookup: options\n  });\n};\n\n/**\r\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\r\n *\r\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\r\n *\r\n * #### Example:\r\n *\r\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\r\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\r\n *\r\n * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\r\n * @param {Object} options to $graphLookup as described in the above link\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.graphLookup = function (options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ? cloneOptions.startWith : '$' + cloneOptions.startWith;\n    }\n  }\n  return this.append({\n    $graphLookup: cloneOptions\n  });\n};\n\n/**\r\n * Appends new custom $sample operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\r\n *\r\n * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample\r\n * @param {Number} size number of random documents to pick\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.sample = function (size) {\n  return this.append({\n    $sample: {\n      size: size\n    }\n  });\n};\n\n/**\r\n * Appends a new $sort operator to this aggregate pipeline.\r\n *\r\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\r\n *\r\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\r\n *\r\n * #### Example:\r\n *\r\n *     // these are equivalent\r\n *     aggregate.sort({ field: 'asc', test: -1 });\r\n *     aggregate.sort('field -test');\r\n *\r\n * @see $sort https://docs.mongodb.org/manual/reference/aggregation/sort/\r\n * @param {Object|String} arg\r\n * @return {Aggregate} this\r\n * @api public\r\n */\n\nAggregate.prototype.sort = function (arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function (field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n  return this.append({\n    $sort: sort\n  });\n};\n\n/**\r\n * Appends new $unionWith operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\r\n *\r\n * @see $unionWith https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith\r\n * @param {Object} options to $unionWith query as described in the above link\r\n * @return {Aggregate}\r\n * @api public\r\n */\n\nAggregate.prototype.unionWith = function (options) {\n  return this.append({\n    $unionWith: options\n  });\n};\n\n/**\r\n * Sets the readPreference option for the aggregation query.\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate(pipeline).read('primaryPreferred');\r\n *\r\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\r\n * @param {Array} [tags] optional tags for this query. DEPRECATED\r\n * @return {Aggregate} this\r\n * @api public\r\n * @see mongodb https://docs.mongodb.org/manual/applications/replication/#read-preference\r\n */\n\nAggregate.prototype.read = function (pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\r\n * Sets the readConcern level for the aggregation query.\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate(pipeline).readConcern('majority');\r\n *\r\n * @param {String} level one of the listed read concern level or their aliases\r\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\r\n * @return {Aggregate} this\r\n * @api public\r\n */\n\nAggregate.prototype.readConcern = function (level) {\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\r\n * Appends a new $redact operator to this aggregate pipeline.\r\n *\r\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\r\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate(pipeline).redact({\r\n *       $cond: {\r\n *         if: { $eq: [ '$level', 5 ] },\r\n *         then: '$$PRUNE',\r\n *         else: '$$DESCEND'\r\n *       }\r\n *     });\r\n *\r\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\r\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\r\n *\r\n * @param {Object} expression redact options or conditional expression\r\n * @param {String|Object} [thenExpr] true case for the condition\r\n * @param {String|Object} [elseExpr] false case for the condition\r\n * @return {Aggregate} this\r\n * @see $redact https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\r\n * @api public\r\n */\n\nAggregate.prototype.redact = function (expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if (typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr) || typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr)) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n  return this.append({\n    $redact: expression\n  });\n};\n\n/**\r\n * Execute the aggregation with explain\r\n *\r\n * #### Example:\r\n *\r\n *     Model.aggregate(..).explain(callback)\r\n *\r\n * @param {String} [verbosity]\r\n * @param {Function} [callback] The callback function to call, if not specified, will return a Promise instead.\r\n * @return {Promise} Returns a promise if no \"callback\" is given\r\n */\n\nAggregate.prototype.explain = function (verbosity, callback) {\n  const model = this._model;\n  if (typeof verbosity === 'function') {\n    callback = verbosity;\n    verbosity = null;\n  }\n  return promiseOrCallback(callback, cb => {\n    if (!this._pipeline.length) {\n      const err = new Error('Aggregate has empty pipeline');\n      return cb(err);\n    }\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = {\n          error: error\n        };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n      model.collection.aggregate(this._pipeline, this.options, (error, cursor) => {\n        if (error != null) {\n          const _opts = {\n            error: error\n          };\n          return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n            cb(error);\n          });\n        }\n        if (verbosity != null) {\n          cursor.explain(verbosity, (error, result) => {\n            const _opts = {\n              error: error\n            };\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\n              if (error) {\n                return cb(error);\n              }\n              return cb(null, result);\n            });\n          });\n        } else {\n          cursor.explain((error, result) => {\n            const _opts = {\n              error: error\n            };\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\n              if (error) {\n                return cb(error);\n              }\n              return cb(null, result);\n            });\n          });\n        }\n      });\n    });\n  }, model.events);\n};\n\n/**\r\n * Sets the allowDiskUse option for the aggregation query\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\r\n *\r\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\r\n * @return {Aggregate} this\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n */\n\nAggregate.prototype.allowDiskUse = function (value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\r\n * Sets the hint option for the aggregation query\r\n *\r\n * #### Example:\r\n *\r\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec(callback)\r\n *\r\n * @param {Object|String} value a hint object or the index name\r\n * @return {Aggregate} this\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n */\n\nAggregate.prototype.hint = function (value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\r\n * Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html).\r\n *\r\n * #### Example:\r\n *\r\n *     const session = await Model.startSession();\r\n *     await Model.aggregate(..).session(session);\r\n *\r\n * @param {ClientSession} session\r\n * @return {Aggregate} this\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n */\n\nAggregate.prototype.session = function (session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\r\n * Lets you set arbitrary options, for middleware or plugins.\r\n *\r\n * #### Example:\r\n *\r\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\r\n *     agg.options; // `{ allowDiskUse: true }`\r\n *\r\n * @param {Object} options keys to merge into current options\r\n * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)\r\n * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\r\n * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](./docs/api/aggregate.html#aggregate_Aggregate-collation)\r\n * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](./docs/api/aggregate.html#aggregate_Aggregate-session)\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n * @return {Aggregate} this\r\n * @api public\r\n */\n\nAggregate.prototype.option = function (value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\r\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\r\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\r\n * because the aggregation result is too big to fit into memory.\r\n *\r\n * #### Example:\r\n *\r\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\r\n *     cursor.eachAsync(function(doc, i) {\r\n *       // use doc\r\n *     });\r\n *\r\n * @param {Object} options\r\n * @param {Number} [options.batchSize] set the cursor batch size\r\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\r\n * @return {AggregationCursor} cursor representing this aggregation\r\n * @api public\r\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html\r\n */\n\nAggregate.prototype.cursor = function (options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n\n/**\r\n * Adds a collation\r\n *\r\n * #### Example:\r\n *\r\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\r\n *\r\n * @param {Object} collation options\r\n * @return {Aggregate} this\r\n * @api public\r\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html\r\n */\n\nAggregate.prototype.collation = function (collation) {\n  this.options.collation = collation;\n  return this;\n};\n\n/**\r\n * Combines multiple aggregation pipelines.\r\n *\r\n * #### Example:\r\n *\r\n *     const res = await Model.aggregate().facet({\r\n *       books: [{ groupBy: '$author' }],\r\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\r\n *     });\r\n *\r\n *     // Output: { books: [...], price: [{...}, {...}] }\r\n *\r\n * @param {Object} facet options\r\n * @return {Aggregate} this\r\n * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/\r\n * @api public\r\n */\n\nAggregate.prototype.facet = function (options) {\n  return this.append({\n    $facet: options\n  });\n};\n\n/**\r\n * Helper for [Atlas Text Search](https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/)'s\r\n * `$search` stage.\r\n *\r\n * #### Example:\r\n *\r\n *     const res = await Model.aggregate().\r\n *      search({\r\n *        text: {\r\n *          query: 'baseball',\r\n *          path: 'plot'\r\n *        }\r\n *      });\r\n *\r\n *     // Output: [{ plot: '...', title: '...' }]\r\n *\r\n * @param {Object} $search options\r\n * @return {Aggregate} this\r\n * @see $search https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/\r\n * @api public\r\n */\n\nAggregate.prototype.search = function (options) {\n  return this.append({\n    $search: options\n  });\n};\n\n/**\r\n * Returns the current pipeline\r\n *\r\n * #### Example:\r\n *\r\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\r\n *\r\n * @return {Array} The current pipeline similar to the operation that will be executed\r\n * @api public\r\n */\n\nAggregate.prototype.pipeline = function () {\n  return this._pipeline;\n};\n\n/**\r\n * Executes the aggregate pipeline on the currently bound Model.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.exec(callback);\r\n *\r\n *     // Because a promise is returned, the `callback` is optional.\r\n *     const result = await aggregate.exec();\r\n *\r\n * @param {Function} [callback]\r\n * @return {Promise} Returns a Promise if no \"callback\" is given.\r\n * @api public\r\n */\n\nAggregate.prototype.exec = function (callback) {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  const model = this._model;\n  const collection = this._model.collection;\n  applyGlobalMaxTimeMS(this.options, model);\n  applyGlobalDiskUse(this.options, model);\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n  return promiseOrCallback(callback, cb => {\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n    stringifyFunctionOperators(this._pipeline);\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = {\n          error: error\n        };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n      if (!this._pipeline.length) {\n        return cb(new Error('Aggregate has empty pipeline'));\n      }\n      const options = utils.clone(this.options || {});\n      collection.aggregate(this._pipeline, options, (err, cursor) => {\n        if (err != null) {\n          return cb(err);\n        }\n        cursor.toArray((error, result) => {\n          const _opts = {\n            error: error\n          };\n          model.hooks.execPost('aggregate', this, [result], _opts, (error, result) => {\n            if (error) {\n              return cb(error);\n            }\n            cb(null, result);\n          });\n        });\n      });\n    });\n  }, model.events);\n};\n\n/**\r\n * Provides a Promise-like `then` function, which will call `.exec` without a callback\r\n * Compatible with `await`.\r\n *\r\n * #### Example:\r\n *\r\n *     Model.aggregate(..).then(successCallback, errorCallback);\r\n *\r\n * @param {Function} [resolve] successCallback\r\n * @param {Function} [reject]  errorCallback\r\n * @return {Promise}\r\n */\nAggregate.prototype.then = function (resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\r\n * Executes the query returning a `Promise` which will be\r\n * resolved with either the doc(s) or rejected with the error.\r\n * Like [`.then()`](#query_Query-then), but only takes a rejection handler.\r\n * Compatible with `await`.\r\n *\r\n * @param {Function} [reject]\r\n * @return {Promise}\r\n * @api public\r\n */\n\nAggregate.prototype.catch = function (reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\r\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\r\n * You do not need to call this function explicitly, the JavaScript runtime\r\n * will call it for you.\r\n *\r\n * #### Example:\r\n *\r\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\r\n *     for await (const doc of agg) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n * Node.js 10.x supports async iterators natively without any flags. You can\r\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\r\n *\r\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\r\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\r\n * support async iterators.\r\n *\r\n * @method Symbol.asyncIterator\r\n * @memberOf Aggregate\r\n * @instance\r\n * @api public\r\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function () {\n    return this.cursor({\n      useMongooseAggCursor: true\n    }).transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\r\n * Helpers\r\n */\n\n/**\r\n * Checks whether an object is likely a pipeline operator\r\n *\r\n * @param {Object} obj object to check\r\n * @return {Boolean}\r\n * @api private\r\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n  const k = Object.keys(obj);\n  return k.length === 1 && k[0][0] === '$';\n}\n\n/**\r\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\r\n * pipeline, should it's model is a non-root discriminator type. This is\r\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\r\n *\r\n * @param {Aggregate} aggregate Aggregate to prepare\r\n * @api private\r\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\n/*!\r\n * Exports\r\n */\n\nmodule.exports = Aggregate;","map":{"version":3,"names":["AggregationCursor","require","Query","applyGlobalMaxTimeMS","applyGlobalDiskUse","getConstructorName","prepareDiscriminatorPipeline","promiseOrCallback","stringifyFunctionOperators","utils","read","prototype","readConcern","validRedactStringValues","Set","Aggregate","pipeline","model","_pipeline","_model","options","arguments","length","Array","isArray","append","apply","schema","readPreference","collation","args","every","isOperator","Error","concat","addFields","arg","$addFields","Object","assign","project","fields","keys","forEach","field","split","include","substring","$project","near","op","$geoNear","$operator","unwind","res","push","$unwind","replaceRoot","newRoot","ret","startsWith","$replaceRoot","count","fieldName","$count","sortByCount","$sortByCount","TypeError","lookup","$lookup","graphLookup","cloneOptions","isObject","mergeClone","startWith","$graphLookup","sample","size","$sample","sort","desc","$meta","indexOf","ascend","$sort","unionWith","$unionWith","pref","tags","call","level","redact","expression","thenExpr","elseExpr","has","$cond","if","then","else","$redact","explain","verbosity","callback","cb","err","hooks","execPre","error","_opts","execPost","collection","aggregate","cursor","result","events","allowDiskUse","value","hint","session","option","key","facet","$facet","search","$search","exec","clone","toArray","resolve","reject","catch","Symbol","asyncIterator","useMongooseAggCursor","transformNull","_transformForAsyncIterator","obj","k","_prepareDiscriminatorPipeline","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/aggregate.js"],"sourcesContent":["'use strict';\r\n\r\n/*!\r\n * Module dependencies\r\n */\r\n\r\nconst AggregationCursor = require('./cursor/AggregationCursor');\r\nconst Query = require('./query');\r\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require('./helpers/query/applyGlobalOption');\r\nconst getConstructorName = require('./helpers/getConstructorName');\r\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\r\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\r\nconst stringifyFunctionOperators = require('./helpers/aggregate/stringifyFunctionOperators');\r\nconst utils = require('./utils');\r\nconst read = Query.prototype.read;\r\nconst readConcern = Query.prototype.readConcern;\r\n\r\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\r\n\r\n/**\r\n * Aggregate constructor used for building aggregation pipelines. Do not\r\n * instantiate this class directly, use [Model.aggregate()](/docs/api/model.html#model_Model-aggregate) instead.\r\n *\r\n * #### Example:\r\n *\r\n *     const aggregate = Model.aggregate([\r\n *       { $project: { a: 1, b: 1 } },\r\n *       { $skip: 5 }\r\n *     ]);\r\n *\r\n *     Model.\r\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\r\n *       unwind('tags').\r\n *       exec(callback);\r\n *\r\n * #### Note:\r\n *\r\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\r\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\r\n *\r\n *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\r\n *     // Do this instead to cast to an ObjectId\r\n *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\r\n *\r\n * @see MongoDB https://docs.mongodb.org/manual/applications/aggregation/\r\n * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate\r\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\r\n * @param {Model} [model] the model to use with this aggregate.\r\n * @api public\r\n */\r\n\r\nfunction Aggregate(pipeline, model) {\r\n  this._pipeline = [];\r\n  this._model = model;\r\n  this.options = {};\r\n\r\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\r\n    this.append.apply(this, pipeline);\r\n  }\r\n}\r\n\r\n/**\r\n * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).\r\n * Supported options are:\r\n *\r\n * - [`allowDiskUse`](./api/aggregate.html#aggregate_Aggregate-allowDiskUse)\r\n * - `bypassDocumentValidation`\r\n * - [`collation`](./api/aggregate.html#aggregate_Aggregate-collation)\r\n * - `comment`\r\n * - [`cursor`](./api/aggregate.html#aggregate_Aggregate-cursor)\r\n * - [`explain`](./api/aggregate.html#aggregate_Aggregate-explain)\r\n * - `fieldsAsRaw`\r\n * - `hint`\r\n * - `let`\r\n * - `maxTimeMS`\r\n * - `raw`\r\n * - `readConcern`\r\n * - `readPreference`\r\n * - [`session`](./api/aggregate.html#aggregate_Aggregate-session)\r\n * - `writeConcern`\r\n *\r\n * @property options\r\n * @memberOf Aggregate\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.options;\r\n\r\n/**\r\n * Get/set the model that this aggregation will execute on.\r\n *\r\n * #### Example:\r\n *\r\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\r\n *     aggregate.model() === MyModel; // true\r\n *\r\n *     // Change the model. There's rarely any reason to do this.\r\n *     aggregate.model(SomeOtherModel);\r\n *     aggregate.model() === SomeOtherModel; // true\r\n *\r\n * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\r\n * @return {Model}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.model = function(model) {\r\n  if (arguments.length === 0) {\r\n    return this._model;\r\n  }\r\n\r\n  this._model = model;\r\n  if (model.schema != null) {\r\n    if (this.options.readPreference == null &&\r\n      model.schema.options.read != null) {\r\n      this.options.readPreference = model.schema.options.read;\r\n    }\r\n    if (this.options.collation == null &&\r\n      model.schema.options.collation != null) {\r\n      this.options.collation = model.schema.options.collation;\r\n    }\r\n  }\r\n\r\n  return model;\r\n};\r\n\r\n/**\r\n * Appends new operators to this aggregate pipeline\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\r\n *\r\n *     // or pass an array\r\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\r\n *     aggregate.append(pipeline);\r\n *\r\n * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.append = function() {\r\n  const args = (arguments.length === 1 && Array.isArray(arguments[0]))\r\n    ? arguments[0]\r\n    : [...arguments];\r\n\r\n  if (!args.every(isOperator)) {\r\n    throw new Error('Arguments must be aggregate pipeline operators');\r\n  }\r\n\r\n  this._pipeline = this._pipeline.concat(args);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a new $addFields operator to this aggregate pipeline.\r\n * Requires MongoDB v3.4+ to work\r\n *\r\n * #### Example:\r\n *\r\n *     // adding new fields based on existing fields\r\n *     aggregate.addFields({\r\n *         newField: '$b.nested'\r\n *       , plusTen: { $add: ['$val', 10]}\r\n *       , sub: {\r\n *            name: '$a'\r\n *         }\r\n *     })\r\n *\r\n *     // etc\r\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\r\n *\r\n * @param {Object} arg field specification\r\n * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\nAggregate.prototype.addFields = function(arg) {\r\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\r\n    throw new Error('Invalid addFields() argument. Must be an object');\r\n  }\r\n  return this.append({ $addFields: Object.assign({}, arg) });\r\n};\r\n\r\n/**\r\n * Appends a new $project operator to this aggregate pipeline.\r\n *\r\n * Mongoose query [selection syntax](#query_Query-select) is also supported.\r\n *\r\n * #### Example:\r\n *\r\n *     // include a, include b, exclude _id\r\n *     aggregate.project(\"a b -_id\");\r\n *\r\n *     // or you may use object notation, useful when\r\n *     // you have keys already prefixed with a \"-\"\r\n *     aggregate.project({a: 1, b: 1, _id: 0});\r\n *\r\n *     // reshaping documents\r\n *     aggregate.project({\r\n *         newField: '$b.nested'\r\n *       , plusTen: { $add: ['$val', 10]}\r\n *       , sub: {\r\n *            name: '$a'\r\n *         }\r\n *     })\r\n *\r\n *     // etc\r\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\r\n *\r\n * @param {Object|String} arg field specification\r\n * @see projection https://docs.mongodb.org/manual/reference/aggregation/project/\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.project = function(arg) {\r\n  const fields = {};\r\n\r\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\r\n    Object.keys(arg).forEach(function(field) {\r\n      fields[field] = arg[field];\r\n    });\r\n  } else if (arguments.length === 1 && typeof arg === 'string') {\r\n    arg.split(/\\s+/).forEach(function(field) {\r\n      if (!field) {\r\n        return;\r\n      }\r\n      const include = field[0] === '-' ? 0 : 1;\r\n      if (include === 0) {\r\n        field = field.substring(1);\r\n      }\r\n      fields[field] = include;\r\n    });\r\n  } else {\r\n    throw new Error('Invalid project() argument. Must be string or object');\r\n  }\r\n\r\n  return this.append({ $project: fields });\r\n};\r\n\r\n/**\r\n * Appends a new custom $group operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.group({ _id: \"$department\" });\r\n *\r\n * @see $group https://docs.mongodb.org/manual/reference/aggregation/group/\r\n * @method group\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $group operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\n/**\r\n * Appends a new custom $match operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\r\n *\r\n * @see $match https://docs.mongodb.org/manual/reference/aggregation/match/\r\n * @method match\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $match operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\n/**\r\n * Appends a new $skip operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.skip(10);\r\n *\r\n * @see $skip https://docs.mongodb.org/manual/reference/aggregation/skip/\r\n * @method skip\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Number} num number of records to skip before next stage\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\n/**\r\n * Appends a new $limit operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.limit(10);\r\n *\r\n * @see $limit https://docs.mongodb.org/manual/reference/aggregation/limit/\r\n * @method limit\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Number} num maximum number of records to pass to the next stage\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\n\r\n/**\r\n * Appends a new $densify operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *      aggregate.densify({\r\n *        field: 'timestamp',\r\n *        range: {\r\n *          step: 1,\r\n *          unit: 'hour',\r\n *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\r\n *        }\r\n *      });\r\n *\r\n * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/\r\n * @method densify\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $densify operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\n/**\r\n * Appends a new $fill operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *      aggregate.fill({\r\n *        output: {\r\n *          bootsSold: { value: 0 },\r\n *          sandalsSold: { value: 0 },\r\n *          sneakersSold: { value: 0 }\r\n *        }\r\n *      });\r\n *\r\n * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/\r\n * @method fill\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg $fill operator contents\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\n/**\r\n * Appends a new $geoNear operator to this aggregate pipeline.\r\n *\r\n * #### Note:\r\n *\r\n * **MUST** be used as the first operator in the pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.near({\r\n *       near: [40.724, -73.997],\r\n *       distanceField: \"dist.calculated\", // required\r\n *       maxDistance: 0.008,\r\n *       query: { type: \"public\" },\r\n *       includeLocs: \"dist.location\",\r\n *       uniqueDocs: true,\r\n *       num: 5\r\n *     });\r\n *\r\n * @see $geoNear https://docs.mongodb.org/manual/reference/aggregation/geoNear/\r\n * @method near\r\n * @memberOf Aggregate\r\n * @instance\r\n * @param {Object} arg\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.near = function(arg) {\r\n  const op = {};\r\n  op.$geoNear = arg;\r\n  return this.append(op);\r\n};\r\n\r\n/*!\r\n * define methods\r\n */\r\n\r\n'group match skip limit out densify fill'.split(' ').forEach(function($operator) {\r\n  Aggregate.prototype[$operator] = function(arg) {\r\n    const op = {};\r\n    op['$' + $operator] = arg;\r\n    return this.append(op);\r\n  };\r\n});\r\n\r\n/**\r\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\r\n *\r\n * Note that the `$unwind` operator requires the path name to start with '$'.\r\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.unwind(\"tags\");\r\n *     aggregate.unwind(\"a\", \"b\", \"c\");\r\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\r\n *\r\n * @see $unwind https://docs.mongodb.org/manual/reference/aggregation/unwind/\r\n * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.unwind = function() {\r\n  const args = [...arguments];\r\n\r\n  const res = [];\r\n  for (const arg of args) {\r\n    if (arg && typeof arg === 'object') {\r\n      res.push({ $unwind: arg });\r\n    } else if (typeof arg === 'string') {\r\n      res.push({\r\n        $unwind: (arg[0] === '$') ? arg : '$' + arg\r\n      });\r\n    } else {\r\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\r\n        'must be string or object');\r\n    }\r\n  }\r\n\r\n  return this.append.apply(this, res);\r\n};\r\n\r\n/**\r\n * Appends a new $replaceRoot operator to this aggregate pipeline.\r\n *\r\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\r\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\r\n * If you are passing in an object the strings in your expression will not be altered.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.replaceRoot(\"user\");\r\n *\r\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\r\n *\r\n * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot\r\n * @param {String|Object} newRoot the field or document which will become the new root document\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.replaceRoot = function(newRoot) {\r\n  let ret;\r\n\r\n  if (typeof newRoot === 'string') {\r\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\r\n  } else {\r\n    ret = newRoot;\r\n  }\r\n\r\n  return this.append({\r\n    $replaceRoot: {\r\n      newRoot: ret\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Appends a new $count operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.count(\"userCount\");\r\n *\r\n * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count\r\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.count = function(fieldName) {\r\n  return this.append({ $count: fieldName });\r\n};\r\n\r\n/**\r\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\r\n * or a pipeline object.\r\n *\r\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\r\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.sortByCount('users');\r\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\r\n *\r\n * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\r\n * @param {Object|String} arg\r\n * @return {Aggregate} this\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.sortByCount = function(arg) {\r\n  if (arg && typeof arg === 'object') {\r\n    return this.append({ $sortByCount: arg });\r\n  } else if (typeof arg === 'string') {\r\n    return this.append({\r\n      $sortByCount: (arg[0] === '$') ? arg : '$' + arg\r\n    });\r\n  } else {\r\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\r\n      'must be string or object');\r\n  }\r\n};\r\n\r\n/**\r\n * Appends new custom $lookup operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\r\n *\r\n * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\r\n * @param {Object} options to $lookup as described in the above link\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.lookup = function(options) {\r\n  return this.append({ $lookup: options });\r\n};\r\n\r\n/**\r\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\r\n *\r\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\r\n *\r\n * #### Example:\r\n *\r\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\r\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\r\n *\r\n * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\r\n * @param {Object} options to $graphLookup as described in the above link\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.graphLookup = function(options) {\r\n  const cloneOptions = {};\r\n  if (options) {\r\n    if (!utils.isObject(options)) {\r\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\r\n    }\r\n\r\n    utils.mergeClone(cloneOptions, options);\r\n    const startWith = cloneOptions.startWith;\r\n\r\n    if (startWith && typeof startWith === 'string') {\r\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?\r\n        cloneOptions.startWith :\r\n        '$' + cloneOptions.startWith;\r\n    }\r\n\r\n  }\r\n  return this.append({ $graphLookup: cloneOptions });\r\n};\r\n\r\n/**\r\n * Appends new custom $sample operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\r\n *\r\n * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample\r\n * @param {Number} size number of random documents to pick\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.sample = function(size) {\r\n  return this.append({ $sample: { size: size } });\r\n};\r\n\r\n/**\r\n * Appends a new $sort operator to this aggregate pipeline.\r\n *\r\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\r\n *\r\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\r\n *\r\n * #### Example:\r\n *\r\n *     // these are equivalent\r\n *     aggregate.sort({ field: 'asc', test: -1 });\r\n *     aggregate.sort('field -test');\r\n *\r\n * @see $sort https://docs.mongodb.org/manual/reference/aggregation/sort/\r\n * @param {Object|String} arg\r\n * @return {Aggregate} this\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.sort = function(arg) {\r\n  // TODO refactor to reuse the query builder logic\r\n\r\n  const sort = {};\r\n\r\n  if (getConstructorName(arg) === 'Object') {\r\n    const desc = ['desc', 'descending', -1];\r\n    Object.keys(arg).forEach(function(field) {\r\n      // If sorting by text score, skip coercing into 1/-1\r\n      if (arg[field] instanceof Object && arg[field].$meta) {\r\n        sort[field] = arg[field];\r\n        return;\r\n      }\r\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\r\n    });\r\n  } else if (arguments.length === 1 && typeof arg === 'string') {\r\n    arg.split(/\\s+/).forEach(function(field) {\r\n      if (!field) {\r\n        return;\r\n      }\r\n      const ascend = field[0] === '-' ? -1 : 1;\r\n      if (ascend === -1) {\r\n        field = field.substring(1);\r\n      }\r\n      sort[field] = ascend;\r\n    });\r\n  } else {\r\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\r\n  }\r\n\r\n  return this.append({ $sort: sort });\r\n};\r\n\r\n/**\r\n * Appends new $unionWith operator to this aggregate pipeline.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\r\n *\r\n * @see $unionWith https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith\r\n * @param {Object} options to $unionWith query as described in the above link\r\n * @return {Aggregate}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.unionWith = function(options) {\r\n  return this.append({ $unionWith: options });\r\n};\r\n\r\n\r\n/**\r\n * Sets the readPreference option for the aggregation query.\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate(pipeline).read('primaryPreferred');\r\n *\r\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\r\n * @param {Array} [tags] optional tags for this query. DEPRECATED\r\n * @return {Aggregate} this\r\n * @api public\r\n * @see mongodb https://docs.mongodb.org/manual/applications/replication/#read-preference\r\n */\r\n\r\nAggregate.prototype.read = function(pref, tags) {\r\n  read.call(this, pref, tags);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the readConcern level for the aggregation query.\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate(pipeline).readConcern('majority');\r\n *\r\n * @param {String} level one of the listed read concern level or their aliases\r\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\r\n * @return {Aggregate} this\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.readConcern = function(level) {\r\n  readConcern.call(this, level);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a new $redact operator to this aggregate pipeline.\r\n *\r\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\r\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate(pipeline).redact({\r\n *       $cond: {\r\n *         if: { $eq: [ '$level', 5 ] },\r\n *         then: '$$PRUNE',\r\n *         else: '$$DESCEND'\r\n *       }\r\n *     });\r\n *\r\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\r\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\r\n *\r\n * @param {Object} expression redact options or conditional expression\r\n * @param {String|Object} [thenExpr] true case for the condition\r\n * @param {String|Object} [elseExpr] false case for the condition\r\n * @return {Aggregate} this\r\n * @see $redact https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\r\n  if (arguments.length === 3) {\r\n    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||\r\n      (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {\r\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\r\n    }\r\n\r\n    expression = {\r\n      $cond: {\r\n        if: expression,\r\n        then: thenExpr,\r\n        else: elseExpr\r\n      }\r\n    };\r\n  } else if (arguments.length !== 1) {\r\n    throw new TypeError('Invalid arguments');\r\n  }\r\n\r\n  return this.append({ $redact: expression });\r\n};\r\n\r\n/**\r\n * Execute the aggregation with explain\r\n *\r\n * #### Example:\r\n *\r\n *     Model.aggregate(..).explain(callback)\r\n *\r\n * @param {String} [verbosity]\r\n * @param {Function} [callback] The callback function to call, if not specified, will return a Promise instead.\r\n * @return {Promise} Returns a promise if no \"callback\" is given\r\n */\r\n\r\nAggregate.prototype.explain = function(verbosity, callback) {\r\n  const model = this._model;\r\n  if (typeof verbosity === 'function') {\r\n    callback = verbosity;\r\n    verbosity = null;\r\n  }\r\n\r\n  return promiseOrCallback(callback, cb => {\r\n    if (!this._pipeline.length) {\r\n      const err = new Error('Aggregate has empty pipeline');\r\n      return cb(err);\r\n    }\r\n\r\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\r\n\r\n    model.hooks.execPre('aggregate', this, error => {\r\n      if (error) {\r\n        const _opts = { error: error };\r\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\r\n          cb(error);\r\n        });\r\n      }\r\n\r\n      model.collection.aggregate(this._pipeline, this.options, (error, cursor) => {\r\n        if (error != null) {\r\n          const _opts = { error: error };\r\n          return model.hooks.execPost('aggregate', this, [null], _opts, error => {\r\n            cb(error);\r\n          });\r\n        }\r\n        if (verbosity != null) {\r\n          cursor.explain(verbosity, (error, result) => {\r\n            const _opts = { error: error };\r\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\r\n              if (error) {\r\n                return cb(error);\r\n              }\r\n              return cb(null, result);\r\n            });\r\n          });\r\n        } else {\r\n          cursor.explain((error, result) => {\r\n            const _opts = { error: error };\r\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\r\n              if (error) {\r\n                return cb(error);\r\n              }\r\n              return cb(null, result);\r\n            });\r\n          });\r\n        }\r\n      });\r\n    });\r\n  }, model.events);\r\n};\r\n\r\n/**\r\n * Sets the allowDiskUse option for the aggregation query\r\n *\r\n * #### Example:\r\n *\r\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\r\n *\r\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\r\n * @return {Aggregate} this\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n */\r\n\r\nAggregate.prototype.allowDiskUse = function(value) {\r\n  this.options.allowDiskUse = value;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the hint option for the aggregation query\r\n *\r\n * #### Example:\r\n *\r\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec(callback)\r\n *\r\n * @param {Object|String} value a hint object or the index name\r\n * @return {Aggregate} this\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n */\r\n\r\nAggregate.prototype.hint = function(value) {\r\n  this.options.hint = value;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html).\r\n *\r\n * #### Example:\r\n *\r\n *     const session = await Model.startSession();\r\n *     await Model.aggregate(..).session(session);\r\n *\r\n * @param {ClientSession} session\r\n * @return {Aggregate} this\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n */\r\n\r\nAggregate.prototype.session = function(session) {\r\n  if (session == null) {\r\n    delete this.options.session;\r\n  } else {\r\n    this.options.session = session;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Lets you set arbitrary options, for middleware or plugins.\r\n *\r\n * #### Example:\r\n *\r\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\r\n *     agg.options; // `{ allowDiskUse: true }`\r\n *\r\n * @param {Object} options keys to merge into current options\r\n * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)\r\n * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\r\n * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](./docs/api/aggregate.html#aggregate_Aggregate-collation)\r\n * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](./docs/api/aggregate.html#aggregate_Aggregate-session)\r\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\r\n * @return {Aggregate} this\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.option = function(value) {\r\n  for (const key in value) {\r\n    this.options[key] = value[key];\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\r\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\r\n * because the aggregation result is too big to fit into memory.\r\n *\r\n * #### Example:\r\n *\r\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\r\n *     cursor.eachAsync(function(doc, i) {\r\n *       // use doc\r\n *     });\r\n *\r\n * @param {Object} options\r\n * @param {Number} [options.batchSize] set the cursor batch size\r\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\r\n * @return {AggregationCursor} cursor representing this aggregation\r\n * @api public\r\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html\r\n */\r\n\r\nAggregate.prototype.cursor = function(options) {\r\n  this.options.cursor = options || {};\r\n  return new AggregationCursor(this); // return this;\r\n};\r\n\r\n/**\r\n * Adds a collation\r\n *\r\n * #### Example:\r\n *\r\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\r\n *\r\n * @param {Object} collation options\r\n * @return {Aggregate} this\r\n * @api public\r\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html\r\n */\r\n\r\nAggregate.prototype.collation = function(collation) {\r\n  this.options.collation = collation;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Combines multiple aggregation pipelines.\r\n *\r\n * #### Example:\r\n *\r\n *     const res = await Model.aggregate().facet({\r\n *       books: [{ groupBy: '$author' }],\r\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\r\n *     });\r\n *\r\n *     // Output: { books: [...], price: [{...}, {...}] }\r\n *\r\n * @param {Object} facet options\r\n * @return {Aggregate} this\r\n * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.facet = function(options) {\r\n  return this.append({ $facet: options });\r\n};\r\n\r\n/**\r\n * Helper for [Atlas Text Search](https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/)'s\r\n * `$search` stage.\r\n *\r\n * #### Example:\r\n *\r\n *     const res = await Model.aggregate().\r\n *      search({\r\n *        text: {\r\n *          query: 'baseball',\r\n *          path: 'plot'\r\n *        }\r\n *      });\r\n *\r\n *     // Output: [{ plot: '...', title: '...' }]\r\n *\r\n * @param {Object} $search options\r\n * @return {Aggregate} this\r\n * @see $search https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.search = function(options) {\r\n  return this.append({ $search: options });\r\n};\r\n\r\n/**\r\n * Returns the current pipeline\r\n *\r\n * #### Example:\r\n *\r\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\r\n *\r\n * @return {Array} The current pipeline similar to the operation that will be executed\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.pipeline = function() {\r\n  return this._pipeline;\r\n};\r\n\r\n/**\r\n * Executes the aggregate pipeline on the currently bound Model.\r\n *\r\n * #### Example:\r\n *\r\n *     aggregate.exec(callback);\r\n *\r\n *     // Because a promise is returned, the `callback` is optional.\r\n *     const result = await aggregate.exec();\r\n *\r\n * @param {Function} [callback]\r\n * @return {Promise} Returns a Promise if no \"callback\" is given.\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.exec = function(callback) {\r\n  if (!this._model) {\r\n    throw new Error('Aggregate not bound to any Model');\r\n  }\r\n  const model = this._model;\r\n  const collection = this._model.collection;\r\n\r\n  applyGlobalMaxTimeMS(this.options, model);\r\n  applyGlobalDiskUse(this.options, model);\r\n\r\n  if (this.options && this.options.cursor) {\r\n    return new AggregationCursor(this);\r\n  }\r\n\r\n  return promiseOrCallback(callback, cb => {\r\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\r\n    stringifyFunctionOperators(this._pipeline);\r\n\r\n    model.hooks.execPre('aggregate', this, error => {\r\n      if (error) {\r\n        const _opts = { error: error };\r\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\r\n          cb(error);\r\n        });\r\n      }\r\n      if (!this._pipeline.length) {\r\n        return cb(new Error('Aggregate has empty pipeline'));\r\n      }\r\n\r\n      const options = utils.clone(this.options || {});\r\n\r\n      collection.aggregate(this._pipeline, options, (err, cursor) => {\r\n        if (err != null) {\r\n          return cb(err);\r\n        }\r\n\r\n        cursor.toArray((error, result) => {\r\n          const _opts = { error: error };\r\n          model.hooks.execPost('aggregate', this, [result], _opts, (error, result) => {\r\n            if (error) {\r\n              return cb(error);\r\n            }\r\n\r\n            cb(null, result);\r\n          });\r\n        });\r\n      });\r\n    });\r\n  }, model.events);\r\n};\r\n\r\n/**\r\n * Provides a Promise-like `then` function, which will call `.exec` without a callback\r\n * Compatible with `await`.\r\n *\r\n * #### Example:\r\n *\r\n *     Model.aggregate(..).then(successCallback, errorCallback);\r\n *\r\n * @param {Function} [resolve] successCallback\r\n * @param {Function} [reject]  errorCallback\r\n * @return {Promise}\r\n */\r\nAggregate.prototype.then = function(resolve, reject) {\r\n  return this.exec().then(resolve, reject);\r\n};\r\n\r\n/**\r\n * Executes the query returning a `Promise` which will be\r\n * resolved with either the doc(s) or rejected with the error.\r\n * Like [`.then()`](#query_Query-then), but only takes a rejection handler.\r\n * Compatible with `await`.\r\n *\r\n * @param {Function} [reject]\r\n * @return {Promise}\r\n * @api public\r\n */\r\n\r\nAggregate.prototype.catch = function(reject) {\r\n  return this.exec().then(null, reject);\r\n};\r\n\r\n/**\r\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\r\n * You do not need to call this function explicitly, the JavaScript runtime\r\n * will call it for you.\r\n *\r\n * #### Example:\r\n *\r\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\r\n *     for await (const doc of agg) {\r\n *       console.log(doc.name);\r\n *     }\r\n *\r\n * Node.js 10.x supports async iterators natively without any flags. You can\r\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\r\n *\r\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\r\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\r\n * support async iterators.\r\n *\r\n * @method Symbol.asyncIterator\r\n * @memberOf Aggregate\r\n * @instance\r\n * @api public\r\n */\r\n\r\nif (Symbol.asyncIterator != null) {\r\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\r\n    return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();\r\n  };\r\n}\r\n\r\n/*!\r\n * Helpers\r\n */\r\n\r\n/**\r\n * Checks whether an object is likely a pipeline operator\r\n *\r\n * @param {Object} obj object to check\r\n * @return {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction isOperator(obj) {\r\n  if (typeof obj !== 'object' || obj === null) {\r\n    return false;\r\n  }\r\n\r\n  const k = Object.keys(obj);\r\n\r\n  return k.length === 1 && k[0][0] === '$';\r\n}\r\n\r\n/**\r\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\r\n * pipeline, should it's model is a non-root discriminator type. This is\r\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\r\n *\r\n * @param {Aggregate} aggregate Aggregate to prepare\r\n * @api private\r\n */\r\n\r\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\r\n\r\n/*!\r\n * Exports\r\n */\r\n\r\nmodule.exports = Aggregate;\r\n"],"mappings":"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AC,CAAC;MAC5B;MACAN,MAAM,CAACG,KAAK,CAAC,GAAGE,OAAO;IACzB,CAAC,CAAC;EACJ,CAAC,MAAM;IACL,MAAM,IAAIb,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,OAAO,IAAI,CAACR,MAAM,CAAC;IAAEuB,QAAQ,EAAEP;EAAO,CAAC,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA1B,SAAS,CAACJ,SAAS,CAACsC,IAAI,GAAG,UAASb,GAAG,EAAE;EACvC,MAAMc,EAAE,GAAG,CAAC,CAAC;EACbA,EAAE,CAACC,QAAQ,GAAGf,GAAG;EACjB,OAAO,IAAI,CAACX,MAAM,CAACyB,EAAE,CAAC;AACxB,CAAC;;AAED;AACA;AACA;;AAEA,yCAAyC,CAACL,KAAK,CAAC,GAAG,CAAC,CAACF,OAAO,CAAC,UAASS,SAAS,EAAE;EAC/ErC,SAAS,CAACJ,SAAS,CAACyC,SAAS,CAAC,GAAG,UAAShB,GAAG,EAAE;IAC7C,MAAMc,EA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}