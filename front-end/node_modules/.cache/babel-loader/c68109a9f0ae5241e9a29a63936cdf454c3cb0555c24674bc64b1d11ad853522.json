{"ast":null,"code":"'use strict';\n\n/**\r\n * Create a new instance\r\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n  this.args = [...arguments];\n};\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n  this.args = [...arguments];\n};\n\n/**\r\n * Execute all \"pre\" hooks for \"name\"\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array|Function} args Optional arguments or directly the callback\r\n * @param {Function} [callback] The callback to call when executing all hooks are finished\r\n * @returns {void}\r\n */\nKareem.prototype.execPre = function (name, context, args, callback) {\n  if (arguments.length === 3) {\n    callback = args;\n    args = [];\n  }\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  const numAsyncPres = pres.numAsync || 0;\n  let currentPre = 0;\n  let asyncPresLeft = numAsyncPres;\n  let done = false;\n  const $args = args;\n  let shouldSkipWrappedFunction = null;\n  if (!numPres) {\n    return nextTick(function () {\n      callback(null);\n    });\n  }\n  function next() {\n    if (currentPre >= numPres) {\n      return;\n    }\n    const pre = pres[currentPre];\n    if (pre.isAsync) {\n      const args = [decorateNextFn(_next), decorateNextFn(function (error) {\n        if (error) {\n          if (done) {\n            return;\n          }\n          if (error instanceof Kareem.skipWrappedFunction) {\n            shouldSkipWrappedFunction = error;\n          } else {\n            done = true;\n            return callback(error);\n          }\n        }\n        if (--asyncPresLeft === 0 && currentPre >= numPres) {\n          return callback(shouldSkipWrappedFunction);\n        }\n      })];\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else if (pre.fn.length > 0) {\n      const args = [decorateNextFn(_next)];\n      const _args = arguments.length >= 2 ? arguments : [null].concat($args);\n      for (let i = 1; i < _args.length; ++i) {\n        args.push(_args[i]);\n      }\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else {\n      let maybePromiseLike = null;\n      try {\n        maybePromiseLike = pre.fn.call(context);\n      } catch (err) {\n        if (err != null) {\n          return callback(err);\n        }\n      }\n      if (isPromiseLike(maybePromiseLike)) {\n        maybePromiseLike.then(() => _next(), err => _next(err));\n      } else {\n        if (++currentPre >= numPres) {\n          if (asyncPresLeft > 0) {\n            // Leave parallel hooks to run\n            return;\n          } else {\n            return nextTick(function () {\n              callback(shouldSkipWrappedFunction);\n            });\n          }\n        }\n        next();\n      }\n    }\n  }\n  next.apply(null, [null].concat(args));\n  function _next(error) {\n    if (error) {\n      if (done) {\n        return;\n      }\n      if (error instanceof Kareem.skipWrappedFunction) {\n        shouldSkipWrappedFunction = error;\n      } else {\n        done = true;\n        return callback(error);\n      }\n    }\n    if (++currentPre >= numPres) {\n      if (asyncPresLeft > 0) {\n        // Leave parallel hooks to run\n        return;\n      } else {\n        return callback(shouldSkipWrappedFunction);\n      }\n    }\n    next.apply(context, arguments);\n  }\n};\n\n/**\r\n * Execute all \"pre\" hooks for \"name\" synchronously\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array} [args] Apply custom arguments to the hook\r\n * @returns {void}\r\n */\nKareem.prototype.execPreSync = function (name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  for (let i = 0; i < numPres; ++i) {\n    pres[i].fn.apply(context, args || []);\n  }\n};\n\n/**\r\n * Execute all \"post\" hooks for \"name\"\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array|Function} args Apply custom arguments to the hook\r\n * @param {*} options Optional options or directly the callback\r\n * @param {Function} [callback] The callback to call when executing all hooks are finished\r\n * @returns {void}\r\n */\nKareem.prototype.execPost = function (name, context, args, options, callback) {\n  if (arguments.length < 5) {\n    callback = options;\n    options = null;\n  }\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  let currentPost = 0;\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n  if (!numPosts) {\n    return nextTick(function () {\n      callback.apply(null, [firstError].concat(args));\n    });\n  }\n  function next() {\n    const post = posts[currentPost].fn;\n    let numArgs = 0;\n    const argLength = args.length;\n    const newArgs = [];\n    for (let i = 0; i < argLength; ++i) {\n      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\n      if (!args[i] || !args[i]._kareemIgnore) {\n        newArgs.push(args[i]);\n      }\n    }\n    if (firstError) {\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        const _cb = decorateNextFn(function (error) {\n          if (error) {\n            if (error instanceof Kareem.overwriteResult) {\n              args = error.args;\n              if (++currentPost >= numPosts) {\n                return callback.call(null, firstError);\n              }\n              return next();\n            }\n            firstError = error;\n          }\n          if (++currentPost >= numPosts) {\n            return callback.call(null, firstError);\n          }\n          next();\n        });\n        callMiddlewareFunction(post, context, [firstError].concat(newArgs).concat([_cb]), _cb);\n      } else {\n        if (++currentPost >= numPosts) {\n          return callback.call(null, firstError);\n        }\n        next();\n      }\n    } else {\n      const _cb = decorateNextFn(function (error) {\n        if (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            if (++currentPost >= numPosts) {\n              return callback.apply(null, [null].concat(args));\n            }\n            return next();\n          }\n          firstError = error;\n          return next();\n        }\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n        next();\n      });\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        // Skip error handlers if no error\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n        return next();\n      }\n      if (post.length === numArgs + 1) {\n        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);\n      } else {\n        let error;\n        let maybePromiseLike;\n        try {\n          maybePromiseLike = post.apply(context, newArgs);\n        } catch (err) {\n          error = err;\n          firstError = err;\n        }\n        if (isPromiseLike(maybePromiseLike)) {\n          return maybePromiseLike.then(res => {\n            _cb(res instanceof Kareem.overwriteResult ? res : null);\n          }, err => _cb(err));\n        }\n        if (maybePromiseLike instanceof Kareem.overwriteResult) {\n          args = maybePromiseLike.args;\n        }\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [error].concat(args));\n        }\n        next();\n      }\n    }\n  }\n  next();\n};\n\n/**\r\n * Execute all \"post\" hooks for \"name\" synchronously\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array|Function} args Apply custom arguments to the hook\r\n * @returns {Array} The used arguments\r\n */\nKareem.prototype.execPostSync = function (name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n  return args;\n};\n\n/**\r\n * Create a synchronous wrapper for \"fn\"\r\n * @param {String} name The name of the hook\r\n * @param {Function} fn The function to wrap\r\n * @returns {Function} The wrapped function\r\n */\nKareem.prototype.createWrapperSync = function (name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    _this.execPreSync(name, this, arguments);\n    const toReturn = fn.apply(this, arguments);\n    const result = _this.execPostSync(name, this, [toReturn]);\n    return result[0];\n  };\n};\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\n  if (options.useErrorHandlers) {\n    return instance.execPost(name, context, args, {\n      error: error\n    }, function (error) {\n      return typeof callback === 'function' && callback(error);\n    });\n  } else {\n    return typeof callback === 'function' && callback(error);\n  }\n}\n\n/**\r\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\r\n * @param {String} name The name of the hook\r\n * @param {Function} fn The function for the hook\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array} args Apply custom arguments to the hook\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.checkForPromise]\r\n * @returns {void}\r\n */\nKareem.prototype.wrap = function (name, fn, context, args, options) {\n  const lastArg = args.length > 0 ? args[args.length - 1] : null;\n  const argsWithoutCb = Array.from(args);\n  typeof lastArg === 'function' && argsWithoutCb.pop();\n  const _this = this;\n  options = options || {};\n  const checkForPromise = options.checkForPromise;\n  this.execPre(name, context, args, function (error) {\n    if (error && !(error instanceof Kareem.skipWrappedFunction)) {\n      const numCallbackParams = options.numCallbackParams || 0;\n      const errorArgs = options.contextParameter ? [context] : [];\n      for (let i = errorArgs.length; i < numCallbackParams; ++i) {\n        errorArgs.push(null);\n      }\n      return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);\n    }\n    const numParameters = fn.length;\n    let ret;\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args[0];\n      return _cb(null, ...error.args);\n    } else {\n      try {\n        ret = fn.apply(context, argsWithoutCb.concat(_cb));\n      } catch (err) {\n        return _cb(err);\n      }\n    }\n    if (checkForPromise) {\n      if (isPromiseLike(ret)) {\n        // Thenable, use it\n        return ret.then(res => _cb(null, res), err => _cb(err));\n      }\n\n      // If `fn()` doesn't have a callback argument and doesn't return a\n      // promise, assume it is sync\n      if (numParameters < argsWithoutCb.length + 1) {\n        return _cb(null, ret);\n      }\n    }\n    function _cb() {\n      const argsWithoutError = Array.from(arguments);\n      argsWithoutError.shift();\n      if (options.nullResultByDefault && argsWithoutError.length === 0) {\n        argsWithoutError.push(null);\n      }\n      if (arguments[0]) {\n        // Assume error\n        return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);\n      } else {\n        _this.execPost(name, context, argsWithoutError, function () {\n          if (lastArg === null) {\n            return;\n          }\n          arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);\n        });\n      }\n    }\n  });\n};\n\n/**\r\n * Filter current instance for something specific and return the filtered clone\r\n * @param {Function} fn The filter function\r\n * @returns {Kareem} The cloned and filtered instance\r\n */\nKareem.prototype.filter = function (fn) {\n  const clone = this.clone();\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).map(h => Object.assign({}, h, {\n      name: name\n    })).filter(fn);\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n    hooks.numAsync = hooks.filter(h => h.isAsync).length;\n    clone._pres.set(name, hooks);\n  }\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).map(h => Object.assign({}, h, {\n      name: name\n    })).filter(fn);\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n    clone._posts.set(name, hooks);\n  }\n  return clone;\n};\n\n/**\r\n * Check for a \"name\" to exist either in pre or post hooks\r\n * @param {String} name The name of the hook\r\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\r\n */\nKareem.prototype.hasHooks = function (name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\r\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\r\n * @param {String} name The name of the hook\r\n * @param {Function} fn The function to wrap\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Object} [options]\r\n * @returns {Function} The wrapped function\r\n */\nKareem.prototype.createWrapper = function (name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the\n    // function wrapped in a nextTick()\n    return function () {\n      nextTick(() => fn.apply(this, arguments));\n    };\n  }\n  return function () {\n    const _context = context || this;\n    _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\r\n * Register a new hook for \"pre\"\r\n * @param {String} name The name of the hook\r\n * @param {Boolean} [isAsync]\r\n * @param {Function} fn The function to register for \"name\"\r\n * @param {never} error Unused\r\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\r\n * @returns {Kareem}\r\n */\nKareem.prototype.pre = function (name, isAsync, fn, error, unshift) {\n  let options = {};\n  if (typeof isAsync === 'object' && isAsync !== null) {\n    options = isAsync;\n    isAsync = options.isAsync;\n  } else if (typeof arguments[1] !== 'boolean') {\n    fn = isAsync;\n    isAsync = false;\n  }\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n  if (isAsync) {\n    pres.numAsync = pres.numAsync || 0;\n    ++pres.numAsync;\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, {\n      fn: fn,\n      isAsync: isAsync\n    }));\n  } else {\n    pres.push(Object.assign({}, options, {\n      fn: fn,\n      isAsync: isAsync\n    }));\n  }\n  return this;\n};\n\n/**\r\n * Register a new hook for \"post\"\r\n * @param {String} name The name of the hook\r\n * @param {Object} [options]\r\n * @param {Function} fn The function to register for \"name\"\r\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\r\n * @returns {Kareem}\r\n */\nKareem.prototype.post = function (name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, {\n      fn: fn\n    }));\n  } else {\n    posts.push(Object.assign({}, options, {\n      fn: fn\n    }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\r\n * Clone the current instance\r\n * @returns {Kareem} The cloned instance\r\n */\nKareem.prototype.clone = function () {\n  const n = new Kareem();\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    clone.numAsync = this._pres.get(key).numAsync;\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n  return n;\n};\n\n/**\r\n * Merge \"other\" into self or \"clone\"\r\n * @param {Kareem} other The instance to merge with\r\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\r\n * @returns {Kareem} The merged instance\r\n */\nKareem.prototype.merge = function (other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n    // Deduplicate based on `fn`\n    filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    combined.numAsync = sourcePres.numAsync || 0;\n    combined.numAsync += deduplicated.filter(p => p.isAsync).length;\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n  return ret;\n};\nfunction callMiddlewareFunction(fn, context, args, next) {\n  let maybePromiseLike;\n  try {\n    maybePromiseLike = fn.apply(context, args);\n  } catch (error) {\n    return next(error);\n  }\n  if (isPromiseLike(maybePromiseLike)) {\n    maybePromiseLike.then(() => next(), err => next(err));\n  }\n}\nfunction isPromiseLike(v) {\n  return typeof v === 'object' && v !== null && typeof v.then === 'function';\n}\nfunction decorateNextFn(fn) {\n  let called = false;\n  const _this = this;\n  return function () {\n    // Ensure this function can only be called once\n    if (called) {\n      return;\n    }\n    called = true;\n    // Make sure to clear the stack so try/catch doesn't catch errors\n    // in subsequent middleware\n    return nextTick(() => fn.apply(_this, arguments));\n  };\n}\nconst nextTick = typeof process === 'object' && process !== null && process.nextTick || function nextTick(cb) {\n  setTimeout(cb, 0);\n};\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\nmodule.exports = Kareem;","map":{"version":3,"names":["Kareem","_pres","Map","_posts","skipWrappedFunction","arguments","args","overwriteResult","prototype","execPre","name","context","callback","length","pres","get","numPres","numAsyncPres","numAsync","currentPre","asyncPresLeft","done","$args","shouldSkipWrappedFunction","nextTick","next","pre","isAsync","decorateNextFn","_next","error","callMiddlewareFunction","fn","_args","concat","i","push","maybePromiseLike","call","err","isPromiseLike","then","apply","execPreSync","execPost","options","posts","numPosts","currentPost","firstError","post","numArgs","argLength","newArgs","_kareemIgnore","isErrorHandlingMiddleware","_cb","res","execPostSync","createWrapperSync","_this","syncWrapper","toReturn","result","_handleWrapError","instance","useErrorHandlers","wrap","lastArg","argsWithoutCb","Array","from","pop","checkForPromise","numCallbackParams","errorArgs","contextParameter","numParameters","ret","argsWithoutError","shift","nullResultByDefault","filter","clone","keys","hooks","map","h","Object","assign","delete","set","hasHooks","has","createWrapper","_context","unshift","Error","n","key","slice","merge","other","sourcePres","deduplicated","p","_p","indexOf","combined","sourcePosts","v","called","process","cb","setTimeout","errorHandler","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/kareem/index.js"],"sourcesContent":["'use strict';\r\n\r\n/**\r\n * Create a new instance\r\n */\r\nfunction Kareem() {\r\n  this._pres = new Map();\r\n  this._posts = new Map();\r\n}\r\n\r\nKareem.skipWrappedFunction = function skipWrappedFunction() {\r\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\r\n    return new Kareem.skipWrappedFunction(...arguments);\r\n  }\r\n\r\n  this.args = [...arguments];\r\n};\r\n\r\nKareem.overwriteResult = function overwriteResult() {\r\n  if (!(this instanceof Kareem.overwriteResult)) {\r\n    return new Kareem.overwriteResult(...arguments);\r\n  }\r\n\r\n  this.args = [...arguments];\r\n};\r\n\r\n/**\r\n * Execute all \"pre\" hooks for \"name\"\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array|Function} args Optional arguments or directly the callback\r\n * @param {Function} [callback] The callback to call when executing all hooks are finished\r\n * @returns {void}\r\n */\r\nKareem.prototype.execPre = function(name, context, args, callback) {\r\n  if (arguments.length === 3) {\r\n    callback = args;\r\n    args = [];\r\n  }\r\n  const pres = this._pres.get(name) || [];\r\n  const numPres = pres.length;\r\n  const numAsyncPres = pres.numAsync || 0;\r\n  let currentPre = 0;\r\n  let asyncPresLeft = numAsyncPres;\r\n  let done = false;\r\n  const $args = args;\r\n  let shouldSkipWrappedFunction = null;\r\n\r\n  if (!numPres) {\r\n    return nextTick(function() {\r\n      callback(null);\r\n    });\r\n  }\r\n\r\n  function next() {\r\n    if (currentPre >= numPres) {\r\n      return;\r\n    }\r\n    const pre = pres[currentPre];\r\n\r\n    if (pre.isAsync) {\r\n      const args = [\r\n        decorateNextFn(_next),\r\n        decorateNextFn(function(error) {\r\n          if (error) {\r\n            if (done) {\r\n              return;\r\n            }\r\n            if (error instanceof Kareem.skipWrappedFunction) {\r\n              shouldSkipWrappedFunction = error;\r\n            } else {\r\n              done = true;\r\n              return callback(error);\r\n            }\r\n          }\r\n          if (--asyncPresLeft === 0 && currentPre >= numPres) {\r\n            return callback(shouldSkipWrappedFunction);\r\n          }\r\n        })\r\n      ];\r\n\r\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\r\n    } else if (pre.fn.length > 0) {\r\n      const args = [decorateNextFn(_next)];\r\n      const _args = arguments.length >= 2 ? arguments : [null].concat($args);\r\n      for (let i = 1; i < _args.length; ++i) {\r\n        args.push(_args[i]);\r\n      }\r\n\r\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\r\n    } else {\r\n      let maybePromiseLike = null;\r\n      try {\r\n        maybePromiseLike = pre.fn.call(context);\r\n      } catch (err) {\r\n        if (err != null) {\r\n          return callback(err);\r\n        }\r\n      }\r\n\r\n      if (isPromiseLike(maybePromiseLike)) {\r\n        maybePromiseLike.then(() => _next(), err => _next(err));\r\n      } else {\r\n        if (++currentPre >= numPres) {\r\n          if (asyncPresLeft > 0) {\r\n            // Leave parallel hooks to run\r\n            return;\r\n          } else {\r\n            return nextTick(function() {\r\n              callback(shouldSkipWrappedFunction);\r\n            });\r\n          }\r\n        }\r\n        next();\r\n      }\r\n    }\r\n  }\r\n\r\n  next.apply(null, [null].concat(args));\r\n\r\n  function _next(error) {\r\n    if (error) {\r\n      if (done) {\r\n        return;\r\n      }\r\n      if (error instanceof Kareem.skipWrappedFunction) {\r\n        shouldSkipWrappedFunction = error;\r\n      } else {\r\n        done = true;\r\n        return callback(error);\r\n      }\r\n    }\r\n\r\n    if (++currentPre >= numPres) {\r\n      if (asyncPresLeft > 0) {\r\n        // Leave parallel hooks to run\r\n        return;\r\n      } else {\r\n        return callback(shouldSkipWrappedFunction);\r\n      }\r\n    }\r\n\r\n    next.apply(context, arguments);\r\n  }\r\n};\r\n\r\n/**\r\n * Execute all \"pre\" hooks for \"name\" synchronously\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array} [args] Apply custom arguments to the hook\r\n * @returns {void}\r\n */\r\nKareem.prototype.execPreSync = function(name, context, args) {\r\n  const pres = this._pres.get(name) || [];\r\n  const numPres = pres.length;\r\n\r\n  for (let i = 0; i < numPres; ++i) {\r\n    pres[i].fn.apply(context, args || []);\r\n  }\r\n};\r\n\r\n/**\r\n * Execute all \"post\" hooks for \"name\"\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array|Function} args Apply custom arguments to the hook\r\n * @param {*} options Optional options or directly the callback\r\n * @param {Function} [callback] The callback to call when executing all hooks are finished\r\n * @returns {void}\r\n */\r\nKareem.prototype.execPost = function(name, context, args, options, callback) {\r\n  if (arguments.length < 5) {\r\n    callback = options;\r\n    options = null;\r\n  }\r\n  const posts = this._posts.get(name) || [];\r\n  const numPosts = posts.length;\r\n  let currentPost = 0;\r\n\r\n  let firstError = null;\r\n  if (options && options.error) {\r\n    firstError = options.error;\r\n  }\r\n\r\n  if (!numPosts) {\r\n    return nextTick(function() {\r\n      callback.apply(null, [firstError].concat(args));\r\n    });\r\n  }\r\n\r\n  function next() {\r\n    const post = posts[currentPost].fn;\r\n    let numArgs = 0;\r\n    const argLength = args.length;\r\n    const newArgs = [];\r\n    for (let i = 0; i < argLength; ++i) {\r\n      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\r\n      if (!args[i] || !args[i]._kareemIgnore) {\r\n        newArgs.push(args[i]);\r\n      }\r\n    }\r\n\r\n    if (firstError) {\r\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\r\n        const _cb = decorateNextFn(function(error) {\r\n          if (error) {\r\n            if (error instanceof Kareem.overwriteResult) {\r\n              args = error.args;\r\n              if (++currentPost >= numPosts) {\r\n                return callback.call(null, firstError);\r\n              }\r\n              return next();\r\n            }\r\n            firstError = error;\r\n          }\r\n          if (++currentPost >= numPosts) {\r\n            return callback.call(null, firstError);\r\n          }\r\n          next();\r\n        });\r\n\r\n        callMiddlewareFunction(post, context,\r\n          [firstError].concat(newArgs).concat([_cb]), _cb);\r\n      } else {\r\n        if (++currentPost >= numPosts) {\r\n          return callback.call(null, firstError);\r\n        }\r\n        next();\r\n      }\r\n    } else {\r\n      const _cb = decorateNextFn(function(error) {\r\n        if (error) {\r\n          if (error instanceof Kareem.overwriteResult) {\r\n            args = error.args;\r\n            if (++currentPost >= numPosts) {\r\n              return callback.apply(null, [null].concat(args));\r\n            }\r\n            return next();\r\n          }\r\n          firstError = error;\r\n          return next();\r\n        }\r\n\r\n        if (++currentPost >= numPosts) {\r\n          return callback.apply(null, [null].concat(args));\r\n        }\r\n\r\n        next();\r\n      });\r\n\r\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\r\n        // Skip error handlers if no error\r\n        if (++currentPost >= numPosts) {\r\n          return callback.apply(null, [null].concat(args));\r\n        }\r\n        return next();\r\n      }\r\n      if (post.length === numArgs + 1) {\r\n        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);\r\n      } else {\r\n        let error;\r\n        let maybePromiseLike;\r\n        try {\r\n          maybePromiseLike = post.apply(context, newArgs);\r\n        } catch (err) {\r\n          error = err;\r\n          firstError = err;\r\n        }\r\n\r\n        if (isPromiseLike(maybePromiseLike)) {\r\n          return maybePromiseLike.then(\r\n            (res) => {\r\n              _cb(res instanceof Kareem.overwriteResult ? res : null);\r\n            },\r\n            err => _cb(err)\r\n          );\r\n        }\r\n\r\n        if (maybePromiseLike instanceof Kareem.overwriteResult) {\r\n          args = maybePromiseLike.args;\r\n        }\r\n\r\n        if (++currentPost >= numPosts) {\r\n          return callback.apply(null, [error].concat(args));\r\n        }\r\n\r\n        next();\r\n      }\r\n    }\r\n  }\r\n\r\n  next();\r\n};\r\n\r\n/**\r\n * Execute all \"post\" hooks for \"name\" synchronously\r\n * @param {String} name The hook name to execute\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array|Function} args Apply custom arguments to the hook\r\n * @returns {Array} The used arguments\r\n */\r\nKareem.prototype.execPostSync = function(name, context, args) {\r\n  const posts = this._posts.get(name) || [];\r\n  const numPosts = posts.length;\r\n\r\n  for (let i = 0; i < numPosts; ++i) {\r\n    const res = posts[i].fn.apply(context, args || []);\r\n    if (res instanceof Kareem.overwriteResult) {\r\n      args = res.args;\r\n    }\r\n  }\r\n\r\n  return args;\r\n};\r\n\r\n/**\r\n * Create a synchronous wrapper for \"fn\"\r\n * @param {String} name The name of the hook\r\n * @param {Function} fn The function to wrap\r\n * @returns {Function} The wrapped function\r\n */\r\nKareem.prototype.createWrapperSync = function(name, fn) {\r\n  const _this = this;\r\n  return function syncWrapper() {\r\n    _this.execPreSync(name, this, arguments);\r\n\r\n    const toReturn = fn.apply(this, arguments);\r\n\r\n    const result = _this.execPostSync(name, this, [toReturn]);\r\n\r\n    return result[0];\r\n  };\r\n};\r\n\r\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\r\n  if (options.useErrorHandlers) {\r\n    return instance.execPost(name, context, args, { error: error }, function(error) {\r\n      return typeof callback === 'function' && callback(error);\r\n    });\r\n  } else {\r\n    return typeof callback === 'function' && callback(error);\r\n  }\r\n}\r\n\r\n/**\r\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\r\n * @param {String} name The name of the hook\r\n * @param {Function} fn The function for the hook\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Array} args Apply custom arguments to the hook\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.checkForPromise]\r\n * @returns {void}\r\n */\r\nKareem.prototype.wrap = function(name, fn, context, args, options) {\r\n  const lastArg = (args.length > 0 ? args[args.length - 1] : null);\r\n  const argsWithoutCb = Array.from(args);\r\n  typeof lastArg === 'function' && argsWithoutCb.pop();\r\n  const _this = this;\r\n\r\n  options = options || {};\r\n  const checkForPromise = options.checkForPromise;\r\n\r\n  this.execPre(name, context, args, function(error) {\r\n    if (error && !(error instanceof Kareem.skipWrappedFunction)) {\r\n      const numCallbackParams = options.numCallbackParams || 0;\r\n      const errorArgs = options.contextParameter ? [context] : [];\r\n      for (let i = errorArgs.length; i < numCallbackParams; ++i) {\r\n        errorArgs.push(null);\r\n      }\r\n      return _handleWrapError(_this, error, name, context, errorArgs,\r\n        options, lastArg);\r\n    }\r\n\r\n    const numParameters = fn.length;\r\n    let ret;\r\n\r\n    if (error instanceof Kareem.skipWrappedFunction) {\r\n      ret = error.args[0];\r\n      return _cb(null, ...error.args);\r\n    } else {\r\n      try {\r\n        ret = fn.apply(context, argsWithoutCb.concat(_cb));\r\n      } catch (err) {\r\n        return _cb(err);\r\n      }\r\n    }\r\n\r\n    if (checkForPromise) {\r\n      if (isPromiseLike(ret)) {\r\n        // Thenable, use it\r\n        return ret.then(\r\n          res => _cb(null, res),\r\n          err => _cb(err)\r\n        );\r\n      }\r\n\r\n      // If `fn()` doesn't have a callback argument and doesn't return a\r\n      // promise, assume it is sync\r\n      if (numParameters < argsWithoutCb.length + 1) {\r\n        return _cb(null, ret);\r\n      }\r\n    }\r\n\r\n    function _cb() {\r\n      const argsWithoutError = Array.from(arguments);\r\n      argsWithoutError.shift();\r\n      if (options.nullResultByDefault && argsWithoutError.length === 0) {\r\n        argsWithoutError.push(null);\r\n      }\r\n      if (arguments[0]) {\r\n        // Assume error\r\n        return _handleWrapError(_this, arguments[0], name, context,\r\n          argsWithoutError, options, lastArg);\r\n      } else {\r\n        _this.execPost(name, context, argsWithoutError, function() {\r\n          if (lastArg === null) {\r\n            return;\r\n          }\r\n          arguments[0]\r\n            ? lastArg(arguments[0])\r\n            : lastArg.apply(context, arguments);\r\n        });\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Filter current instance for something specific and return the filtered clone\r\n * @param {Function} fn The filter function\r\n * @returns {Kareem} The cloned and filtered instance\r\n */\r\nKareem.prototype.filter = function(fn) {\r\n  const clone = this.clone();\r\n\r\n  const pres = Array.from(clone._pres.keys());\r\n  for (const name of pres) {\r\n    const hooks = this._pres.get(name).\r\n      map(h => Object.assign({}, h, { name: name })).\r\n      filter(fn);\r\n\r\n    if (hooks.length === 0) {\r\n      clone._pres.delete(name);\r\n      continue;\r\n    }\r\n\r\n    hooks.numAsync = hooks.filter(h => h.isAsync).length;\r\n\r\n    clone._pres.set(name, hooks);\r\n  }\r\n\r\n  const posts = Array.from(clone._posts.keys());\r\n  for (const name of posts) {\r\n    const hooks = this._posts.get(name).\r\n      map(h => Object.assign({}, h, { name: name })).\r\n      filter(fn);\r\n\r\n    if (hooks.length === 0) {\r\n      clone._posts.delete(name);\r\n      continue;\r\n    }\r\n\r\n    clone._posts.set(name, hooks);\r\n  }\r\n\r\n  return clone;\r\n};\r\n\r\n/**\r\n * Check for a \"name\" to exist either in pre or post hooks\r\n * @param {String} name The name of the hook\r\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\r\n */\r\nKareem.prototype.hasHooks = function(name) {\r\n  return this._pres.has(name) || this._posts.has(name);\r\n};\r\n\r\n/**\r\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\r\n * @param {String} name The name of the hook\r\n * @param {Function} fn The function to wrap\r\n * @param {*} context Overwrite the \"this\" for the hook\r\n * @param {Object} [options]\r\n * @returns {Function} The wrapped function\r\n */\r\nKareem.prototype.createWrapper = function(name, fn, context, options) {\r\n  const _this = this;\r\n  if (!this.hasHooks(name)) {\r\n    // Fast path: if there's no hooks for this function, just return the\r\n    // function wrapped in a nextTick()\r\n    return function() {\r\n      nextTick(() => fn.apply(this, arguments));\r\n    };\r\n  }\r\n  return function() {\r\n    const _context = context || this;\r\n    _this.wrap(name, fn, _context, Array.from(arguments), options);\r\n  };\r\n};\r\n\r\n/**\r\n * Register a new hook for \"pre\"\r\n * @param {String} name The name of the hook\r\n * @param {Boolean} [isAsync]\r\n * @param {Function} fn The function to register for \"name\"\r\n * @param {never} error Unused\r\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\r\n * @returns {Kareem}\r\n */\r\nKareem.prototype.pre = function(name, isAsync, fn, error, unshift) {\r\n  let options = {};\r\n  if (typeof isAsync === 'object' && isAsync !== null) {\r\n    options = isAsync;\r\n    isAsync = options.isAsync;\r\n  } else if (typeof arguments[1] !== 'boolean') {\r\n    fn = isAsync;\r\n    isAsync = false;\r\n  }\r\n\r\n  const pres = this._pres.get(name) || [];\r\n  this._pres.set(name, pres);\r\n\r\n  if (isAsync) {\r\n    pres.numAsync = pres.numAsync || 0;\r\n    ++pres.numAsync;\r\n  }\r\n\r\n  if (typeof fn !== 'function') {\r\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\r\n  }\r\n\r\n  if (unshift) {\r\n    pres.unshift(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\r\n  } else {\r\n    pres.push(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Register a new hook for \"post\"\r\n * @param {String} name The name of the hook\r\n * @param {Object} [options]\r\n * @param {Function} fn The function to register for \"name\"\r\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\r\n * @returns {Kareem}\r\n */\r\nKareem.prototype.post = function(name, options, fn, unshift) {\r\n  const posts = this._posts.get(name) || [];\r\n\r\n  if (typeof options === 'function') {\r\n    unshift = !!fn;\r\n    fn = options;\r\n    options = {};\r\n  }\r\n\r\n  if (typeof fn !== 'function') {\r\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\r\n  }\r\n\r\n  if (unshift) {\r\n    posts.unshift(Object.assign({}, options, { fn: fn }));\r\n  } else {\r\n    posts.push(Object.assign({}, options, { fn: fn }));\r\n  }\r\n  this._posts.set(name, posts);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Clone the current instance\r\n * @returns {Kareem} The cloned instance\r\n */\r\nKareem.prototype.clone = function() {\r\n  const n = new Kareem();\r\n\r\n  for (const key of this._pres.keys()) {\r\n    const clone = this._pres.get(key).slice();\r\n    clone.numAsync = this._pres.get(key).numAsync;\r\n    n._pres.set(key, clone);\r\n  }\r\n  for (const key of this._posts.keys()) {\r\n    n._posts.set(key, this._posts.get(key).slice());\r\n  }\r\n\r\n  return n;\r\n};\r\n\r\n/**\r\n * Merge \"other\" into self or \"clone\"\r\n * @param {Kareem} other The instance to merge with\r\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\r\n * @returns {Kareem} The merged instance\r\n */\r\nKareem.prototype.merge = function(other, clone) {\r\n  clone = arguments.length === 1 ? true : clone;\r\n  const ret = clone ? this.clone() : this;\r\n\r\n  for (const key of other._pres.keys()) {\r\n    const sourcePres = ret._pres.get(key) || [];\r\n    const deduplicated = other._pres.get(key).\r\n      // Deduplicate based on `fn`\r\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\r\n    const combined = sourcePres.concat(deduplicated);\r\n    combined.numAsync = sourcePres.numAsync || 0;\r\n    combined.numAsync += deduplicated.filter(p => p.isAsync).length;\r\n    ret._pres.set(key, combined);\r\n  }\r\n  for (const key of other._posts.keys()) {\r\n    const sourcePosts = ret._posts.get(key) || [];\r\n    const deduplicated = other._posts.get(key).\r\n      filter(p => sourcePosts.indexOf(p) === -1);\r\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nfunction callMiddlewareFunction(fn, context, args, next) {\r\n  let maybePromiseLike;\r\n  try {\r\n    maybePromiseLike = fn.apply(context, args);\r\n  } catch (error) {\r\n    return next(error);\r\n  }\r\n\r\n  if (isPromiseLike(maybePromiseLike)) {\r\n    maybePromiseLike.then(() => next(), err => next(err));\r\n  }\r\n}\r\n\r\nfunction isPromiseLike(v) {\r\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\r\n}\r\n\r\nfunction decorateNextFn(fn) {\r\n  let called = false;\r\n  const _this = this;\r\n  return function() {\r\n    // Ensure this function can only be called once\r\n    if (called) {\r\n      return;\r\n    }\r\n    called = true;\r\n    // Make sure to clear the stack so try/catch doesn't catch errors\r\n    // in subsequent middleware\r\n    return nextTick(() => fn.apply(_this, arguments));\r\n  };\r\n}\r\n\r\nconst nextTick = typeof process === 'object' && process !== null && process.nextTick || function nextTick(cb) {\r\n  setTimeout(cb, 0);\r\n};\r\n\r\nfunction isErrorHandlingMiddleware(post, numArgs) {\r\n  if (post.errorHandler) {\r\n    return true;\r\n  }\r\n  return post.fn.length === numArgs + 2;\r\n}\r\n\r\nmodule.exports = Kareem;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}