{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\nconst exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\r\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\r\n * @internal\r\n */\nclass MapReduceOperation extends command_1.CommandOperation {\n  /**\r\n   * Constructs a MapReduce operation.\r\n   *\r\n   * @param collection - Collection instance.\r\n   * @param map - The mapping function.\r\n   * @param reduce - The reduce function.\r\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\r\n   */\n  constructor(collection, map, reduce, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    const mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    }\n    // Add any other options passed in\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n    options = Object.assign({}, options);\n    // If we have a read preference and inline is not set as output fail hard\n    if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = read_preference_1.ReadPreference.primary;\n      // Decorate command with writeConcern if supported\n      (0, utils_1.applyWriteConcern)(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n    }\n    // Is bypassDocumentValidation specified\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    // Have we specified collation\n    try {\n      (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n    if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n      return;\n    }\n    // Execute command\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err);\n      // Check if we have an error\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new error_1.MongoServerError(result));\n      }\n      // If an explain option was executed, don't process the server results\n      if (this.explain) return callback(undefined, result);\n      // Create statistics value\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing;\n      // invoked with inline?\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n        return callback(undefined, {\n          results: result.results,\n          stats: stats\n        });\n      }\n      // The returned collection\n      let collection = null;\n      // If we have an object it's a different db\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result;\n        // Return a collection from another db\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      }\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      }\n      // Return stats as third set of values\n      callback(err, {\n        collection,\n        stats\n      });\n    });\n  }\n}\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n  const newScope = {};\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n  return newScope;\n}\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":{"version":3,"mappings":"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","names":["exclusionList","MapReduceOperation","command_1","constructor","collection","map","reduce","options","execute","server","session","callback","coll","mapCommandHash","mapReduce","collectionName","scope","processScope","n","indexOf","Object","assign","readPreference","mode","read_preference_1","primary","out","inline","db","s","bypassDocumentValidation","err","explain","error_1","name","executeCommand","result","ok","errmsg","undefined","stats","timeMillis","counts","timing","results","doc","client","exports","_bsontype","newScope","key","keys","bson_1","String","operation_1","EXPLAINABLE"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongoose\\node_modules\\mongodb\\src\\operations\\map_reduce.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\r\nimport { Code, Document } from '../bson';\r\nimport type { Collection } from '../collection';\r\nimport { MongoCompatibilityError, MongoServerError } from '../error';\r\nimport { ReadPreference, ReadPreferenceMode } from '../read_preference';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Sort } from '../sort';\r\nimport {\r\n  applyWriteConcern,\r\n  Callback,\r\n  decorateWithCollation,\r\n  decorateWithReadConcern,\r\n  isObject,\r\n  maxWireVersion\r\n} from '../utils';\r\nimport { CommandOperation, CommandOperationOptions } from './command';\r\nimport { Aspect, defineAspects } from './operation';\r\n\r\nconst exclusionList = [\r\n  'explain',\r\n  'readPreference',\r\n  'readConcern',\r\n  'session',\r\n  'bypassDocumentValidation',\r\n  'writeConcern',\r\n  'raw',\r\n  'fieldsAsRaw',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'bsonRegExp',\r\n  'serializeFunctions',\r\n  'ignoreUndefined',\r\n  'enableUtf8Validation',\r\n  'scope' // this option is reformatted thus exclude the original\r\n];\r\n\r\n/** @public */\r\nexport type MapFunction<TSchema = Document> = (this: TSchema) => void;\r\n/** @public */\r\nexport type ReduceFunction<TKey = ObjectId, TValue = any> = (key: TKey, values: TValue[]) => TValue;\r\n/** @public */\r\nexport type FinalizeFunction<TKey = ObjectId, TValue = Document> = (\r\n  key: TKey,\r\n  reducedValue: TValue\r\n) => TValue;\r\n\r\n/** @public */\r\nexport interface MapReduceOptions<TKey = ObjectId, TValue = Document>\r\n  extends CommandOperationOptions {\r\n  /** Sets the output target for the map reduce job. */\r\n  out?: 'inline' | { inline: 1 } | { replace: string } | { merge: string } | { reduce: string };\r\n  /** Query filter object. */\r\n  query?: Document;\r\n  /** Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces. */\r\n  sort?: Sort;\r\n  /** Number of objects to return from collection. */\r\n  limit?: number;\r\n  /** Keep temporary data. */\r\n  keeptemp?: boolean;\r\n  /** Finalize function. */\r\n  finalize?: FinalizeFunction<TKey, TValue> | string;\r\n  /** Can pass in variables that can be access from map/reduce/finalize. */\r\n  scope?: Document;\r\n  /** It is possible to make the execution stay in JS. Provided in MongoDB \\> 2.0.X. */\r\n  jsMode?: boolean;\r\n  /** Provide statistics on job execution time. */\r\n  verbose?: boolean;\r\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\r\n  bypassDocumentValidation?: boolean;\r\n}\r\n\r\ninterface MapReduceStats {\r\n  processtime?: number;\r\n  counts?: number;\r\n  timing?: number;\r\n}\r\n\r\n/**\r\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\r\n * @internal\r\n */\r\nexport class MapReduceOperation extends CommandOperation<Document | Document[]> {\r\n  override options: MapReduceOptions;\r\n  collection: Collection;\r\n  /** The mapping function. */\r\n  map: MapFunction | string;\r\n  /** The reduce function. */\r\n  reduce: ReduceFunction | string;\r\n\r\n  /**\r\n   * Constructs a MapReduce operation.\r\n   *\r\n   * @param collection - Collection instance.\r\n   * @param map - The mapping function.\r\n   * @param reduce - The reduce function.\r\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\r\n   */\r\n  constructor(\r\n    collection: Collection,\r\n    map: MapFunction | string,\r\n    reduce: ReduceFunction | string,\r\n    options?: MapReduceOptions\r\n  ) {\r\n    super(collection, options);\r\n\r\n    this.options = options ?? {};\r\n    this.collection = collection;\r\n    this.map = map;\r\n    this.reduce = reduce;\r\n  }\r\n\r\n  override execute(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document | Document[]>\r\n  ): void {\r\n    const coll = this.collection;\r\n    const map = this.map;\r\n    const reduce = this.reduce;\r\n    let options = this.options;\r\n\r\n    const mapCommandHash: Document = {\r\n      mapReduce: coll.collectionName,\r\n      map: map,\r\n      reduce: reduce\r\n    };\r\n\r\n    if (options.scope) {\r\n      mapCommandHash.scope = processScope(options.scope);\r\n    }\r\n\r\n    // Add any other options passed in\r\n    for (const n in options) {\r\n      // Only include if not in exclusion list\r\n      if (exclusionList.indexOf(n) === -1) {\r\n        mapCommandHash[n] = (options as any)[n];\r\n      }\r\n    }\r\n\r\n    options = Object.assign({}, options);\r\n\r\n    // If we have a read preference and inline is not set as output fail hard\r\n    if (\r\n      this.readPreference.mode === ReadPreferenceMode.primary &&\r\n      options.out &&\r\n      (options.out as any).inline !== 1 &&\r\n      options.out !== 'inline'\r\n    ) {\r\n      // Force readPreference to primary\r\n      options.readPreference = ReadPreference.primary;\r\n      // Decorate command with writeConcern if supported\r\n      applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);\r\n    } else {\r\n      decorateWithReadConcern(mapCommandHash, coll, options);\r\n    }\r\n\r\n    // Is bypassDocumentValidation specified\r\n    if (options.bypassDocumentValidation === true) {\r\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\r\n    }\r\n\r\n    // Have we specified collation\r\n    try {\r\n      decorateWithCollation(mapCommandHash, coll, options);\r\n    } catch (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    if (this.explain && maxWireVersion(server) < 9) {\r\n      callback(\r\n        new MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`)\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Execute command\r\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\r\n      if (err) return callback(err);\r\n      // Check if we have an error\r\n      if (1 !== result.ok || result.err || result.errmsg) {\r\n        return callback(new MongoServerError(result));\r\n      }\r\n\r\n      // If an explain option was executed, don't process the server results\r\n      if (this.explain) return callback(undefined, result);\r\n\r\n      // Create statistics value\r\n      const stats: MapReduceStats = {};\r\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\r\n      if (result.counts) stats['counts'] = result.counts;\r\n      if (result.timing) stats['timing'] = result.timing;\r\n\r\n      // invoked with inline?\r\n      if (result.results) {\r\n        // If we wish for no verbosity\r\n        if (options['verbose'] == null || !options['verbose']) {\r\n          return callback(undefined, result.results);\r\n        }\r\n\r\n        return callback(undefined, { results: result.results, stats: stats });\r\n      }\r\n\r\n      // The returned collection\r\n      let collection = null;\r\n\r\n      // If we have an object it's a different db\r\n      if (result.result != null && typeof result.result === 'object') {\r\n        const doc = result.result;\r\n        // Return a collection from another db\r\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\r\n      } else {\r\n        // Create a collection object that wraps the result collection\r\n        collection = coll.s.db.collection(result.result);\r\n      }\r\n\r\n      // If we wish for no verbosity\r\n      if (options['verbose'] == null || !options['verbose']) {\r\n        return callback(err, collection);\r\n      }\r\n\r\n      // Return stats as third set of values\r\n      callback(err, { collection, stats });\r\n    });\r\n  }\r\n}\r\n\r\n/** Functions that are passed as scope args must be converted to Code instances. */\r\nfunction processScope(scope: Document | ObjectId) {\r\n  if (!isObject(scope) || (scope as any)._bsontype === 'ObjectID') {\r\n    return scope;\r\n  }\r\n\r\n  const newScope: Document = {};\r\n\r\n  for (const key of Object.keys(scope)) {\r\n    if ('function' === typeof (scope as Document)[key]) {\r\n      newScope[key] = new Code(String((scope as Document)[key]));\r\n    } else if ((scope as Document)[key]._bsontype === 'Code') {\r\n      newScope[key] = (scope as Document)[key];\r\n    } else {\r\n      newScope[key] = processScope((scope as Document)[key]);\r\n    }\r\n  }\r\n\r\n  return newScope;\r\n}\r\n\r\ndefineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}