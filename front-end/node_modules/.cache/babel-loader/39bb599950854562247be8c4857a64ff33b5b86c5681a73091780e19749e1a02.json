{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObjectId = void 0;\nvar buffer_1 = require(\"buffer\");\nvar ensure_buffer_1 = require(\"./ensure_buffer\");\nvar error_1 = require(\"./error\");\nvar utils_1 = require(\"./parser/utils\");\n// Regular expression that checks for hex value\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\n// Unique sequence for the current process (initialized on first use)\nvar PROCESS_UNIQUE = null;\nvar kId = Symbol('id');\n/**\r\n * A class representation of the BSON ObjectId type.\r\n * @public\r\n * @category BSONType\r\n */\nvar ObjectId = /** @class */function () {\n  /**\r\n   * Create an ObjectId type\r\n   *\r\n   * @param inputId - Can be a 24 character hex string, 12 byte binary Buffer, or a number.\r\n   */\n  function ObjectId(inputId) {\n    if (!(this instanceof ObjectId)) return new ObjectId(inputId);\n    // workingId is set based on type of input and whether valid id exists for the input\n    var workingId;\n    if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n      if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n        throw new error_1.BSONTypeError('Argument passed in must have an id that is of type string or Buffer');\n      }\n      if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n        workingId = buffer_1.Buffer.from(inputId.toHexString(), 'hex');\n      } else {\n        workingId = inputId.id;\n      }\n    } else {\n      workingId = inputId;\n    }\n    // the following cases use workingId to construct an ObjectId\n    if (workingId == null || typeof workingId === 'number') {\n      // The most common use case (blank id, new objectId instance)\n      // Generate a new id\n      this[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n      // If intstanceof matches we can escape calling ensure buffer in Node.js environments\n      this[kId] = workingId instanceof buffer_1.Buffer ? workingId : (0, ensure_buffer_1.ensureBuffer)(workingId);\n    } else if (typeof workingId === 'string') {\n      if (workingId.length === 12) {\n        var bytes = buffer_1.Buffer.from(workingId);\n        if (bytes.byteLength === 12) {\n          this[kId] = bytes;\n        } else {\n          throw new error_1.BSONTypeError('Argument passed in must be a string of 12 bytes');\n        }\n      } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n        this[kId] = buffer_1.Buffer.from(workingId, 'hex');\n      } else {\n        throw new error_1.BSONTypeError('Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer');\n      }\n    } else {\n      throw new error_1.BSONTypeError('Argument passed in does not match the accepted types');\n    }\n    // If we are caching the hex string\n    if (ObjectId.cacheHexString) {\n      this.__id = this.id.toString('hex');\n    }\n  }\n  Object.defineProperty(ObjectId.prototype, \"id\", {\n    /**\r\n     * The ObjectId bytes\r\n     * @readonly\r\n     */\n    get: function () {\n      return this[kId];\n    },\n    set: function (value) {\n      this[kId] = value;\n      if (ObjectId.cacheHexString) {\n        this.__id = value.toString('hex');\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ObjectId.prototype, \"generationTime\", {\n    /**\r\n     * The generation time of this ObjectId instance\r\n     * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch\r\n     */\n    get: function () {\n      return this.id.readInt32BE(0);\n    },\n    set: function (value) {\n      // Encode time into first 4 bytes\n      this.id.writeUInt32BE(value, 0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Returns the ObjectId id as a 24 character hex string representation */\n  ObjectId.prototype.toHexString = function () {\n    if (ObjectId.cacheHexString && this.__id) {\n      return this.__id;\n    }\n    var hexString = this.id.toString('hex');\n    if (ObjectId.cacheHexString && !this.__id) {\n      this.__id = hexString;\n    }\n    return hexString;\n  };\n  /**\r\n   * Update the ObjectId index\r\n   * @privateRemarks\r\n   * Used in generating new ObjectId's on the driver\r\n   * @internal\r\n   */\n  ObjectId.getInc = function () {\n    return ObjectId.index = (ObjectId.index + 1) % 0xffffff;\n  };\n  /**\r\n   * Generate a 12 byte id buffer used in ObjectId's\r\n   *\r\n   * @param time - pass in a second based timestamp.\r\n   */\n  ObjectId.generate = function (time) {\n    if ('number' !== typeof time) {\n      time = Math.floor(Date.now() / 1000);\n    }\n    var inc = ObjectId.getInc();\n    var buffer = buffer_1.Buffer.alloc(12);\n    // 4-byte timestamp\n    buffer.writeUInt32BE(time, 0);\n    // set PROCESS_UNIQUE if yet not initialized\n    if (PROCESS_UNIQUE === null) {\n      PROCESS_UNIQUE = (0, utils_1.randomBytes)(5);\n    }\n    // 5-byte process unique\n    buffer[4] = PROCESS_UNIQUE[0];\n    buffer[5] = PROCESS_UNIQUE[1];\n    buffer[6] = PROCESS_UNIQUE[2];\n    buffer[7] = PROCESS_UNIQUE[3];\n    buffer[8] = PROCESS_UNIQUE[4];\n    // 3-byte counter\n    buffer[11] = inc & 0xff;\n    buffer[10] = inc >> 8 & 0xff;\n    buffer[9] = inc >> 16 & 0xff;\n    return buffer;\n  };\n  /**\r\n   * Converts the id into a 24 character hex string for printing\r\n   *\r\n   * @param format - The Buffer toString format parameter.\r\n   */\n  ObjectId.prototype.toString = function (format) {\n    // Is the id a buffer then use the buffer toString method to return the format\n    if (format) return this.id.toString(format);\n    return this.toHexString();\n  };\n  /** Converts to its JSON the 24 character hex string representation. */\n  ObjectId.prototype.toJSON = function () {\n    return this.toHexString();\n  };\n  /**\r\n   * Compares the equality of this ObjectId with `otherID`.\r\n   *\r\n   * @param otherId - ObjectId instance to compare against.\r\n   */\n  ObjectId.prototype.equals = function (otherId) {\n    if (otherId === undefined || otherId === null) {\n      return false;\n    }\n    if (otherId instanceof ObjectId) {\n      return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);\n    }\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12 && (0, utils_1.isUint8Array)(this.id)) {\n      return otherId === buffer_1.Buffer.prototype.toString.call(this.id, 'latin1');\n    }\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {\n      return otherId.toLowerCase() === this.toHexString();\n    }\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {\n      return buffer_1.Buffer.from(otherId).equals(this.id);\n    }\n    if (typeof otherId === 'object' && 'toHexString' in otherId && typeof otherId.toHexString === 'function') {\n      var otherIdString = otherId.toHexString();\n      var thisIdString = this.toHexString().toLowerCase();\n      return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n    }\n    return false;\n  };\n  /** Returns the generation date (accurate up to the second) that this ID was generated. */\n  ObjectId.prototype.getTimestamp = function () {\n    var timestamp = new Date();\n    var time = this.id.readUInt32BE(0);\n    timestamp.setTime(Math.floor(time) * 1000);\n    return timestamp;\n  };\n  /** @internal */\n  ObjectId.createPk = function () {\n    return new ObjectId();\n  };\n  /**\r\n   * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\r\n   *\r\n   * @param time - an integer number representing a number of seconds.\r\n   */\n  ObjectId.createFromTime = function (time) {\n    var buffer = buffer_1.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    // Encode time into first 4 bytes\n    buffer.writeUInt32BE(time, 0);\n    // Return the new objectId\n    return new ObjectId(buffer);\n  };\n  /**\r\n   * Creates an ObjectId from a hex string representation of an ObjectId.\r\n   *\r\n   * @param hexString - create a ObjectId from a passed in 24 character hexstring.\r\n   */\n  ObjectId.createFromHexString = function (hexString) {\n    // Throw an error if it's not a valid setup\n    if (typeof hexString === 'undefined' || hexString != null && hexString.length !== 24) {\n      throw new error_1.BSONTypeError('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n    }\n    return new ObjectId(buffer_1.Buffer.from(hexString, 'hex'));\n  };\n  /**\r\n   * Checks if a value is a valid bson ObjectId\r\n   *\r\n   * @param id - ObjectId instance to validate.\r\n   */\n  ObjectId.isValid = function (id) {\n    if (id == null) return false;\n    try {\n      new ObjectId(id);\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  };\n  /** @internal */\n  ObjectId.prototype.toExtendedJSON = function () {\n    if (this.toHexString) return {\n      $oid: this.toHexString()\n    };\n    return {\n      $oid: this.toString('hex')\n    };\n  };\n  /** @internal */\n  ObjectId.fromExtendedJSON = function (doc) {\n    return new ObjectId(doc.$oid);\n  };\n  /**\r\n   * Converts to a string representation of this Id.\r\n   *\r\n   * @returns return the 24 character hex string representation.\r\n   * @internal\r\n   */\n  ObjectId.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {\n    return this.inspect();\n  };\n  ObjectId.prototype.inspect = function () {\n    return \"new ObjectId(\\\"\".concat(this.toHexString(), \"\\\")\");\n  };\n  /** @internal */\n  ObjectId.index = Math.floor(Math.random() * 0xffffff);\n  return ObjectId;\n}();\nexports.ObjectId = ObjectId;\n// Deprecated methods\nObject.defineProperty(ObjectId.prototype, 'generate', {\n  value: (0, utils_1.deprecate)(function (time) {\n    return ObjectId.generate(time);\n  }, 'Please use the static `ObjectId.generate(time)` instead')\n});\nObject.defineProperty(ObjectId.prototype, 'getInc', {\n  value: (0, utils_1.deprecate)(function () {\n    return ObjectId.getInc();\n  }, 'Please use the static `ObjectId.getInc()` instead')\n});\nObject.defineProperty(ObjectId.prototype, 'get_inc', {\n  value: (0, utils_1.deprecate)(function () {\n    return ObjectId.getInc();\n  }, 'Please use the static `ObjectId.getInc()` instead')\n});\nObject.defineProperty(ObjectId, 'get_inc', {\n  value: (0, utils_1.deprecate)(function () {\n    return ObjectId.getInc();\n  }, 'Please use the static `ObjectId.getInc()` instead')\n});\nObject.defineProperty(ObjectId.prototype, '_bsontype', {\n  value: 'ObjectID'\n});","map":{"version":3,"mappings":"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","names":["checkForHexRegExp","RegExp","PROCESS_UNIQUE","kId","Symbol","inputId","ObjectId","workingId","id","ArrayBuffer","isView","error_1","toHexString","buffer_1","from","generate","undefined","byteLength","length","bytes","test","cacheHexString","__id","toString","Object","value","readInt32BE","writeUInt32BE","hexString","index","time","Math","floor","Date","now","inc","getInc","buffer","alloc","format","otherId","equals","isValid","prototype","call","toLowerCase","otherIdString","thisIdString","timestamp","readUInt32BE","setTime","$oid","doc","for","inspect","random","exports","defineProperty"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\bson\\src\\objectid.ts"],"sourcesContent":["import { Buffer } from 'buffer';\r\nimport { ensureBuffer } from './ensure_buffer';\r\nimport { BSONTypeError } from './error';\r\nimport { deprecate, isUint8Array, randomBytes } from './parser/utils';\r\n\r\n// Regular expression that checks for hex value\r\nconst checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\r\n\r\n// Unique sequence for the current process (initialized on first use)\r\nlet PROCESS_UNIQUE: Uint8Array | null = null;\r\n\r\n/** @public */\r\nexport interface ObjectIdLike {\r\n  id: string | Buffer;\r\n  __id?: string;\r\n  toHexString(): string;\r\n}\r\n\r\n/** @public */\r\nexport interface ObjectIdExtended {\r\n  $oid: string;\r\n}\r\n\r\nconst kId = Symbol('id');\r\n\r\n/**\r\n * A class representation of the BSON ObjectId type.\r\n * @public\r\n * @category BSONType\r\n */\r\nexport class ObjectId {\r\n  _bsontype!: 'ObjectID';\r\n\r\n  /** @internal */\r\n  static index = Math.floor(Math.random() * 0xffffff);\r\n\r\n  static cacheHexString: boolean;\r\n\r\n  /** ObjectId Bytes @internal */\r\n  private [kId]!: Buffer;\r\n  /** ObjectId hexString cache @internal */\r\n  private __id?: string;\r\n\r\n  /**\r\n   * Create an ObjectId type\r\n   *\r\n   * @param inputId - Can be a 24 character hex string, 12 byte binary Buffer, or a number.\r\n   */\r\n  constructor(inputId?: string | number | ObjectId | ObjectIdLike | Buffer | Uint8Array) {\r\n    if (!(this instanceof ObjectId)) return new ObjectId(inputId);\r\n\r\n    // workingId is set based on type of input and whether valid id exists for the input\r\n    let workingId;\r\n    if (typeof inputId === 'object' && inputId && 'id' in inputId) {\r\n      if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\r\n        throw new BSONTypeError(\r\n          'Argument passed in must have an id that is of type string or Buffer'\r\n        );\r\n      }\r\n      if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\r\n        workingId = Buffer.from(inputId.toHexString(), 'hex');\r\n      } else {\r\n        workingId = inputId.id;\r\n      }\r\n    } else {\r\n      workingId = inputId;\r\n    }\r\n\r\n    // the following cases use workingId to construct an ObjectId\r\n    if (workingId == null || typeof workingId === 'number') {\r\n      // The most common use case (blank id, new objectId instance)\r\n      // Generate a new id\r\n      this[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\r\n    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\r\n      // If intstanceof matches we can escape calling ensure buffer in Node.js environments\r\n      this[kId] = workingId instanceof Buffer ? workingId : ensureBuffer(workingId);\r\n    } else if (typeof workingId === 'string') {\r\n      if (workingId.length === 12) {\r\n        const bytes = Buffer.from(workingId);\r\n        if (bytes.byteLength === 12) {\r\n          this[kId] = bytes;\r\n        } else {\r\n          throw new BSONTypeError('Argument passed in must be a string of 12 bytes');\r\n        }\r\n      } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\r\n        this[kId] = Buffer.from(workingId, 'hex');\r\n      } else {\r\n        throw new BSONTypeError(\r\n          'Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer'\r\n        );\r\n      }\r\n    } else {\r\n      throw new BSONTypeError('Argument passed in does not match the accepted types');\r\n    }\r\n    // If we are caching the hex string\r\n    if (ObjectId.cacheHexString) {\r\n      this.__id = this.id.toString('hex');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The ObjectId bytes\r\n   * @readonly\r\n   */\r\n  get id(): Buffer {\r\n    return this[kId];\r\n  }\r\n\r\n  set id(value: Buffer) {\r\n    this[kId] = value;\r\n    if (ObjectId.cacheHexString) {\r\n      this.__id = value.toString('hex');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The generation time of this ObjectId instance\r\n   * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch\r\n   */\r\n  get generationTime(): number {\r\n    return this.id.readInt32BE(0);\r\n  }\r\n\r\n  set generationTime(value: number) {\r\n    // Encode time into first 4 bytes\r\n    this.id.writeUInt32BE(value, 0);\r\n  }\r\n\r\n  /** Returns the ObjectId id as a 24 character hex string representation */\r\n  toHexString(): string {\r\n    if (ObjectId.cacheHexString && this.__id) {\r\n      return this.__id;\r\n    }\r\n\r\n    const hexString = this.id.toString('hex');\r\n\r\n    if (ObjectId.cacheHexString && !this.__id) {\r\n      this.__id = hexString;\r\n    }\r\n\r\n    return hexString;\r\n  }\r\n\r\n  /**\r\n   * Update the ObjectId index\r\n   * @privateRemarks\r\n   * Used in generating new ObjectId's on the driver\r\n   * @internal\r\n   */\r\n  static getInc(): number {\r\n    return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);\r\n  }\r\n\r\n  /**\r\n   * Generate a 12 byte id buffer used in ObjectId's\r\n   *\r\n   * @param time - pass in a second based timestamp.\r\n   */\r\n  static generate(time?: number): Buffer {\r\n    if ('number' !== typeof time) {\r\n      time = Math.floor(Date.now() / 1000);\r\n    }\r\n\r\n    const inc = ObjectId.getInc();\r\n    const buffer = Buffer.alloc(12);\r\n\r\n    // 4-byte timestamp\r\n    buffer.writeUInt32BE(time, 0);\r\n\r\n    // set PROCESS_UNIQUE if yet not initialized\r\n    if (PROCESS_UNIQUE === null) {\r\n      PROCESS_UNIQUE = randomBytes(5);\r\n    }\r\n\r\n    // 5-byte process unique\r\n    buffer[4] = PROCESS_UNIQUE[0];\r\n    buffer[5] = PROCESS_UNIQUE[1];\r\n    buffer[6] = PROCESS_UNIQUE[2];\r\n    buffer[7] = PROCESS_UNIQUE[3];\r\n    buffer[8] = PROCESS_UNIQUE[4];\r\n\r\n    // 3-byte counter\r\n    buffer[11] = inc & 0xff;\r\n    buffer[10] = (inc >> 8) & 0xff;\r\n    buffer[9] = (inc >> 16) & 0xff;\r\n\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Converts the id into a 24 character hex string for printing\r\n   *\r\n   * @param format - The Buffer toString format parameter.\r\n   */\r\n  toString(format?: string): string {\r\n    // Is the id a buffer then use the buffer toString method to return the format\r\n    if (format) return this.id.toString(format);\r\n    return this.toHexString();\r\n  }\r\n\r\n  /** Converts to its JSON the 24 character hex string representation. */\r\n  toJSON(): string {\r\n    return this.toHexString();\r\n  }\r\n\r\n  /**\r\n   * Compares the equality of this ObjectId with `otherID`.\r\n   *\r\n   * @param otherId - ObjectId instance to compare against.\r\n   */\r\n  equals(otherId: string | ObjectId | ObjectIdLike): boolean {\r\n    if (otherId === undefined || otherId === null) {\r\n      return false;\r\n    }\r\n\r\n    if (otherId instanceof ObjectId) {\r\n      return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);\r\n    }\r\n\r\n    if (\r\n      typeof otherId === 'string' &&\r\n      ObjectId.isValid(otherId) &&\r\n      otherId.length === 12 &&\r\n      isUint8Array(this.id)\r\n    ) {\r\n      return otherId === Buffer.prototype.toString.call(this.id, 'latin1');\r\n    }\r\n\r\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {\r\n      return otherId.toLowerCase() === this.toHexString();\r\n    }\r\n\r\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {\r\n      return Buffer.from(otherId).equals(this.id);\r\n    }\r\n\r\n    if (\r\n      typeof otherId === 'object' &&\r\n      'toHexString' in otherId &&\r\n      typeof otherId.toHexString === 'function'\r\n    ) {\r\n      const otherIdString = otherId.toHexString();\r\n      const thisIdString = this.toHexString().toLowerCase();\r\n      return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Returns the generation date (accurate up to the second) that this ID was generated. */\r\n  getTimestamp(): Date {\r\n    const timestamp = new Date();\r\n    const time = this.id.readUInt32BE(0);\r\n    timestamp.setTime(Math.floor(time) * 1000);\r\n    return timestamp;\r\n  }\r\n\r\n  /** @internal */\r\n  static createPk(): ObjectId {\r\n    return new ObjectId();\r\n  }\r\n\r\n  /**\r\n   * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\r\n   *\r\n   * @param time - an integer number representing a number of seconds.\r\n   */\r\n  static createFromTime(time: number): ObjectId {\r\n    const buffer = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n    // Encode time into first 4 bytes\r\n    buffer.writeUInt32BE(time, 0);\r\n    // Return the new objectId\r\n    return new ObjectId(buffer);\r\n  }\r\n\r\n  /**\r\n   * Creates an ObjectId from a hex string representation of an ObjectId.\r\n   *\r\n   * @param hexString - create a ObjectId from a passed in 24 character hexstring.\r\n   */\r\n  static createFromHexString(hexString: string): ObjectId {\r\n    // Throw an error if it's not a valid setup\r\n    if (typeof hexString === 'undefined' || (hexString != null && hexString.length !== 24)) {\r\n      throw new BSONTypeError(\r\n        'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\r\n      );\r\n    }\r\n\r\n    return new ObjectId(Buffer.from(hexString, 'hex'));\r\n  }\r\n\r\n  /**\r\n   * Checks if a value is a valid bson ObjectId\r\n   *\r\n   * @param id - ObjectId instance to validate.\r\n   */\r\n  static isValid(id: string | number | ObjectId | ObjectIdLike | Buffer | Uint8Array): boolean {\r\n    if (id == null) return false;\r\n\r\n    try {\r\n      new ObjectId(id);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  toExtendedJSON(): ObjectIdExtended {\r\n    if (this.toHexString) return { $oid: this.toHexString() };\r\n    return { $oid: this.toString('hex') };\r\n  }\r\n\r\n  /** @internal */\r\n  static fromExtendedJSON(doc: ObjectIdExtended): ObjectId {\r\n    return new ObjectId(doc.$oid);\r\n  }\r\n\r\n  /**\r\n   * Converts to a string representation of this Id.\r\n   *\r\n   * @returns return the 24 character hex string representation.\r\n   * @internal\r\n   */\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    return `new ObjectId(\"${this.toHexString()}\")`;\r\n  }\r\n}\r\n\r\n// Deprecated methods\r\nObject.defineProperty(ObjectId.prototype, 'generate', {\r\n  value: deprecate(\r\n    (time: number) => ObjectId.generate(time),\r\n    'Please use the static `ObjectId.generate(time)` instead'\r\n  )\r\n});\r\n\r\nObject.defineProperty(ObjectId.prototype, 'getInc', {\r\n  value: deprecate(() => ObjectId.getInc(), 'Please use the static `ObjectId.getInc()` instead')\r\n});\r\n\r\nObject.defineProperty(ObjectId.prototype, 'get_inc', {\r\n  value: deprecate(() => ObjectId.getInc(), 'Please use the static `ObjectId.getInc()` instead')\r\n});\r\n\r\nObject.defineProperty(ObjectId, 'get_inc', {\r\n  value: deprecate(() => ObjectId.getInc(), 'Please use the static `ObjectId.getInc()` instead')\r\n});\r\n\r\nObject.defineProperty(ObjectId.prototype, '_bsontype', { value: 'ObjectID' });\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}