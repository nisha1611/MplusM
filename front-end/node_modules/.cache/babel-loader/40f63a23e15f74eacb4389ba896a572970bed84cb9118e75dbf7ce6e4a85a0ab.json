{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst {\n  topLevelSymbolTag\n} = InnerGraph;\nclass InnerGraphPlugin {\n  /**\r\n   * Apply the plugin\r\n   * @param {Compiler} compiler the compiler instance\r\n   * @returns {void}\r\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"InnerGraphPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      const logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n      compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template());\n\n      /**\r\n       * @param {JavascriptParser} parser the parser\r\n       * @param {Object} parserOptions options\r\n       * @returns {void}\r\n       */\n      const handler = (parser, parserOptions) => {\n        const onUsageSuper = sup => {\n          InnerGraph.onUsage(parser.state, usedByExports => {\n            switch (usedByExports) {\n              case undefined:\n              case true:\n                return;\n              default:\n                {\n                  const dep = new PureExpressionDependency(sup.range);\n                  dep.loc = sup.loc;\n                  dep.usedByExports = usedByExports;\n                  parser.state.module.addDependency(dep);\n                  break;\n                }\n            }\n          });\n        };\n        parser.hooks.program.tap(\"InnerGraphPlugin\", () => {\n          InnerGraph.enable(parser.state);\n        });\n        parser.hooks.finish.tap(\"InnerGraphPlugin\", () => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          logger.time(\"infer dependency usage\");\n          InnerGraph.inferDependencyUsage(parser.state);\n          logger.timeAggregate(\"infer dependency usage\");\n        });\n\n        // During prewalking the following datastructures are filled with\n        // nodes that have a TopLevelSymbol assigned and\n        // variables are tagged with the assigned TopLevelSymbol\n\n        // We differ 3 types of nodes:\n        // 1. full statements (export default, function declaration)\n        // 2. classes (class declaration, class expression)\n        // 3. variable declarators (const x = ...)\n\n        /** @type {WeakMap<Node, TopLevelSymbol>} */\n        const statementWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<Node, Node>} */\n        const statementPurePart = new WeakMap();\n\n        /** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n        const classWithTopLevelSymbol = new WeakMap();\n\n        /** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n        const declWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakSet<VariableDeclaratorNode>} */\n        const pureDeclarators = new WeakSet();\n\n        // The following hooks are used during prewalking:\n\n        parser.hooks.preStatement.tap(\"InnerGraphPlugin\", statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"FunctionDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              statementWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n          }\n        });\n        parser.hooks.blockPreStatement.tap(\"InnerGraphPlugin\", statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"ClassDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n            if (statement.type === \"ExportDefaultDeclaration\") {\n              const name = \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              const decl = statement.declaration;\n              if (decl.type === \"ClassExpression\" || decl.type === \"ClassDeclaration\") {\n                classWithTopLevelSymbol.set(decl, fn);\n              } else if (parser.isPure(decl, statement.range[0])) {\n                statementWithTopLevelSymbol.set(statement, fn);\n                if (!decl.type.endsWith(\"FunctionExpression\") && !decl.type.endsWith(\"Declaration\") && decl.type !== \"Literal\") {\n                  statementPurePart.set(statement, decl);\n                }\n              }\n            }\n          }\n        });\n        parser.hooks.preDeclarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true && decl.init && decl.id.type === \"Identifier\") {\n            const name = decl.id.name;\n            if (decl.init.type === \"ClassExpression\") {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(decl.init, fn);\n            } else if (parser.isPure(decl.init, decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              declWithTopLevelSymbol.set(decl, fn);\n              if (!decl.init.type.endsWith(\"FunctionExpression\") && decl.init.type !== \"Literal\") {\n                pureDeclarators.add(decl);\n              }\n              return true;\n            }\n          }\n        });\n\n        // During real walking we set the TopLevelSymbol state to the assigned\n        // TopLevelSymbol by using the fill datastructures.\n\n        // In addition to tracking TopLevelSymbols, we sometimes need to\n        // add a PureExpressionDependency. This is needed to skip execution\n        // of pure expressions, even when they are not dropped due to\n        // minimizing. Otherwise symbols used there might not exist anymore\n        // as they are removed as unused by this optimization\n\n        // When we find a reference to a TopLevelSymbol, we register a\n        // TopLevelSymbol dependency from TopLevelSymbol in state to the\n        // referenced TopLevelSymbol. This way we get a graph of all\n        // TopLevelSymbols.\n\n        // The following hooks are called during walking:\n\n        parser.hooks.statement.tap(\"InnerGraphPlugin\", statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            const fn = statementWithTopLevelSymbol.get(statement);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              const purePart = statementPurePart.get(statement);\n              if (purePart) {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(purePart.range);\n                        dep.loc = statement.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n          }\n        });\n        parser.hooks.classExtendsExpression.tap(\"InnerGraphPlugin\", (expr, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(statement);\n            if (fn && parser.isPure(expr, statement.id ? statement.id.range[1] : statement.range[0])) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              onUsageSuper(expr);\n            }\n          }\n        });\n        parser.hooks.classBodyElement.tap(\"InnerGraphPlugin\", (element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            }\n          }\n        });\n        parser.hooks.classBodyValue.tap(\"InnerGraphPlugin\", (expression, element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n            if (fn) {\n              if (!element.static || parser.isPure(expression, element.key ? element.key.range[1] : element.range[0])) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n                if (element.type !== \"MethodDefinition\" && element.static) {\n                  InnerGraph.onUsage(parser.state, usedByExports => {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n                      default:\n                        {\n                          const dep = new PureExpressionDependency(expression.range);\n                          dep.loc = expression.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              } else {\n                InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              }\n            }\n          }\n        });\n        parser.hooks.declarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          const fn = declWithTopLevelSymbol.get(decl);\n          if (fn) {\n            InnerGraph.setTopLevelSymbol(parser.state, fn);\n            if (pureDeclarators.has(decl)) {\n              if (decl.init.type === \"ClassExpression\") {\n                if (decl.init.superClass) {\n                  onUsageSuper(decl.init.superClass);\n                }\n              } else {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(decl.init.range);\n                        dep.loc = decl.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n            parser.walkExpression(decl.init);\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            return true;\n          }\n        });\n        parser.hooks.expression.for(topLevelSymbolTag).tap(\"InnerGraphPlugin\", () => {\n          const topLevelSymbol = /** @type {TopLevelSymbol} */\n          parser.currentTagData;\n          const currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);\n          InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || true);\n        });\n        parser.hooks.assign.for(topLevelSymbolTag).tap(\"InnerGraphPlugin\", expr => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (expr.operator === \"=\") return true;\n        });\n      };\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"InnerGraphPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"InnerGraphPlugin\", handler);\n      compilation.hooks.finishModules.tap(\"InnerGraphPlugin\", () => {\n        logger.timeAggregateEnd(\"infer dependency usage\");\n      });\n    });\n  }\n}\nmodule.exports = InnerGraphPlugin;","map":{"version":3,"names":["PureExpressionDependency","require","InnerGraph","topLevelSymbolTag","InnerGraphPlugin","apply","compiler","hooks","compilation","tap","normalModuleFactory","logger","getLogger","dependencyTemplates","set","Template","handler","parser","parserOptions","onUsageSuper","sup","onUsage","state","usedByExports","undefined","dep","range","loc","module","addDependency","program","enable","finish","isEnabled","time","inferDependencyUsage","timeAggregate","statementWithTopLevelSymbol","WeakMap","statementPurePart","classWithTopLevelSymbol","declWithTopLevelSymbol","pureDeclarators","WeakSet","preStatement","statement","scope","topLevelScope","type","name","id","fn","tagTopLevelSymbol","blockPreStatement","decl","declaration","isPure","endsWith","preDeclarator","init","add","setTopLevelSymbol","get","purePart","classExtendsExpression","expr","classBodyElement","element","classDefinition","classBodyValue","expression","static","key","declarator","has","superClass","walkExpression","for","topLevelSymbol","currentTagData","currentTopLevelSymbol","getTopLevelSymbol","addUsage","assign","operator","finishModules","timeAggregateEnd","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/optimize/InnerGraphPlugin.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\r\nconst InnerGraph = require(\"./InnerGraph\");\r\n\r\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\r\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\r\n/** @typedef {import(\"estree\").Node} Node */\r\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\r\n/** @typedef {import(\"../Compiler\")} Compiler */\r\n/** @typedef {import(\"../Dependency\")} Dependency */\r\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\r\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\r\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\r\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\r\n\r\nconst { topLevelSymbolTag } = InnerGraph;\r\n\r\nclass InnerGraphPlugin {\r\n\t/**\r\n\t * Apply the plugin\r\n\t * @param {Compiler} compiler the compiler instance\r\n\t * @returns {void}\r\n\t */\r\n\tapply(compiler) {\r\n\t\tcompiler.hooks.compilation.tap(\r\n\t\t\t\"InnerGraphPlugin\",\r\n\t\t\t(compilation, { normalModuleFactory }) => {\r\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\r\n\r\n\t\t\t\tcompilation.dependencyTemplates.set(\r\n\t\t\t\t\tPureExpressionDependency,\r\n\t\t\t\t\tnew PureExpressionDependency.Template()\r\n\t\t\t\t);\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {JavascriptParser} parser the parser\r\n\t\t\t\t * @param {Object} parserOptions options\r\n\t\t\t\t * @returns {void}\r\n\t\t\t\t */\r\n\t\t\t\tconst handler = (parser, parserOptions) => {\r\n\t\t\t\t\tconst onUsageSuper = sup => {\r\n\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\r\n\t\t\t\t\t\t\tswitch (usedByExports) {\r\n\t\t\t\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\tdefault: {\r\n\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(sup.range);\r\n\t\t\t\t\t\t\t\t\tdep.loc = sup.loc;\r\n\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\r\n\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tparser.hooks.program.tap(\"InnerGraphPlugin\", () => {\r\n\t\t\t\t\t\tInnerGraph.enable(parser.state);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tparser.hooks.finish.tap(\"InnerGraphPlugin\", () => {\r\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\r\n\t\t\t\t\t\tlogger.time(\"infer dependency usage\");\r\n\t\t\t\t\t\tInnerGraph.inferDependencyUsage(parser.state);\r\n\t\t\t\t\t\tlogger.timeAggregate(\"infer dependency usage\");\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// During prewalking the following datastructures are filled with\r\n\t\t\t\t\t// nodes that have a TopLevelSymbol assigned and\r\n\t\t\t\t\t// variables are tagged with the assigned TopLevelSymbol\r\n\r\n\t\t\t\t\t// We differ 3 types of nodes:\r\n\t\t\t\t\t// 1. full statements (export default, function declaration)\r\n\t\t\t\t\t// 2. classes (class declaration, class expression)\r\n\t\t\t\t\t// 3. variable declarators (const x = ...)\r\n\r\n\t\t\t\t\t/** @type {WeakMap<Node, TopLevelSymbol>} */\r\n\t\t\t\t\tconst statementWithTopLevelSymbol = new WeakMap();\r\n\t\t\t\t\t/** @type {WeakMap<Node, Node>} */\r\n\t\t\t\t\tconst statementPurePart = new WeakMap();\r\n\r\n\t\t\t\t\t/** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\r\n\t\t\t\t\tconst classWithTopLevelSymbol = new WeakMap();\r\n\r\n\t\t\t\t\t/** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\r\n\t\t\t\t\tconst declWithTopLevelSymbol = new WeakMap();\r\n\t\t\t\t\t/** @type {WeakSet<VariableDeclaratorNode>} */\r\n\t\t\t\t\tconst pureDeclarators = new WeakSet();\r\n\r\n\t\t\t\t\t// The following hooks are used during prewalking:\r\n\r\n\t\t\t\t\tparser.hooks.preStatement.tap(\"InnerGraphPlugin\", statement => {\r\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\r\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\r\n\t\t\t\t\t\t\tif (statement.type === \"FunctionDeclaration\") {\r\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\r\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\r\n\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tparser.hooks.blockPreStatement.tap(\"InnerGraphPlugin\", statement => {\r\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\r\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\r\n\t\t\t\t\t\t\tif (statement.type === \"ClassDeclaration\") {\r\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\r\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\r\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(statement, fn);\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (statement.type === \"ExportDefaultDeclaration\") {\r\n\t\t\t\t\t\t\t\tconst name = \"*default*\";\r\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\r\n\t\t\t\t\t\t\t\tconst decl = statement.declaration;\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tdecl.type === \"ClassExpression\" ||\r\n\t\t\t\t\t\t\t\t\tdecl.type === \"ClassDeclaration\"\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl, fn);\r\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl, statement.range[0])) {\r\n\t\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"FunctionExpression\") &&\r\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"Declaration\") &&\r\n\t\t\t\t\t\t\t\t\t\tdecl.type !== \"Literal\"\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tstatementPurePart.set(statement, decl);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tparser.hooks.preDeclarator.tap(\r\n\t\t\t\t\t\t\"InnerGraphPlugin\",\r\n\t\t\t\t\t\t(decl, statement) => {\r\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tparser.scope.topLevelScope === true &&\r\n\t\t\t\t\t\t\t\tdecl.init &&\r\n\t\t\t\t\t\t\t\tdecl.id.type === \"Identifier\"\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tconst name = decl.id.name;\r\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\r\n\t\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\r\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl.init, fn);\r\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl.init, decl.id.range[1])) {\r\n\t\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\r\n\t\t\t\t\t\t\t\t\tdeclWithTopLevelSymbol.set(decl, fn);\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t!decl.init.type.endsWith(\"FunctionExpression\") &&\r\n\t\t\t\t\t\t\t\t\t\tdecl.init.type !== \"Literal\"\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tpureDeclarators.add(decl);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// During real walking we set the TopLevelSymbol state to the assigned\r\n\t\t\t\t\t// TopLevelSymbol by using the fill datastructures.\r\n\r\n\t\t\t\t\t// In addition to tracking TopLevelSymbols, we sometimes need to\r\n\t\t\t\t\t// add a PureExpressionDependency. This is needed to skip execution\r\n\t\t\t\t\t// of pure expressions, even when they are not dropped due to\r\n\t\t\t\t\t// minimizing. Otherwise symbols used there might not exist anymore\r\n\t\t\t\t\t// as they are removed as unused by this optimization\r\n\r\n\t\t\t\t\t// When we find a reference to a TopLevelSymbol, we register a\r\n\t\t\t\t\t// TopLevelSymbol dependency from TopLevelSymbol in state to the\r\n\t\t\t\t\t// referenced TopLevelSymbol. This way we get a graph of all\r\n\t\t\t\t\t// TopLevelSymbols.\r\n\r\n\t\t\t\t\t// The following hooks are called during walking:\r\n\r\n\t\t\t\t\tparser.hooks.statement.tap(\"InnerGraphPlugin\", statement => {\r\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\r\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\r\n\r\n\t\t\t\t\t\t\tconst fn = statementWithTopLevelSymbol.get(statement);\r\n\t\t\t\t\t\t\tif (fn) {\r\n\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\r\n\t\t\t\t\t\t\t\tconst purePart = statementPurePart.get(statement);\r\n\t\t\t\t\t\t\t\tif (purePart) {\r\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\r\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\r\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\t\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpurePart.range\r\n\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = statement.loc;\r\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\r\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tparser.hooks.classExtendsExpression.tap(\r\n\t\t\t\t\t\t\"InnerGraphPlugin\",\r\n\t\t\t\t\t\t(expr, statement) => {\r\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\r\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(statement);\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tfn &&\r\n\t\t\t\t\t\t\t\t\tparser.isPure(\r\n\t\t\t\t\t\t\t\t\t\texpr,\r\n\t\t\t\t\t\t\t\t\t\tstatement.id ? statement.id.range[1] : statement.range[0]\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\r\n\t\t\t\t\t\t\t\t\tonUsageSuper(expr);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tparser.hooks.classBodyElement.tap(\r\n\t\t\t\t\t\t\"InnerGraphPlugin\",\r\n\t\t\t\t\t\t(element, classDefinition) => {\r\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\r\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\r\n\t\t\t\t\t\t\t\tif (fn) {\r\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tparser.hooks.classBodyValue.tap(\r\n\t\t\t\t\t\t\"InnerGraphPlugin\",\r\n\t\t\t\t\t\t(expression, element, classDefinition) => {\r\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\r\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\r\n\t\t\t\t\t\t\t\tif (fn) {\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t!element.static ||\r\n\t\t\t\t\t\t\t\t\t\tparser.isPure(\r\n\t\t\t\t\t\t\t\t\t\t\texpression,\r\n\t\t\t\t\t\t\t\t\t\t\telement.key ? element.key.range[1] : element.range[0]\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\r\n\t\t\t\t\t\t\t\t\t\tif (element.type !== \"MethodDefinition\" && element.static) {\r\n\t\t\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\r\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpression.range\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tparser.hooks.declarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\r\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\tconst fn = declWithTopLevelSymbol.get(decl);\r\n\r\n\t\t\t\t\t\tif (fn) {\r\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\r\n\t\t\t\t\t\t\tif (pureDeclarators.has(decl)) {\r\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\r\n\t\t\t\t\t\t\t\t\tif (decl.init.superClass) {\r\n\t\t\t\t\t\t\t\t\t\tonUsageSuper(decl.init.superClass);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\r\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\r\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\r\n\t\t\t\t\t\t\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdecl.init.range\r\n\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = decl.loc;\r\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\r\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\r\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tparser.hooks.expression\r\n\t\t\t\t\t\t.for(topLevelSymbolTag)\r\n\t\t\t\t\t\t.tap(\"InnerGraphPlugin\", () => {\r\n\t\t\t\t\t\t\tconst topLevelSymbol = /** @type {TopLevelSymbol} */ (\r\n\t\t\t\t\t\t\t\tparser.currentTagData\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tconst currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(\r\n\t\t\t\t\t\t\t\tparser.state\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tInnerGraph.addUsage(\r\n\t\t\t\t\t\t\t\tparser.state,\r\n\t\t\t\t\t\t\t\ttopLevelSymbol,\r\n\t\t\t\t\t\t\t\tcurrentTopLevelSymbol || true\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\tparser.hooks.assign\r\n\t\t\t\t\t\t.for(topLevelSymbolTag)\r\n\t\t\t\t\t\t.tap(\"InnerGraphPlugin\", expr => {\r\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\r\n\t\t\t\t\t\t\tif (expr.operator === \"=\") return true;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t\tnormalModuleFactory.hooks.parser\r\n\t\t\t\t\t.for(\"javascript/auto\")\r\n\t\t\t\t\t.tap(\"InnerGraphPlugin\", handler);\r\n\t\t\t\tnormalModuleFactory.hooks.parser\r\n\t\t\t\t\t.for(\"javascript/esm\")\r\n\t\t\t\t\t.tap(\"InnerGraphPlugin\", handler);\r\n\r\n\t\t\t\tcompilation.hooks.finishModules.tap(\"InnerGraphPlugin\", () => {\r\n\t\t\t\t\tlogger.timeAggregateEnd(\"infer dependency usage\");\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = InnerGraphPlugin;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}