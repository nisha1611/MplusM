{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n      if (!modelNames) {\n        continue;\n      }\n    }\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n    if (!modelNames) {\n      continue;\n    }\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    let match = get(options, 'match', null);\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null && schema[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {\n      return {\n        modelNames: null\n      };\n    }\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null && typeof ref === 'function' && options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return {\n          modelNames: modelNames,\n          justOne: justOne,\n          isRefPath: isRefPath,\n          refPath: refPath\n        };\n      }\n    }\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n    return {\n      modelNames: modelNames,\n      justOne: justOne,\n      isRefPath: isRefPath,\n      refPath: refPath\n    };\n  }\n};\n\n/*!\r\n * ignore\r\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n    if (!localField || !foreignField) {\n      return new MongooseError('If you are populating a virtual, you must set the ' + 'localField and foreignField options');\n    }\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n    if (virtual.options.refPath) {\n      modelNames = modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    let match = get(options, 'match', null) || get(data, 'virtual.options.match', null) || get(data, 'virtual.options.options.match', null);\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n  if (modelNames == null) {\n    return;\n  }\n  let k = modelNames.length;\n  while (k--) {\n    const modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n    const perDocumentLimit = options.perDocumentLimit == null ? get(options, 'options.perDocumentLimit', null) : options.perDocumentLimit;\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = utils.clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n  return conn.model(modelName);\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ? model.schema.path(localField) : localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n  const _populateOptions = get(options, 'options', {});\n  const getters = 'getters' in _populateOptions ? _populateOptions.getters : get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\r\n * Retrieve the _id of `val` if a Document or Array of Documents.\r\n *\r\n * @param {Array|Document|Any} val\r\n * @param {Schema} schema\r\n * @return {Array|Document|Any}\r\n * @api private\r\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' && (\n  // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return val;\n}\n\n/*!\r\n * ignore\r\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n  return modelNames;\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","get","getDiscriminatorByValue","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","modelNamesFromRefPath","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","StrictPopulate","module","exports","getModelsMapForPopulate","model","docs","options","doc","len","length","map","modelNameFromQuery","modelName","schema","refPath","modelNames","available","modelSchema","_localModel","nested","path","_virtualRes","virtual","_virtualPopulate","allSchemaTypes","Array","isArray","filter","v","strictPopulate","_fullPath","i","justOne","docSchema","$__","$__schema","$isMongooseDocumentArray","ref","isUnderneathDocArray","$isUnderneathDocArray","isRefPath","normalizedRefPath","schemaOptions","modelNamesInOrder","instance","data","localField","foreignField","res","_getModelNames","unpopulatedValue","id","addModelNamesToMap","schemasArray","_schema","_modelNames","error","indexOf","push","from","Set","endsWith","every","$isMongooseArray","isVirtual","ret","_getLocalFieldValues","String","getValue","_docs","slice","match","hasMatchFunction","call","embeddedDiscriminatorModelNames","_findRefPathForDiscriminators","err","originalSchema","caster","$isSchemaMap","$__schemaType","subdocPath","vals","subdocsBeingPopulated","array","flatten","subdoc","_queryProjection","forEach","name","add","schemaForCurrentDoc","discriminatorValue","modelForCurrentDoc","discriminatorKey","discriminatorModel","discriminators","_getModelFromConn","db","_getSchema","_arrayPath","handleRefFunction","virtualPrefix","nestedSchemaPath","field","count","skip","hasOwnProperty","limit","perDocumentLimit","normalizedRef","Object","assign","convertTo_id","connection","cloneArrays","k","Model","ids","flat","modelNamesForRefPath","val","currentOptions","clone","merge","allIds","unpopulatedValues","conn","models","_parent","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","_populateOptions","hydratedDoc","hydrate","localFieldValue","localFieldHydratedValue","split","localFieldArrVal","localFieldArrIndex","applyGetters","_id","rawVal","__array","isMongooseArray","$schema","_castForPopulate","$parent","concat","key","keys","Map","values","pieces","cur","piece","schematype","subdocs","remnant","substring","discriminatorName","discriminator","discriminatorSchema","_path","docValue","join"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\r\n\r\nconst MongooseError = require('../../error/index');\r\nconst SkipPopulateValue = require('./SkipPopulateValue');\r\nconst get = require('../get');\r\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\r\nconst getConstructorName = require('../getConstructorName');\r\nconst getSchemaTypes = require('./getSchemaTypes');\r\nconst getVirtual = require('./getVirtual');\r\nconst lookupLocalFields = require('./lookupLocalFields');\r\nconst mpath = require('mpath');\r\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\r\nconst utils = require('../../utils');\r\n\r\nconst modelSymbol = require('../symbols').modelSymbol;\r\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\r\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\r\nconst StrictPopulate = require('../../error/strictPopulate');\r\n\r\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\r\n  let doc;\r\n  const len = docs.length;\r\n  const map = [];\r\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\r\n  let schema;\r\n  let refPath;\r\n  let modelNames;\r\n  const available = {};\r\n\r\n  const modelSchema = model.schema;\r\n\r\n  // Populating a nested path should always be a no-op re: #9073.\r\n  // People shouldn't do this, but apparently they do.\r\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\r\n    return [];\r\n  }\r\n\r\n  const _virtualRes = getVirtual(model.schema, options.path);\r\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\r\n  if (virtual != null) {\r\n    return _virtualPopulate(model, docs, options, _virtualRes);\r\n  }\r\n\r\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\r\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\r\n\r\n  if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {\r\n    return new StrictPopulate(options._fullPath || options.path);\r\n  }\r\n\r\n  for (let i = 0; i < len; i++) {\r\n    doc = docs[i];\r\n    let justOne = null;\r\n\r\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\r\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\r\n\r\n    // Special case: populating a path that's a DocumentArray unless\r\n    // there's an explicit `ref` or `refPath` re: gh-8946\r\n    if (schema != null &&\r\n        schema.$isMongooseDocumentArray &&\r\n        schema.options.ref == null &&\r\n        schema.options.refPath == null) {\r\n      continue;\r\n    }\r\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\r\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\r\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\r\n        ' because it is a subproperty of a document array');\r\n    }\r\n\r\n    modelNames = null;\r\n    let isRefPath = false;\r\n    let normalizedRefPath = null;\r\n    let schemaOptions = null;\r\n    let modelNamesInOrder = null;\r\n\r\n    if (schema != null && schema.instance === 'Embedded') {\r\n      if (schema.options.ref) {\r\n        const data = {\r\n          localField: options.path + '._id',\r\n          foreignField: '_id',\r\n          justOne: true\r\n        };\r\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\r\n\r\n        const unpopulatedValue = mpath.get(options.path, doc);\r\n        const id = mpath.get('_id', unpopulatedValue);\r\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\r\n      }\r\n      // No-op if no `ref` set. See gh-11538\r\n      continue;\r\n    }\r\n\r\n    if (Array.isArray(schema)) {\r\n      const schemasArray = schema;\r\n      for (const _schema of schemasArray) {\r\n        let _modelNames;\r\n        let res;\r\n        try {\r\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\r\n          _modelNames = res.modelNames;\r\n          isRefPath = isRefPath || res.isRefPath;\r\n          normalizedRefPath = normalizedRefPath || res.refPath;\r\n          justOne = res.justOne;\r\n        } catch (error) {\r\n          return error;\r\n        }\r\n\r\n        if (isRefPath && !res.isRefPath) {\r\n          continue;\r\n        }\r\n        if (!_modelNames) {\r\n          continue;\r\n        }\r\n        modelNames = modelNames || [];\r\n        for (const modelName of _modelNames) {\r\n          if (modelNames.indexOf(modelName) === -1) {\r\n            modelNames.push(modelName);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      try {\r\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\r\n        modelNames = res.modelNames;\r\n        isRefPath = res.isRefPath;\r\n        normalizedRefPath = normalizedRefPath || res.refPath;\r\n        justOne = res.justOne;\r\n        schemaOptions = get(schema, 'options.populate', null);\r\n        // Dedupe, because `refPath` can return duplicates of the same model name,\r\n        // and that causes perf issues.\r\n        if (isRefPath) {\r\n          modelNamesInOrder = modelNames;\r\n          modelNames = Array.from(new Set(modelNames));\r\n        }\r\n      } catch (error) {\r\n        return error;\r\n      }\r\n\r\n      if (!modelNames) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    const data = {};\r\n    const localField = options.path;\r\n    const foreignField = '_id';\r\n\r\n    // `justOne = null` means we don't know from the schema whether the end\r\n    // result should be an array or a single doc. This can result from\r\n    // populating a POJO using `Model.populate()`\r\n    if ('justOne' in options && options.justOne !== void 0) {\r\n      justOne = options.justOne;\r\n    } else if (schema && !schema[schemaMixedSymbol]) {\r\n      // Skip Mixed types because we explicitly don't do casting on those.\r\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\r\n        justOne = Array.isArray(schema) ?\r\n          schema.every(schema => !schema.$isMongooseArray) :\r\n          !schema.$isMongooseArray;\r\n      }\r\n    }\r\n\r\n    if (!modelNames) {\r\n      continue;\r\n    }\r\n\r\n    data.isVirtual = false;\r\n    data.justOne = justOne;\r\n    data.localField = localField;\r\n    data.foreignField = foreignField;\r\n\r\n    // Get local fields\r\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\r\n\r\n    const id = String(utils.getValue(foreignField, doc));\r\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\r\n\r\n    let match = get(options, 'match', null);\r\n\r\n    const hasMatchFunction = typeof match === 'function';\r\n    if (hasMatchFunction) {\r\n      match = match.call(doc, doc);\r\n    }\r\n    data.match = match;\r\n    data.hasMatchFunction = hasMatchFunction;\r\n    data.isRefPath = isRefPath;\r\n    data.modelNamesInOrder = modelNamesInOrder;\r\n\r\n    if (isRefPath) {\r\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\r\n        modelSchema, data, options, normalizedRefPath, ret);\r\n\r\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\r\n    }\r\n\r\n    try {\r\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\r\n    } catch (err) {\r\n      return err;\r\n    }\r\n  }\r\n  return map;\r\n\r\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\r\n    let modelNames;\r\n    let isRefPath = false;\r\n    let justOne = null;\r\n\r\n    const originalSchema = schema;\r\n    if (schema && schema.instance === 'Array') {\r\n      schema = schema.caster;\r\n    }\r\n    if (schema && schema.$isSchemaMap) {\r\n      schema = schema.$__schemaType;\r\n    }\r\n\r\n    const ref = schema && schema.options && schema.options.ref;\r\n    refPath = schema && schema.options && schema.options.refPath;\r\n    if (schema != null &&\r\n        schema[schemaMixedSymbol] &&\r\n        !ref &&\r\n        !refPath &&\r\n        !modelNameFromQuery) {\r\n      return { modelNames: null };\r\n    }\r\n\r\n    if (modelNameFromQuery) {\r\n      modelNames = [modelNameFromQuery]; // query options\r\n    } else if (refPath != null) {\r\n      if (typeof refPath === 'function') {\r\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\r\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\r\n        const subdocsBeingPopulated = Array.isArray(vals) ?\r\n          utils.array.flatten(vals) :\r\n          (vals ? [vals] : []);\r\n\r\n        modelNames = new Set();\r\n        for (const subdoc of subdocsBeingPopulated) {\r\n          refPath = refPath.call(subdoc, subdoc, options.path);\r\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\r\n            forEach(name => modelNames.add(name));\r\n        }\r\n        modelNames = Array.from(modelNames);\r\n      } else {\r\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\r\n      }\r\n\r\n      isRefPath = true;\r\n    } else {\r\n      let ref;\r\n      let refPath;\r\n      let schemaForCurrentDoc;\r\n      let discriminatorValue;\r\n      let modelForCurrentDoc = model;\r\n      const discriminatorKey = model.schema.options.discriminatorKey;\r\n\r\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\r\n        // `modelNameForFind` is the discriminator value, so we might need\r\n        // find the discriminated model name\r\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\r\n        if (discriminatorModel != null) {\r\n          modelForCurrentDoc = discriminatorModel;\r\n        } else {\r\n          try {\r\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\r\n          } catch (error) {\r\n            return error;\r\n          }\r\n        }\r\n\r\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\r\n\r\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\r\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\r\n        }\r\n      } else {\r\n        schemaForCurrentDoc = schema;\r\n      }\r\n\r\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\r\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\r\n      } else if (schemaForCurrentDoc != null) {\r\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\r\n      }\r\n\r\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\r\n        if (schemaForCurrentDoc != null &&\r\n            typeof ref === 'function' &&\r\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\r\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\r\n          modelNames = new Set();\r\n\r\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\r\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\r\n          const subdocsBeingPopulated = Array.isArray(vals) ?\r\n            utils.array.flatten(vals) :\r\n            (vals ? [vals] : []);\r\n          for (const subdoc of subdocsBeingPopulated) {\r\n            modelNames.add(handleRefFunction(ref, subdoc));\r\n          }\r\n\r\n          if (subdocsBeingPopulated.length === 0) {\r\n            modelNames = [handleRefFunction(ref, doc)];\r\n          } else {\r\n            modelNames = Array.from(modelNames);\r\n          }\r\n        } else {\r\n          ref = handleRefFunction(ref, doc);\r\n          modelNames = [ref];\r\n        }\r\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\r\n        isRefPath = true;\r\n        if (typeof refPath === 'function') {\r\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\r\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\r\n          const subdocsBeingPopulated = Array.isArray(vals) ?\r\n            utils.array.flatten(vals) :\r\n            (vals ? [vals] : []);\r\n\r\n          modelNames = new Set();\r\n          for (const subdoc of subdocsBeingPopulated) {\r\n            refPath = refPath.call(subdoc, subdoc, options.path);\r\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\r\n              forEach(name => modelNames.add(name));\r\n          }\r\n          modelNames = Array.from(modelNames);\r\n        } else {\r\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!modelNames) {\r\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\r\n      if (options._localModel == null) {\r\n        modelNames = [model.modelName];\r\n      } else {\r\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\r\n      }\r\n    }\r\n\r\n    if (!Array.isArray(modelNames)) {\r\n      modelNames = [modelNames];\r\n    }\r\n\r\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\r\n  }\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\r\n  const map = [];\r\n  const available = {};\r\n  const virtual = _virtualRes.virtual;\r\n\r\n  for (const doc of docs) {\r\n    let modelNames = null;\r\n    const data = {};\r\n\r\n    // localField and foreignField\r\n    let localField;\r\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\r\n      _virtualRes.nestedSchemaPath + '.' : '';\r\n    if (typeof options.localField === 'string') {\r\n      localField = options.localField;\r\n    } else if (typeof virtual.options.localField === 'function') {\r\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\r\n    } else if (Array.isArray(virtual.options.localField)) {\r\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\r\n    } else {\r\n      localField = virtualPrefix + virtual.options.localField;\r\n    }\r\n    data.count = virtual.options.count;\r\n\r\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\r\n      options.skip = virtual.options.skip;\r\n    }\r\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\r\n      options.limit = virtual.options.limit;\r\n    }\r\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\r\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\r\n    }\r\n    let foreignField = virtual.options.foreignField;\r\n\r\n    if (!localField || !foreignField) {\r\n      return new MongooseError('If you are populating a virtual, you must set the ' +\r\n        'localField and foreignField options');\r\n    }\r\n\r\n    if (typeof localField === 'function') {\r\n      localField = localField.call(doc, doc);\r\n    }\r\n    if (typeof foreignField === 'function') {\r\n      foreignField = foreignField.call(doc, doc);\r\n    }\r\n\r\n    data.isRefPath = false;\r\n\r\n    // `justOne = null` means we don't know from the schema whether the end\r\n    // result should be an array or a single doc. This can result from\r\n    // populating a POJO using `Model.populate()`\r\n    let justOne = null;\r\n    if ('justOne' in options && options.justOne !== void 0) {\r\n      justOne = options.justOne;\r\n    }\r\n\r\n    if (virtual.options.refPath) {\r\n      modelNames =\r\n        modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\r\n      justOne = !!virtual.options.justOne;\r\n      data.isRefPath = true;\r\n    } else if (virtual.options.ref) {\r\n      let normalizedRef;\r\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\r\n        normalizedRef = virtual.options.ref.call(doc, doc);\r\n      } else {\r\n        normalizedRef = virtual.options.ref;\r\n      }\r\n      justOne = !!virtual.options.justOne;\r\n      // When referencing nested arrays, the ref should be an Array\r\n      // of modelNames.\r\n      if (Array.isArray(normalizedRef)) {\r\n        modelNames = normalizedRef;\r\n      } else {\r\n        modelNames = [normalizedRef];\r\n      }\r\n    }\r\n\r\n    data.isVirtual = true;\r\n    data.virtual = virtual;\r\n    data.justOne = justOne;\r\n\r\n    // `match`\r\n    let match = get(options, 'match', null) ||\r\n      get(data, 'virtual.options.match', null) ||\r\n      get(data, 'virtual.options.options.match', null);\r\n\r\n    let hasMatchFunction = typeof match === 'function';\r\n    if (hasMatchFunction) {\r\n      match = match.call(doc, doc);\r\n    }\r\n\r\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\r\n      match = Object.assign({}, match);\r\n      for (let i = 1; i < localField.length; ++i) {\r\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\r\n        hasMatchFunction = true;\r\n      }\r\n\r\n      localField = localField[0];\r\n      foreignField = foreignField[0];\r\n    }\r\n    data.localField = localField;\r\n    data.foreignField = foreignField;\r\n    data.match = match;\r\n    data.hasMatchFunction = hasMatchFunction;\r\n\r\n    // Get local fields\r\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\r\n\r\n    try {\r\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\r\n    } catch (err) {\r\n      return err;\r\n    }\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\r\n  // `PopulateOptions#connection`: if the model is passed as a string, the\r\n  // connection matters because different connections have different models.\r\n  const connection = options.connection != null ? options.connection : model.db;\r\n\r\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\r\n  if (Array.isArray(unpopulatedValue)) {\r\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\r\n  }\r\n\r\n  if (modelNames == null) {\r\n    return;\r\n  }\r\n\r\n  let k = modelNames.length;\r\n  while (k--) {\r\n    const modelName = modelNames[k];\r\n    if (modelName == null) {\r\n      continue;\r\n    }\r\n\r\n    let Model;\r\n    if (options.model && options.model[modelSymbol]) {\r\n      Model = options.model;\r\n    } else if (modelName[modelSymbol]) {\r\n      Model = modelName;\r\n    } else {\r\n      try {\r\n        Model = _getModelFromConn(connection, modelName);\r\n      } catch (err) {\r\n        if (ret !== void 0) {\r\n          throw err;\r\n        }\r\n        Model = null;\r\n      }\r\n    }\r\n\r\n    let ids = ret;\r\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\r\n\r\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\r\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\r\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\r\n    }\r\n\r\n    const perDocumentLimit = options.perDocumentLimit == null ?\r\n      get(options, 'options.perDocumentLimit', null) :\r\n      options.perDocumentLimit;\r\n\r\n    if (!available[modelName] || perDocumentLimit != null) {\r\n      const currentOptions = {\r\n        model: Model\r\n      };\r\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\r\n        currentOptions.options = utils.clone(data.virtual.options.options);\r\n      } else if (schemaOptions != null) {\r\n        currentOptions.options = Object.assign({}, schemaOptions);\r\n      }\r\n      utils.merge(currentOptions, options);\r\n\r\n      // Used internally for checking what model was used to populate this\r\n      // path.\r\n      options[populateModelSymbol] = Model;\r\n      available[modelName] = {\r\n        model: Model,\r\n        options: currentOptions,\r\n        match: data.hasMatchFunction ? [data.match] : data.match,\r\n        docs: [doc],\r\n        ids: [ids],\r\n        allIds: [ret],\r\n        unpopulatedValues: [unpopulatedValue],\r\n        localField: new Set([data.localField]),\r\n        foreignField: new Set([data.foreignField]),\r\n        justOne: data.justOne,\r\n        isVirtual: data.isVirtual,\r\n        virtual: data.virtual,\r\n        count: data.count,\r\n        [populateModelSymbol]: Model\r\n      };\r\n      map.push(available[modelName]);\r\n    } else {\r\n      available[modelName].localField.add(data.localField);\r\n      available[modelName].foreignField.add(data.foreignField);\r\n      available[modelName].docs.push(doc);\r\n      available[modelName].ids.push(ids);\r\n      available[modelName].allIds.push(ret);\r\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\r\n      if (data.hasMatchFunction) {\r\n        available[modelName].match.push(data.match);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction _getModelFromConn(conn, modelName) {\r\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\r\n  if (conn.models[modelName] == null && conn._parent != null) {\r\n    return _getModelFromConn(conn._parent, modelName);\r\n  }\r\n\r\n  return conn.model(modelName);\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction handleRefFunction(ref, doc) {\r\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\r\n    return ref.call(doc, doc);\r\n  }\r\n  return ref;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\r\n  // Get Local fields\r\n  const localFieldPathType = model.schema._getPathType(localField);\r\n  const localFieldPath = localFieldPathType === 'real' ?\r\n    model.schema.path(localField) :\r\n    localFieldPathType.schema;\r\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\r\n    localFieldPath.getters : [];\r\n\r\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\r\n\r\n  const _populateOptions = get(options, 'options', {});\r\n\r\n  const getters = 'getters' in _populateOptions ?\r\n    _populateOptions.getters :\r\n    get(virtual, 'options.getters', false);\r\n  if (localFieldGetters.length !== 0 && getters) {\r\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\r\n    const localFieldValue = utils.getValue(localField, doc);\r\n    if (Array.isArray(localFieldValue)) {\r\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\r\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\r\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\r\n    } else {\r\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\r\n    }\r\n  } else {\r\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieve the _id of `val` if a Document or Array of Documents.\r\n *\r\n * @param {Array|Document|Any} val\r\n * @param {Schema} schema\r\n * @return {Array|Document|Any}\r\n * @api private\r\n */\r\n\r\nfunction convertTo_id(val, schema) {\r\n  if (val != null && val.$__ != null) {\r\n    return val._id;\r\n  }\r\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\r\n    return val._id;\r\n  }\r\n\r\n  if (Array.isArray(val)) {\r\n    const rawVal = val.__array != null ? val.__array : val;\r\n    for (let i = 0; i < rawVal.length; ++i) {\r\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\r\n        rawVal[i] = rawVal[i]._id;\r\n      }\r\n    }\r\n    if (utils.isMongooseArray(val) && val.$schema()) {\r\n      return val.$schema()._castForPopulate(val, val.$parent());\r\n    }\r\n\r\n    return [].concat(val);\r\n  }\r\n\r\n  // `populate('map')` may be an object if populating on a doc that hasn't\r\n  // been hydrated yet\r\n  if (getConstructorName(val) === 'Object' &&\r\n      // The intent here is we should only flatten the object if we expect\r\n      // to get a Map in the end. Avoid doing this for mixed types.\r\n      (schema == null || schema[schemaMixedSymbol] == null)) {\r\n    const ret = [];\r\n    for (const key of Object.keys(val)) {\r\n      ret.push(val[key]);\r\n    }\r\n    return ret;\r\n  }\r\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\r\n  // then `val` will already be a map\r\n  if (val instanceof Map) {\r\n    return Array.from(val.values());\r\n  }\r\n\r\n  return val;\r\n}\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\r\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\r\n  // out embedded discriminator docs that don't have a `refPath` on the\r\n  // populated path.\r\n  if (!data.isRefPath || normalizedRefPath == null) {\r\n    return;\r\n  }\r\n\r\n  const pieces = normalizedRefPath.split('.');\r\n  let cur = '';\r\n  let modelNames = void 0;\r\n  for (let i = 0; i < pieces.length; ++i) {\r\n    const piece = pieces[i];\r\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\r\n    const schematype = modelSchema.path(cur);\r\n    if (schematype != null &&\r\n        schematype.$isMongooseArray &&\r\n        schematype.caster.discriminators != null &&\r\n        Object.keys(schematype.caster.discriminators).length !== 0) {\r\n      const subdocs = utils.getValue(cur, doc);\r\n      const remnant = options.path.substring(cur.length + 1);\r\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\r\n      modelNames = [];\r\n      for (const subdoc of subdocs) {\r\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\r\n        const discriminator = schematype.caster.discriminators[discriminatorName];\r\n        const discriminatorSchema = discriminator && discriminator.schema;\r\n        if (discriminatorSchema == null) {\r\n          continue;\r\n        }\r\n        const _path = discriminatorSchema.path(remnant);\r\n        if (_path == null || _path.options.refPath == null) {\r\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\r\n          ret.forEach((v, i) => {\r\n            if (v === docValue) {\r\n              ret[i] = SkipPopulateValue(v);\r\n            }\r\n          });\r\n          continue;\r\n        }\r\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\r\n        modelNames.push(modelName);\r\n      }\r\n    }\r\n  }\r\n\r\n  return modelNames;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}