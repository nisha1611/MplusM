{"ast":null,"code":"/*!\r\n * Module dependencies.\r\n */\n\n'use strict';\n\nconst utils = require('./utils'); // eslint-disable-line no-unused-vars\n\n/**\r\n * StateMachine represents a minimal `interface` for the\r\n * constructors it builds via StateMachine.ctor(...).\r\n *\r\n * @api private\r\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {};\n\n/**\r\n * StateMachine.ctor('state1', 'state2', ...)\r\n * A factory method for subclassing StateMachine.\r\n * The arguments are a list of states. For each state,\r\n * the constructor's prototype gets state transition\r\n * methods named after each state. These transition methods\r\n * place their path argument into the given state.\r\n *\r\n * @param {String} state\r\n * @param {String} [state]\r\n * @return {Function} subclass constructor\r\n * @api private\r\n */\n\nStateMachine.ctor = function () {\n  const states = [...arguments];\n  const ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n  };\n  ctor.prototype = new StateMachine();\n  ctor.prototype.stateNames = states;\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    };\n  });\n  return ctor;\n};\n\n/**\r\n * This function is wrapped by the state change functions:\r\n *\r\n * - `require(path)`\r\n * - `modify(path)`\r\n * - `init(path)`\r\n *\r\n * @api private\r\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n  this.paths[path] = nextState;\n  this.states[nextState] = this.states[nextState] || {};\n  this.states[nextState][path] = true;\n};\n\n/*!\r\n * ignore\r\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  if (this.states[state] == null) {\n    return;\n  }\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\r\n * ignore\r\n */\n\nStateMachine.prototype.clearPath = function clearPath(path) {\n  const state = this.paths[path];\n  if (!state) {\n    return;\n  }\n  delete this.paths[path];\n  delete this.states[state][path];\n};\n\n/**\r\n * Gets the paths for the given state, or empty object `{}` if none.\r\n * @api private\r\n */\n\nStateMachine.prototype.getStatePaths = function getStatePaths(state) {\n  if (this.states[state] != null) {\n    return this.states[state];\n  }\n  return {};\n};\n\n/**\r\n * Checks to see if at least one path is in the states passed in via `arguments`\r\n * e.g., this.some('required', 'inited')\r\n *\r\n * @param {String} state that we want to check for.\r\n * @api private\r\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    if (_this.states[state] == null) {\n      return false;\n    }\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/**\r\n * This function builds the functions that get assigned to `forEach` and `map`,\r\n * since both of those methods share a lot of the same logic.\r\n *\r\n * @param {String} iterMethod is either 'forEach' or 'map'\r\n * @return {Function}\r\n * @api private\r\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function () {\n    let states = [...arguments];\n    const callback = states.pop();\n    if (!states.length) states = this.stateNames;\n    const _this = this;\n    const paths = states.reduce(function (paths, state) {\n      if (_this.states[state] == null) {\n        return paths;\n      }\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/**\r\n * Iterates over the paths that belong to one of the parameter states.\r\n *\r\n * The function profile can look like:\r\n * this.forEach(state1, fn);         // iterates over all paths in state1\r\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\r\n * this.forEach(fn);                 // iterates over all paths in all states\r\n *\r\n * @param {String} [state]\r\n * @param {String} [state]\r\n * @param {Function} callback\r\n * @api private\r\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/**\r\n * Maps over the paths that belong to one of the parameter states.\r\n *\r\n * The function profile can look like:\r\n * this.forEach(state1, fn);         // iterates over all paths in state1\r\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\r\n * this.forEach(fn);                 // iterates over all paths in all states\r\n *\r\n * @param {String} [state]\r\n * @param {String} [state]\r\n * @param {Function} callback\r\n * @return {Array}\r\n * @api private\r\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};","map":{"version":3,"names":["utils","require","StateMachine","module","exports","ctor","states","arguments","apply","paths","prototype","stateNames","forEach","state","path","_changeState","nextState","prevBucket","clear","keys","Object","i","length","clearPath","getStatePaths","some","_this","what","Array","call","_iter","iterMethod","callback","pop","reduce","concat","map"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/statemachine.js"],"sourcesContent":["\r\n/*!\r\n * Module dependencies.\r\n */\r\n\r\n'use strict';\r\n\r\nconst utils = require('./utils'); // eslint-disable-line no-unused-vars\r\n\r\n/**\r\n * StateMachine represents a minimal `interface` for the\r\n * constructors it builds via StateMachine.ctor(...).\r\n *\r\n * @api private\r\n */\r\n\r\nconst StateMachine = module.exports = exports = function StateMachine() {\r\n};\r\n\r\n/**\r\n * StateMachine.ctor('state1', 'state2', ...)\r\n * A factory method for subclassing StateMachine.\r\n * The arguments are a list of states. For each state,\r\n * the constructor's prototype gets state transition\r\n * methods named after each state. These transition methods\r\n * place their path argument into the given state.\r\n *\r\n * @param {String} state\r\n * @param {String} [state]\r\n * @return {Function} subclass constructor\r\n * @api private\r\n */\r\n\r\nStateMachine.ctor = function() {\r\n  const states = [...arguments];\r\n\r\n  const ctor = function() {\r\n    StateMachine.apply(this, arguments);\r\n    this.paths = {};\r\n    this.states = {};\r\n  };\r\n\r\n  ctor.prototype = new StateMachine();\r\n\r\n  ctor.prototype.stateNames = states;\r\n\r\n  states.forEach(function(state) {\r\n    // Changes the `path`'s state to `state`.\r\n    ctor.prototype[state] = function(path) {\r\n      this._changeState(path, state);\r\n    };\r\n  });\r\n\r\n  return ctor;\r\n};\r\n\r\n/**\r\n * This function is wrapped by the state change functions:\r\n *\r\n * - `require(path)`\r\n * - `modify(path)`\r\n * - `init(path)`\r\n *\r\n * @api private\r\n */\r\n\r\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\r\n  const prevBucket = this.states[this.paths[path]];\r\n  if (prevBucket) delete prevBucket[path];\r\n\r\n  this.paths[path] = nextState;\r\n  this.states[nextState] = this.states[nextState] || {};\r\n  this.states[nextState][path] = true;\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nStateMachine.prototype.clear = function clear(state) {\r\n  if (this.states[state] == null) {\r\n    return;\r\n  }\r\n  const keys = Object.keys(this.states[state]);\r\n  let i = keys.length;\r\n  let path;\r\n\r\n  while (i--) {\r\n    path = keys[i];\r\n    delete this.states[state][path];\r\n    delete this.paths[path];\r\n  }\r\n};\r\n\r\n/*!\r\n * ignore\r\n */\r\n\r\nStateMachine.prototype.clearPath = function clearPath(path) {\r\n  const state = this.paths[path];\r\n  if (!state) {\r\n    return;\r\n  }\r\n  delete this.paths[path];\r\n  delete this.states[state][path];\r\n};\r\n\r\n/**\r\n * Gets the paths for the given state, or empty object `{}` if none.\r\n * @api private\r\n */\r\n\r\nStateMachine.prototype.getStatePaths = function getStatePaths(state) {\r\n  if (this.states[state] != null) {\r\n    return this.states[state];\r\n  }\r\n  return {};\r\n};\r\n\r\n/**\r\n * Checks to see if at least one path is in the states passed in via `arguments`\r\n * e.g., this.some('required', 'inited')\r\n *\r\n * @param {String} state that we want to check for.\r\n * @api private\r\n */\r\n\r\nStateMachine.prototype.some = function some() {\r\n  const _this = this;\r\n  const what = arguments.length ? arguments : this.stateNames;\r\n  return Array.prototype.some.call(what, function(state) {\r\n    if (_this.states[state] == null) {\r\n      return false;\r\n    }\r\n    return Object.keys(_this.states[state]).length;\r\n  });\r\n};\r\n\r\n/**\r\n * This function builds the functions that get assigned to `forEach` and `map`,\r\n * since both of those methods share a lot of the same logic.\r\n *\r\n * @param {String} iterMethod is either 'forEach' or 'map'\r\n * @return {Function}\r\n * @api private\r\n */\r\n\r\nStateMachine.prototype._iter = function _iter(iterMethod) {\r\n  return function() {\r\n    let states = [...arguments];\r\n    const callback = states.pop();\r\n\r\n    if (!states.length) states = this.stateNames;\r\n\r\n    const _this = this;\r\n\r\n    const paths = states.reduce(function(paths, state) {\r\n      if (_this.states[state] == null) {\r\n        return paths;\r\n      }\r\n      return paths.concat(Object.keys(_this.states[state]));\r\n    }, []);\r\n\r\n    return paths[iterMethod](function(path, i, paths) {\r\n      return callback(path, i, paths);\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * Iterates over the paths that belong to one of the parameter states.\r\n *\r\n * The function profile can look like:\r\n * this.forEach(state1, fn);         // iterates over all paths in state1\r\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\r\n * this.forEach(fn);                 // iterates over all paths in all states\r\n *\r\n * @param {String} [state]\r\n * @param {String} [state]\r\n * @param {Function} callback\r\n * @api private\r\n */\r\n\r\nStateMachine.prototype.forEach = function forEach() {\r\n  this.forEach = this._iter('forEach');\r\n  return this.forEach.apply(this, arguments);\r\n};\r\n\r\n/**\r\n * Maps over the paths that belong to one of the parameter states.\r\n *\r\n * The function profile can look like:\r\n * this.forEach(state1, fn);         // iterates over all paths in state1\r\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\r\n * this.forEach(fn);                 // iterates over all paths in all states\r\n *\r\n * @param {String} [state]\r\n * @param {String} [state]\r\n * @param {Function} callback\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nStateMachine.prototype.map = function map() {\r\n  this.map = this._iter('map');\r\n  return this.map.apply(this, arguments);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}