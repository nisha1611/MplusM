{"ast":null,"code":"'use strict';\n\nconst schemaMerge = require('../schema/merge');\nconst specialProperties = require('../../helpers/specialProperties');\nconst isBsonType = require('../../helpers/isBsonType');\nconst ObjectId = require('../../types/objectid');\nconst isObject = require('../../helpers/isObject');\n/**\r\n * Merges `from` into `to` without overwriting existing properties.\r\n *\r\n * @param {Object} to\r\n * @param {Object} from\r\n * @param {String} [path]\r\n * @api private\r\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n  path = path || '';\n  while (i < len) {\n    key = keys[i++];\n    if (key === 'discriminators' || key === 'base' || key === '_applyDiscriminators') {\n      continue;\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectID')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key);\n    }\n  }\n};","map":{"version":3,"names":["schemaMerge","require","specialProperties","isBsonType","ObjectId","isObject","module","exports","mergeDiscriminatorSchema","to","from","path","keys","Object","i","len","length","key","instanceOfSchema","has","$isSingleNested","$isMongooseDocumentArray","clone"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/back-end/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js"],"sourcesContent":["'use strict';\r\nconst schemaMerge = require('../schema/merge');\r\nconst specialProperties = require('../../helpers/specialProperties');\r\nconst isBsonType = require('../../helpers/isBsonType');\r\nconst ObjectId = require('../../types/objectid');\r\nconst isObject = require('../../helpers/isObject');\r\n/**\r\n * Merges `from` into `to` without overwriting existing properties.\r\n *\r\n * @param {Object} to\r\n * @param {Object} from\r\n * @param {String} [path]\r\n * @api private\r\n */\r\n\r\nmodule.exports = function mergeDiscriminatorSchema(to, from, path) {\r\n  const keys = Object.keys(from);\r\n  let i = 0;\r\n  const len = keys.length;\r\n  let key;\r\n\r\n  path = path || '';\r\n\r\n  while (i < len) {\r\n    key = keys[i++];\r\n    if (key === 'discriminators' || key === 'base' || key === '_applyDiscriminators') {\r\n      continue;\r\n    }\r\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\r\n      continue;\r\n    }\r\n    if (specialProperties.has(key)) {\r\n      continue;\r\n    }\r\n    if (to[key] == null) {\r\n      to[key] = from[key];\r\n    } else if (isObject(from[key])) {\r\n      if (!isObject(to[key])) {\r\n        to[key] = {};\r\n      }\r\n      if (from[key] != null) {\r\n        // Skip merging schemas if we're creating a discriminator schema and\r\n        // base schema has a given path as a single nested but discriminator schema\r\n        // has the path as a document array, or vice versa (gh-9534)\r\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\r\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested)) {\r\n          continue;\r\n        } else if (from[key].instanceOfSchema) {\r\n          if (to[key].instanceOfSchema) {\r\n            schemaMerge(to[key], from[key].clone(), true);\r\n          } else {\r\n            to[key] = from[key].clone();\r\n          }\r\n          continue;\r\n        } else if (isBsonType(from[key], 'ObjectID')) {\r\n          to[key] = new ObjectId(from[key]);\r\n          continue;\r\n        }\r\n      }\r\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key);\r\n    }\r\n  }\r\n};\r\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC9C,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,iCAAiC,CAAC;AACpE,MAAME,UAAU,GAAGF,OAAO,CAAC,0BAA0B,CAAC;AACtD,MAAMG,QAAQ,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAChD,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAK,MAAM,CAACC,OAAO,GAAG,SAASC,wBAAwB,CAACC,EAAE,EAAEC,IAAI,EAAEC,IAAI,EAAE;EACjE,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACF,IAAI,CAAC;EAC9B,IAAII,CAAC,GAAG,CAAC;EACT,MAAMC,GAAG,GAAGH,IAAI,CAACI,MAAM;EACvB,IAAIC,GAAG;EAEPN,IAAI,GAAGA,IAAI,IAAI,EAAE;EAEjB,OAAOG,CAAC,GAAGC,GAAG,EAAE;IACdE,GAAG,GAAGL,IAAI,CAACE,CAAC,EAAE,CAAC;IACf,IAAIG,GAAG,KAAK,gBAAgB,IAAIA,GAAG,KAAK,MAAM,IAAIA,GAAG,KAAK,sBAAsB,EAAE;MAChF;IACF;IACA,IAAIN,IAAI,KAAK,MAAM,IAAID,IAAI,IAAI,IAAI,IAAIA,IAAI,CAACQ,gBAAgB,EAAE;MAC5D;IACF;IACA,IAAIhB,iBAAiB,CAACiB,GAAG,CAACF,GAAG,CAAC,EAAE;MAC9B;IACF;IACA,IAAIR,EAAE,CAACQ,GAAG,CAAC,IAAI,IAAI,EAAE;MACnBR,EAAE,CAACQ,GAAG,CAAC,GAAGP,IAAI,CAACO,GAAG,CAAC;IACrB,CAAC,MAAM,IAAIZ,QAAQ,CAACK,IAAI,CAACO,GAAG,CAAC,CAAC,EAAE;MAC9B,IAAI,CAACZ,QAAQ,CAACI,EAAE,CAACQ,GAAG,CAAC,CAAC,EAAE;QACtBR,EAAE,CAACQ,GAAG,CAAC,GAAG,CAAC,CAAC;MACd;MACA,IAAIP,IAAI,CAACO,GAAG,CAAC,IAAI,IAAI,EAAE;QACrB;QACA;QACA;QACA,IAAKP,IAAI,CAACO,GAAG,CAAC,CAACG,eAAe,IAAIX,EAAE,CAACQ,GAAG,CAAC,CAACI,wBAAwB,IAC3DX,IAAI,CAACO,GAAG,CAAC,CAACI,wBAAwB,IAAIZ,EAAE,CAACQ,GAAG,CAAC,CAACG,eAAgB,EAAE;UACrE;QACF,CAAC,MAAM,IAAIV,IAAI,CAACO,GAAG,CAAC,CAACC,gBAAgB,EAAE;UACrC,IAAIT,EAAE,CAACQ,GAAG,CAAC,CAACC,gBAAgB,EAAE;YAC5BlB,WAAW,CAACS,EAAE,CAACQ,GAAG,CAAC,EAAEP,IAAI,CAACO,GAAG,CAAC,CAACK,KAAK,EAAE,EAAE,IAAI,CAAC;UAC/C,CAAC,MAAM;YACLb,EAAE,CAACQ,GAAG,CAAC,GAAGP,IAAI,CAACO,GAAG,CAAC,CAACK,KAAK,EAAE;UAC7B;UACA;QACF,CAAC,MAAM,IAAInB,UAAU,CAACO,IAAI,CAACO,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE;UAC5CR,EAAE,CAACQ,GAAG,CAAC,GAAG,IAAIb,QAAQ,CAACM,IAAI,CAACO,GAAG,CAAC,CAAC;UACjC;QACF;MACF;MACAT,wBAAwB,CAACC,EAAE,CAACQ,GAAG,CAAC,EAAEP,IAAI,CAACO,GAAG,CAAC,EAAEN,IAAI,GAAGA,IAAI,GAAG,GAAG,GAAGM,GAAG,GAAGA,GAAG,CAAC;IAC7E;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}