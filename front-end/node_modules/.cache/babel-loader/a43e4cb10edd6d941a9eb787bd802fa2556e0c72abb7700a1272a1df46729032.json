{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst {\n  SyncHook\n} = require(\"tapable\");\n\n/**\r\n * @typedef {Object} RuleCondition\r\n * @property {string | string[]} property\r\n * @property {boolean} matchWhenEmpty\r\n * @property {function(string): boolean} fn\r\n */\n\n/**\r\n * @typedef {Object} Condition\r\n * @property {boolean} matchWhenEmpty\r\n * @property {function(string): boolean} fn\r\n */\n\n/**\r\n * @typedef {Object} CompiledRule\r\n * @property {RuleCondition[]} conditions\r\n * @property {(Effect|function(object): Effect[])[]} effects\r\n * @property {CompiledRule[]=} rules\r\n * @property {CompiledRule[]=} oneOf\r\n */\n\n/**\r\n * @typedef {Object} Effect\r\n * @property {string} type\r\n * @property {any} value\r\n */\n\n/**\r\n * @typedef {Object} RuleSet\r\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\r\n * @property {function(object): Effect[]} exec execute the rule set\r\n */\n\nclass RuleSetCompiler {\n  constructor(plugins) {\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n      rule: new SyncHook([\"path\", \"rule\", \"unhandledProperties\", \"compiledRule\", \"references\"])\n    });\n    if (plugins) {\n      for (const plugin of plugins) {\n        plugin.apply(this);\n      }\n    }\n  }\n\n  /**\r\n   * @param {object[]} ruleSet raw user provided rules\r\n   * @returns {RuleSet} compiled RuleSet\r\n   */\n  compile(ruleSet) {\n    const refs = new Map();\n    const rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n\n    /**\r\n     * @param {object} data data passed in\r\n     * @param {CompiledRule} rule the compiled rule\r\n     * @param {Effect[]} effects an array where effects are pushed to\r\n     * @returns {boolean} true, if the rule has matched\r\n     */\n    const execRule = (data, rule, effects) => {\n      for (const condition of rule.conditions) {\n        const p = condition.property;\n        if (Array.isArray(p)) {\n          let current = data;\n          for (const subProperty of p) {\n            if (current && typeof current === \"object\" && Object.prototype.hasOwnProperty.call(current, subProperty)) {\n              current = current[subProperty];\n            } else {\n              current = undefined;\n              break;\n            }\n          }\n          if (current !== undefined) {\n            if (!condition.fn(current)) return false;\n            continue;\n          }\n        } else if (p in data) {\n          const value = data[p];\n          if (value !== undefined) {\n            if (!condition.fn(value)) return false;\n            continue;\n          }\n        }\n        if (!condition.matchWhenEmpty) {\n          return false;\n        }\n      }\n      for (const effect of rule.effects) {\n        if (typeof effect === \"function\") {\n          const returnedEffects = effect(data);\n          for (const effect of returnedEffects) {\n            effects.push(effect);\n          }\n        } else {\n          effects.push(effect);\n        }\n      }\n      if (rule.rules) {\n        for (const childRule of rule.rules) {\n          execRule(data, childRule, effects);\n        }\n      }\n      if (rule.oneOf) {\n        for (const childRule of rule.oneOf) {\n          if (execRule(data, childRule, effects)) {\n            break;\n          }\n        }\n      }\n      return true;\n    };\n    return {\n      references: refs,\n      exec: data => {\n        /** @type {Effect[]} */\n        const effects = [];\n        for (const rule of rules) {\n          execRule(data, rule, effects);\n        }\n        return effects;\n      }\n    };\n  }\n\n  /**\r\n   * @param {string} path current path\r\n   * @param {object[]} rules the raw rules provided by user\r\n   * @param {Map<string, any>} refs references\r\n   * @returns {CompiledRule[]} rules\r\n   */\n  compileRules(path, rules, refs) {\n    return rules.map((rule, i) => this.compileRule(`${path}[${i}]`, rule, refs));\n  }\n\n  /**\r\n   * @param {string} path current path\r\n   * @param {object} rule the raw rule provided by user\r\n   * @param {Map<string, any>} refs references\r\n   * @returns {CompiledRule} normalized and compiled rule for processing\r\n   */\n  compileRule(path, rule, refs) {\n    const unhandledProperties = new Set(Object.keys(rule).filter(key => rule[key] !== undefined));\n\n    /** @type {CompiledRule} */\n    const compiledRule = {\n      conditions: [],\n      effects: [],\n      rules: undefined,\n      oneOf: undefined\n    };\n    this.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n    if (unhandledProperties.has(\"rules\")) {\n      unhandledProperties.delete(\"rules\");\n      const rules = rule.rules;\n      if (!Array.isArray(rules)) throw this.error(path, rules, \"Rule.rules must be an array of rules\");\n      compiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\n    }\n    if (unhandledProperties.has(\"oneOf\")) {\n      unhandledProperties.delete(\"oneOf\");\n      const oneOf = rule.oneOf;\n      if (!Array.isArray(oneOf)) throw this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n      compiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\n    }\n    if (unhandledProperties.size > 0) {\n      throw this.error(path, rule, `Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`);\n    }\n    return compiledRule;\n  }\n\n  /**\r\n   * @param {string} path current path\r\n   * @param {any} condition user provided condition value\r\n   * @returns {Condition} compiled condition\r\n   */\n  compileCondition(path, condition) {\n    if (condition === \"\") {\n      return {\n        matchWhenEmpty: true,\n        fn: str => str === \"\"\n      };\n    }\n    if (!condition) {\n      throw this.error(path, condition, \"Expected condition but got falsy value\");\n    }\n    if (typeof condition === \"string\") {\n      return {\n        matchWhenEmpty: condition.length === 0,\n        fn: str => typeof str === \"string\" && str.startsWith(condition)\n      };\n    }\n    if (typeof condition === \"function\") {\n      try {\n        return {\n          matchWhenEmpty: condition(\"\"),\n          fn: condition\n        };\n      } catch (err) {\n        throw this.error(path, condition, \"Evaluation of condition function threw error\");\n      }\n    }\n    if (condition instanceof RegExp) {\n      return {\n        matchWhenEmpty: condition.test(\"\"),\n        fn: v => typeof v === \"string\" && condition.test(v)\n      };\n    }\n    if (Array.isArray(condition)) {\n      const items = condition.map((c, i) => this.compileCondition(`${path}[${i}]`, c));\n      return this.combineConditionsOr(items);\n    }\n    if (typeof condition !== \"object\") {\n      throw this.error(path, condition, `Unexpected ${typeof condition} when condition was expected`);\n    }\n    const conditions = [];\n    for (const key of Object.keys(condition)) {\n      const value = condition[key];\n      switch (key) {\n        case \"or\":\n          if (value) {\n            if (!Array.isArray(value)) {\n              throw this.error(`${path}.or`, condition.and, \"Expected array of conditions\");\n            }\n            conditions.push(this.compileCondition(`${path}.or`, value));\n          }\n          break;\n        case \"and\":\n          if (value) {\n            if (!Array.isArray(value)) {\n              throw this.error(`${path}.and`, condition.and, \"Expected array of conditions\");\n            }\n            let i = 0;\n            for (const item of value) {\n              conditions.push(this.compileCondition(`${path}.and[${i}]`, item));\n              i++;\n            }\n          }\n          break;\n        case \"not\":\n          if (value) {\n            const matcher = this.compileCondition(`${path}.not`, value);\n            const fn = matcher.fn;\n            conditions.push({\n              matchWhenEmpty: !matcher.matchWhenEmpty,\n              fn: v => !fn(v)\n            });\n          }\n          break;\n        default:\n          throw this.error(`${path}.${key}`, condition[key], `Unexpected property ${key} in condition`);\n      }\n    }\n    if (conditions.length === 0) {\n      throw this.error(path, condition, \"Expected condition, but got empty thing\");\n    }\n    return this.combineConditionsAnd(conditions);\n  }\n\n  /**\r\n   * @param {Condition[]} conditions some conditions\r\n   * @returns {Condition} merged condition\r\n   */\n  combineConditionsOr(conditions) {\n    if (conditions.length === 0) {\n      return {\n        matchWhenEmpty: false,\n        fn: () => false\n      };\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    } else {\n      return {\n        matchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\n        fn: v => conditions.some(c => c.fn(v))\n      };\n    }\n  }\n\n  /**\r\n   * @param {Condition[]} conditions some conditions\r\n   * @returns {Condition} merged condition\r\n   */\n  combineConditionsAnd(conditions) {\n    if (conditions.length === 0) {\n      return {\n        matchWhenEmpty: false,\n        fn: () => false\n      };\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    } else {\n      return {\n        matchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\n        fn: v => conditions.every(c => c.fn(v))\n      };\n    }\n  }\n\n  /**\r\n   * @param {string} path current path\r\n   * @param {any} value value at the error location\r\n   * @param {string} message message explaining the problem\r\n   * @returns {Error} an error object\r\n   */\n  error(path, value, message) {\n    return new Error(`Compiling RuleSet failed: ${message} (at ${path}: ${value})`);\n  }\n}\nmodule.exports = RuleSetCompiler;","map":{"version":3,"names":["SyncHook","require","RuleSetCompiler","constructor","plugins","hooks","Object","freeze","rule","plugin","apply","compile","ruleSet","refs","Map","rules","compileRules","execRule","data","effects","condition","conditions","p","property","Array","isArray","current","subProperty","prototype","hasOwnProperty","call","undefined","fn","value","matchWhenEmpty","effect","returnedEffects","push","childRule","oneOf","references","exec","path","map","i","compileRule","unhandledProperties","Set","keys","filter","key","compiledRule","has","delete","error","size","from","join","compileCondition","str","length","startsWith","err","RegExp","test","v","items","c","combineConditionsOr","and","item","matcher","combineConditionsAnd","some","every","message","Error","module","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/rules/RuleSetCompiler.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst { SyncHook } = require(\"tapable\");\r\n\r\n/**\r\n * @typedef {Object} RuleCondition\r\n * @property {string | string[]} property\r\n * @property {boolean} matchWhenEmpty\r\n * @property {function(string): boolean} fn\r\n */\r\n\r\n/**\r\n * @typedef {Object} Condition\r\n * @property {boolean} matchWhenEmpty\r\n * @property {function(string): boolean} fn\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompiledRule\r\n * @property {RuleCondition[]} conditions\r\n * @property {(Effect|function(object): Effect[])[]} effects\r\n * @property {CompiledRule[]=} rules\r\n * @property {CompiledRule[]=} oneOf\r\n */\r\n\r\n/**\r\n * @typedef {Object} Effect\r\n * @property {string} type\r\n * @property {any} value\r\n */\r\n\r\n/**\r\n * @typedef {Object} RuleSet\r\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\r\n * @property {function(object): Effect[]} exec execute the rule set\r\n */\r\n\r\nclass RuleSetCompiler {\r\n\tconstructor(plugins) {\r\n\t\tthis.hooks = Object.freeze({\r\n\t\t\t/** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\r\n\t\t\trule: new SyncHook([\r\n\t\t\t\t\"path\",\r\n\t\t\t\t\"rule\",\r\n\t\t\t\t\"unhandledProperties\",\r\n\t\t\t\t\"compiledRule\",\r\n\t\t\t\t\"references\"\r\n\t\t\t])\r\n\t\t});\r\n\t\tif (plugins) {\r\n\t\t\tfor (const plugin of plugins) {\r\n\t\t\t\tplugin.apply(this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {object[]} ruleSet raw user provided rules\r\n\t * @returns {RuleSet} compiled RuleSet\r\n\t */\r\n\tcompile(ruleSet) {\r\n\t\tconst refs = new Map();\r\n\t\tconst rules = this.compileRules(\"ruleSet\", ruleSet, refs);\r\n\r\n\t\t/**\r\n\t\t * @param {object} data data passed in\r\n\t\t * @param {CompiledRule} rule the compiled rule\r\n\t\t * @param {Effect[]} effects an array where effects are pushed to\r\n\t\t * @returns {boolean} true, if the rule has matched\r\n\t\t */\r\n\t\tconst execRule = (data, rule, effects) => {\r\n\t\t\tfor (const condition of rule.conditions) {\r\n\t\t\t\tconst p = condition.property;\r\n\t\t\t\tif (Array.isArray(p)) {\r\n\t\t\t\t\tlet current = data;\r\n\t\t\t\t\tfor (const subProperty of p) {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tcurrent &&\r\n\t\t\t\t\t\t\ttypeof current === \"object\" &&\r\n\t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(current, subProperty)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tcurrent = current[subProperty];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcurrent = undefined;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (current !== undefined) {\r\n\t\t\t\t\t\tif (!condition.fn(current)) return false;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (p in data) {\r\n\t\t\t\t\tconst value = data[p];\r\n\t\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\t\tif (!condition.fn(value)) return false;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!condition.matchWhenEmpty) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (const effect of rule.effects) {\r\n\t\t\t\tif (typeof effect === \"function\") {\r\n\t\t\t\t\tconst returnedEffects = effect(data);\r\n\t\t\t\t\tfor (const effect of returnedEffects) {\r\n\t\t\t\t\t\teffects.push(effect);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\teffects.push(effect);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (rule.rules) {\r\n\t\t\t\tfor (const childRule of rule.rules) {\r\n\t\t\t\t\texecRule(data, childRule, effects);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (rule.oneOf) {\r\n\t\t\t\tfor (const childRule of rule.oneOf) {\r\n\t\t\t\t\tif (execRule(data, childRule, effects)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\treferences: refs,\r\n\t\t\texec: data => {\r\n\t\t\t\t/** @type {Effect[]} */\r\n\t\t\t\tconst effects = [];\r\n\t\t\t\tfor (const rule of rules) {\r\n\t\t\t\t\texecRule(data, rule, effects);\r\n\t\t\t\t}\r\n\t\t\t\treturn effects;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} path current path\r\n\t * @param {object[]} rules the raw rules provided by user\r\n\t * @param {Map<string, any>} refs references\r\n\t * @returns {CompiledRule[]} rules\r\n\t */\r\n\tcompileRules(path, rules, refs) {\r\n\t\treturn rules.map((rule, i) =>\r\n\t\t\tthis.compileRule(`${path}[${i}]`, rule, refs)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} path current path\r\n\t * @param {object} rule the raw rule provided by user\r\n\t * @param {Map<string, any>} refs references\r\n\t * @returns {CompiledRule} normalized and compiled rule for processing\r\n\t */\r\n\tcompileRule(path, rule, refs) {\r\n\t\tconst unhandledProperties = new Set(\r\n\t\t\tObject.keys(rule).filter(key => rule[key] !== undefined)\r\n\t\t);\r\n\r\n\t\t/** @type {CompiledRule} */\r\n\t\tconst compiledRule = {\r\n\t\t\tconditions: [],\r\n\t\t\teffects: [],\r\n\t\t\trules: undefined,\r\n\t\t\toneOf: undefined\r\n\t\t};\r\n\r\n\t\tthis.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\r\n\r\n\t\tif (unhandledProperties.has(\"rules\")) {\r\n\t\t\tunhandledProperties.delete(\"rules\");\r\n\t\t\tconst rules = rule.rules;\r\n\t\t\tif (!Array.isArray(rules))\r\n\t\t\t\tthrow this.error(path, rules, \"Rule.rules must be an array of rules\");\r\n\t\t\tcompiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\r\n\t\t}\r\n\r\n\t\tif (unhandledProperties.has(\"oneOf\")) {\r\n\t\t\tunhandledProperties.delete(\"oneOf\");\r\n\t\t\tconst oneOf = rule.oneOf;\r\n\t\t\tif (!Array.isArray(oneOf))\r\n\t\t\t\tthrow this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\r\n\t\t\tcompiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\r\n\t\t}\r\n\r\n\t\tif (unhandledProperties.size > 0) {\r\n\t\t\tthrow this.error(\r\n\t\t\t\tpath,\r\n\t\t\t\trule,\r\n\t\t\t\t`Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn compiledRule;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} path current path\r\n\t * @param {any} condition user provided condition value\r\n\t * @returns {Condition} compiled condition\r\n\t */\r\n\tcompileCondition(path, condition) {\r\n\t\tif (condition === \"\") {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: true,\r\n\t\t\t\tfn: str => str === \"\"\r\n\t\t\t};\r\n\t\t}\r\n\t\tif (!condition) {\r\n\t\t\tthrow this.error(\r\n\t\t\t\tpath,\r\n\t\t\t\tcondition,\r\n\t\t\t\t\"Expected condition but got falsy value\"\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (typeof condition === \"string\") {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: condition.length === 0,\r\n\t\t\t\tfn: str => typeof str === \"string\" && str.startsWith(condition)\r\n\t\t\t};\r\n\t\t}\r\n\t\tif (typeof condition === \"function\") {\r\n\t\t\ttry {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatchWhenEmpty: condition(\"\"),\r\n\t\t\t\t\tfn: condition\r\n\t\t\t\t};\r\n\t\t\t} catch (err) {\r\n\t\t\t\tthrow this.error(\r\n\t\t\t\t\tpath,\r\n\t\t\t\t\tcondition,\r\n\t\t\t\t\t\"Evaluation of condition function threw error\"\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (condition instanceof RegExp) {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: condition.test(\"\"),\r\n\t\t\t\tfn: v => typeof v === \"string\" && condition.test(v)\r\n\t\t\t};\r\n\t\t}\r\n\t\tif (Array.isArray(condition)) {\r\n\t\t\tconst items = condition.map((c, i) =>\r\n\t\t\t\tthis.compileCondition(`${path}[${i}]`, c)\r\n\t\t\t);\r\n\t\t\treturn this.combineConditionsOr(items);\r\n\t\t}\r\n\r\n\t\tif (typeof condition !== \"object\") {\r\n\t\t\tthrow this.error(\r\n\t\t\t\tpath,\r\n\t\t\t\tcondition,\r\n\t\t\t\t`Unexpected ${typeof condition} when condition was expected`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst conditions = [];\r\n\t\tfor (const key of Object.keys(condition)) {\r\n\t\t\tconst value = condition[key];\r\n\t\t\tswitch (key) {\r\n\t\t\t\tcase \"or\":\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tif (!Array.isArray(value)) {\r\n\t\t\t\t\t\t\tthrow this.error(\r\n\t\t\t\t\t\t\t\t`${path}.or`,\r\n\t\t\t\t\t\t\t\tcondition.and,\r\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.or`, value));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"and\":\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tif (!Array.isArray(value)) {\r\n\t\t\t\t\t\t\tthrow this.error(\r\n\t\t\t\t\t\t\t\t`${path}.and`,\r\n\t\t\t\t\t\t\t\tcondition.and,\r\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlet i = 0;\r\n\t\t\t\t\t\tfor (const item of value) {\r\n\t\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.and[${i}]`, item));\r\n\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"not\":\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tconst matcher = this.compileCondition(`${path}.not`, value);\r\n\t\t\t\t\t\tconst fn = matcher.fn;\r\n\t\t\t\t\t\tconditions.push({\r\n\t\t\t\t\t\t\tmatchWhenEmpty: !matcher.matchWhenEmpty,\r\n\t\t\t\t\t\t\tfn: v => !fn(v)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow this.error(\r\n\t\t\t\t\t\t`${path}.${key}`,\r\n\t\t\t\t\t\tcondition[key],\r\n\t\t\t\t\t\t`Unexpected property ${key} in condition`\r\n\t\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (conditions.length === 0) {\r\n\t\t\tthrow this.error(\r\n\t\t\t\tpath,\r\n\t\t\t\tcondition,\r\n\t\t\t\t\"Expected condition, but got empty thing\"\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn this.combineConditionsAnd(conditions);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Condition[]} conditions some conditions\r\n\t * @returns {Condition} merged condition\r\n\t */\r\n\tcombineConditionsOr(conditions) {\r\n\t\tif (conditions.length === 0) {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: false,\r\n\t\t\t\tfn: () => false\r\n\t\t\t};\r\n\t\t} else if (conditions.length === 1) {\r\n\t\t\treturn conditions[0];\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\r\n\t\t\t\tfn: v => conditions.some(c => c.fn(v))\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Condition[]} conditions some conditions\r\n\t * @returns {Condition} merged condition\r\n\t */\r\n\tcombineConditionsAnd(conditions) {\r\n\t\tif (conditions.length === 0) {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: false,\r\n\t\t\t\tfn: () => false\r\n\t\t\t};\r\n\t\t} else if (conditions.length === 1) {\r\n\t\t\treturn conditions[0];\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\tmatchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\r\n\t\t\t\tfn: v => conditions.every(c => c.fn(v))\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} path current path\r\n\t * @param {any} value value at the error location\r\n\t * @param {string} message message explaining the problem\r\n\t * @returns {Error} an error object\r\n\t */\r\n\terror(path, value, message) {\r\n\t\treturn new Error(\r\n\t\t\t`Compiling RuleSet failed: ${message} (at ${path}: ${value})`\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = RuleSetCompiler;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}