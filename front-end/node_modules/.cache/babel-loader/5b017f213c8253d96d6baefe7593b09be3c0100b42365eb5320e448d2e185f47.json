{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Explain = exports.ExplainVerbosity = void 0;\nconst error_1 = require(\"./error\");\n/** @public */\nexports.ExplainVerbosity = Object.freeze({\n  queryPlanner: 'queryPlanner',\n  queryPlannerExtended: 'queryPlannerExtended',\n  executionStats: 'executionStats',\n  allPlansExecution: 'allPlansExecution'\n});\n/** @internal */\nclass Explain {\n  constructor(verbosity) {\n    if (typeof verbosity === 'boolean') {\n      this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;\n    } else {\n      this.verbosity = verbosity;\n    }\n  }\n  static fromOptions(options) {\n    if ((options === null || options === void 0 ? void 0 : options.explain) == null) return;\n    const explain = options.explain;\n    if (typeof explain === 'boolean' || typeof explain === 'string') {\n      return new Explain(explain);\n    }\n    throw new error_1.MongoInvalidArgumentError('Field \"explain\" must be a string or a boolean');\n  }\n}\nexports.Explain = Explain;","map":{"version":3,"mappings":";;;;;;AAAA;AAEA;AACaA,wBAAgB,GAAGC,MAAM,CAACC,MAAM,CAAC;EAC5CC,YAAY,EAAE,cAAc;EAC5BC,oBAAoB,EAAE,sBAAsB;EAC5CC,cAAc,EAAE,gBAAgB;EAChCC,iBAAiB,EAAE;CACX,CAAC;AAmBX;AACA,MAAaC,OAAO;EAGlBC,YAAYC,SAA+B;IACzC,IAAI,OAAOA,SAAS,KAAK,SAAS,EAAE;MAClC,IAAI,CAACA,SAAS,GAAGA,SAAS,GACtBT,wBAAgB,CAACM,iBAAiB,GAClCN,wBAAgB,CAACG,YAAY;KAClC,MAAM;MACL,IAAI,CAACM,SAAS,GAAGA,SAAS;;EAE9B;EAEA,OAAOC,WAAW,CAACC,OAAwB;IACzC,IAAI,QAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,OAAO,KAAI,IAAI,EAAE;IAE9B,MAAMA,OAAO,GAAGD,OAAO,CAACC,OAAO;IAC/B,IAAI,OAAOA,OAAO,KAAK,SAAS,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC/D,OAAO,IAAIL,OAAO,CAACK,OAAO,CAAC;;IAG7B,MAAM,IAAIC,iCAAyB,CAAC,+CAA+C,CAAC;EACtF;;AAtBFb","names":["exports","Object","freeze","queryPlanner","queryPlannerExtended","executionStats","allPlansExecution","Explain","constructor","verbosity","fromOptions","options","explain","error_1"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongoose\\node_modules\\mongodb\\src\\explain.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from './error';\r\n\r\n/** @public */\r\nexport const ExplainVerbosity = Object.freeze({\r\n  queryPlanner: 'queryPlanner',\r\n  queryPlannerExtended: 'queryPlannerExtended',\r\n  executionStats: 'executionStats',\r\n  allPlansExecution: 'allPlansExecution'\r\n} as const);\r\n\r\n/** @public */\r\nexport type ExplainVerbosity = string;\r\n\r\n/**\r\n * For backwards compatibility, true is interpreted as \"allPlansExecution\"\r\n * and false as \"queryPlanner\". Prior to server version 3.6, aggregate()\r\n * ignores the verbosity parameter and executes in \"queryPlanner\".\r\n * @public\r\n */\r\nexport type ExplainVerbosityLike = ExplainVerbosity | boolean;\r\n\r\n/** @public */\r\nexport interface ExplainOptions {\r\n  /** Specifies the verbosity mode for the explain output. */\r\n  explain?: ExplainVerbosityLike;\r\n}\r\n\r\n/** @internal */\r\nexport class Explain {\r\n  verbosity: ExplainVerbosity;\r\n\r\n  constructor(verbosity: ExplainVerbosityLike) {\r\n    if (typeof verbosity === 'boolean') {\r\n      this.verbosity = verbosity\r\n        ? ExplainVerbosity.allPlansExecution\r\n        : ExplainVerbosity.queryPlanner;\r\n    } else {\r\n      this.verbosity = verbosity;\r\n    }\r\n  }\r\n\r\n  static fromOptions(options?: ExplainOptions): Explain | undefined {\r\n    if (options?.explain == null) return;\r\n\r\n    const explain = options.explain;\r\n    if (typeof explain === 'boolean' || typeof explain === 'string') {\r\n      return new Explain(explain);\r\n    }\r\n\r\n    throw new MongoInvalidArgumentError('Field \"explain\" must be a string or a boolean');\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}