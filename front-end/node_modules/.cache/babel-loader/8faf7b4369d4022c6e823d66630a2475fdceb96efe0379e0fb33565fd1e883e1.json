{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst {\n  connectChunkGroupParentAndChild\n} = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  getEntryRuntime,\n  mergeRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\r\n * @typedef {Object} QueueItem\r\n * @property {number} action\r\n * @property {DependenciesBlock} block\r\n * @property {Module} module\r\n * @property {Chunk} chunk\r\n * @property {ChunkGroup} chunkGroup\r\n * @property {ChunkGroupInfo} chunkGroupInfo\r\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\r\n * @typedef {Object} ChunkGroupInfo\r\n * @property {ChunkGroup} chunkGroup the chunk group\r\n * @property {RuntimeSpec} runtime the runtimes\r\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\r\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\r\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\r\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\r\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\r\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\r\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\r\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\r\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\r\n * @property {number} preOrderIndex next pre order index\r\n * @property {number} postOrderIndex next post order index\r\n * @property {boolean} chunkLoading has a chunk loading mechanism\r\n * @property {boolean} asyncChunks create async chunks\r\n */\n\n/**\r\n * @typedef {Object} BlockChunkGroupConnection\r\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\r\n * @property {ChunkGroup} chunkGroup referenced chunk group\r\n */\n\nconst EMPTY_SET = /** @type {ModuleSetPlus} */new Set();\nEMPTY_SET.plus = EMPTY_SET;\n\n/**\r\n * @param {ModuleSetPlus} a first set\r\n * @param {ModuleSetPlus} b second set\r\n * @returns {number} cmp\r\n */\nconst bySetSize = (a, b) => {\n  return b.size + b.plus.size - a.size - a.plus.size;\n};\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n  let blockCache;\n  let modules;\n  const arrays = [];\n  const queue = [module];\n  while (queue.length > 0) {\n    const block = queue.pop();\n    const arr = [];\n    arrays.push(arr);\n    blockModulesMap.set(block, arr);\n    for (const b of block.blocks) {\n      queue.push(b);\n    }\n  }\n  for (const connection of moduleGraph.getOutgoingConnections(module)) {\n    const d = connection.dependency;\n    // We skip connections without dependency\n    if (!d) continue;\n    const m = connection.module;\n    // We skip connections without Module pointer\n    if (!m) continue;\n    // We skip weak connections\n    if (connection.weak) continue;\n    const state = connection.getActiveState(runtime);\n    // We skip inactive connections\n    if (state === false) continue;\n    const block = moduleGraph.getParentBlock(d);\n    let index = moduleGraph.getParentBlockIndex(d);\n\n    // deprecated fallback\n    if (index < 0) {\n      index = block.dependencies.indexOf(d);\n    }\n    if (blockCache !== block) {\n      modules = blockModulesMap.get(blockCache = block);\n    }\n    const i = index << 2;\n    modules[i] = m;\n    modules[i + 1] = state;\n  }\n  for (const modules of arrays) {\n    if (modules.length === 0) continue;\n    let indexMap;\n    let length = 0;\n    outer: for (let j = 0; j < modules.length; j += 2) {\n      const m = modules[j];\n      if (m === undefined) continue;\n      const state = modules[j + 1];\n      if (indexMap === undefined) {\n        let i = 0;\n        for (; i < length; i += 2) {\n          if (modules[i] === m) {\n            const merged = modules[i + 1];\n            if (merged === true) continue outer;\n            modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);\n          }\n        }\n        modules[length] = m;\n        length++;\n        modules[length] = state;\n        length++;\n        if (length > 30) {\n          // To avoid worse case performance, we will use an index map for\n          // linear cost access, which allows to maintain O(n) complexity\n          // while keeping allocations down to a minimum\n          indexMap = new Map();\n          for (let i = 0; i < length; i += 2) {\n            indexMap.set(modules[i], i + 1);\n          }\n        }\n      } else {\n        const idx = indexMap.get(m);\n        if (idx !== undefined) {\n          const merged = modules[idx];\n          if (merged === true) continue outer;\n          modules[idx] = ModuleGraphConnection.addConnectionStates(merged, state);\n        } else {\n          modules[length] = m;\n          length++;\n          modules[length] = state;\n          indexMap.set(m, length);\n          length++;\n        }\n      }\n    }\n    modules.length = length;\n  }\n};\n\n/**\r\n *\r\n * @param {Logger} logger a logger\r\n * @param {Compilation} compilation the compilation\r\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\r\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\r\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\r\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\r\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\r\n */\nconst visitModules = (logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const {\n    moduleGraph,\n    chunkGraph,\n    moduleMemCaches\n  } = compilation;\n  const blockModulesRuntimeMap = new Map();\n\n  /** @type {RuntimeSpec | false} */\n  let blockModulesMapRuntime = false;\n  let blockModulesMap;\n\n  /**\r\n   *\r\n   * @param {DependenciesBlock} block block\r\n   * @param {RuntimeSpec} runtime runtime\r\n   * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\r\n   */\n  const getBlockModules = (block, runtime) => {\n    if (blockModulesMapRuntime !== runtime) {\n      blockModulesMap = blockModulesRuntimeMap.get(runtime);\n      if (blockModulesMap === undefined) {\n        blockModulesMap = new Map();\n        blockModulesRuntimeMap.set(runtime, blockModulesMap);\n      }\n    }\n    let blockModules = blockModulesMap.get(block);\n    if (blockModules !== undefined) return blockModules;\n    const module = /** @type {Module} */block.getRootBlock();\n    const memCache = moduleMemCaches && moduleMemCaches.get(module);\n    if (memCache !== undefined) {\n      const map = memCache.provide(\"bundleChunkGraph.blockModules\", runtime, () => {\n        logger.time(\"visitModules: prepare\");\n        const map = new Map();\n        extractBlockModules(module, moduleGraph, runtime, map);\n        logger.timeAggregate(\"visitModules: prepare\");\n        return map;\n      });\n      for (const [block, blockModules] of map) blockModulesMap.set(block, blockModules);\n      return map.get(block);\n    } else {\n      logger.time(\"visitModules: prepare\");\n      extractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n      blockModules = blockModulesMap.get(block);\n      logger.timeAggregate(\"visitModules: prepare\");\n      return blockModules;\n    }\n  };\n  let statProcessedQueueItems = 0;\n  let statProcessedBlocks = 0;\n  let statConnectedChunkGroups = 0;\n  let statProcessedChunkGroupsForMerging = 0;\n  let statMergedAvailableModuleSets = 0;\n  let statForkedAvailableModules = 0;\n  let statForkedAvailableModulesCount = 0;\n  let statForkedAvailableModulesCountPlus = 0;\n  let statForkedMergedModulesCount = 0;\n  let statForkedMergedModulesCountPlus = 0;\n  let statForkedResultModulesCount = 0;\n  let statChunkGroupInfoUpdated = 0;\n  let statChildChunkGroupsReconnected = 0;\n  let nextChunkGroupIndex = 0;\n  let nextFreeModulePreOrderIndex = 0;\n  let nextFreeModulePostOrderIndex = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n  const blockChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  const namedChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  const namedAsyncEntrypoints = new Map();\n  const ADD_AND_ENTER_ENTRY_MODULE = 0;\n  const ADD_AND_ENTER_MODULE = 1;\n  const ENTER_MODULE = 2;\n  const PROCESS_BLOCK = 3;\n  const PROCESS_ENTRY_BLOCK = 4;\n  const LEAVE_MODULE = 5;\n\n  /** @type {QueueItem[]} */\n  let queue = [];\n\n  /** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  const chunkGroupsForCombining = new Set();\n\n  // Fill queue with entrypoint modules\n  // Create ChunkGroupInfo for entrypoints\n  for (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n    const runtime = getEntryRuntime(compilation, chunkGroup.name, chunkGroup.options);\n    /** @type {ChunkGroupInfo} */\n    const chunkGroupInfo = {\n      chunkGroup,\n      runtime,\n      minAvailableModules: undefined,\n      minAvailableModulesOwned: false,\n      availableModulesToBeMerged: [],\n      skippedItems: undefined,\n      resultingAvailableModules: undefined,\n      children: undefined,\n      availableSources: undefined,\n      availableChildren: undefined,\n      preOrderIndex: 0,\n      postOrderIndex: 0,\n      chunkLoading: chunkGroup.options.chunkLoading !== undefined ? chunkGroup.options.chunkLoading !== false : compilation.outputOptions.chunkLoading !== false,\n      asyncChunks: chunkGroup.options.asyncChunks !== undefined ? chunkGroup.options.asyncChunks : compilation.outputOptions.asyncChunks !== false\n    };\n    chunkGroup.index = nextChunkGroupIndex++;\n    if (chunkGroup.getNumberOfParents() > 0) {\n      // minAvailableModules for child entrypoints are unknown yet, set to undefined.\n      // This means no module is added until other sets are merged into\n      // this minAvailableModules (by the parent entrypoints)\n      const skippedItems = new Set();\n      for (const module of modules) {\n        skippedItems.add(module);\n      }\n      chunkGroupInfo.skippedItems = skippedItems;\n      chunkGroupsForCombining.add(chunkGroupInfo);\n    } else {\n      // The application may start here: We start with an empty list of available modules\n      chunkGroupInfo.minAvailableModules = EMPTY_SET;\n      const chunk = chunkGroup.getEntrypointChunk();\n      for (const module of modules) {\n        queue.push({\n          action: ADD_AND_ENTER_MODULE,\n          block: module,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n    chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n    if (chunkGroup.name) {\n      namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n    }\n  }\n  // Fill availableSources with parent-child dependencies between entrypoints\n  for (const chunkGroupInfo of chunkGroupsForCombining) {\n    const {\n      chunkGroup\n    } = chunkGroupInfo;\n    chunkGroupInfo.availableSources = new Set();\n    for (const parent of chunkGroup.parentsIterable) {\n      const parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n      chunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n      if (parentChunkGroupInfo.availableChildren === undefined) {\n        parentChunkGroupInfo.availableChildren = new Set();\n      }\n      parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n    }\n  }\n  // pop() is used to read from the queue\n  // so it need to be reversed to be iterated in\n  // correct order\n  queue.reverse();\n\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {Set<ChunkGroupInfo>} */\n  const chunkGroupsForMerging = new Set();\n  /** @type {QueueItem[]} */\n  let queueDelayed = [];\n\n  /** @type {[Module, ConnectionState][]} */\n  const skipConnectionBuffer = [];\n  /** @type {Module[]} */\n  const skipBuffer = [];\n  /** @type {QueueItem[]} */\n  const queueBuffer = [];\n\n  /** @type {Module} */\n  let module;\n  /** @type {Chunk} */\n  let chunk;\n  /** @type {ChunkGroup} */\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {ChunkGroupInfo} */\n  let chunkGroupInfo;\n\n  // For each async Block in graph\n  /**\r\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\r\n   * @returns {void}\r\n   */\n  const iteratorBlock = b => {\n    // 1. We create a chunk group with single chunk in it for this Block\n    // but only once (blockChunkGroups map)\n    let cgi = blockChunkGroups.get(b);\n    /** @type {ChunkGroup} */\n    let c;\n    /** @type {Entrypoint} */\n    let entrypoint;\n    const entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n    if (cgi === undefined) {\n      const chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;\n      if (entryOptions) {\n        cgi = namedAsyncEntrypoints.get(chunkName);\n        if (!cgi) {\n          entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, b.loc, b.request);\n          entrypoint.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: entrypoint,\n            runtime: entrypoint.options.runtime || entrypoint.name,\n            minAvailableModules: EMPTY_SET,\n            minAvailableModulesOwned: false,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: entryOptions.chunkLoading !== undefined ? entryOptions.chunkLoading !== false : chunkGroupInfo.chunkLoading,\n            asyncChunks: entryOptions.asyncChunks !== undefined ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks\n          };\n          chunkGroupInfoMap.set(entrypoint, cgi);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n          if (chunkName) {\n            namedAsyncEntrypoints.set(chunkName, cgi);\n          }\n        } else {\n          entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n          // TODO merge entryOptions\n          entrypoint.addOrigin(module, b.loc, b.request);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n        }\n\n        // 2. We enqueue the DependenciesBlock for traversal\n        queueDelayed.push({\n          action: PROCESS_ENTRY_BLOCK,\n          block: b,\n          module: module,\n          chunk: entrypoint.chunks[0],\n          chunkGroup: entrypoint,\n          chunkGroupInfo: cgi\n        });\n      } else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n        // Just queue the block into the current chunk group\n        queue.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module: module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } else {\n        cgi = chunkName && namedChunkGroups.get(chunkName);\n        if (!cgi) {\n          c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n          c.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: c,\n            runtime: chunkGroupInfo.runtime,\n            minAvailableModules: undefined,\n            minAvailableModulesOwned: undefined,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: chunkGroupInfo.chunkLoading,\n            asyncChunks: chunkGroupInfo.asyncChunks\n          };\n          allCreatedChunkGroups.add(c);\n          chunkGroupInfoMap.set(c, cgi);\n          if (chunkName) {\n            namedChunkGroups.set(chunkName, cgi);\n          }\n        } else {\n          c = cgi.chunkGroup;\n          if (c.isInitial()) {\n            compilation.errors.push(new AsyncDependencyToInitialChunkError(chunkName, module, b.loc));\n            c = chunkGroup;\n          } else {\n            c.addOptions(b.groupOptions);\n          }\n          c.addOrigin(module, b.loc, b.request);\n        }\n        blockConnections.set(b, []);\n      }\n      blockChunkGroups.set(b, cgi);\n    } else if (entryOptions) {\n      entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n    } else {\n      c = cgi.chunkGroup;\n    }\n    if (c !== undefined) {\n      // 2. We store the connection for the block\n      // to connect it later if needed\n      blockConnections.get(b).push({\n        originChunkGroupInfo: chunkGroupInfo,\n        chunkGroup: c\n      });\n\n      // 3. We enqueue the chunk group info creation/updating\n      let connectList = queueConnect.get(chunkGroupInfo);\n      if (connectList === undefined) {\n        connectList = new Set();\n        queueConnect.set(chunkGroupInfo, connectList);\n      }\n      connectList.add(cgi);\n\n      // TODO check if this really need to be done for each traversal\n      // or if it is enough when it's queued when created\n      // 4. We enqueue the DependenciesBlock for traversal\n      queueDelayed.push({\n        action: PROCESS_BLOCK,\n        block: b,\n        module: module,\n        chunk: c.chunks[0],\n        chunkGroup: c,\n        chunkGroupInfo: cgi\n      });\n    } else if (entrypoint !== undefined) {\n      chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n    }\n  };\n\n  /**\r\n   * @param {DependenciesBlock} block the block\r\n   * @returns {void}\r\n   */\n  const processBlock = block => {\n    statProcessedBlocks++;\n    // get prepared block info\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      const {\n        minAvailableModules\n      } = chunkGroupInfo;\n      // Buffer items because order need to be reversed to get indices correct\n      // Traverse all referenced modules\n      for (let i = 0; i < blockModules.length; i += 2) {\n        const refModule = /** @type {Module} */blockModules[i];\n        if (chunkGraph.isModuleInChunk(refModule, chunk)) {\n          // skip early if already connected\n          continue;\n        }\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        if (activeState !== true) {\n          skipConnectionBuffer.push([refModule, activeState]);\n          if (activeState === false) continue;\n        }\n        if (activeState === true && (minAvailableModules.has(refModule) || minAvailableModules.plus.has(refModule))) {\n          // already in parent chunks, skip it for now\n          skipBuffer.push(refModule);\n          continue;\n        }\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n      // Add buffered items in reverse order\n      if (skipConnectionBuffer.length > 0) {\n        let {\n          skippedModuleConnections\n        } = chunkGroupInfo;\n        if (skippedModuleConnections === undefined) {\n          chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set();\n        }\n        for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n          skippedModuleConnections.add(skipConnectionBuffer[i]);\n        }\n        skipConnectionBuffer.length = 0;\n      }\n      if (skipBuffer.length > 0) {\n        let {\n          skippedItems\n        } = chunkGroupInfo;\n        if (skippedItems === undefined) {\n          chunkGroupInfo.skippedItems = skippedItems = new Set();\n        }\n        for (let i = skipBuffer.length - 1; i >= 0; i--) {\n          skippedItems.add(skipBuffer[i]);\n        }\n        skipBuffer.length = 0;\n      }\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n        queueBuffer.length = 0;\n      }\n    }\n\n    // Traverse all Blocks\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n\n  /**\r\n   * @param {DependenciesBlock} block the block\r\n   * @returns {void}\r\n   */\n  const processEntryBlock = block => {\n    statProcessedBlocks++;\n    // get prepared block info\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      // Traverse all referenced modules\n      for (let i = 0; i < blockModules.length; i += 2) {\n        const refModule = /** @type {Module} */blockModules[i];\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n      // Add buffered items in reverse order\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n        queueBuffer.length = 0;\n      }\n    }\n\n    // Traverse all Blocks\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n  const processQueue = () => {\n    while (queue.length) {\n      statProcessedQueueItems++;\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      chunkGroup = queueItem.chunkGroup;\n      chunkGroupInfo = queueItem.chunkGroupInfo;\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_ENTRY_MODULE:\n          chunkGraph.connectChunkAndEntryModule(chunk, module, /** @type {Entrypoint} */chunkGroup);\n        // fallthrough\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (chunkGraph.isModuleInChunk(module, chunk)) {\n              // already connected, skip it\n              break;\n            }\n            // We connect Module and Chunk\n            chunkGraph.connectChunkAndModule(chunk, module);\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            const index = chunkGroup.getModulePreOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++);\n            }\n            if (moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex)) {\n              nextFreeModulePreOrderIndex++;\n            }\n\n            // reuse queueItem\n            queueItem.action = LEAVE_MODULE;\n            queue.push(queueItem);\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            processBlock(block);\n            break;\n          }\n        case PROCESS_ENTRY_BLOCK:\n          {\n            processEntryBlock(block);\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            const index = chunkGroup.getModulePostOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++);\n            }\n            if (moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex)) {\n              nextFreeModulePostOrderIndex++;\n            }\n            break;\n          }\n      }\n    }\n  };\n  const calculateResultingAvailableModules = chunkGroupInfo => {\n    if (chunkGroupInfo.resultingAvailableModules) return chunkGroupInfo.resultingAvailableModules;\n    const minAvailableModules = chunkGroupInfo.minAvailableModules;\n\n    // Create a new Set of available modules at this point\n    // We want to be as lazy as possible. There are multiple ways doing this:\n    // Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n    // - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n    // - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n    // We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n    let resultingAvailableModules;\n    if (minAvailableModules.size > minAvailableModules.plus.size) {\n      // resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n      resultingAvailableModules = /** @type {Set<Module> & {plus: Set<Module>}} */new Set();\n      for (const module of minAvailableModules.plus) minAvailableModules.add(module);\n      minAvailableModules.plus = EMPTY_SET;\n      resultingAvailableModules.plus = minAvailableModules;\n      chunkGroupInfo.minAvailableModulesOwned = false;\n    } else {\n      // resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n      resultingAvailableModules = /** @type {Set<Module> & {plus: Set<Module>}} */\n      new Set(minAvailableModules);\n      resultingAvailableModules.plus = minAvailableModules.plus;\n    }\n\n    // add the modules from the chunk group to the set\n    for (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n      for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n        resultingAvailableModules.add(m);\n      }\n    }\n    return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;\n  };\n  const processConnectQueue = () => {\n    // Figure out new parents for chunk groups\n    // to get new available modules for these children\n    for (const [chunkGroupInfo, targets] of queueConnect) {\n      // 1. Add new targets to the list of children\n      if (chunkGroupInfo.children === undefined) {\n        chunkGroupInfo.children = targets;\n      } else {\n        for (const target of targets) {\n          chunkGroupInfo.children.add(target);\n        }\n      }\n\n      // 2. Calculate resulting available modules\n      const resultingAvailableModules = calculateResultingAvailableModules(chunkGroupInfo);\n      const runtime = chunkGroupInfo.runtime;\n\n      // 3. Update chunk group info\n      for (const target of targets) {\n        target.availableModulesToBeMerged.push(resultingAvailableModules);\n        chunkGroupsForMerging.add(target);\n        const oldRuntime = target.runtime;\n        const newRuntime = mergeRuntime(oldRuntime, runtime);\n        if (oldRuntime !== newRuntime) {\n          target.runtime = newRuntime;\n          outdatedChunkGroupInfo.add(target);\n        }\n      }\n      statConnectedChunkGroups += targets.size;\n    }\n    queueConnect.clear();\n  };\n  const processChunkGroupsForMerging = () => {\n    statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n    // Execute the merge\n    for (const info of chunkGroupsForMerging) {\n      const availableModulesToBeMerged = info.availableModulesToBeMerged;\n      let cachedMinAvailableModules = info.minAvailableModules;\n      statMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n      // 1. Get minimal available modules\n      // It doesn't make sense to traverse a chunk again with more available modules.\n      // This step calculates the minimal available modules and skips traversal when\n      // the list didn't shrink.\n      if (availableModulesToBeMerged.length > 1) {\n        availableModulesToBeMerged.sort(bySetSize);\n      }\n      let changed = false;\n      merge: for (const availableModules of availableModulesToBeMerged) {\n        if (cachedMinAvailableModules === undefined) {\n          cachedMinAvailableModules = availableModules;\n          info.minAvailableModules = cachedMinAvailableModules;\n          info.minAvailableModulesOwned = false;\n          changed = true;\n        } else {\n          if (info.minAvailableModulesOwned) {\n            // We own it and can modify it\n            if (cachedMinAvailableModules.plus === availableModules.plus) {\n              for (const m of cachedMinAvailableModules) {\n                if (!availableModules.has(m)) {\n                  cachedMinAvailableModules.delete(m);\n                  changed = true;\n                }\n              }\n            } else {\n              for (const m of cachedMinAvailableModules) {\n                if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                  cachedMinAvailableModules.delete(m);\n                  changed = true;\n                }\n              }\n              for (const m of cachedMinAvailableModules.plus) {\n                if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                  // We can't remove modules from the plus part\n                  // so we need to merge plus into the normal part to allow modifying it\n                  const iterator = cachedMinAvailableModules.plus[Symbol.iterator]();\n                  // fast forward add all modules until m\n                  /** @type {IteratorResult<Module>} */\n                  let it;\n                  while (!(it = iterator.next()).done) {\n                    const module = it.value;\n                    if (module === m) break;\n                    cachedMinAvailableModules.add(module);\n                  }\n                  // check the remaining modules before adding\n                  while (!(it = iterator.next()).done) {\n                    const module = it.value;\n                    if (availableModules.has(module) || availableModules.plus.has(module)) {\n                      cachedMinAvailableModules.add(module);\n                    }\n                  }\n                  cachedMinAvailableModules.plus = EMPTY_SET;\n                  changed = true;\n                  continue merge;\n                }\n              }\n            }\n          } else if (cachedMinAvailableModules.plus === availableModules.plus) {\n            // Common and fast case when the plus part is shared\n            // We only need to care about the normal part\n            if (availableModules.size < cachedMinAvailableModules.size) {\n              // the new availableModules is smaller so it's faster to\n              // fork from the new availableModules\n              statForkedAvailableModules++;\n              statForkedAvailableModulesCount += availableModules.size;\n              statForkedMergedModulesCount += cachedMinAvailableModules.size;\n              // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n              const newSet = /** @type {ModuleSetPlus} */new Set();\n              newSet.plus = availableModules.plus;\n              for (const m of availableModules) {\n                if (cachedMinAvailableModules.has(m)) {\n                  newSet.add(m);\n                }\n              }\n              statForkedResultModulesCount += newSet.size;\n              cachedMinAvailableModules = newSet;\n              info.minAvailableModulesOwned = true;\n              info.minAvailableModules = newSet;\n              changed = true;\n              continue merge;\n            }\n            for (const m of cachedMinAvailableModules) {\n              if (!availableModules.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedMergedModulesCount += availableModules.size;\n                // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                // as the plus part is equal we can just take over this one\n                const newSet = /** @type {ModuleSetPlus} */new Set();\n                newSet.plus = availableModules.plus;\n                const iterator = cachedMinAvailableModules[Symbol.iterator]();\n                // fast forward add all modules until m\n                /** @type {IteratorResult<Module>} */\n                let it;\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                }\n                // check the remaining modules before adding\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (availableModules.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n          } else {\n            for (const m of cachedMinAvailableModules) {\n              if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                statForkedMergedModulesCount += availableModules.size;\n                statForkedMergedModulesCountPlus += availableModules.plus.size;\n                // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                const newSet = /** @type {ModuleSetPlus} */new Set();\n                newSet.plus = EMPTY_SET;\n                const iterator = cachedMinAvailableModules[Symbol.iterator]();\n                // fast forward add all modules until m\n                /** @type {IteratorResult<Module>} */\n                let it;\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                }\n                // check the remaining modules before adding\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n                // also check all modules in cachedMinAvailableModules.plus\n                for (const module of cachedMinAvailableModules.plus) {\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n            for (const m of cachedMinAvailableModules.plus) {\n              if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                statForkedMergedModulesCount += availableModules.size;\n                statForkedMergedModulesCountPlus += availableModules.plus.size;\n                // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                // we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n                const newSet = /** @type {ModuleSetPlus} */\n                new Set(cachedMinAvailableModules);\n                newSet.plus = EMPTY_SET;\n                const iterator = cachedMinAvailableModules.plus[Symbol.iterator]();\n                // fast forward add all modules until m\n                /** @type {IteratorResult<Module>} */\n                let it;\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                }\n                // check the remaining modules before adding\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n          }\n        }\n      }\n      availableModulesToBeMerged.length = 0;\n      if (changed) {\n        info.resultingAvailableModules = undefined;\n        outdatedChunkGroupInfo.add(info);\n      }\n    }\n    chunkGroupsForMerging.clear();\n  };\n  const processChunkGroupsForCombining = () => {\n    for (const info of chunkGroupsForCombining) {\n      for (const source of info.availableSources) {\n        if (!source.minAvailableModules) {\n          chunkGroupsForCombining.delete(info);\n          break;\n        }\n      }\n    }\n    for (const info of chunkGroupsForCombining) {\n      const availableModules = /** @type {ModuleSetPlus} */new Set();\n      availableModules.plus = EMPTY_SET;\n      const mergeSet = set => {\n        if (set.size > availableModules.plus.size) {\n          for (const item of availableModules.plus) availableModules.add(item);\n          availableModules.plus = set;\n        } else {\n          for (const item of set) availableModules.add(item);\n        }\n      };\n      // combine minAvailableModules from all resultingAvailableModules\n      for (const source of info.availableSources) {\n        const resultingAvailableModules = calculateResultingAvailableModules(source);\n        mergeSet(resultingAvailableModules);\n        mergeSet(resultingAvailableModules.plus);\n      }\n      info.minAvailableModules = availableModules;\n      info.minAvailableModulesOwned = false;\n      info.resultingAvailableModules = undefined;\n      outdatedChunkGroupInfo.add(info);\n    }\n    chunkGroupsForCombining.clear();\n  };\n  const processOutdatedChunkGroupInfo = () => {\n    statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n    // Revisit skipped elements\n    for (const info of outdatedChunkGroupInfo) {\n      // 1. Reconsider skipped items\n      if (info.skippedItems !== undefined) {\n        const {\n          minAvailableModules\n        } = info;\n        for (const module of info.skippedItems) {\n          if (!minAvailableModules.has(module) && !minAvailableModules.plus.has(module)) {\n            queue.push({\n              action: ADD_AND_ENTER_MODULE,\n              block: module,\n              module,\n              chunk: info.chunkGroup.chunks[0],\n              chunkGroup: info.chunkGroup,\n              chunkGroupInfo: info\n            });\n            info.skippedItems.delete(module);\n          }\n        }\n      }\n\n      // 2. Reconsider skipped connections\n      if (info.skippedModuleConnections !== undefined) {\n        const {\n          minAvailableModules\n        } = info;\n        for (const entry of info.skippedModuleConnections) {\n          const [module, activeState] = entry;\n          if (activeState === false) continue;\n          if (activeState === true) {\n            info.skippedModuleConnections.delete(entry);\n          }\n          if (activeState === true && (minAvailableModules.has(module) || minAvailableModules.plus.has(module))) {\n            info.skippedItems.add(module);\n            continue;\n          }\n          queue.push({\n            action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n            block: module,\n            module,\n            chunk: info.chunkGroup.chunks[0],\n            chunkGroup: info.chunkGroup,\n            chunkGroupInfo: info\n          });\n        }\n      }\n\n      // 2. Reconsider children chunk groups\n      if (info.children !== undefined) {\n        statChildChunkGroupsReconnected += info.children.size;\n        for (const cgi of info.children) {\n          let connectList = queueConnect.get(info);\n          if (connectList === undefined) {\n            connectList = new Set();\n            queueConnect.set(info, connectList);\n          }\n          connectList.add(cgi);\n        }\n      }\n\n      // 3. Reconsider chunk groups for combining\n      if (info.availableChildren !== undefined) {\n        for (const cgi of info.availableChildren) {\n          chunkGroupsForCombining.add(cgi);\n        }\n      }\n    }\n    outdatedChunkGroupInfo.clear();\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length || queueConnect.size) {\n    logger.time(\"visitModules: visiting\");\n    processQueue();\n    logger.timeAggregateEnd(\"visitModules: prepare\");\n    logger.timeEnd(\"visitModules: visiting\");\n    if (chunkGroupsForCombining.size > 0) {\n      logger.time(\"visitModules: combine available modules\");\n      processChunkGroupsForCombining();\n      logger.timeEnd(\"visitModules: combine available modules\");\n    }\n    if (queueConnect.size > 0) {\n      logger.time(\"visitModules: calculating available modules\");\n      processConnectQueue();\n      logger.timeEnd(\"visitModules: calculating available modules\");\n      if (chunkGroupsForMerging.size > 0) {\n        logger.time(\"visitModules: merging available modules\");\n        processChunkGroupsForMerging();\n        logger.timeEnd(\"visitModules: merging available modules\");\n      }\n    }\n    if (outdatedChunkGroupInfo.size > 0) {\n      logger.time(\"visitModules: check modules for revisit\");\n      processOutdatedChunkGroupInfo();\n      logger.timeEnd(\"visitModules: check modules for revisit\");\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indexing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n  logger.log(`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`);\n  logger.log(`${statConnectedChunkGroups} chunk groups connected`);\n  logger.log(`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`);\n  logger.log(`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`);\n};\n\n/**\r\n *\r\n * @param {Compilation} compilation the compilation\r\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\r\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\r\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\r\n */\nconst connectChunkGroups = (compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {\n  const {\n    chunkGraph\n  } = compilation;\n\n  /**\r\n   * Helper function to check if all modules of a chunk are available\r\n   *\r\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\r\n   * @param {ModuleSetPlus} availableModules the comparator set\r\n   * @returns {boolean} return true if all modules of a chunk are available\r\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n        if (!availableModules.has(module) && !availableModules.plus.has(module)) return false;\n      }\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if (\n    // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(_ref => {\n      let {\n        chunkGroup,\n        originChunkGroupInfo\n      } = _ref;\n      return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n    })) {\n      continue;\n    }\n\n    // 2. Foreach edge\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i];\n\n      // 3. Connect block with chunk\n      chunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n      // 4. Connect chunk with parent\n      connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n\n/**\r\n * Remove all unconnected chunk groups\r\n * @param {Compilation} compilation the compilation\r\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\r\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  const {\n    chunkGraph\n  } = compilation;\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        compilation.chunks.delete(chunk);\n        chunkGraph.disconnectChunk(chunk);\n      }\n      chunkGraph.disconnectChunkGroup(chunkGroup);\n      chunkGroup.remove();\n    }\n  }\n};\n\n/**\r\n * This method creates the Chunk graph from the Module graph\r\n * @param {Compilation} compilation the compilation\r\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\r\n * @returns {void}\r\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  const blockConnections = new Map();\n\n  /** @type {Set<ChunkGroup>} */\n  const allCreatedChunkGroups = new Set();\n\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n  const chunkGroupInfoMap = new Map();\n\n  /** @type {Set<DependenciesBlock>} */\n  const blocksWithNestedBlocks = new Set();\n\n  // PART ONE\n\n  logger.time(\"visitModules\");\n  visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups);\n  logger.timeEnd(\"visitModules\");\n\n  // PART TWO\n\n  logger.time(\"connectChunkGroups\");\n  connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap);\n  logger.timeEnd(\"connectChunkGroups\");\n  for (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n    for (const chunk of chunkGroup.chunks) chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n  }\n\n  // Cleanup work\n\n  logger.time(\"cleanup\");\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n  logger.timeEnd(\"cleanup\");\n};\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","connectChunkGroupParentAndChild","ModuleGraphConnection","getEntryRuntime","mergeRuntime","EMPTY_SET","Set","plus","bySetSize","a","b","size","extractBlockModules","module","moduleGraph","runtime","blockModulesMap","blockCache","modules","arrays","queue","length","block","pop","arr","push","set","blocks","connection","getOutgoingConnections","d","dependency","m","weak","state","getActiveState","getParentBlock","index","getParentBlockIndex","dependencies","indexOf","get","i","indexMap","outer","j","undefined","merged","addConnectionStates","Map","idx","visitModules","logger","compilation","inputEntrypointsAndModules","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","chunkGraph","moduleMemCaches","blockModulesRuntimeMap","blockModulesMapRuntime","getBlockModules","blockModules","getRootBlock","memCache","map","provide","time","timeAggregate","statProcessedQueueItems","statProcessedBlocks","statConnectedChunkGroups","statProcessedChunkGroupsForMerging","statMergedAvailableModuleSets","statForkedAvailableModules","statForkedAvailableModulesCount","statForkedAvailableModulesCountPlus","statForkedMergedModulesCount","statForkedMergedModulesCountPlus","statForkedResultModulesCount","statChunkGroupInfoUpdated","statChildChunkGroupsReconnected","nextChunkGroupIndex","nextFreeModulePreOrderIndex","nextFreeModulePostOrderIndex","blockChunkGroups","namedChunkGroups","namedAsyncEntrypoints","ADD_AND_ENTER_ENTRY_MODULE","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","PROCESS_ENTRY_BLOCK","LEAVE_MODULE","queueConnect","chunkGroupsForCombining","chunkGroup","name","options","chunkGroupInfo","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","children","availableSources","availableChildren","preOrderIndex","postOrderIndex","chunkLoading","outputOptions","asyncChunks","getNumberOfParents","add","chunk","getEntrypointChunk","action","parent","parentsIterable","parentChunkGroupInfo","reverse","outdatedChunkGroupInfo","chunkGroupsForMerging","queueDelayed","skipConnectionBuffer","skipBuffer","queueBuffer","iteratorBlock","cgi","c","entrypoint","entryOptions","groupOptions","chunkName","addAsyncEntrypoint","loc","request","connectBlockAndChunkGroup","addOrigin","chunks","addChunkInGroup","isInitial","errors","addOptions","originChunkGroupInfo","connectList","processBlock","refModule","isModuleInChunk","activeState","has","skippedModuleConnections","processEntryBlock","processQueue","queueItem","connectChunkAndEntryModule","connectChunkAndModule","getModulePreOrderIndex","setModulePreOrderIndex","setPreOrderIndexIfUnset","getModulePostOrderIndex","setModulePostOrderIndex","setPostOrderIndexIfUnset","calculateResultingAvailableModules","getChunkModulesIterable","processConnectQueue","targets","target","oldRuntime","newRuntime","clear","processChunkGroupsForMerging","info","cachedMinAvailableModules","sort","changed","merge","availableModules","delete","iterator","Symbol","it","next","done","value","newSet","processChunkGroupsForCombining","source","mergeSet","item","processOutdatedChunkGroupInfo","entry","timeAggregateEnd","timeEnd","tempQueue","log","connectChunkGroups","areModulesAvailable","connections","every","cleanupUnconnectedGroups","disconnectChunk","disconnectChunkGroup","remove","buildChunkGraph","getLogger","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\r\nconst { connectChunkGroupParentAndChild } = require(\"./GraphHelpers\");\r\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\r\nconst { getEntryRuntime, mergeRuntime } = require(\"./util/runtime\");\r\n\r\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\r\n/** @typedef {import(\"./Chunk\")} Chunk */\r\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\r\n/** @typedef {import(\"./Compilation\")} Compilation */\r\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\r\n/** @typedef {import(\"./Dependency\")} Dependency */\r\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\r\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\r\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\r\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\r\n\r\n/**\r\n * @typedef {Object} QueueItem\r\n * @property {number} action\r\n * @property {DependenciesBlock} block\r\n * @property {Module} module\r\n * @property {Chunk} chunk\r\n * @property {ChunkGroup} chunkGroup\r\n * @property {ChunkGroupInfo} chunkGroupInfo\r\n */\r\n\r\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\r\n\r\n/**\r\n * @typedef {Object} ChunkGroupInfo\r\n * @property {ChunkGroup} chunkGroup the chunk group\r\n * @property {RuntimeSpec} runtime the runtimes\r\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\r\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\r\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\r\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\r\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\r\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\r\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\r\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\r\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\r\n * @property {number} preOrderIndex next pre order index\r\n * @property {number} postOrderIndex next post order index\r\n * @property {boolean} chunkLoading has a chunk loading mechanism\r\n * @property {boolean} asyncChunks create async chunks\r\n */\r\n\r\n/**\r\n * @typedef {Object} BlockChunkGroupConnection\r\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\r\n * @property {ChunkGroup} chunkGroup referenced chunk group\r\n */\r\n\r\nconst EMPTY_SET = /** @type {ModuleSetPlus} */ (new Set());\r\nEMPTY_SET.plus = EMPTY_SET;\r\n\r\n/**\r\n * @param {ModuleSetPlus} a first set\r\n * @param {ModuleSetPlus} b second set\r\n * @returns {number} cmp\r\n */\r\nconst bySetSize = (a, b) => {\r\n\treturn b.size + b.plus.size - a.size - a.plus.size;\r\n};\r\n\r\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\r\n\tlet blockCache;\r\n\tlet modules;\r\n\r\n\tconst arrays = [];\r\n\r\n\tconst queue = [module];\r\n\twhile (queue.length > 0) {\r\n\t\tconst block = queue.pop();\r\n\t\tconst arr = [];\r\n\t\tarrays.push(arr);\r\n\t\tblockModulesMap.set(block, arr);\r\n\t\tfor (const b of block.blocks) {\r\n\t\t\tqueue.push(b);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\r\n\t\tconst d = connection.dependency;\r\n\t\t// We skip connections without dependency\r\n\t\tif (!d) continue;\r\n\t\tconst m = connection.module;\r\n\t\t// We skip connections without Module pointer\r\n\t\tif (!m) continue;\r\n\t\t// We skip weak connections\r\n\t\tif (connection.weak) continue;\r\n\t\tconst state = connection.getActiveState(runtime);\r\n\t\t// We skip inactive connections\r\n\t\tif (state === false) continue;\r\n\r\n\t\tconst block = moduleGraph.getParentBlock(d);\r\n\t\tlet index = moduleGraph.getParentBlockIndex(d);\r\n\r\n\t\t// deprecated fallback\r\n\t\tif (index < 0) {\r\n\t\t\tindex = block.dependencies.indexOf(d);\r\n\t\t}\r\n\r\n\t\tif (blockCache !== block) {\r\n\t\t\tmodules = blockModulesMap.get((blockCache = block));\r\n\t\t}\r\n\r\n\t\tconst i = index << 2;\r\n\t\tmodules[i] = m;\r\n\t\tmodules[i + 1] = state;\r\n\t}\r\n\r\n\tfor (const modules of arrays) {\r\n\t\tif (modules.length === 0) continue;\r\n\t\tlet indexMap;\r\n\t\tlet length = 0;\r\n\t\touter: for (let j = 0; j < modules.length; j += 2) {\r\n\t\t\tconst m = modules[j];\r\n\t\t\tif (m === undefined) continue;\r\n\t\t\tconst state = modules[j + 1];\r\n\t\t\tif (indexMap === undefined) {\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tfor (; i < length; i += 2) {\r\n\t\t\t\t\tif (modules[i] === m) {\r\n\t\t\t\t\t\tconst merged = modules[i + 1];\r\n\t\t\t\t\t\tif (merged === true) continue outer;\r\n\t\t\t\t\t\tmodules[i + 1] = ModuleGraphConnection.addConnectionStates(\r\n\t\t\t\t\t\t\tmerged,\r\n\t\t\t\t\t\t\tstate\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tmodules[length] = m;\r\n\t\t\t\tlength++;\r\n\t\t\t\tmodules[length] = state;\r\n\t\t\t\tlength++;\r\n\t\t\t\tif (length > 30) {\r\n\t\t\t\t\t// To avoid worse case performance, we will use an index map for\r\n\t\t\t\t\t// linear cost access, which allows to maintain O(n) complexity\r\n\t\t\t\t\t// while keeping allocations down to a minimum\r\n\t\t\t\t\tindexMap = new Map();\r\n\t\t\t\t\tfor (let i = 0; i < length; i += 2) {\r\n\t\t\t\t\t\tindexMap.set(modules[i], i + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst idx = indexMap.get(m);\r\n\t\t\t\tif (idx !== undefined) {\r\n\t\t\t\t\tconst merged = modules[idx];\r\n\t\t\t\t\tif (merged === true) continue outer;\r\n\t\t\t\t\tmodules[idx] = ModuleGraphConnection.addConnectionStates(\r\n\t\t\t\t\t\tmerged,\r\n\t\t\t\t\t\tstate\r\n\t\t\t\t\t);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmodules[length] = m;\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t\tmodules[length] = state;\r\n\t\t\t\t\tindexMap.set(m, length);\r\n\t\t\t\t\tlength++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tmodules.length = length;\r\n\t}\r\n};\r\n\r\n/**\r\n *\r\n * @param {Logger} logger a logger\r\n * @param {Compilation} compilation the compilation\r\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\r\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\r\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\r\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\r\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\r\n */\r\nconst visitModules = (\r\n\tlogger,\r\n\tcompilation,\r\n\tinputEntrypointsAndModules,\r\n\tchunkGroupInfoMap,\r\n\tblockConnections,\r\n\tblocksWithNestedBlocks,\r\n\tallCreatedChunkGroups\r\n) => {\r\n\tconst { moduleGraph, chunkGraph, moduleMemCaches } = compilation;\r\n\r\n\tconst blockModulesRuntimeMap = new Map();\r\n\r\n\t/** @type {RuntimeSpec | false} */\r\n\tlet blockModulesMapRuntime = false;\r\n\tlet blockModulesMap;\r\n\r\n\t/**\r\n\t *\r\n\t * @param {DependenciesBlock} block block\r\n\t * @param {RuntimeSpec} runtime runtime\r\n\t * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\r\n\t */\r\n\tconst getBlockModules = (block, runtime) => {\r\n\t\tif (blockModulesMapRuntime !== runtime) {\r\n\t\t\tblockModulesMap = blockModulesRuntimeMap.get(runtime);\r\n\t\t\tif (blockModulesMap === undefined) {\r\n\t\t\t\tblockModulesMap = new Map();\r\n\t\t\t\tblockModulesRuntimeMap.set(runtime, blockModulesMap);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet blockModules = blockModulesMap.get(block);\r\n\t\tif (blockModules !== undefined) return blockModules;\r\n\t\tconst module = /** @type {Module} */ (block.getRootBlock());\r\n\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\r\n\t\tif (memCache !== undefined) {\r\n\t\t\tconst map = memCache.provide(\r\n\t\t\t\t\"bundleChunkGraph.blockModules\",\r\n\t\t\t\truntime,\r\n\t\t\t\t() => {\r\n\t\t\t\t\tlogger.time(\"visitModules: prepare\");\r\n\t\t\t\t\tconst map = new Map();\r\n\t\t\t\t\textractBlockModules(module, moduleGraph, runtime, map);\r\n\t\t\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\r\n\t\t\t\t\treturn map;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tfor (const [block, blockModules] of map)\r\n\t\t\t\tblockModulesMap.set(block, blockModules);\r\n\t\t\treturn map.get(block);\r\n\t\t} else {\r\n\t\t\tlogger.time(\"visitModules: prepare\");\r\n\t\t\textractBlockModules(module, moduleGraph, runtime, blockModulesMap);\r\n\t\t\tblockModules = blockModulesMap.get(block);\r\n\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\r\n\t\t\treturn blockModules;\r\n\t\t}\r\n\t};\r\n\r\n\tlet statProcessedQueueItems = 0;\r\n\tlet statProcessedBlocks = 0;\r\n\tlet statConnectedChunkGroups = 0;\r\n\tlet statProcessedChunkGroupsForMerging = 0;\r\n\tlet statMergedAvailableModuleSets = 0;\r\n\tlet statForkedAvailableModules = 0;\r\n\tlet statForkedAvailableModulesCount = 0;\r\n\tlet statForkedAvailableModulesCountPlus = 0;\r\n\tlet statForkedMergedModulesCount = 0;\r\n\tlet statForkedMergedModulesCountPlus = 0;\r\n\tlet statForkedResultModulesCount = 0;\r\n\tlet statChunkGroupInfoUpdated = 0;\r\n\tlet statChildChunkGroupsReconnected = 0;\r\n\r\n\tlet nextChunkGroupIndex = 0;\r\n\tlet nextFreeModulePreOrderIndex = 0;\r\n\tlet nextFreeModulePostOrderIndex = 0;\r\n\r\n\t/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\r\n\tconst blockChunkGroups = new Map();\r\n\r\n\t/** @type {Map<string, ChunkGroupInfo>} */\r\n\tconst namedChunkGroups = new Map();\r\n\r\n\t/** @type {Map<string, ChunkGroupInfo>} */\r\n\tconst namedAsyncEntrypoints = new Map();\r\n\r\n\tconst ADD_AND_ENTER_ENTRY_MODULE = 0;\r\n\tconst ADD_AND_ENTER_MODULE = 1;\r\n\tconst ENTER_MODULE = 2;\r\n\tconst PROCESS_BLOCK = 3;\r\n\tconst PROCESS_ENTRY_BLOCK = 4;\r\n\tconst LEAVE_MODULE = 5;\r\n\r\n\t/** @type {QueueItem[]} */\r\n\tlet queue = [];\r\n\r\n\t/** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\r\n\tconst queueConnect = new Map();\r\n\t/** @type {Set<ChunkGroupInfo>} */\r\n\tconst chunkGroupsForCombining = new Set();\r\n\r\n\t// Fill queue with entrypoint modules\r\n\t// Create ChunkGroupInfo for entrypoints\r\n\tfor (const [chunkGroup, modules] of inputEntrypointsAndModules) {\r\n\t\tconst runtime = getEntryRuntime(\r\n\t\t\tcompilation,\r\n\t\t\tchunkGroup.name,\r\n\t\t\tchunkGroup.options\r\n\t\t);\r\n\t\t/** @type {ChunkGroupInfo} */\r\n\t\tconst chunkGroupInfo = {\r\n\t\t\tchunkGroup,\r\n\t\t\truntime,\r\n\t\t\tminAvailableModules: undefined,\r\n\t\t\tminAvailableModulesOwned: false,\r\n\t\t\tavailableModulesToBeMerged: [],\r\n\t\t\tskippedItems: undefined,\r\n\t\t\tresultingAvailableModules: undefined,\r\n\t\t\tchildren: undefined,\r\n\t\t\tavailableSources: undefined,\r\n\t\t\tavailableChildren: undefined,\r\n\t\t\tpreOrderIndex: 0,\r\n\t\t\tpostOrderIndex: 0,\r\n\t\t\tchunkLoading:\r\n\t\t\t\tchunkGroup.options.chunkLoading !== undefined\r\n\t\t\t\t\t? chunkGroup.options.chunkLoading !== false\r\n\t\t\t\t\t: compilation.outputOptions.chunkLoading !== false,\r\n\t\t\tasyncChunks:\r\n\t\t\t\tchunkGroup.options.asyncChunks !== undefined\r\n\t\t\t\t\t? chunkGroup.options.asyncChunks\r\n\t\t\t\t\t: compilation.outputOptions.asyncChunks !== false\r\n\t\t};\r\n\t\tchunkGroup.index = nextChunkGroupIndex++;\r\n\t\tif (chunkGroup.getNumberOfParents() > 0) {\r\n\t\t\t// minAvailableModules for child entrypoints are unknown yet, set to undefined.\r\n\t\t\t// This means no module is added until other sets are merged into\r\n\t\t\t// this minAvailableModules (by the parent entrypoints)\r\n\t\t\tconst skippedItems = new Set();\r\n\t\t\tfor (const module of modules) {\r\n\t\t\t\tskippedItems.add(module);\r\n\t\t\t}\r\n\t\t\tchunkGroupInfo.skippedItems = skippedItems;\r\n\t\t\tchunkGroupsForCombining.add(chunkGroupInfo);\r\n\t\t} else {\r\n\t\t\t// The application may start here: We start with an empty list of available modules\r\n\t\t\tchunkGroupInfo.minAvailableModules = EMPTY_SET;\r\n\t\t\tconst chunk = chunkGroup.getEntrypointChunk();\r\n\t\t\tfor (const module of modules) {\r\n\t\t\t\tqueue.push({\r\n\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\r\n\t\t\t\t\tblock: module,\r\n\t\t\t\t\tmodule,\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tchunkGroup,\r\n\t\t\t\t\tchunkGroupInfo\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\tchunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\r\n\t\tif (chunkGroup.name) {\r\n\t\t\tnamedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\r\n\t\t}\r\n\t}\r\n\t// Fill availableSources with parent-child dependencies between entrypoints\r\n\tfor (const chunkGroupInfo of chunkGroupsForCombining) {\r\n\t\tconst { chunkGroup } = chunkGroupInfo;\r\n\t\tchunkGroupInfo.availableSources = new Set();\r\n\t\tfor (const parent of chunkGroup.parentsIterable) {\r\n\t\t\tconst parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\r\n\t\t\tchunkGroupInfo.availableSources.add(parentChunkGroupInfo);\r\n\t\t\tif (parentChunkGroupInfo.availableChildren === undefined) {\r\n\t\t\t\tparentChunkGroupInfo.availableChildren = new Set();\r\n\t\t\t}\r\n\t\t\tparentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\r\n\t\t}\r\n\t}\r\n\t// pop() is used to read from the queue\r\n\t// so it need to be reversed to be iterated in\r\n\t// correct order\r\n\tqueue.reverse();\r\n\r\n\t/** @type {Set<ChunkGroupInfo>} */\r\n\tconst outdatedChunkGroupInfo = new Set();\r\n\t/** @type {Set<ChunkGroupInfo>} */\r\n\tconst chunkGroupsForMerging = new Set();\r\n\t/** @type {QueueItem[]} */\r\n\tlet queueDelayed = [];\r\n\r\n\t/** @type {[Module, ConnectionState][]} */\r\n\tconst skipConnectionBuffer = [];\r\n\t/** @type {Module[]} */\r\n\tconst skipBuffer = [];\r\n\t/** @type {QueueItem[]} */\r\n\tconst queueBuffer = [];\r\n\r\n\t/** @type {Module} */\r\n\tlet module;\r\n\t/** @type {Chunk} */\r\n\tlet chunk;\r\n\t/** @type {ChunkGroup} */\r\n\tlet chunkGroup;\r\n\t/** @type {DependenciesBlock} */\r\n\tlet block;\r\n\t/** @type {ChunkGroupInfo} */\r\n\tlet chunkGroupInfo;\r\n\r\n\t// For each async Block in graph\r\n\t/**\r\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\r\n\t * @returns {void}\r\n\t */\r\n\tconst iteratorBlock = b => {\r\n\t\t// 1. We create a chunk group with single chunk in it for this Block\r\n\t\t// but only once (blockChunkGroups map)\r\n\t\tlet cgi = blockChunkGroups.get(b);\r\n\t\t/** @type {ChunkGroup} */\r\n\t\tlet c;\r\n\t\t/** @type {Entrypoint} */\r\n\t\tlet entrypoint;\r\n\t\tconst entryOptions = b.groupOptions && b.groupOptions.entryOptions;\r\n\t\tif (cgi === undefined) {\r\n\t\t\tconst chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;\r\n\t\t\tif (entryOptions) {\r\n\t\t\t\tcgi = namedAsyncEntrypoints.get(chunkName);\r\n\t\t\t\tif (!cgi) {\r\n\t\t\t\t\tentrypoint = compilation.addAsyncEntrypoint(\r\n\t\t\t\t\t\tentryOptions,\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\tb.loc,\r\n\t\t\t\t\t\tb.request\r\n\t\t\t\t\t);\r\n\t\t\t\t\tentrypoint.index = nextChunkGroupIndex++;\r\n\t\t\t\t\tcgi = {\r\n\t\t\t\t\t\tchunkGroup: entrypoint,\r\n\t\t\t\t\t\truntime: entrypoint.options.runtime || entrypoint.name,\r\n\t\t\t\t\t\tminAvailableModules: EMPTY_SET,\r\n\t\t\t\t\t\tminAvailableModulesOwned: false,\r\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\r\n\t\t\t\t\t\tskippedItems: undefined,\r\n\t\t\t\t\t\tresultingAvailableModules: undefined,\r\n\t\t\t\t\t\tchildren: undefined,\r\n\t\t\t\t\t\tavailableSources: undefined,\r\n\t\t\t\t\t\tavailableChildren: undefined,\r\n\t\t\t\t\t\tpreOrderIndex: 0,\r\n\t\t\t\t\t\tpostOrderIndex: 0,\r\n\t\t\t\t\t\tchunkLoading:\r\n\t\t\t\t\t\t\tentryOptions.chunkLoading !== undefined\r\n\t\t\t\t\t\t\t\t? entryOptions.chunkLoading !== false\r\n\t\t\t\t\t\t\t\t: chunkGroupInfo.chunkLoading,\r\n\t\t\t\t\t\tasyncChunks:\r\n\t\t\t\t\t\t\tentryOptions.asyncChunks !== undefined\r\n\t\t\t\t\t\t\t\t? entryOptions.asyncChunks\r\n\t\t\t\t\t\t\t\t: chunkGroupInfo.asyncChunks\r\n\t\t\t\t\t};\r\n\t\t\t\t\tchunkGroupInfoMap.set(entrypoint, cgi);\r\n\r\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\r\n\t\t\t\t\tif (chunkName) {\r\n\t\t\t\t\t\tnamedAsyncEntrypoints.set(chunkName, cgi);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\r\n\t\t\t\t\t// TODO merge entryOptions\r\n\t\t\t\t\tentrypoint.addOrigin(module, b.loc, b.request);\r\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 2. We enqueue the DependenciesBlock for traversal\r\n\t\t\t\tqueueDelayed.push({\r\n\t\t\t\t\taction: PROCESS_ENTRY_BLOCK,\r\n\t\t\t\t\tblock: b,\r\n\t\t\t\t\tmodule: module,\r\n\t\t\t\t\tchunk: entrypoint.chunks[0],\r\n\t\t\t\t\tchunkGroup: entrypoint,\r\n\t\t\t\t\tchunkGroupInfo: cgi\r\n\t\t\t\t});\r\n\t\t\t} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\r\n\t\t\t\t// Just queue the block into the current chunk group\r\n\t\t\t\tqueue.push({\r\n\t\t\t\t\taction: PROCESS_BLOCK,\r\n\t\t\t\t\tblock: b,\r\n\t\t\t\t\tmodule: module,\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tchunkGroup,\r\n\t\t\t\t\tchunkGroupInfo\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tcgi = chunkName && namedChunkGroups.get(chunkName);\r\n\t\t\t\tif (!cgi) {\r\n\t\t\t\t\tc = compilation.addChunkInGroup(\r\n\t\t\t\t\t\tb.groupOptions || b.chunkName,\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\tb.loc,\r\n\t\t\t\t\t\tb.request\r\n\t\t\t\t\t);\r\n\t\t\t\t\tc.index = nextChunkGroupIndex++;\r\n\t\t\t\t\tcgi = {\r\n\t\t\t\t\t\tchunkGroup: c,\r\n\t\t\t\t\t\truntime: chunkGroupInfo.runtime,\r\n\t\t\t\t\t\tminAvailableModules: undefined,\r\n\t\t\t\t\t\tminAvailableModulesOwned: undefined,\r\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\r\n\t\t\t\t\t\tskippedItems: undefined,\r\n\t\t\t\t\t\tresultingAvailableModules: undefined,\r\n\t\t\t\t\t\tchildren: undefined,\r\n\t\t\t\t\t\tavailableSources: undefined,\r\n\t\t\t\t\t\tavailableChildren: undefined,\r\n\t\t\t\t\t\tpreOrderIndex: 0,\r\n\t\t\t\t\t\tpostOrderIndex: 0,\r\n\t\t\t\t\t\tchunkLoading: chunkGroupInfo.chunkLoading,\r\n\t\t\t\t\t\tasyncChunks: chunkGroupInfo.asyncChunks\r\n\t\t\t\t\t};\r\n\t\t\t\t\tallCreatedChunkGroups.add(c);\r\n\t\t\t\t\tchunkGroupInfoMap.set(c, cgi);\r\n\t\t\t\t\tif (chunkName) {\r\n\t\t\t\t\t\tnamedChunkGroups.set(chunkName, cgi);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tc = cgi.chunkGroup;\r\n\t\t\t\t\tif (c.isInitial()) {\r\n\t\t\t\t\t\tcompilation.errors.push(\r\n\t\t\t\t\t\t\tnew AsyncDependencyToInitialChunkError(chunkName, module, b.loc)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tc = chunkGroup;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tc.addOptions(b.groupOptions);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc.addOrigin(module, b.loc, b.request);\r\n\t\t\t\t}\r\n\t\t\t\tblockConnections.set(b, []);\r\n\t\t\t}\r\n\t\t\tblockChunkGroups.set(b, cgi);\r\n\t\t} else if (entryOptions) {\r\n\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\r\n\t\t} else {\r\n\t\t\tc = cgi.chunkGroup;\r\n\t\t}\r\n\r\n\t\tif (c !== undefined) {\r\n\t\t\t// 2. We store the connection for the block\r\n\t\t\t// to connect it later if needed\r\n\t\t\tblockConnections.get(b).push({\r\n\t\t\t\toriginChunkGroupInfo: chunkGroupInfo,\r\n\t\t\t\tchunkGroup: c\r\n\t\t\t});\r\n\r\n\t\t\t// 3. We enqueue the chunk group info creation/updating\r\n\t\t\tlet connectList = queueConnect.get(chunkGroupInfo);\r\n\t\t\tif (connectList === undefined) {\r\n\t\t\t\tconnectList = new Set();\r\n\t\t\t\tqueueConnect.set(chunkGroupInfo, connectList);\r\n\t\t\t}\r\n\t\t\tconnectList.add(cgi);\r\n\r\n\t\t\t// TODO check if this really need to be done for each traversal\r\n\t\t\t// or if it is enough when it's queued when created\r\n\t\t\t// 4. We enqueue the DependenciesBlock for traversal\r\n\t\t\tqueueDelayed.push({\r\n\t\t\t\taction: PROCESS_BLOCK,\r\n\t\t\t\tblock: b,\r\n\t\t\t\tmodule: module,\r\n\t\t\t\tchunk: c.chunks[0],\r\n\t\t\t\tchunkGroup: c,\r\n\t\t\t\tchunkGroupInfo: cgi\r\n\t\t\t});\r\n\t\t} else if (entrypoint !== undefined) {\r\n\t\t\tchunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * @param {DependenciesBlock} block the block\r\n\t * @returns {void}\r\n\t */\r\n\tconst processBlock = block => {\r\n\t\tstatProcessedBlocks++;\r\n\t\t// get prepared block info\r\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\r\n\r\n\t\tif (blockModules !== undefined) {\r\n\t\t\tconst { minAvailableModules } = chunkGroupInfo;\r\n\t\t\t// Buffer items because order need to be reversed to get indices correct\r\n\t\t\t// Traverse all referenced modules\r\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\r\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\r\n\t\t\t\tif (chunkGraph.isModuleInChunk(refModule, chunk)) {\r\n\t\t\t\t\t// skip early if already connected\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\r\n\t\t\t\t\tblockModules[i + 1]\r\n\t\t\t\t);\r\n\t\t\t\tif (activeState !== true) {\r\n\t\t\t\t\tskipConnectionBuffer.push([refModule, activeState]);\r\n\t\t\t\t\tif (activeState === false) continue;\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\tactiveState === true &&\r\n\t\t\t\t\t(minAvailableModules.has(refModule) ||\r\n\t\t\t\t\t\tminAvailableModules.plus.has(refModule))\r\n\t\t\t\t) {\r\n\t\t\t\t\t// already in parent chunks, skip it for now\r\n\t\t\t\t\tskipBuffer.push(refModule);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// enqueue, then add and enter to be in the correct order\r\n\t\t\t\t// this is relevant with circular dependencies\r\n\t\t\t\tqueueBuffer.push({\r\n\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\r\n\t\t\t\t\tblock: refModule,\r\n\t\t\t\t\tmodule: refModule,\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tchunkGroup,\r\n\t\t\t\t\tchunkGroupInfo\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Add buffered items in reverse order\r\n\t\t\tif (skipConnectionBuffer.length > 0) {\r\n\t\t\t\tlet { skippedModuleConnections } = chunkGroupInfo;\r\n\t\t\t\tif (skippedModuleConnections === undefined) {\r\n\t\t\t\t\tchunkGroupInfo.skippedModuleConnections = skippedModuleConnections =\r\n\t\t\t\t\t\tnew Set();\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tskippedModuleConnections.add(skipConnectionBuffer[i]);\r\n\t\t\t\t}\r\n\t\t\t\tskipConnectionBuffer.length = 0;\r\n\t\t\t}\r\n\t\t\tif (skipBuffer.length > 0) {\r\n\t\t\t\tlet { skippedItems } = chunkGroupInfo;\r\n\t\t\t\tif (skippedItems === undefined) {\r\n\t\t\t\t\tchunkGroupInfo.skippedItems = skippedItems = new Set();\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tskippedItems.add(skipBuffer[i]);\r\n\t\t\t\t}\r\n\t\t\t\tskipBuffer.length = 0;\r\n\t\t\t}\r\n\t\t\tif (queueBuffer.length > 0) {\r\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tqueue.push(queueBuffer[i]);\r\n\t\t\t\t}\r\n\t\t\t\tqueueBuffer.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Traverse all Blocks\r\n\t\tfor (const b of block.blocks) {\r\n\t\t\titeratorBlock(b);\r\n\t\t}\r\n\r\n\t\tif (block.blocks.length > 0 && module !== block) {\r\n\t\t\tblocksWithNestedBlocks.add(block);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * @param {DependenciesBlock} block the block\r\n\t * @returns {void}\r\n\t */\r\n\tconst processEntryBlock = block => {\r\n\t\tstatProcessedBlocks++;\r\n\t\t// get prepared block info\r\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\r\n\r\n\t\tif (blockModules !== undefined) {\r\n\t\t\t// Traverse all referenced modules\r\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\r\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\r\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\r\n\t\t\t\t\tblockModules[i + 1]\r\n\t\t\t\t);\r\n\t\t\t\t// enqueue, then add and enter to be in the correct order\r\n\t\t\t\t// this is relevant with circular dependencies\r\n\t\t\t\tqueueBuffer.push({\r\n\t\t\t\t\taction:\r\n\t\t\t\t\t\tactiveState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\r\n\t\t\t\t\tblock: refModule,\r\n\t\t\t\t\tmodule: refModule,\r\n\t\t\t\t\tchunk,\r\n\t\t\t\t\tchunkGroup,\r\n\t\t\t\t\tchunkGroupInfo\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Add buffered items in reverse order\r\n\t\t\tif (queueBuffer.length > 0) {\r\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tqueue.push(queueBuffer[i]);\r\n\t\t\t\t}\r\n\t\t\t\tqueueBuffer.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Traverse all Blocks\r\n\t\tfor (const b of block.blocks) {\r\n\t\t\titeratorBlock(b);\r\n\t\t}\r\n\r\n\t\tif (block.blocks.length > 0 && module !== block) {\r\n\t\t\tblocksWithNestedBlocks.add(block);\r\n\t\t}\r\n\t};\r\n\r\n\tconst processQueue = () => {\r\n\t\twhile (queue.length) {\r\n\t\t\tstatProcessedQueueItems++;\r\n\t\t\tconst queueItem = queue.pop();\r\n\t\t\tmodule = queueItem.module;\r\n\t\t\tblock = queueItem.block;\r\n\t\t\tchunk = queueItem.chunk;\r\n\t\t\tchunkGroup = queueItem.chunkGroup;\r\n\t\t\tchunkGroupInfo = queueItem.chunkGroupInfo;\r\n\r\n\t\t\tswitch (queueItem.action) {\r\n\t\t\t\tcase ADD_AND_ENTER_ENTRY_MODULE:\r\n\t\t\t\t\tchunkGraph.connectChunkAndEntryModule(\r\n\t\t\t\t\t\tchunk,\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t/** @type {Entrypoint} */ (chunkGroup)\r\n\t\t\t\t\t);\r\n\t\t\t\t// fallthrough\r\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\r\n\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) {\r\n\t\t\t\t\t\t// already connected, skip it\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// We connect Module and Chunk\r\n\t\t\t\t\tchunkGraph.connectChunkAndModule(chunk, module);\r\n\t\t\t\t}\r\n\t\t\t\t// fallthrough\r\n\t\t\t\tcase ENTER_MODULE: {\r\n\t\t\t\t\tconst index = chunkGroup.getModulePreOrderIndex(module);\r\n\t\t\t\t\tif (index === undefined) {\r\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tchunkGroupInfo.preOrderIndex++\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tmoduleGraph.setPreOrderIndexIfUnset(\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tnextFreeModulePreOrderIndex\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tnextFreeModulePreOrderIndex++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// reuse queueItem\r\n\t\t\t\t\tqueueItem.action = LEAVE_MODULE;\r\n\t\t\t\t\tqueue.push(queueItem);\r\n\t\t\t\t}\r\n\t\t\t\t// fallthrough\r\n\t\t\t\tcase PROCESS_BLOCK: {\r\n\t\t\t\t\tprocessBlock(block);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase PROCESS_ENTRY_BLOCK: {\r\n\t\t\t\t\tprocessEntryBlock(block);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase LEAVE_MODULE: {\r\n\t\t\t\t\tconst index = chunkGroup.getModulePostOrderIndex(module);\r\n\t\t\t\t\tif (index === undefined) {\r\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tchunkGroupInfo.postOrderIndex++\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tmoduleGraph.setPostOrderIndexIfUnset(\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tnextFreeModulePostOrderIndex\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tnextFreeModulePostOrderIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconst calculateResultingAvailableModules = chunkGroupInfo => {\r\n\t\tif (chunkGroupInfo.resultingAvailableModules)\r\n\t\t\treturn chunkGroupInfo.resultingAvailableModules;\r\n\r\n\t\tconst minAvailableModules = chunkGroupInfo.minAvailableModules;\r\n\r\n\t\t// Create a new Set of available modules at this point\r\n\t\t// We want to be as lazy as possible. There are multiple ways doing this:\r\n\t\t// Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\r\n\t\t// - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\r\n\t\t// - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\r\n\t\t// We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\r\n\r\n\t\tlet resultingAvailableModules;\r\n\t\tif (minAvailableModules.size > minAvailableModules.plus.size) {\r\n\t\t\t// resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\r\n\t\t\tresultingAvailableModules =\r\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (new Set());\r\n\t\t\tfor (const module of minAvailableModules.plus)\r\n\t\t\t\tminAvailableModules.add(module);\r\n\t\t\tminAvailableModules.plus = EMPTY_SET;\r\n\t\t\tresultingAvailableModules.plus = minAvailableModules;\r\n\t\t\tchunkGroupInfo.minAvailableModulesOwned = false;\r\n\t\t} else {\r\n\t\t\t// resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\r\n\t\t\tresultingAvailableModules =\r\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (\r\n\t\t\t\t\tnew Set(minAvailableModules)\r\n\t\t\t\t);\r\n\t\t\tresultingAvailableModules.plus = minAvailableModules.plus;\r\n\t\t}\r\n\r\n\t\t// add the modules from the chunk group to the set\r\n\t\tfor (const chunk of chunkGroupInfo.chunkGroup.chunks) {\r\n\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\r\n\t\t\t\tresultingAvailableModules.add(m);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (chunkGroupInfo.resultingAvailableModules =\r\n\t\t\tresultingAvailableModules);\r\n\t};\r\n\r\n\tconst processConnectQueue = () => {\r\n\t\t// Figure out new parents for chunk groups\r\n\t\t// to get new available modules for these children\r\n\t\tfor (const [chunkGroupInfo, targets] of queueConnect) {\r\n\t\t\t// 1. Add new targets to the list of children\r\n\t\t\tif (chunkGroupInfo.children === undefined) {\r\n\t\t\t\tchunkGroupInfo.children = targets;\r\n\t\t\t} else {\r\n\t\t\t\tfor (const target of targets) {\r\n\t\t\t\t\tchunkGroupInfo.children.add(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Calculate resulting available modules\r\n\t\t\tconst resultingAvailableModules =\r\n\t\t\t\tcalculateResultingAvailableModules(chunkGroupInfo);\r\n\r\n\t\t\tconst runtime = chunkGroupInfo.runtime;\r\n\r\n\t\t\t// 3. Update chunk group info\r\n\t\t\tfor (const target of targets) {\r\n\t\t\t\ttarget.availableModulesToBeMerged.push(resultingAvailableModules);\r\n\t\t\t\tchunkGroupsForMerging.add(target);\r\n\t\t\t\tconst oldRuntime = target.runtime;\r\n\t\t\t\tconst newRuntime = mergeRuntime(oldRuntime, runtime);\r\n\t\t\t\tif (oldRuntime !== newRuntime) {\r\n\t\t\t\t\ttarget.runtime = newRuntime;\r\n\t\t\t\t\toutdatedChunkGroupInfo.add(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tstatConnectedChunkGroups += targets.size;\r\n\t\t}\r\n\t\tqueueConnect.clear();\r\n\t};\r\n\r\n\tconst processChunkGroupsForMerging = () => {\r\n\t\tstatProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\r\n\r\n\t\t// Execute the merge\r\n\t\tfor (const info of chunkGroupsForMerging) {\r\n\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\r\n\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\r\n\r\n\t\t\tstatMergedAvailableModuleSets += availableModulesToBeMerged.length;\r\n\r\n\t\t\t// 1. Get minimal available modules\r\n\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\r\n\t\t\t// This step calculates the minimal available modules and skips traversal when\r\n\t\t\t// the list didn't shrink.\r\n\t\t\tif (availableModulesToBeMerged.length > 1) {\r\n\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\r\n\t\t\t}\r\n\t\t\tlet changed = false;\r\n\t\t\tmerge: for (const availableModules of availableModulesToBeMerged) {\r\n\t\t\t\tif (cachedMinAvailableModules === undefined) {\r\n\t\t\t\t\tcachedMinAvailableModules = availableModules;\r\n\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\r\n\t\t\t\t\tinfo.minAvailableModulesOwned = false;\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (info.minAvailableModulesOwned) {\r\n\t\t\t\t\t\t// We own it and can modify it\r\n\t\t\t\t\t\tif (cachedMinAvailableModules.plus === availableModules.plus) {\r\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\r\n\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\r\n\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\r\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\r\n\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\r\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\r\n\t\t\t\t\t\t\t\t\t// We can't remove modules from the plus part\r\n\t\t\t\t\t\t\t\t\t// so we need to merge plus into the normal part to allow modifying it\r\n\t\t\t\t\t\t\t\t\tconst iterator =\r\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\r\n\t\t\t\t\t\t\t\t\t// fast forward add all modules until m\r\n\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\r\n\t\t\t\t\t\t\t\t\tlet it;\r\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\t\tif (module === m) break;\r\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// check the remaining modules before adding\r\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\r\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\r\n\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus = EMPTY_SET;\r\n\t\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\t\tcontinue merge;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (cachedMinAvailableModules.plus === availableModules.plus) {\r\n\t\t\t\t\t\t// Common and fast case when the plus part is shared\r\n\t\t\t\t\t\t// We only need to care about the normal part\r\n\t\t\t\t\t\tif (availableModules.size < cachedMinAvailableModules.size) {\r\n\t\t\t\t\t\t\t// the new availableModules is smaller so it's faster to\r\n\t\t\t\t\t\t\t// fork from the new availableModules\r\n\t\t\t\t\t\t\tstatForkedAvailableModules++;\r\n\t\t\t\t\t\t\tstatForkedAvailableModulesCount += availableModules.size;\r\n\t\t\t\t\t\t\tstatForkedMergedModulesCount += cachedMinAvailableModules.size;\r\n\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\r\n\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\r\n\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\r\n\t\t\t\t\t\t\tfor (const m of availableModules) {\r\n\t\t\t\t\t\t\t\tif (cachedMinAvailableModules.has(m)) {\r\n\t\t\t\t\t\t\t\t\tnewSet.add(m);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\r\n\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\r\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\r\n\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\r\n\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\tcontinue merge;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\r\n\t\t\t\t\t\t\tif (!availableModules.has(m)) {\r\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\r\n\t\t\t\t\t\t\t\t// but we don't own it\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\r\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\r\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\r\n\t\t\t\t\t\t\t\t// as the plus part is equal we can just take over this one\r\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\r\n\t\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\r\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\r\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\r\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\r\n\t\t\t\t\t\t\t\tlet it;\r\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\tif (module === m) break;\r\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\r\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\r\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\r\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\r\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\r\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\tcontinue merge;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\r\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\r\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\r\n\t\t\t\t\t\t\t\t// but we don't own it\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\r\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\r\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\r\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\r\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\r\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\r\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\r\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\r\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\r\n\t\t\t\t\t\t\t\tlet it;\r\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\tif (module === m) break;\r\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\r\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\r\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// also check all modules in cachedMinAvailableModules.plus\r\n\t\t\t\t\t\t\t\tfor (const module of cachedMinAvailableModules.plus) {\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\r\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\r\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\r\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\r\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\tcontinue merge;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\r\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\r\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\r\n\t\t\t\t\t\t\t\t// but we don't own it\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\r\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\r\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\r\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\r\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\r\n\t\t\t\t\t\t\t\t// we already know that all modules directly from cachedMinAvailableModules are in availableModules too\r\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (\r\n\t\t\t\t\t\t\t\t\tnew Set(cachedMinAvailableModules)\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\r\n\t\t\t\t\t\t\t\tconst iterator =\r\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\r\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\r\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\r\n\t\t\t\t\t\t\t\tlet it;\r\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\tif (module === m) break;\r\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\r\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\r\n\t\t\t\t\t\t\t\t\tconst module = it.value;\r\n\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\r\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\r\n\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\r\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\r\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\r\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\tcontinue merge;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tavailableModulesToBeMerged.length = 0;\r\n\t\t\tif (changed) {\r\n\t\t\t\tinfo.resultingAvailableModules = undefined;\r\n\t\t\t\toutdatedChunkGroupInfo.add(info);\r\n\t\t\t}\r\n\t\t}\r\n\t\tchunkGroupsForMerging.clear();\r\n\t};\r\n\r\n\tconst processChunkGroupsForCombining = () => {\r\n\t\tfor (const info of chunkGroupsForCombining) {\r\n\t\t\tfor (const source of info.availableSources) {\r\n\t\t\t\tif (!source.minAvailableModules) {\r\n\t\t\t\t\tchunkGroupsForCombining.delete(info);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const info of chunkGroupsForCombining) {\r\n\t\t\tconst availableModules = /** @type {ModuleSetPlus} */ (new Set());\r\n\t\t\tavailableModules.plus = EMPTY_SET;\r\n\t\t\tconst mergeSet = set => {\r\n\t\t\t\tif (set.size > availableModules.plus.size) {\r\n\t\t\t\t\tfor (const item of availableModules.plus) availableModules.add(item);\r\n\t\t\t\t\tavailableModules.plus = set;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (const item of set) availableModules.add(item);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// combine minAvailableModules from all resultingAvailableModules\r\n\t\t\tfor (const source of info.availableSources) {\r\n\t\t\t\tconst resultingAvailableModules =\r\n\t\t\t\t\tcalculateResultingAvailableModules(source);\r\n\t\t\t\tmergeSet(resultingAvailableModules);\r\n\t\t\t\tmergeSet(resultingAvailableModules.plus);\r\n\t\t\t}\r\n\t\t\tinfo.minAvailableModules = availableModules;\r\n\t\t\tinfo.minAvailableModulesOwned = false;\r\n\t\t\tinfo.resultingAvailableModules = undefined;\r\n\t\t\toutdatedChunkGroupInfo.add(info);\r\n\t\t}\r\n\t\tchunkGroupsForCombining.clear();\r\n\t};\r\n\r\n\tconst processOutdatedChunkGroupInfo = () => {\r\n\t\tstatChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\r\n\t\t// Revisit skipped elements\r\n\t\tfor (const info of outdatedChunkGroupInfo) {\r\n\t\t\t// 1. Reconsider skipped items\r\n\t\t\tif (info.skippedItems !== undefined) {\r\n\t\t\t\tconst { minAvailableModules } = info;\r\n\t\t\t\tfor (const module of info.skippedItems) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t!minAvailableModules.has(module) &&\r\n\t\t\t\t\t\t!minAvailableModules.plus.has(module)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tqueue.push({\r\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\r\n\t\t\t\t\t\t\tblock: module,\r\n\t\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\r\n\t\t\t\t\t\t\tchunkGroup: info.chunkGroup,\r\n\t\t\t\t\t\t\tchunkGroupInfo: info\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tinfo.skippedItems.delete(module);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Reconsider skipped connections\r\n\t\t\tif (info.skippedModuleConnections !== undefined) {\r\n\t\t\t\tconst { minAvailableModules } = info;\r\n\t\t\t\tfor (const entry of info.skippedModuleConnections) {\r\n\t\t\t\t\tconst [module, activeState] = entry;\r\n\t\t\t\t\tif (activeState === false) continue;\r\n\t\t\t\t\tif (activeState === true) {\r\n\t\t\t\t\t\tinfo.skippedModuleConnections.delete(entry);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tactiveState === true &&\r\n\t\t\t\t\t\t(minAvailableModules.has(module) ||\r\n\t\t\t\t\t\t\tminAvailableModules.plus.has(module))\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tinfo.skippedItems.add(module);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tqueue.push({\r\n\t\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\r\n\t\t\t\t\t\tblock: module,\r\n\t\t\t\t\t\tmodule,\r\n\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\r\n\t\t\t\t\t\tchunkGroup: info.chunkGroup,\r\n\t\t\t\t\t\tchunkGroupInfo: info\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Reconsider children chunk groups\r\n\t\t\tif (info.children !== undefined) {\r\n\t\t\t\tstatChildChunkGroupsReconnected += info.children.size;\r\n\t\t\t\tfor (const cgi of info.children) {\r\n\t\t\t\t\tlet connectList = queueConnect.get(info);\r\n\t\t\t\t\tif (connectList === undefined) {\r\n\t\t\t\t\t\tconnectList = new Set();\r\n\t\t\t\t\t\tqueueConnect.set(info, connectList);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconnectList.add(cgi);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Reconsider chunk groups for combining\r\n\t\t\tif (info.availableChildren !== undefined) {\r\n\t\t\t\tfor (const cgi of info.availableChildren) {\r\n\t\t\t\t\tchunkGroupsForCombining.add(cgi);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\toutdatedChunkGroupInfo.clear();\r\n\t};\r\n\r\n\t// Iterative traversal of the Module graph\r\n\t// Recursive would be simpler to write but could result in Stack Overflows\r\n\twhile (queue.length || queueConnect.size) {\r\n\t\tlogger.time(\"visitModules: visiting\");\r\n\t\tprocessQueue();\r\n\t\tlogger.timeAggregateEnd(\"visitModules: prepare\");\r\n\t\tlogger.timeEnd(\"visitModules: visiting\");\r\n\r\n\t\tif (chunkGroupsForCombining.size > 0) {\r\n\t\t\tlogger.time(\"visitModules: combine available modules\");\r\n\t\t\tprocessChunkGroupsForCombining();\r\n\t\t\tlogger.timeEnd(\"visitModules: combine available modules\");\r\n\t\t}\r\n\r\n\t\tif (queueConnect.size > 0) {\r\n\t\t\tlogger.time(\"visitModules: calculating available modules\");\r\n\t\t\tprocessConnectQueue();\r\n\t\t\tlogger.timeEnd(\"visitModules: calculating available modules\");\r\n\r\n\t\t\tif (chunkGroupsForMerging.size > 0) {\r\n\t\t\t\tlogger.time(\"visitModules: merging available modules\");\r\n\t\t\t\tprocessChunkGroupsForMerging();\r\n\t\t\t\tlogger.timeEnd(\"visitModules: merging available modules\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (outdatedChunkGroupInfo.size > 0) {\r\n\t\t\tlogger.time(\"visitModules: check modules for revisit\");\r\n\t\t\tprocessOutdatedChunkGroupInfo();\r\n\t\t\tlogger.timeEnd(\"visitModules: check modules for revisit\");\r\n\t\t}\r\n\r\n\t\t// Run queueDelayed when all items of the queue are processed\r\n\t\t// This is important to get the global indexing correct\r\n\t\t// Async blocks should be processed after all sync blocks are processed\r\n\t\tif (queue.length === 0) {\r\n\t\t\tconst tempQueue = queue;\r\n\t\t\tqueue = queueDelayed.reverse();\r\n\t\t\tqueueDelayed = tempQueue;\r\n\t\t}\r\n\t}\r\n\r\n\tlogger.log(\r\n\t\t`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`\r\n\t);\r\n\tlogger.log(`${statConnectedChunkGroups} chunk groups connected`);\r\n\tlogger.log(\r\n\t\t`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`\r\n\t);\r\n\tlogger.log(\r\n\t\t`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`\r\n\t);\r\n};\r\n\r\n/**\r\n *\r\n * @param {Compilation} compilation the compilation\r\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\r\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\r\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\r\n */\r\nconst connectChunkGroups = (\r\n\tcompilation,\r\n\tblocksWithNestedBlocks,\r\n\tblockConnections,\r\n\tchunkGroupInfoMap\r\n) => {\r\n\tconst { chunkGraph } = compilation;\r\n\r\n\t/**\r\n\t * Helper function to check if all modules of a chunk are available\r\n\t *\r\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\r\n\t * @param {ModuleSetPlus} availableModules the comparator set\r\n\t * @returns {boolean} return true if all modules of a chunk are available\r\n\t */\r\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\r\n\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\r\n\t\t\t\tif (!availableModules.has(module) && !availableModules.plus.has(module))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t// For each edge in the basic chunk graph\r\n\tfor (const [block, connections] of blockConnections) {\r\n\t\t// 1. Check if connection is needed\r\n\t\t// When none of the dependencies need to be connected\r\n\t\t// we can skip all of them\r\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\r\n\t\t// connections and modules can only create one version\r\n\t\t// TODO maybe decide this per runtime\r\n\t\tif (\r\n\t\t\t// TODO is this needed?\r\n\t\t\t!blocksWithNestedBlocks.has(block) &&\r\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\r\n\t\t\t\tareModulesAvailable(\r\n\t\t\t\t\tchunkGroup,\r\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// 2. Foreach edge\r\n\t\tfor (let i = 0; i < connections.length; i++) {\r\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\r\n\r\n\t\t\t// 3. Connect block with chunk\r\n\t\t\tchunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\r\n\r\n\t\t\t// 4. Connect chunk with parent\r\n\t\t\tconnectChunkGroupParentAndChild(\r\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\r\n\t\t\t\tchunkGroup\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * Remove all unconnected chunk groups\r\n * @param {Compilation} compilation the compilation\r\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\r\n */\r\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\r\n\tconst { chunkGraph } = compilation;\r\n\r\n\tfor (const chunkGroup of allCreatedChunkGroups) {\r\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\r\n\t\t\tfor (const chunk of chunkGroup.chunks) {\r\n\t\t\t\tcompilation.chunks.delete(chunk);\r\n\t\t\t\tchunkGraph.disconnectChunk(chunk);\r\n\t\t\t}\r\n\t\t\tchunkGraph.disconnectChunkGroup(chunkGroup);\r\n\t\t\tchunkGroup.remove();\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * This method creates the Chunk graph from the Module graph\r\n * @param {Compilation} compilation the compilation\r\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\r\n * @returns {void}\r\n */\r\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\r\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph\");\r\n\r\n\t// SHARED STATE\r\n\r\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\r\n\tconst blockConnections = new Map();\r\n\r\n\t/** @type {Set<ChunkGroup>} */\r\n\tconst allCreatedChunkGroups = new Set();\r\n\r\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\r\n\tconst chunkGroupInfoMap = new Map();\r\n\r\n\t/** @type {Set<DependenciesBlock>} */\r\n\tconst blocksWithNestedBlocks = new Set();\r\n\r\n\t// PART ONE\r\n\r\n\tlogger.time(\"visitModules\");\r\n\tvisitModules(\r\n\t\tlogger,\r\n\t\tcompilation,\r\n\t\tinputEntrypointsAndModules,\r\n\t\tchunkGroupInfoMap,\r\n\t\tblockConnections,\r\n\t\tblocksWithNestedBlocks,\r\n\t\tallCreatedChunkGroups\r\n\t);\r\n\tlogger.timeEnd(\"visitModules\");\r\n\r\n\t// PART TWO\r\n\r\n\tlogger.time(\"connectChunkGroups\");\r\n\tconnectChunkGroups(\r\n\t\tcompilation,\r\n\t\tblocksWithNestedBlocks,\r\n\t\tblockConnections,\r\n\t\tchunkGroupInfoMap\r\n\t);\r\n\tlogger.timeEnd(\"connectChunkGroups\");\r\n\r\n\tfor (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\r\n\t\tfor (const chunk of chunkGroup.chunks)\r\n\t\t\tchunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\r\n\t}\r\n\r\n\t// Cleanup work\r\n\r\n\tlogger.time(\"cleanup\");\r\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\r\n\tlogger.timeEnd(\"cleanup\");\r\n};\r\n\r\nmodule.exports = buildChunkGraph;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}