{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\r\n * Module itself is not connected, but transitive modules are connected transitively.\r\n */\nconst TRANSITIVE_ONLY = Symbol(\"transitive only\");\n\n/**\r\n * While determining the active state, this flag is used to signal a circular connection.\r\n */\nconst CIRCULAR_CONNECTION = Symbol(\"circular connection\");\n\n/** @typedef {boolean | typeof TRANSITIVE_ONLY | typeof CIRCULAR_CONNECTION} ConnectionState */\n\n/**\r\n * @param {ConnectionState} a first\r\n * @param {ConnectionState} b second\r\n * @returns {ConnectionState} merged\r\n */\nconst addConnectionStates = (a, b) => {\n  if (a === true || b === true) return true;\n  if (a === false) return b;\n  if (b === false) return a;\n  if (a === TRANSITIVE_ONLY) return b;\n  if (b === TRANSITIVE_ONLY) return a;\n  return a;\n};\n\n/**\r\n * @param {ConnectionState} a first\r\n * @param {ConnectionState} b second\r\n * @returns {ConnectionState} intersected\r\n */\nconst intersectConnectionStates = (a, b) => {\n  if (a === false || b === false) return false;\n  if (a === true) return b;\n  if (b === true) return a;\n  if (a === CIRCULAR_CONNECTION) return b;\n  if (b === CIRCULAR_CONNECTION) return a;\n  return a;\n};\nclass ModuleGraphConnection {\n  /**\r\n   * @param {Module|null} originModule the referencing module\r\n   * @param {Dependency|null} dependency the referencing dependency\r\n   * @param {Module} module the referenced module\r\n   * @param {string=} explanation some extra detail\r\n   * @param {boolean=} weak the reference is weak\r\n   * @param {false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState=} condition condition for the connection\r\n   */\n  constructor(originModule, dependency, module, explanation) {\n    let weak = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let condition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n    this.originModule = originModule;\n    this.resolvedOriginModule = originModule;\n    this.dependency = dependency;\n    this.resolvedModule = module;\n    this.module = module;\n    this.weak = weak;\n    this.conditional = !!condition;\n    this._active = condition !== false;\n    /** @type {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} */\n    this.condition = condition || undefined;\n    /** @type {Set<string>} */\n    this.explanations = undefined;\n    if (explanation) {\n      this.explanations = new Set();\n      this.explanations.add(explanation);\n    }\n  }\n  clone() {\n    const clone = new ModuleGraphConnection(this.resolvedOriginModule, this.dependency, this.resolvedModule, undefined, this.weak, this.condition);\n    clone.originModule = this.originModule;\n    clone.module = this.module;\n    clone.conditional = this.conditional;\n    clone._active = this._active;\n    if (this.explanations) clone.explanations = new Set(this.explanations);\n    return clone;\n  }\n\n  /**\r\n   * @param {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} condition condition for the connection\r\n   * @returns {void}\r\n   */\n  addCondition(condition) {\n    if (this.conditional) {\n      const old = this.condition;\n      this.condition = (c, r) => intersectConnectionStates(old(c, r), condition(c, r));\n    } else if (this._active) {\n      this.conditional = true;\n      this.condition = condition;\n    }\n  }\n\n  /**\r\n   * @param {string} explanation the explanation to add\r\n   * @returns {void}\r\n   */\n  addExplanation(explanation) {\n    if (this.explanations === undefined) {\n      this.explanations = new Set();\n    }\n    this.explanations.add(explanation);\n  }\n  get explanation() {\n    if (this.explanations === undefined) return \"\";\n    return Array.from(this.explanations).join(\" \");\n  }\n\n  // TODO webpack 5 remove\n  get active() {\n    throw new Error(\"Use getActiveState instead\");\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, if the connection is active\r\n   */\n  isActive(runtime) {\n    if (!this.conditional) return this._active;\n    return this.condition(this, runtime) !== false;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {boolean} true, if the connection is active\r\n   */\n  isTargetActive(runtime) {\n    if (!this.conditional) return this._active;\n    return this.condition(this, runtime) === true;\n  }\n\n  /**\r\n   * @param {RuntimeSpec} runtime the runtime\r\n   * @returns {ConnectionState} true: fully active, false: inactive, TRANSITIVE: direct module inactive, but transitive connection maybe active\r\n   */\n  getActiveState(runtime) {\n    if (!this.conditional) return this._active;\n    return this.condition(this, runtime);\n  }\n\n  /**\r\n   * @param {boolean} value active or not\r\n   * @returns {void}\r\n   */\n  setActive(value) {\n    this.conditional = false;\n    this._active = value;\n  }\n  set active(value) {\n    throw new Error(\"Use setActive instead\");\n  }\n}\n\n/** @typedef {typeof TRANSITIVE_ONLY} TRANSITIVE_ONLY */\n/** @typedef {typeof CIRCULAR_CONNECTION} CIRCULAR_CONNECTION */\n\nmodule.exports = ModuleGraphConnection;\nmodule.exports.addConnectionStates = addConnectionStates;\nmodule.exports.TRANSITIVE_ONLY = /** @type {typeof TRANSITIVE_ONLY} */\nTRANSITIVE_ONLY;\nmodule.exports.CIRCULAR_CONNECTION = /** @type {typeof CIRCULAR_CONNECTION} */\nCIRCULAR_CONNECTION;","map":{"version":3,"names":["TRANSITIVE_ONLY","Symbol","CIRCULAR_CONNECTION","addConnectionStates","a","b","intersectConnectionStates","ModuleGraphConnection","constructor","originModule","dependency","module","explanation","weak","condition","undefined","resolvedOriginModule","resolvedModule","conditional","_active","explanations","Set","add","clone","addCondition","old","c","r","addExplanation","Array","from","join","active","Error","isActive","runtime","isTargetActive","getActiveState","setActive","value","exports"],"sources":["C:/Users/91930/Desktop/Github projects/Pharmacy Demo/front-end/node_modules/webpack/lib/ModuleGraphConnection.js"],"sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n\"use strict\";\r\n\r\n/** @typedef {import(\"./Dependency\")} Dependency */\r\n/** @typedef {import(\"./Module\")} Module */\r\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\r\n\r\n/**\r\n * Module itself is not connected, but transitive modules are connected transitively.\r\n */\r\nconst TRANSITIVE_ONLY = Symbol(\"transitive only\");\r\n\r\n/**\r\n * While determining the active state, this flag is used to signal a circular connection.\r\n */\r\nconst CIRCULAR_CONNECTION = Symbol(\"circular connection\");\r\n\r\n/** @typedef {boolean | typeof TRANSITIVE_ONLY | typeof CIRCULAR_CONNECTION} ConnectionState */\r\n\r\n/**\r\n * @param {ConnectionState} a first\r\n * @param {ConnectionState} b second\r\n * @returns {ConnectionState} merged\r\n */\r\nconst addConnectionStates = (a, b) => {\r\n\tif (a === true || b === true) return true;\r\n\tif (a === false) return b;\r\n\tif (b === false) return a;\r\n\tif (a === TRANSITIVE_ONLY) return b;\r\n\tif (b === TRANSITIVE_ONLY) return a;\r\n\treturn a;\r\n};\r\n\r\n/**\r\n * @param {ConnectionState} a first\r\n * @param {ConnectionState} b second\r\n * @returns {ConnectionState} intersected\r\n */\r\nconst intersectConnectionStates = (a, b) => {\r\n\tif (a === false || b === false) return false;\r\n\tif (a === true) return b;\r\n\tif (b === true) return a;\r\n\tif (a === CIRCULAR_CONNECTION) return b;\r\n\tif (b === CIRCULAR_CONNECTION) return a;\r\n\treturn a;\r\n};\r\n\r\nclass ModuleGraphConnection {\r\n\t/**\r\n\t * @param {Module|null} originModule the referencing module\r\n\t * @param {Dependency|null} dependency the referencing dependency\r\n\t * @param {Module} module the referenced module\r\n\t * @param {string=} explanation some extra detail\r\n\t * @param {boolean=} weak the reference is weak\r\n\t * @param {false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState=} condition condition for the connection\r\n\t */\r\n\tconstructor(\r\n\t\toriginModule,\r\n\t\tdependency,\r\n\t\tmodule,\r\n\t\texplanation,\r\n\t\tweak = false,\r\n\t\tcondition = undefined\r\n\t) {\r\n\t\tthis.originModule = originModule;\r\n\t\tthis.resolvedOriginModule = originModule;\r\n\t\tthis.dependency = dependency;\r\n\t\tthis.resolvedModule = module;\r\n\t\tthis.module = module;\r\n\t\tthis.weak = weak;\r\n\t\tthis.conditional = !!condition;\r\n\t\tthis._active = condition !== false;\r\n\t\t/** @type {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} */\r\n\t\tthis.condition = condition || undefined;\r\n\t\t/** @type {Set<string>} */\r\n\t\tthis.explanations = undefined;\r\n\t\tif (explanation) {\r\n\t\t\tthis.explanations = new Set();\r\n\t\t\tthis.explanations.add(explanation);\r\n\t\t}\r\n\t}\r\n\r\n\tclone() {\r\n\t\tconst clone = new ModuleGraphConnection(\r\n\t\t\tthis.resolvedOriginModule,\r\n\t\t\tthis.dependency,\r\n\t\t\tthis.resolvedModule,\r\n\t\t\tundefined,\r\n\t\t\tthis.weak,\r\n\t\t\tthis.condition\r\n\t\t);\r\n\t\tclone.originModule = this.originModule;\r\n\t\tclone.module = this.module;\r\n\t\tclone.conditional = this.conditional;\r\n\t\tclone._active = this._active;\r\n\t\tif (this.explanations) clone.explanations = new Set(this.explanations);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {function(ModuleGraphConnection, RuntimeSpec): ConnectionState} condition condition for the connection\r\n\t * @returns {void}\r\n\t */\r\n\taddCondition(condition) {\r\n\t\tif (this.conditional) {\r\n\t\t\tconst old = this.condition;\r\n\t\t\tthis.condition = (c, r) =>\r\n\t\t\t\tintersectConnectionStates(old(c, r), condition(c, r));\r\n\t\t} else if (this._active) {\r\n\t\t\tthis.conditional = true;\r\n\t\t\tthis.condition = condition;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} explanation the explanation to add\r\n\t * @returns {void}\r\n\t */\r\n\taddExplanation(explanation) {\r\n\t\tif (this.explanations === undefined) {\r\n\t\t\tthis.explanations = new Set();\r\n\t\t}\r\n\t\tthis.explanations.add(explanation);\r\n\t}\r\n\r\n\tget explanation() {\r\n\t\tif (this.explanations === undefined) return \"\";\r\n\t\treturn Array.from(this.explanations).join(\" \");\r\n\t}\r\n\r\n\t// TODO webpack 5 remove\r\n\tget active() {\r\n\t\tthrow new Error(\"Use getActiveState instead\");\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, if the connection is active\r\n\t */\r\n\tisActive(runtime) {\r\n\t\tif (!this.conditional) return this._active;\r\n\t\treturn this.condition(this, runtime) !== false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {boolean} true, if the connection is active\r\n\t */\r\n\tisTargetActive(runtime) {\r\n\t\tif (!this.conditional) return this._active;\r\n\t\treturn this.condition(this, runtime) === true;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {RuntimeSpec} runtime the runtime\r\n\t * @returns {ConnectionState} true: fully active, false: inactive, TRANSITIVE: direct module inactive, but transitive connection maybe active\r\n\t */\r\n\tgetActiveState(runtime) {\r\n\t\tif (!this.conditional) return this._active;\r\n\t\treturn this.condition(this, runtime);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {boolean} value active or not\r\n\t * @returns {void}\r\n\t */\r\n\tsetActive(value) {\r\n\t\tthis.conditional = false;\r\n\t\tthis._active = value;\r\n\t}\r\n\r\n\tset active(value) {\r\n\t\tthrow new Error(\"Use setActive instead\");\r\n\t}\r\n}\r\n\r\n/** @typedef {typeof TRANSITIVE_ONLY} TRANSITIVE_ONLY */\r\n/** @typedef {typeof CIRCULAR_CONNECTION} CIRCULAR_CONNECTION */\r\n\r\nmodule.exports = ModuleGraphConnection;\r\nmodule.exports.addConnectionStates = addConnectionStates;\r\nmodule.exports.TRANSITIVE_ONLY = /** @type {typeof TRANSITIVE_ONLY} */ (\r\n\tTRANSITIVE_ONLY\r\n);\r\nmodule.exports.CIRCULAR_CONNECTION = /** @type {typeof CIRCULAR_CONNECTION} */ (\r\n\tCIRCULAR_CONNECTION\r\n);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}