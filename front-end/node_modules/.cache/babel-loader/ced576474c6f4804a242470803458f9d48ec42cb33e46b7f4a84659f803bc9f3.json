{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = void 0;\nconst change_stream_1 = require(\"../change_stream\");\nconst constants_1 = require(\"../constants\");\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(client, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(client, namespace, options);\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n  get resumeToken() {\n    return this._resumeToken;\n  }\n  get resumeOptions() {\n    const options = {\n      ...this.options\n    };\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {\n      delete options[key];\n    }\n    if (this.resumeToken != null) {\n      if (this.options.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n    return options;\n  }\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n  _processBatch(response) {\n    const cursor = response.cursor;\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n      const batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n      if (batch.length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n  clone() {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n      const server = aggregateOperation.server;\n      this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n      this._processBatch(response);\n      this.emit(constants_1.INIT, response);\n      this.emit(constants_1.RESPONSE);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server,\n        session,\n        response\n      });\n    });\n  }\n  _getMore(batchSize, callback) {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n      this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n      this._processBatch(response);\n      this.emit(change_stream_1.ChangeStream.MORE, response);\n      this.emit(change_stream_1.ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n}\nexports.ChangeStreamCursor = ChangeStreamCursor;","map":{"version":3,"mappings":"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","names":["ChangeStreamCursor","abstract_cursor_1","constructor","client","namespace","pipeline","options","_resumeToken","startAtOperationTime","startAfter","resumeToken","resumeAfter","token","emit","change_stream_1","RESUME_TOKEN_CHANGED","resumeOptions","key","hasReceived","server","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","response","cursor","batch","firstBatch","nextBatch","length","clone","cursorOptions","_initialize","session","callback","aggregateOperation","aggregate_1","err","maxWireVersion","operationTime","constants_1","undefined","_getMore","batchSize","MORE","RESPONSE","exports"],"sources":["C:\\Users\\91930\\Desktop\\Github projects\\Pharmacy Demo\\back-end\\node_modules\\mongoose\\node_modules\\mongodb\\src\\cursor\\change_stream_cursor.ts"],"sourcesContent":["import type { Document, Long, Timestamp } from '../bson';\r\nimport {\r\n  type ChangeStreamDocument,\r\n  type ChangeStreamEvents,\r\n  type OperationTime,\r\n  type ResumeToken,\r\n  ChangeStream\r\n} from '../change_stream';\r\nimport { INIT, RESPONSE } from '../constants';\r\nimport type { MongoClient } from '../mongo_client';\r\nimport type { TODO_NODE_3286 } from '../mongo_types';\r\nimport { AggregateOperation } from '../operations/aggregate';\r\nimport type { CollationOptions } from '../operations/command';\r\nimport { type ExecutionResult, executeOperation } from '../operations/execute_operation';\r\nimport type { ClientSession } from '../sessions';\r\nimport { type Callback, type MongoDBNamespace, maxWireVersion } from '../utils';\r\nimport { type AbstractCursorOptions, AbstractCursor } from './abstract_cursor';\r\n\r\n/** @internal */\r\nexport interface ChangeStreamCursorOptions extends AbstractCursorOptions {\r\n  startAtOperationTime?: OperationTime;\r\n  resumeAfter?: ResumeToken;\r\n  startAfter?: ResumeToken;\r\n  maxAwaitTimeMS?: number;\r\n  collation?: CollationOptions;\r\n  fullDocument?: string;\r\n}\r\n\r\n/** @internal */\r\nexport type ChangeStreamAggregateRawResult<TChange> = {\r\n  $clusterTime: { clusterTime: Timestamp };\r\n  cursor: {\r\n    postBatchResumeToken: ResumeToken;\r\n    ns: string;\r\n    id: number | Long;\r\n  } & ({ firstBatch: TChange[] } | { nextBatch: TChange[] });\r\n  ok: 1;\r\n  operationTime: Timestamp;\r\n};\r\n\r\n/** @internal */\r\nexport class ChangeStreamCursor<\r\n  TSchema extends Document = Document,\r\n  TChange extends Document = ChangeStreamDocument<TSchema>\r\n> extends AbstractCursor<TChange, ChangeStreamEvents> {\r\n  _resumeToken: ResumeToken;\r\n  startAtOperationTime?: OperationTime;\r\n  hasReceived?: boolean;\r\n  resumeAfter: ResumeToken;\r\n  startAfter: ResumeToken;\r\n  options: ChangeStreamCursorOptions;\r\n\r\n  postBatchResumeToken?: ResumeToken;\r\n  pipeline: Document[];\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   * used to determine change stream resumability\r\n   */\r\n  maxWireVersion: number | undefined;\r\n\r\n  constructor(\r\n    client: MongoClient,\r\n    namespace: MongoDBNamespace,\r\n    pipeline: Document[] = [],\r\n    options: ChangeStreamCursorOptions = {}\r\n  ) {\r\n    super(client, namespace, options);\r\n\r\n    this.pipeline = pipeline;\r\n    this.options = options;\r\n    this._resumeToken = null;\r\n    this.startAtOperationTime = options.startAtOperationTime;\r\n\r\n    if (options.startAfter) {\r\n      this.resumeToken = options.startAfter;\r\n    } else if (options.resumeAfter) {\r\n      this.resumeToken = options.resumeAfter;\r\n    }\r\n  }\r\n\r\n  set resumeToken(token: ResumeToken) {\r\n    this._resumeToken = token;\r\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\r\n  }\r\n\r\n  get resumeToken(): ResumeToken {\r\n    return this._resumeToken;\r\n  }\r\n\r\n  get resumeOptions(): ChangeStreamCursorOptions {\r\n    const options: ChangeStreamCursorOptions = {\r\n      ...this.options\r\n    };\r\n\r\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime'] as const) {\r\n      delete options[key];\r\n    }\r\n\r\n    if (this.resumeToken != null) {\r\n      if (this.options.startAfter && !this.hasReceived) {\r\n        options.startAfter = this.resumeToken;\r\n      } else {\r\n        options.resumeAfter = this.resumeToken;\r\n      }\r\n    } else if (this.startAtOperationTime != null && maxWireVersion(this.server) >= 7) {\r\n      options.startAtOperationTime = this.startAtOperationTime;\r\n    }\r\n\r\n    return options;\r\n  }\r\n\r\n  cacheResumeToken(resumeToken: ResumeToken): void {\r\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\r\n      this.resumeToken = this.postBatchResumeToken;\r\n    } else {\r\n      this.resumeToken = resumeToken;\r\n    }\r\n    this.hasReceived = true;\r\n  }\r\n\r\n  _processBatch(response: ChangeStreamAggregateRawResult<TChange>): void {\r\n    const cursor = response.cursor;\r\n    if (cursor.postBatchResumeToken) {\r\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\r\n\r\n      const batch =\r\n        'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\r\n      if (batch.length === 0) {\r\n        this.resumeToken = cursor.postBatchResumeToken;\r\n      }\r\n    }\r\n  }\r\n\r\n  clone(): AbstractCursor<TChange> {\r\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\r\n      ...this.cursorOptions\r\n    });\r\n  }\r\n\r\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\r\n    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {\r\n      ...this.cursorOptions,\r\n      ...this.options,\r\n      session\r\n    });\r\n\r\n    executeOperation<TODO_NODE_3286, ChangeStreamAggregateRawResult<TChange>>(\r\n      session.client,\r\n      aggregateOperation,\r\n      (err, response) => {\r\n        if (err || response == null) {\r\n          return callback(err);\r\n        }\r\n\r\n        const server = aggregateOperation.server;\r\n        this.maxWireVersion = maxWireVersion(server);\r\n\r\n        if (\r\n          this.startAtOperationTime == null &&\r\n          this.resumeAfter == null &&\r\n          this.startAfter == null &&\r\n          this.maxWireVersion >= 7\r\n        ) {\r\n          this.startAtOperationTime = response.operationTime;\r\n        }\r\n\r\n        this._processBatch(response);\r\n\r\n        this.emit(INIT, response);\r\n        this.emit(RESPONSE);\r\n\r\n        // TODO: NODE-2882\r\n        callback(undefined, { server, session, response });\r\n      }\r\n    );\r\n  }\r\n\r\n  override _getMore(batchSize: number, callback: Callback): void {\r\n    super._getMore(batchSize, (err, response) => {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n\r\n      this.maxWireVersion = maxWireVersion(this.server);\r\n      this._processBatch(response as TODO_NODE_3286 as ChangeStreamAggregateRawResult<TChange>);\r\n\r\n      this.emit(ChangeStream.MORE, response);\r\n      this.emit(ChangeStream.RESPONSE);\r\n      callback(err, response);\r\n    });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}